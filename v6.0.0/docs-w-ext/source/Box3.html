<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-layout-container-Box'>/**
</span> * Base Class for HBoxLayout and VBoxLayout Classes. Generally it should not need to be used directly.
 */
Ext.define(&#39;Ext.layout.container.Box&#39;, {
    extend: &#39;Ext.layout.container.Container&#39;,

    alias: &#39;layout.box&#39;,

    alternateClassName: &#39;Ext.layout.BoxLayout&#39;,

    requires: [
        &#39;Ext.layout.container.boxOverflow.None&#39;,
        &#39;Ext.layout.container.boxOverflow.Scroller&#39;,
        &#39;Ext.util.Format&#39;,
        &#39;Ext.dd.DragDropManager&#39;,
        &#39;Ext.resizer.Splitter&#39;
    ],

<span id='Ext-layout-container-Box-property-type'>    type: &#39;box&#39;,
</span>
    config: {
<span id='Ext-layout-container-Box-cfg-align'>        /**
</span>         * @cfg {String} [align=&quot;begin&quot;]
         * Controls how the child items of the container are aligned. The value is used to
         * position items &quot;perpendicularly&quot;. That is, for horizontal boxes (where `vertical`
         * is `false`), then this will position items vertically. Otherwise, this will position
         * items horizontally. The acceptable values for this property are best explained in
         * context with the value of `vertical`.
         *
         * If `vertical` is `false` then this layout is behaving as an `hbox` and this config
         * operates as follows:
         *
         * - **begin** : Child items are aligned vertically at the top of the container.
         * - **middle** : Child items are vertically centered in the container.
         * - **end** : Child items are aligned vertically at the bottom of the container.
         * - **stretch** : Child items are stretched vertically to fill the height of the container.
         * - **stretchmax** : Child items are stretched vertically to the height of the largest item.
         *
         * If `vertical` is `true` then this layout is behaving as an `vbox` and this config
         * operates as follows:
         *
         * - **begin** : Child items are aligned horizontally at the left side of the container.
         * - **middle** : Child items are horizontally centered in the container.
         * - **end** : Child items are aligned horizontally at the right of the container.
         * - **stretch** : Child items are stretched horizontally to fill the width of the container.
         * - **stretchmax** : Child items are stretched horizontally to the size of the largest item.
         *
         * For backwards compatibility, the following values are also recognized:
         *
         * - **left** : Same as **begin**.
         * - **top** : Same as **begin**.
         * - **center** : Same as **middle**.
         * - **right** : Same as **end**.
         * - **bottom** : Same as **end**.
         */
        align: &#39;begin&#39;, // end, middle, stretch, strechmax

<span id='Ext-layout-container-Box-cfg-constrainAlign'>        /**
</span>         * @cfg {Boolean} constrainAlign
         * Limits the size of {@link #align aligned} components to the size of the container
         * under certain circumstances. Firstly, the container&#39;s height (for `hbox`) or width
         * (for `vbox`) must not be determined by the size of the child components. Secondly,
         * the child components must have {@link Ext.AbstractComponent#shrinkWrap shrinkwrap}
         * enabled for this dimension.
         */
        constrainAlign: false,

<span id='Ext-layout-container-Box-cfg-enableSplitters'>        /**
</span>         * @cfg {Boolean} [enableSplitters=true]
         * This flag can be set to `false` to ignore the `split` config on box items. This is
         * set to `false` by `Ext.layout.container.Accordion`.
         */
        enableSplitters: true,

        // @cmd-auto-dependency { aliasPrefix: &#39;box.overflow.&#39; }
<span id='Ext-layout-container-Box-cfg-overflowHandler'>        /**
</span>         * @cfg {String/Ext.layout.container.boxOverflow.None}
         * An overflow handler or config object for an overflow handler.  This is typically
         * specified as one of the following strings:
         *
         * - `scroller` - Scroller buttons are rendered before and after the content.
         * - `menu` - Overflowing items are rendered into a menu, and a button is rendered
         *    after the items, which shows the menu when clicked.
         *
         * NOTE: This config is currently only supported when box layout is used by the
         * following components:
         *
         * - {@link Ext.toolbar.Toolbar}
         * - {@link Ext.menu.Menu}
         * - {@link Ext.toolbar.Breadcrumb}
         * - {@link Ext.tab.Bar}
         *
         * Components where `overflowHandler` is not supported should use
         * `{@link Ext.Component#scrollable scrollable}:true` if they have overflowing
         * content.
         */
        overflowHandler: {
            $value: null,
            merge: function(newValue, oldValue) {
                if (typeof newValue === &#39;string&#39;) {
                    newValue = {
                        type: newValue
                    };
                }

                return Ext.merge(oldValue ? Ext.Object.chain(oldValue) : {}, newValue);
            }
        },

<span id='Ext-layout-container-Box-cfg-padding'>        /**
</span>         * @cfg {String} padding
         * Sets the padding to be applied to all child items managed by this layout.
         *
         * This property must be specified as a string containing space-separated, numeric
         * padding values. The order of the sides associated with each value matches the
         * way CSS processes padding values:
         *
         *   - If there is only one value, it applies to all sides.
         *   - If there are two values, the top and bottom borders are set to the first
         *     value and the right and left are set to the second.
         *   - If there are three values, the top is set to the first value, the left and
         *     right are set to the second, and the bottom is set to the third.
         *   - If there are four values, they apply to the top, right, bottom, and left,
         *     respectively.
         */
        padding: 0,

<span id='Ext-layout-container-Box-cfg-pack'>        /**
</span>         * @cfg {String} pack
         * Controls how the child items of the container are packed together. Acceptable
         * configuration values for this property are:
         *
         *   - **start** - child items are packed together at **left** (HBox) or **top**
         *     (VBox) side of container (*default**)
         *   - **center** - child items are packed together at **mid-width** (HBox) or
         *     **mid-height** (VBox) of container
         *   - **end** - child items are packed together at **right** (HBox) or **bottom**
         *     (VBox) side of container
         */
        pack: &#39;start&#39;,

<span id='Ext-layout-container-Box-cfg-stretchMaxPartner'>        /**
</span>         * @cfg {String/Ext.Component} stretchMaxPartner
         * Allows stretchMax calculation to take into account the max perpendicular size
         * (height for HBox layout and width for VBox layout) of another Box layout when
         * calculating its maximum perpendicular child size.
         *
         * If specified as a string, this may be either a known Container ID, or a
         * ComponentQuery selector which is rooted at this layout&#39;s Container (ie, to find
         * a sibling, use `&quot;^&gt;#siblingItemId`).
         */
        stretchMaxPartner: undefined,

<span id='Ext-layout-container-Box-cfg-vertical'>        /**
</span>         * @cfg {Boolean} [vertical=false]
         * Set to `true` to switch the layout to `vbox`.
         */
        vertical: false,

<span id='Ext-layout-container-Box-cfg-alignRoundingMethod'>        /**
</span>         * @cfg {&quot;round&quot;/&quot;floor&quot;/&quot;ceil&quot;} [alignRoundingMethod=&#39;round&#39;] The Math method 
         * to use for rounding fractional pixels when `{@link #align}:middle` is used.  
         * The possible values are:
         * 
         *  - [round](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round)
         *  - [floor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor)
         *  - [ceil](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil)
         */
        alignRoundingMethod: &#39;round&#39;
    },

<span id='Ext-layout-container-Box-cfg-itemCls'>    itemCls: Ext.baseCSSPrefix + &#39;box-item&#39;,
</span><span id='Ext-layout-container-Box-property-targetCls'>    targetCls: Ext.baseCSSPrefix + &#39;box-layout-ct&#39;,
</span><span id='Ext-layout-container-Box-property-targetElCls'>    targetElCls: Ext.baseCSSPrefix + &#39;box-target&#39;,
</span><span id='Ext-layout-container-Box-property-innerCls'>    innerCls: Ext.baseCSSPrefix + &#39;box-inner&#39;,
</span>
<span id='Ext-layout-container-Box-property-manageMargins'>    manageMargins: true,
</span>    
<span id='Ext-layout-container-Box-property-createsInnerCt'>    createsInnerCt: true,
</span>
<span id='Ext-layout-container-Box-cfg-childEls'>    childEls: [
</span>        &#39;innerCt&#39;,
        &#39;targetEl&#39;
    ],

<span id='Ext-layout-container-Box-property-renderTpl'>    renderTpl: [
</span>        &#39;{%var oc,l=values.$comp.layout,oh=l.overflowHandler;&#39; +
        &#39;if (oh &amp;&amp; oh.getPrefixConfig!==Ext.emptyFn) {&#39; +
            &#39;if(oc=oh.getPrefixConfig())dh.generateMarkup(oc, out)&#39; +
        &#39;}%}&#39; +
        &#39;&lt;div id=&quot;{ownerId}-innerCt&quot; data-ref=&quot;innerCt&quot; role=&quot;presentation&quot; class=&quot;{[l.innerCls]}&#39; +
            &#39;{[oh ? (&quot; &quot; + oh.getOverflowCls(l.direction)) : &quot;&quot;]}&quot;&gt;&#39; +
            &#39;&lt;div id=&quot;{ownerId}-targetEl&quot; data-ref=&quot;targetEl&quot; class=&quot;{targetElCls}&quot; role=&quot;presentation&quot;&gt;&#39; +
                &#39;{%this.renderBody(out, values)%}&#39; +
            &#39;&lt;/div&gt;&#39; +
        &#39;&lt;/div&gt;&#39; +
        &#39;{%if (oh &amp;&amp; oh.getSuffixConfig!==Ext.emptyFn) {&#39; +
            &#39;if(oc=oh.getSuffixConfig())dh.generateMarkup(oc, out)&#39; +
        &#39;}%}&#39;,
        {
            disableFormats: true,
            definitions: &#39;var dh=Ext.DomHelper;&#39;
        }
    ],

<span id='Ext-layout-container-Box-method-constructor'>    constructor: function(config) {
</span>        var me = this,
            type;

        me.callParent([config]);

        me.setVertical(me.vertical);

        // The sort function needs access to properties in this, so must be bound.
        me.flexSortFn = me.flexSort.bind(me);

        type = typeof me.padding;
        if (type === &#39;string&#39; || type === &#39;number&#39;) {
            me.padding = Ext.util.Format.parseBox(me.padding);
            me.padding.height = me.padding.top  + me.padding.bottom;
            me.padding.width  = me.padding.left + me.padding.right;
        }
    },

<span id='Ext-layout-container-Box-property-_beginRe'>    _beginRe: /^(?:begin|left|top)$/,
</span><span id='Ext-layout-container-Box-property-_centerRe'>    _centerRe: /^(?:center|middle)$/,
</span><span id='Ext-layout-container-Box-property-_endRe'>    _endRe: /^(?:end|right|bottom)$/,
</span>
<span id='Ext-layout-container-Box-property-_percentageRe'>    // Matches: `&lt;spaces&gt;digits[.digits]&lt;spaces&gt;%&lt;spaces&gt;`
</span>    // Captures: `digits[.digits]`
    _percentageRe: /^\s*(\d+(?:\.\d*)?)\s*[%]\s*$/,

<span id='Ext-layout-container-Box-method-getItemSizePolicy'>    getItemSizePolicy: function (item, ownerSizeModel) {
</span>        var me = this,
            policy = me.sizePolicy,
            align = me.align,
            flex = item.flex,
            key = align,
            names = me.names,
            heightName = names.height,
            widthName = names.width,
            width = item[widthName],
            height = item[heightName],
            percentageRe = me._percentageRe,
            percentageWidth = percentageRe.test(width),
            isStretch = (align === &#39;stretch&#39;),
            isStretchMax = (align === &#39;stretchmax&#39;),
            constrain = me.constrainAlign;
            
        // Getting the size model is expensive, so we only want to do so if we really need it
        if (!ownerSizeModel &amp;&amp; (isStretch || flex || percentageWidth || (constrain &amp;&amp; !isStretchMax))) {
            ownerSizeModel = me.owner.getSizeModel();
        }

        if (isStretch) {
            // If we are height.shrinkWrap, we behave as if we were stretchmax (for more
            // details, see beginLayoutCycle)...
            if (!percentageRe.test(height) &amp;&amp; ownerSizeModel[heightName].shrinkWrap) {
                key = &#39;stretchmax&#39;;
                // We leave %age height as stretch since it will not participate in the
                // stretchmax size calculation. This avoid running such a child in its
                // shrinkWrap mode prior to supplying the calculated size.
            }
        } else if (!isStretchMax) {
            if (percentageRe.test(height)) {
                // Height %ages are calculated based on container size, so they are the
                // same as align=stretch for this purpose...
                key = &#39;stretch&#39;;
            } else if (constrain &amp;&amp; !ownerSizeModel[heightName].shrinkWrap) {
                // Same functionality as stretchmax, only the max is going to be the size
                // of the container, not the largest item
                key = &#39;stretchmax&#39;;
            } else {
                key = &#39;&#39;;
            }
        }

        if (flex || percentageWidth) {
            // If we are width.shrinkWrap, we won&#39;t be flexing since that requires a
            // container width...
            if (!ownerSizeModel[widthName].shrinkWrap) {
                policy = policy.flex; // both flex and %age width are calculated
            }
        }

        return policy[key];
    },

<span id='Ext-layout-container-Box-method-flexSort'>    flexSort: function (a, b) {
</span>        // We need to sort the flexed items to ensure that we have
        // the items with max/min width first since when we set the
        // values we may have the value constrained, so we need to
        // react accordingly. Precedence is given from the largest
        // value through to the smallest value
        var maxWidthName = this.names.maxWidth,
            minWidthName = this.names.minWidth,
            infiniteValue = Infinity,
            aTarget = a.target,
            bTarget = b.target,
            aFlex = aTarget.flex,
            bFlex = bTarget.flex,
            result = 0,
            aMin, bMin, aMax, bMax,
            hasMin, hasMax;

        aMax = aTarget[maxWidthName] || infiniteValue;
        bMax = bTarget[maxWidthName] || infiniteValue;
        aMin = aTarget[minWidthName] || 0;
        bMin = bTarget[minWidthName] || 0;
        
        hasMin = isFinite(aMin) || isFinite(bMin);
        hasMax = isFinite(aMax) || isFinite(bMax);

        if (hasMin || hasMax) {
            if (hasMax) {
                result = aMax - bMax;
            }
            
            // If the result is 0, it means either
            // a) hasMax was false
            // b) The max values were the same
            if (result === 0 &amp;&amp; hasMin) {
                result = bMin - aMin;
            }

            // If 0, it means either the max and/or minimum was the same
            if (result === 0) {
                if (hasMax) {
                    result = bFlex - aFlex;
                } else {
                    result = aFlex - bFlex;
                }
            }
        }
        return result;
    },

<span id='Ext-layout-container-Box-method-isItemBoxParent'>    isItemBoxParent: function (itemContext) {
</span>        return true;
    },

<span id='Ext-layout-container-Box-method-isItemShrinkWrap'>    isItemShrinkWrap: function (item) {
</span>        return true;
    },

<span id='Ext-layout-container-Box-method-roundFlex'>    roundFlex: function(width) {
</span>        return Math.floor(width);
    },

<span id='Ext-layout-container-Box-method-beginCollapse'>    /**
</span>     * @private
     * Called by an owning Panel before the Panel begins its collapse process.
     * Most layouts will not need to override the default Ext.emptyFn implementation.
     */
    beginCollapse: function(child) {
        var me = this;

        if (me.direction === &#39;vertical&#39; &amp;&amp; child.collapsedVertical()) {
            child.collapseMemento.capture([&#39;flex&#39;]);
            delete child.flex;
        } else if (me.direction === &#39;horizontal&#39; &amp;&amp; child.collapsedHorizontal()) {
            child.collapseMemento.capture([&#39;flex&#39;]);
            delete child.flex;
        }
    },

<span id='Ext-layout-container-Box-method-beginExpand'>    /**
</span>     * @private
     * Called by an owning Panel before the Panel begins its expand process.
     * Most layouts will not need to override the default Ext.emptyFn implementation.
     */
    beginExpand: function(child) {

        // Restores the flex if we used to be flexed before
        child.collapseMemento.restore([&#39;flex&#39;]);
    },

<span id='Ext-layout-container-Box-method-beginLayout'>    beginLayout: function (ownerContext) {
</span>        var me = this,
            owner = me.owner,
            smp = owner.stretchMaxPartner,
            style = me.innerCt.dom.style,
            names = me.names,
            overflowHandler = me.overflowHandler;

        ownerContext.boxNames = names;

        // this must happen before callParent to allow the overflow handler to do its work
        // that can effect the childItems collection...
        if (overflowHandler) {
            overflowHandler.beginLayout(ownerContext);
        }

        // get the contextItem for our stretchMax buddy:
        if (typeof smp === &#39;string&#39;) {
            smp = Ext.getCmp(smp) || owner.query(smp)[0];
        }

        ownerContext.stretchMaxPartner = smp &amp;&amp; ownerContext.context.getCmp(smp);

        me.callParent([ownerContext]);

        ownerContext.innerCtContext = ownerContext.getEl(&#39;innerCt&#39;, me);
        ownerContext.targetElContext = ownerContext.getEl(&#39;targetEl&#39;, me);
        ownerContext.ownerScrollable = owner.getScrollable();

        // Don&#39;t allow sizes burned on to the innerCt to influence measurements.
        style.width = style.height = &#39;&#39;;
    },

<span id='Ext-layout-container-Box-method-beginLayoutCycle'>    beginLayoutCycle: function (ownerContext, firstCycle) {
</span>        var me = this,
            state = ownerContext.state,
            scrollable = ownerContext.ownerScrollable,
            align = me.align,
            names = ownerContext.boxNames,
            pack = me.pack,
            centerRe = me._centerRe,
            overflowHandler = me.overflowHandler,
            canScroll = ownerContext.state.canScroll,
            widthModel, heightModel;

        // this must happen before callParent to allow the overflow handler to do its work
        // that can effect the childItems collection...
        if (overflowHandler) {
            overflowHandler.beginLayoutCycle(ownerContext, firstCycle);
        }

        me.callParent([ownerContext, firstCycle]);

        // Cache several of our string concat/compare results (since width/heightModel can
        // change if we are invalidated, we cannot do this in beginLayout)

        ownerContext.parallelSizeModel = widthModel = ownerContext[names.widthModel];
        ownerContext.perpendicularSizeModel = heightModel = ownerContext[names.heightModel];

        ownerContext.boxOptions = {
            align: align = {
                stretch:    align === &#39;stretch&#39;,
                stretchmax: align === &#39;stretchmax&#39;,
                center:     centerRe.test(align),
                bottom:     me._endRe.test(align)
            },
            pack: pack = {
                center: centerRe.test(pack),
                end:    pack === &#39;end&#39;
            }
        };

        // Scrolling can occur if:
        // a) The owner is configured to scroll in that direction
        // b) We&#39;re not shrink wrapping. If we shrink wrap, we should always size around the content
        if (scrollable) {
            if (!canScroll) {
                // Use getX/getY here to indicate whether we will show visible scrollbars in that direction, we may have
                // a scrollable and can scroll in that direction without having a visible scrollbar.
                state.canScroll = {
                    parallel: !widthModel.shrinkWrap &amp;&amp; scrollable[names.getX](),
                    perpendicular: !heightModel.shrinkWrap &amp;&amp; scrollable[names.getY]()
                };
            }

            if (!state.actualScroll) {
                // Store the final calculated state for this cycle in here
                state.actualScroll = {
                    parallel: false,
                    perpendicular: false
                };
            }
        }


        // Consider an hbox w/stretch which means &quot;assign all items the container&#39;s height&quot;.
        // The spirit of this request is make all items the same height, but when shrinkWrap
        // height is also requested, the height of the tallest item determines the height.
        // This is exactly what the stretchmax option does, so we jiggle the flags here to
        // act as if stretchmax were requested.

        if (align.stretch &amp;&amp; heightModel.shrinkWrap) {
            align.stretchmax = true;
            align.stretch = false;
        }

        // This is handy for knowing that we might need to apply height %ages
        align.nostretch = !(align.stretch || align.stretchmax);

        // In our example hbox, packing items to the right (end) or center can only work if
        // there is a container width. So, if we are shrinkWrap, we just turn off the pack
        // options for the run.

        if (widthModel.shrinkWrap) {
            pack.center = pack.end = false;
        }

        me.cacheFlexes(ownerContext);

        // We set the width of the target el equal to the width of the innerCt
        // when the layout cycle is finished, so we need to clear the width here
        // to prevent the children from being crushed.
        // IE needs it because of its scrollIntoView bug: https://sencha.jira.com/browse/EXTJSIV-6520
        // Webkit needs it because of its mouse drag bug: https://sencha.jira.com/browse/EXTJSIV-5962
        // FF needs it because of a vertical tab bug: https://sencha.jira.com/browse/EXTJSIV-8614
        me.targetEl.setWidth(20000);
    },

<span id='Ext-layout-container-Box-method-cacheFlexes'>    /**
</span>     * This method is called to (re)cache our understanding of flexes. This happens during beginLayoutCycle and may need to
     * be called again if the flexes are changed during the layout (e.g., like ColumnLayout).
     * @param {Object} ownerContext
     * @protected
     */
    cacheFlexes: function (ownerContext) {
        var me = this,
            names = ownerContext.boxNames,
            widthModelName = names.widthModel,
            heightModelName = names.heightModel,
            nostretch = ownerContext.boxOptions.align.nostretch,
            totalFlex = 0,
            childItems = ownerContext.childItems,
            i = childItems.length,
            flexedItems = [],
            minWidth = 0,
            smallestHeight = 0,
            smallestWidth = 0,
            minWidthName = names.minWidth,
            minHeightName = names.minHeight,
            percentageRe = me._percentageRe,
            percentageWidths = 0,
            percentageHeights = 0,
            child, childContext, flex, match, heightModel, widthModel, width, height;

        while (i--) {
            childContext = childItems[i];
            child = childContext.target;

            widthModel = childContext[widthModelName];
            // check widthModel to see if we are the sizing layout. If so, copy the flex
            // from the item to the contextItem and add it to totalFlex
            //
            if (widthModel.calculated) {
                childContext.flex = flex = child.flex;
                if (flex) {
                    totalFlex += flex;
                    flexedItems.push(childContext);
                    minWidth += child[minWidthName] || 0;
                }
                // a %age width. Note that we are testing the value that is
                // assigned to match.
                else if ((match = percentageRe.exec(child[names.width]))) {
                    childContext.percentageParallel = parseFloat(match[1]) / 100;
                    ++percentageWidths;
                }
            }
            // the above means that &quot;childContext.flex&quot; is properly truthy/falsy, which is
            // often times quite convenient...
            
            if (widthModel.configured) {
                width = child[names.width];
            } else {
                width = child[minWidthName] || 0;
            }
            smallestWidth += width;

            heightModel = childContext[heightModelName];
            if (nostretch &amp;&amp; heightModel.calculated) {
                // the only reason we would be calculated height in this case is due to a
                // height %age...
                match = percentageRe.exec(child[names.height]);
                childContext.percentagePerpendicular = parseFloat(match[1]) / 100;
                ++percentageHeights;
            }

            if (heightModel.configured) {
                height = child[names.height];
            } else {
                height = child[minHeightName] || 0;
            }

            if (height &gt; smallestHeight) {
                smallestHeight = height;
            }

        }

        ownerContext.flexedItems = flexedItems;
        ownerContext.flexedMinWidth = minWidth;
        // These dimensions are the smallest possible dimensions (using known sizes) for
        // the innerCt on each axis
        ownerContext.smallestWidth = smallestWidth;
        ownerContext.smallestHeight = smallestHeight;
        ownerContext.totalFlex = totalFlex;
        ownerContext.percentageWidths = percentageWidths;
        ownerContext.percentageHeights = percentageHeights;

        // The flexed boxes need to be sorted in ascending order of maxSize to work properly
        // so that unallocated space caused by maxWidth being less than flexed width can be
        // reallocated to subsequent flexed boxes.
        Ext.Array.sort(flexedItems, me.flexSortFn);
    },

<span id='Ext-layout-container-Box-method-calculate'>    calculate: function(ownerContext) {
</span>        var me = this,
            names = ownerContext.boxNames,
            state = ownerContext.state,
            actualScroll = state.actualScroll,
            needsScroll = state.needsScroll,
            canScroll = state.canScroll,
            plan = state.boxPlan || (state.boxPlan = {}),
            overflowHandler = me.overflowHandler;

        plan.targetSize = me.getContainerSize(ownerContext);

        if (canScroll &amp;&amp; !needsScroll) {
            state.needsScroll = needsScroll = {
                // Attempt to figure out early on if we need to scroll in the parallel direction. If the perpendicular is
                // done and we need to scroll, we need to invalidate because it may need recalculation.
                parallel: canScroll.parallel &amp;&amp; plan.targetSize[names.width] &lt; ownerContext.smallestWidth,
                perpendicular: canScroll.perpendicular &amp;&amp; plan.targetSize[names.height] &lt; ownerContext.smallestHeight
            };
        }

        if (!state.parallelDone) {
            state.parallelDone = me.calculateParallel(ownerContext, names, plan);
        }

        if (!state.perpendicularDone) {
            state.perpendicularDone = me.calculatePerpendicular(ownerContext, names, plan);
        }

        if (state.parallelDone &amp;&amp; state.perpendicularDone) {
            if (canScroll &amp;&amp; !state.scrollPass) {
                if (needsScroll.parallel !== actualScroll.parallel || needsScroll.perpendicular !== actualScroll.perpendicular) {
                    ownerContext.invalidate({
                        state: {
                            scrollPass: true,
                            canScroll: canScroll,
                            needsScroll: actualScroll
                        }
                    });
                    me.done = false;
                    return;
                }
            }

            me.publishInnerCtSize(ownerContext);

            // We always need to run calculateStretchMax, when relevant since we may 
            // have hit a constraint in an earlier calculation.
            if (me.done &amp;&amp; ownerContext.boxOptions.align.stretchmax &amp;&amp; !state.stretchMaxDone) {
                me.calculateStretchMax(ownerContext, names, plan);
                state.stretchMaxDone = true;
            }

            if (overflowHandler) {
                overflowHandler.calculate(ownerContext);
            }
        } else {
            me.done = false;
        }
    },

<span id='Ext-layout-container-Box-method-calculateParallel'>    calculateParallel: function(ownerContext, names, plan) {
</span>        var me = this,
            widthShrinkWrap = ownerContext.parallelSizeModel.shrinkWrap,
            widthName = names.width,
            childItems = ownerContext.childItems,
            beforeXName = names.beforeX,
            afterXName = names.afterX,
            setWidthName = names.setWidth,
            childItemsLength = childItems.length,
            flexedItems = ownerContext.flexedItems,
            flexedItemsLength = flexedItems.length,
            pack = ownerContext.boxOptions.pack,
            padding = me.padding,
            targetSize = plan.targetSize,
            containerWidth = targetSize[widthName],
            state = ownerContext.state,
            needsScroll = state.needsScroll,
            canScroll = state.canScroll,
            totalMargin = 0,
            left = padding[beforeXName],
            nonFlexWidth = left + padding[afterXName],
            scrollbarSize = Ext.getScrollbarSize(),
            scrollbarWidth = scrollbarSize[names.width],
            scrollbarHeight = scrollbarSize[names.height],
            i, childMargins, remainingWidth, remainingFlex, childContext, flex, flexedWidth,
            contentWidth, childWidth, percentageSpace, availableSpace;
            
        // If we are not widthModel.shrinkWrap, we need the width before we can lay out boxes.
        // This check belongs here so it does not prevent the perpendicular from attempting to
        // calculate. It may have a dependency on the width, but it may be able to achieve
        // the correct size without the width.
        if (!widthShrinkWrap &amp;&amp; !targetSize[names.gotWidth]) {
            return false;
        }

        // Gather the total size taken up by non-flexed items:
        for (i = 0; i &lt; childItemsLength; ++i) {
            childContext = childItems[i];
            childMargins = childContext.marginInfo || childContext.getMarginInfo();

            totalMargin += childMargins[widthName];

            if (!childContext[names.widthModel].calculated) {
                childWidth = childContext.getProp(widthName);
                nonFlexWidth += childWidth; // min/maxWidth safe
                if (isNaN(nonFlexWidth)) {
                    return false;
                }
            }
        }

        nonFlexWidth += totalMargin;
        if (ownerContext.percentageWidths) {
            percentageSpace = containerWidth - totalMargin;
            if (isNaN(percentageSpace)) {
                return false;
            }

            for (i = 0; i &lt; childItemsLength; ++i) {
                childContext = childItems[i];
                if (childContext.percentageParallel) {
                    childWidth = Math.ceil(percentageSpace * childContext.percentageParallel);
                    childWidth = childContext[setWidthName](childWidth);
                    nonFlexWidth += childWidth;
                }
            }
        }

        // if we get here, we have all the childWidths for non-flexed items...
        if (widthShrinkWrap) {
            availableSpace = 0;
            plan.tooNarrow = false;
        } else {
            availableSpace = containerWidth - nonFlexWidth;
            if (needsScroll &amp;&amp; needsScroll.perpendicular) {
                availableSpace -= scrollbarHeight;
            }
            plan.tooNarrow = availableSpace &lt; ownerContext.flexedMinWidth;
            if (plan.tooNarrow &amp;&amp; canScroll &amp;&amp; canScroll.parallel) {
                state.actualScroll.parallel = true;
            }
        }

        contentWidth = nonFlexWidth;
        remainingWidth = availableSpace;
        remainingFlex = ownerContext.totalFlex;

        // Calculate flexed item sizes:
        for (i = 0; i &lt; flexedItemsLength; i++) {
            childContext = flexedItems[i];
            flex         = childContext.flex;
            flexedWidth  = me.roundFlex((flex / remainingFlex) * remainingWidth);
            flexedWidth  = childContext[setWidthName](flexedWidth); // constrained

            // due to minWidth constraints, it may be that flexedWidth &gt; remainingWidth

            contentWidth   += flexedWidth;
            // Remaining space has already had margins subtracted, so just subtract size
            remainingWidth  = Math.max(0, remainingWidth - flexedWidth); // no negatives!
            remainingFlex  -= flex;
        }

        if (pack.center) {
            left += remainingWidth / 2;

            // If content is too wide to pack to center, do not allow the centering calculation to place it off the left edge.
            if (left &lt; 0) {
                left = 0;
            }
        } else if (pack.end) {
            left += remainingWidth;
        }

        // Assign parallel position for the boxes:
        for (i = 0; i &lt; childItemsLength; ++i) {
            childContext = childItems[i];
            childMargins = childContext.marginInfo; // already cached by first loop

            left += childMargins[beforeXName];

            childContext.setProp(names.x, left);

            // We can read directly from &quot;props.width&quot; because we have already properly
            // requested it in the calculation of nonFlexedWidths or we calculated it.
            // We cannot call getProp because that would be inappropriate for flexed items
            // and we don&#39;t need any extra function call overhead:
            left += childMargins[afterXName] + childContext.props[widthName];
        }

        contentWidth += ownerContext.targetContext.getPaddingInfo()[widthName];
        ownerContext.state.contentWidth = contentWidth;

        // if there is perpendicular overflow, the published parallel content size includes
        // the size of the perpendicular scrollbar.
        if (needsScroll &amp;&amp; needsScroll.perpendicular) {
            if (widthShrinkWrap) {
                contentWidth += scrollbarWidth;
            }
            ownerContext[names.hasOverflowY] = true;

            // tell the component layout to set the parallel size in the dom
            ownerContext.target.componentLayout[names.setWidthInDom] = true;

            // IE8 will not create a scrollbar if there is just the *exactly correct*
            // spare space created for it. We have to force that to happen once all the
            // styles have been flushed to the DOM (see completeLayout):
            ownerContext[names.invalidateScrollY] = Ext.isIE8;
        }
        ownerContext[names.setContentWidth](contentWidth);

        return true;
    },

<span id='Ext-layout-container-Box-method-calculatePerpendicular'>    calculatePerpendicular: function(ownerContext, names, plan) {
</span>        var me = this,
            state = ownerContext.state,
            needsScroll = state.needsScroll,
            canScroll = state.canScroll,
            heightShrinkWrap = ownerContext.perpendicularSizeModel.shrinkWrap,
            targetSize = plan.targetSize,
            childItems = ownerContext.childItems,
            childItemsLength = childItems.length,
            mmax = Math.max,
            heightName = names.height,
            setHeightName = names.setHeight,
            beforeYName = names.beforeY,
            topPositionName = names.y,
            padding = me.padding,
            top = padding[beforeYName],
            availHeight = targetSize[heightName] - top - padding[names.afterY],
            align = ownerContext.boxOptions.align,
            isStretch    = align.stretch, // never true if heightShrinkWrap (see beginLayoutCycle)
            isStretchMax = align.stretchmax,
            isCenter     = align.center,
            isBottom     = align.bottom,
            constrain    = me.constrainAlign,
            maxHeight = 0,
            hasPercentageSizes = 0,
            onBeforeInvalidateChild = me.onBeforeConstrainInvalidateChild,
            onAfterInvalidateChild = me.onAfterConstrainInvalidateChild,
            scrollbarHeight = Ext.getScrollbarSize().height,
            childTop, i, childHeight, childMargins, diff, height, childContext,
            stretchMaxPartner, stretchMaxChildren, shrinkWrapParallelOverflow, 
            percentagePerpendicular;

        if (!heightShrinkWrap &amp;&amp; !targetSize[names.gotHeight]) {
            return false;
        }

        if (isStretch || ((isCenter || isBottom) &amp;&amp; !heightShrinkWrap)) {
            if (isNaN(availHeight)) {
                return false;
            }
        }

        // If the intention is to horizontally scroll child components, but the container is too narrow,
        // then:
        //     if we are shrinkwrapping height:
        //         Set a flag because we are going to expand the height taken by the perpendicular dimension to accommodate the scrollbar
        //     else
        //         We must allow for the parallel scrollbar to intrude into the height
        if (needsScroll &amp;&amp; needsScroll.parallel) {
            if (heightShrinkWrap) {
                shrinkWrapParallelOverflow = true;
            } else {
                availHeight -= scrollbarHeight;
                plan.targetSize[heightName] -= scrollbarHeight;
            }
        }

        if (isStretch) {
            height = availHeight; // never heightShrinkWrap...
            maxHeight = mmax(height, ownerContext.smallestHeight);
        } else {
            for (i = 0; i &lt; childItemsLength; i++) {
                childContext = childItems[i];
                childMargins = (childContext.marginInfo || childContext.getMarginInfo())[heightName];

                if (!(percentagePerpendicular = childContext.percentagePerpendicular)) {
                    childHeight = childContext.getProp(heightName);
                } else {
                    ++hasPercentageSizes;
                    if (heightShrinkWrap) {
                        // height %age items cannot contribute to maxHeight... they are going
                        // to be a %age of that maxHeight!
                        continue;
                    } else {
                        childHeight = percentagePerpendicular * availHeight - childMargins;
                        childHeight = childContext[setHeightName](childHeight);
                    }
                }
                
                // Summary:
                // 1) Not shrink wrapping height, so the height is not determined by the children
                // 2) Constrain is set
                // 3) The child item is shrink wrapping
                // 4) It exceeds the max
                if (!heightShrinkWrap &amp;&amp; constrain &amp;&amp; childContext[names.heightModel].shrinkWrap &amp;&amp; childHeight &gt; availHeight) {
                    childContext.invalidate({
                        before: onBeforeInvalidateChild,
                        after: onAfterInvalidateChild,
                        layout: me,
                        childHeight: availHeight,
                        names: names
                    });
                    
                    // By invalidating the height, it could mean the width can change, so we need
                    // to recalculate in the parallel direction.
                    ownerContext.state.parallelDone = false; 
                }

                // Max perpendicular measurement (used for stretchmax) must take the min perpendicular size of each child into account in case any fall short.
                if (isNaN(maxHeight = mmax(maxHeight, childHeight + childMargins,
                                           childContext.target[names.minHeight] || 0))) {
                    return false; // heightShrinkWrap || isCenter || isStretchMax ??
                }
            }
        }

        // If there is going to be a parallel scrollbar maxHeight must include it to the outside world.
        // ie: a stretchmaxPartner, and the setContentHeight
        if (shrinkWrapParallelOverflow) {
            maxHeight += scrollbarHeight;
            ownerContext[names.hasOverflowX] = true;

            // tell the component layout to set the perpendicular size in the dom
            ownerContext.target.componentLayout[names.setHeightInDom] = true;

            // IE8 will not create a scrollbar if there is just the *exactly correct*
            // spare space created for it. We have to force that to happen once all
            // the styles have been flushed to the DOM (see completeLayout):
            ownerContext[names.invalidateScrollX] = Ext.isIE8;
        }

        // If we are associated with another box layout, grab its maxChildHeight
        // This must happen before we calculate and publish our contentHeight
        stretchMaxPartner = ownerContext.stretchMaxPartner;
        if (stretchMaxPartner) {
            // Publish maxChildHeight as soon as it has been calculated for our partner:
            ownerContext.setProp(&#39;maxChildHeight&#39;, maxHeight);
            stretchMaxChildren = stretchMaxPartner.childItems;
            // Only wait for maxChildHeight if our partner has visible items:
            if (stretchMaxChildren &amp;&amp; stretchMaxChildren.length) {
                maxHeight = mmax(maxHeight, stretchMaxPartner.getProp(&#39;maxChildHeight&#39;));
                if (isNaN(maxHeight)) {
                    return false;
                }
            }
        }

        ownerContext[names.setContentHeight](maxHeight + me.padding[heightName] +
                ownerContext.targetContext.getPaddingInfo()[heightName]);

        // We have to publish the contentHeight with the additional scrollbarHeight
        // to encourage our container to accommodate it, but we must remove the height
        // of the scrollbar as we go to sizing or centering the children.
        if (shrinkWrapParallelOverflow) {
            maxHeight -= scrollbarHeight;
        }
        if (maxHeight &gt; targetSize[heightName] &amp;&amp; canScroll &amp;&amp; canScroll.perpendicular) {
            state.actualScroll.perpendicular = true;
        }
        plan.maxSize = maxHeight;

        if (isStretchMax) {
            height = maxHeight;
        } else if (isCenter || isBottom || hasPercentageSizes) {
            if (constrain) {
                height = heightShrinkWrap ? maxHeight : availHeight;
            } else {
                height = heightShrinkWrap ? maxHeight : mmax(availHeight, maxHeight);
            }

            // When calculating a centered position within the content box of the innerCt,
            // the width of the borders must be subtracted from the size to yield the
            // space available to center within. The publishInnerCtSize method explicitly
            // adds the border widths to the set size of the innerCt.
            height -= ownerContext.innerCtContext.getBorderInfo()[heightName];
        }

        for (i = 0; i &lt; childItemsLength; i++) {
            childContext = childItems[i];
            childMargins = childContext.marginInfo || childContext.getMarginInfo();

            childTop = top + childMargins[beforeYName];

            if (isStretch) {
                childContext[setHeightName](height - childMargins[heightName]);
            } else {
                percentagePerpendicular = childContext.percentagePerpendicular;
                if (heightShrinkWrap &amp;&amp; percentagePerpendicular) {
                    childMargins = childContext.marginInfo || childContext.getMarginInfo();
                    childHeight = percentagePerpendicular * height - childMargins[heightName];
                    childHeight = childContext[setHeightName](childHeight);
                }

                if (isCenter) {
                    diff = height - childContext.props[heightName];
                    if (diff &gt; 0) {
                        childTop = top + Math[me.alignRoundingMethod](diff / 2);
                    }
                } else if (isBottom) {
                    childTop = mmax(0, height - childTop - childContext.props[heightName]);
                }
            }

            childContext.setProp(topPositionName, childTop);
        }

        return true;
    },
    
<span id='Ext-layout-container-Box-method-onBeforeConstrainInvalidateChild'>    onBeforeConstrainInvalidateChild: function(childContext, options){
</span>        // NOTE: No &quot;this&quot; pointer in here...
        var heightModelName = options.names.heightModel;
        if (!childContext[heightModelName].constrainedMin) {
            // if the child hit a min constraint, it needs to be at its configured size, so
            // we leave the sizeModel alone
            childContext[heightModelName] = Ext.layout.SizeModel.calculated;
        }
    },
    
<span id='Ext-layout-container-Box-method-onAfterConstrainInvalidateChild'>    onAfterConstrainInvalidateChild: function(childContext, options){
</span>         // NOTE: No &quot;this&quot; pointer in here...
        var names = options.names;

        // We use 0 here because we know the size exceeds the available size.
        // This was chosen on purpose, even for align: &#39;bottom&#39;, because it doesn&#39;t
        // make practical sense to place the item at the bottom and then have it overflow
        // over the top of the container, since it&#39;s not possible to scroll to it. As such,
        // we always put the component at the top to follow normal document flow.
        childContext.setProp(names.beforeY, 0);
        if (childContext[names.heightModel].calculated) {
            childContext[names.setHeight](options.childHeight);
        }
    },

<span id='Ext-layout-container-Box-method-calculateStretchMax'>    calculateStretchMax: function (ownerContext, names, plan) {
</span>        var me = this,
            heightName = names.height,
            widthName = names.width,
            childItems = ownerContext.childItems,
            length = childItems.length,
            height = plan.maxSize,
            onBeforeStretchMaxInvalidateChild = me.onBeforeStretchMaxInvalidateChild,
            onAfterStretchMaxInvalidateChild = me.onAfterStretchMaxInvalidateChild,
            childContext, props, i, childHeight;

        for (i = 0; i &lt; length; ++i) {
            childContext = childItems[i];

            props = childContext.props;
            childHeight = height - childContext.getMarginInfo()[heightName];

            if (childHeight !== props[heightName] ||   // if (wrong height ...
                childContext[names.heightModel].constrained) { // ...or needs invalidation)
                // When we invalidate a child, since we won&#39;t be around to size or position
                // it, we include an after callback that will be run after the invalidate
                // that will (re)do that work. The good news here is that we can read the
                // results of all that from the childContext props.
                //
                // We also include a before callback to change the sizeModel to calculated
                // prior to the layout being invoked.
                childContext.invalidate({
                    before: onBeforeStretchMaxInvalidateChild,
                    after: onAfterStretchMaxInvalidateChild,
                    layout: me,
                    // passing this data avoids a &#39;scope&#39; and its Function.bind
                    childWidth: props[widthName],
                    // subtract margins from the maximum value
                    childHeight: childHeight,
                    childX: props.x,
                    childY: props.y,
                    names: names
                });
            }
        }
    },
    
<span id='Ext-layout-container-Box-method-onBeforeStretchMaxInvalidateChild'>    onBeforeStretchMaxInvalidateChild: function (childContext, options) {
</span>        // NOTE: No &quot;this&quot; pointer in here...
        var heightModelName = options.names.heightModel;

        // Change the childItem to calculated (i.e., &quot;set by ownerCt&quot;). The component layout
        // of the child can course-correct (like dock layout does for a collapsed panel),
        // so we must make these changes here before that layout&#39;s beginLayoutCycle is
        // called.
        if (!childContext[heightModelName].constrainedMax) {
            // if the child hit a max constraint, it needs to be at its configured size, so
            // we leave the sizeModel alone...
            childContext[heightModelName] = Ext.layout.SizeModel.calculated;
        }
    },

<span id='Ext-layout-container-Box-method-onAfterStretchMaxInvalidateChild'>    onAfterStretchMaxInvalidateChild: function (childContext, options) {
</span>        // NOTE: No &quot;this&quot; pointer in here...
        var names = options.names,
            childHeight = options.childHeight,
            childWidth = options.childWidth;

        childContext.setProp(&#39;x&#39;, options.childX);
        childContext.setProp(&#39;y&#39;, options.childY);

        if (childContext[names.heightModel].calculated) {
            // We need to respect a child that is still not calculated (such as a collapsed
            // panel)...
            childContext[names.setHeight](childHeight);
        }

        if (childContext[names.widthModel].calculated) {
            childContext[names.setWidth](childWidth);
        }
    },

<span id='Ext-layout-container-Box-method-completeLayout'>    completeLayout: function(ownerContext) {
</span>        var me = this,
            invalidateScrollX = ownerContext.invalidateScrollX,
            invalidateScrollY = ownerContext.invalidateScrollY,
            overflowHandler = me.overflowHandler,
            dom, el, overflowX, overflowY, styles;

        if (overflowHandler) {
            overflowHandler.completeLayout(ownerContext);
        }

        if (invalidateScrollX || invalidateScrollY) {
            el = me.getTarget();
            dom = el.dom;
            styles = dom.style;

            if (invalidateScrollX) {
                // get computed style to see if we are &#39;auto&#39;
                overflowX = el.getStyle(&#39;overflowX&#39;);
                if (overflowX === &#39;auto&#39;) {
                    // capture the inline style (if any) so we can restore it later:
                    overflowX = styles.overflowX;
                    styles.overflowX = &#39;scroll&#39;; // force the scrollbar to appear
                } else {
                    invalidateScrollX = false; // no work really since not &#39;auto&#39;
                }
            }

            if (invalidateScrollY) {
                // get computed style to see if we are &#39;auto&#39;
                overflowY = el.getStyle(&#39;overflowY&#39;);
                if (overflowY === &#39;auto&#39;) {
                    // capture the inline style (if any) so we can restore it later:
                    overflowY = styles.overflowY;
                    styles.overflowY = &#39;scroll&#39;; // force the scrollbar to appear
                } else {
                    invalidateScrollY = false; // no work really since not &#39;auto&#39;
                }
            }

            if (invalidateScrollX || invalidateScrollY) { // if (some form of &#39;auto&#39; in play)
                // force a reflow...
                dom.scrollWidth; // jshint ignore:line

                if (invalidateScrollX) {
                    styles.overflowX = overflowX; // restore inline style
                }
                if (invalidateScrollY) {
                    styles.overflowY = overflowY; // restore inline style
                }
            }
        }
    },

<span id='Ext-layout-container-Box-method-finishedLayout'>    finishedLayout: function(ownerContext) {
</span>        var overflowHandler = this.overflowHandler;

        if (overflowHandler) {
            overflowHandler.finishedLayout(ownerContext);
        }
        this.callParent([ownerContext]);
    },

<span id='Ext-layout-container-Box-method-getLayoutItems'>    getLayoutItems: function() {
</span>        var items = this.callParent(),
            n = items.length,
            lastVisibleItem, hide, i, item, splitAfter, splitBefore, splitter;

        for (i = 0; i &lt; n; ++i) {
            if ((item = items[i]).isSplitter) {
                continue;
            }

            splitter = item.splitter;
            
            if (item.hidden) {
                if (splitter) {
                    // hidden items always need to hide their splitter
                    if (!splitter.hidden) {
                        splitter.hidden = true;
                        if (splitter.el) {
                            splitter.el.hide();
                        }
                    }
                }
                continue;
            }

            if (splitter) {
                splitBefore = splitter.collapseTarget === &#39;next&#39;;
            } else { // item w/o splitter
                splitBefore = false;
            }

            hide = null;
            if (lastVisibleItem &amp;&amp; splitAfter) {
                // the last item had a splitter after it so we can keep it and hide
                // this one if splitBefore
                if (splitAfter.hidden) {
                    splitAfter.hidden = false;
                    if (splitAfter.el) {
                        splitAfter.el.show();
                    }
                }
                if (splitBefore) {
                    hide = true;
                }
            } else if (splitBefore) {
                hide = !lastVisibleItem;
            }
            // else we have no splitter or are !splitBefore, so we defer the fate of this
            // splitter
            
            if (hide !== null &amp;&amp; splitter.hidden !== hide) {
                splitter.hidden = hide;
                if (splitter.el) {
                    splitter.el.setVisible(!hide);
                }
            }
            
            splitAfter = !splitBefore &amp;&amp; splitter;
            lastVisibleItem = item;
        }

        // If we ended with a visible item and a splitAfter, we need to hide the tail
        // splitter
        if (lastVisibleItem &amp;&amp; splitAfter &amp;&amp; !splitAfter.hidden) {
            splitAfter.hidden = true;
            if (splitAfter.el) {
                splitAfter.el.hide();
            }
        }

        return items;
    },

<span id='Ext-layout-container-Box-method-insertSplitter'>    /**
</span>     * Inserts the splitter for a given region. A reference to the splitter is also stored
     * on the component as &quot;splitter&quot;.
     * @private
     */
    insertSplitter: function (item, index, hidden, splitterCfg) {
        var splitter = {
                xtype: &#39;splitter&#39;,
                id: item.id + &#39;-splitter&#39;,
                hidden: hidden,
                splitterFor: item,
                synthetic: true // not user-defined
            },
            at = index + ((splitterCfg.collapseTarget === &#39;prev&#39;) ? 1 : 0);

        splitter[this.names.height] = &#39;100%&#39;;
        if (splitterCfg) {
            Ext.apply(splitter, splitterCfg);
        }
        item.splitter = this.owner.add(at, splitter);
    },

<span id='Ext-layout-container-Box-method-publishInnerCtSize'>    publishInnerCtSize: function(ownerContext, widthOffset) {
</span>        widthOffset = widthOffset || 0;
        
        var me = this,
            state = ownerContext.state,
            names = ownerContext.boxNames,
            heightName = names.height,
            widthName = names.width,
            align = ownerContext.boxOptions.align,
            padding = me.padding,
            plan = state.boxPlan,
            targetSize = plan.targetSize,
            height = plan.maxSize,
            needsScroll = state.needsScroll,
            innerCtContext = ownerContext.innerCtContext,
            innerCtWidth, innerCtHeight;

        // The state.canScroll check is on purpose here, all we want to know is whether we have
        // a scrollable instance, since even if UI scrolling isn&#39;t available, we may scroll it
        // programmatically
        if (ownerContext.parallelSizeModel.shrinkWrap || (plan.tooNarrow &amp;&amp; state.canScroll)) {
            innerCtWidth = state.contentWidth - ownerContext.targetContext.getPaddingInfo()[widthName];
        } else {
            innerCtWidth = targetSize[widthName];
            if (needsScroll &amp;&amp; needsScroll.perpendicular) {
                innerCtWidth -= Ext.getScrollbarSize()[widthName];
            }
        }
        innerCtWidth -= widthOffset;

        // Allow the other co-operating objects to know whether the columns overflow the available width.
        me.owner.tooNarrow = plan.tooNarrow;

        if (align.stretch) {
            innerCtHeight = height;
        } else {
            innerCtHeight = plan.maxSize + padding[names.beforeY] + padding[names.afterY] + innerCtContext.getBorderInfo()[heightName];

            if (!ownerContext.perpendicularSizeModel.shrinkWrap &amp;&amp; (align.center || align.bottom)) {
                innerCtHeight = Math.max(targetSize[heightName], innerCtHeight);
            }
        }

        innerCtContext[names.setWidth](innerCtWidth);
        innerCtContext[names.setHeight](innerCtHeight);

        // Fix for an obscure webkit bug (EXTJSIV-5962) caused by the targetEl&#39;s 20000px
        // width.  We set a very large width on the targetEl at the beginning of the 
        // layout cycle to prevent any &quot;crushing&quot; effect on the child items, however
        // in some cases the very large width makes it possible to scroll the innerCt
        // by dragging on certain child elements. To prevent this from happening we ensure
        // that the targetEl&#39;s width is the same as the innerCt.
        // IE needs it because of its scrollIntoView bug: https://sencha.jira.com/browse/EXTJSIV-6520
        // Webkit needs it because of its mouse drag bug: https://sencha.jira.com/browse/EXTJSIV-5962
        // FF needs it because of a vertical tab bug: https://sencha.jira.com/browse/EXTJSIV-8614
        ownerContext.targetElContext.setWidth(ownerContext.innerCtContext.props.width -
                (me.vertical ? 0 : (widthOffset || 0)));

        // If unable to publish both dimensions, this layout needs to run again
        if (isNaN(innerCtWidth + innerCtHeight)) {
            me.done = false;
        }
    },

<span id='Ext-layout-container-Box-method-onAdd'>    onAdd: function (item, index) {
</span>        var me = this,
            // Buttons have their own concept of &quot;split&quot; config
            split = me.enableSplitters &amp;&amp; !item.isButton &amp;&amp; item.split;

        me.callParent([item, index]);

        if (split) {
            if (split === true) {
                split = {
                    collapseTarget: &#39;next&#39;
                };
            } else if (Ext.isString(split)) {
                split = {
                    collapseTarget: split === &#39;before&#39; ? &#39;next&#39; : &#39;prev&#39;
                };
            } else {
                split = Ext.apply({
                    collapseTarget: split.side === &#39;before&#39; ? &#39;next&#39; : &#39;prev&#39;
                }, split);
            }

            me.insertSplitter(item, index, !!item.hidden, split);
        }
    },

<span id='Ext-layout-container-Box-method-onRemove'>    onRemove: function(comp, isDestroying){
</span>        var me = this,
            names = me.names,
            owner = me.owner,
            splitter = comp.splitter,
            overflowHandler = me.overflowHandler,
            el;
            
        me.callParent([comp, isDestroying]);

        if (splitter &amp;&amp; owner.contains(splitter)) {
            owner.doRemove(splitter, true);
            comp.splitter = null;
        }

        if (overflowHandler) {
            overflowHandler.onRemove(comp);
        }

        if (comp.layoutMarginCap === me.id) {
            delete comp.layoutMarginCap;
        }
        
        if (!owner.destroying &amp;&amp; !isDestroying &amp;&amp; comp.rendered) {
            // Clear top/left styles
            el = comp.getEl();
            if (el) {
                el.setStyle(names.beforeY, &#39;&#39;);
                el.setStyle(names.beforeX, &#39;&#39;);

                // Box layout imposes margin:0 on its child items and the layout provides margins
                // using its absolute positioning strategy. This has to be reversed on remove.
                el.setStyle(&#39;margin&#39;, &#39;&#39;);
            }
        }
    },

<span id='Ext-layout-container-Box-method-applyOverflowHandler'>    applyOverflowHandler: function(overflowHandler, oldOverflowHandler) {
</span>        var type;

        if (typeof overflowHandler === &#39;string&#39;) {
            overflowHandler = {
                type: overflowHandler
            };
        }

        type = overflowHandler.type;

        if (oldOverflowHandler &amp;&amp; oldOverflowHandler.type === overflowHandler.type) {
            delete overflowHandler.type;
            oldOverflowHandler.setConfig(overflowHandler);
            return oldOverflowHandler;
        }

        overflowHandler.layout = this;

        return Ext.Factory.boxOverflow(overflowHandler);
    },

<span id='Ext-layout-container-Box-method-getRenderTarget'>    // Overridden method from Ext.layout.container.Container.
</span>    // Used in the beforeLayout method to render all items into.
    getRenderTarget: function() {
        return this.targetEl;
    },

<span id='Ext-layout-container-Box-method-getElementTarget'>    // Overridden method from Ext.layout.container.Container.
</span>    // Used by Container classes to insert special DOM elements which must exist in addition to the child components
    getElementTarget: function() {
        return this.innerCt;
    },

<span id='Ext-layout-container-Box-property-calculateChildBox'>    //&lt;debug&gt;
</span>    calculateChildBox: Ext.deprecated(),
<span id='Ext-layout-container-Box-property-calculateChildBoxes'>    calculateChildBoxes: Ext.deprecated(),
</span><span id='Ext-layout-container-Box-property-updateChildBoxes'>    updateChildBoxes: Ext.deprecated(),
</span><span id='Ext-layout-container-Box-method-destroy'>    //&lt;/debug&gt;
</span>
    destroy: function() {
        var me = this;
        Ext.destroy(me.innerCt, me.overflowHandler);
        me.flexSortFn = me.innerCt = null;
        me.callParent();
    },

<span id='Ext-layout-container-Box-method-getRenderData'>    getRenderData: function() {
</span>        var data = this.callParent();

        data.targetElCls = this.targetElCls;

        return data;
    },

<span id='Ext-layout-container-Box-method-updateVertical'>    updateVertical: function (vertical) {
</span>        var me = this,
            overflowHandler = me.overflowHandler,
            owner = me.owner,
            props = me._props;

        Ext.apply(me, vertical ? props.vbox : props.hbox);

        if (overflowHandler &amp;&amp; owner &amp;&amp; owner.rendered) {
            overflowHandler.setVertical(vertical);
        }
    },

<span id='Ext-layout-container-Box-property-_props'>    _props: {
</span>        // HBOX - this key is produced by setVertical
        &#39;hbox&#39;: {
            direction: &#39;horizontal&#39;,
            oppositeDirection: &#39;vertical&#39;,
            horizontal: true,
            vertical: false,
            names: {
                // parallel
                beforeX: &#39;left&#39;,
                beforeScrollX: &#39;left&#39;,
                leftCap: &#39;Left&#39;,
                afterX: &#39;right&#39;,
                width: &#39;width&#39;,
                contentWidth: &#39;contentWidth&#39;,
                minWidth: &#39;minWidth&#39;,
                maxWidth: &#39;maxWidth&#39;,
                widthCap: &#39;Width&#39;,
                widthModel: &#39;widthModel&#39;,
                widthIndex: 0,
                x: &#39;x&#39;,
                getX: &#39;getX&#39;,
                setX: &#39;setX&#39;,
                scrollLeft: &#39;scrollLeft&#39;,
                overflowX: &#39;overflowX&#39;,
                hasOverflowX: &#39;hasOverflowX&#39;,
                invalidateScrollX: &#39;invalidateScrollX&#39;,
                parallelMargins: &#39;lr&#39;,

                // perpendicular
                center: &#39;middle&#39;,
                beforeY: &#39;top&#39;,
                afterY: &#39;bottom&#39;,
                height: &#39;height&#39;,
                contentHeight: &#39;contentHeight&#39;,
                minHeight: &#39;minHeight&#39;,
                maxHeight: &#39;maxHeight&#39;,
                heightCap: &#39;Height&#39;,
                heightModel: &#39;heightModel&#39;,
                heightIndex: 1,
                y: &#39;y&#39;,
                getY: &#39;getY&#39;,
                setY: &#39;setY&#39;,
                overflowY: &#39;overflowY&#39;,
                hasOverflowY: &#39;hasOverflowY&#39;,
                invalidateScrollY: &#39;invalidateScrollY&#39;,
                perpendicularMargins: &#39;tb&#39;,

                // Methods
                getWidth: &#39;getWidth&#39;,
                getHeight: &#39;getHeight&#39;,
                setWidth: &#39;setWidth&#39;,
                setHeight: &#39;setHeight&#39;,
                gotWidth: &#39;gotWidth&#39;,
                gotHeight: &#39;gotHeight&#39;,
                setContentWidth: &#39;setContentWidth&#39;,
                setContentHeight: &#39;setContentHeight&#39;,
                setWidthInDom: &#39;setWidthInDom&#39;,
                setHeightInDom: &#39;setHeightInDom&#39;,
                getScrollLeft: &#39;getScrollLeft&#39;,
                setScrollLeft: &#39;setScrollLeft&#39;,
                scrollTo: &#39;scrollTo&#39;
            },

            sizePolicy: {
                flex: {
                    &#39;&#39;: {
                        readsWidth : 0,
                        readsHeight: 1,
                        setsWidth  : 1,
                        setsHeight : 0
                    },
                    stretch: {
                        readsWidth : 0,
                        readsHeight: 0,
                        setsWidth  : 1,
                        setsHeight : 1
                    },
                    stretchmax: {
                        readsWidth : 0,
                        readsHeight: 1,
                        setsWidth  : 1,
                        setsHeight : 1
                    }
                },
                &#39;&#39;: {
                    readsWidth : 1,
                    readsHeight: 1,
                    setsWidth  : 0,
                    setsHeight : 0
                },
                stretch: {
                    readsWidth : 1,
                    readsHeight: 0,
                    setsWidth  : 0,
                    setsHeight : 1
                },
                stretchmax: {
                    readsWidth : 1,
                    readsHeight: 1,
                    setsWidth  : 0,
                    setsHeight : 1
                }
            }
        },
        // VBOX
        &#39;vbox&#39;: {
            direction: &#39;vertical&#39;,
            oppositeDirection: &#39;horizontal&#39;,
            horizontal: false,
            vertical: true,
            names: {
                // parallel
                beforeX: &#39;top&#39;,
                beforeScrollX: &#39;top&#39;,
                leftCap: &#39;Top&#39;,
                afterX: &#39;bottom&#39;,
                width: &#39;height&#39;,
                contentWidth: &#39;contentHeight&#39;,
                minWidth: &#39;minHeight&#39;,
                maxWidth: &#39;maxHeight&#39;,
                widthCap: &#39;Height&#39;,
                widthModel: &#39;heightModel&#39;,
                widthIndex: 1,
                x: &#39;y&#39;,
                getX: &#39;getY&#39;,
                setX: &#39;setY&#39;,
                scrollLeft: &#39;scrollTop&#39;,
                overflowX: &#39;overflowY&#39;,
                hasOverflowX: &#39;hasOverflowY&#39;,
                invalidateScrollX: &#39;invalidateScrollY&#39;,
                parallelMargins: &#39;tb&#39;,

                // perpendicular
                center: &#39;center&#39;,
                beforeY: &#39;left&#39;,
                afterY: &#39;right&#39;,
                height: &#39;width&#39;,
                contentHeight: &#39;contentWidth&#39;,
                minHeight: &#39;minWidth&#39;,
                maxHeight: &#39;maxWidth&#39;,
                heightCap: &#39;Width&#39;,
                heightModel: &#39;widthModel&#39;,
                heightIndex: 0,
                y: &#39;x&#39;,
                getY: &#39;getX&#39;,
                setY: &#39;setX&#39;,
                overflowY: &#39;overflowX&#39;,
                hasOverflowY: &#39;hasOverflowX&#39;,
                invalidateScrollY: &#39;invalidateScrollX&#39;,
                perpendicularMargins: &#39;lr&#39;,

                // Methods
                getWidth: &#39;getHeight&#39;,
                getHeight: &#39;getWidth&#39;,
                setWidth: &#39;setHeight&#39;,
                setHeight: &#39;setWidth&#39;,
                gotWidth: &#39;gotHeight&#39;,
                gotHeight: &#39;gotWidth&#39;,
                setContentWidth: &#39;setContentHeight&#39;,
                setContentHeight: &#39;setContentWidth&#39;,
                setWidthInDom: &#39;setHeightInDom&#39;,
                setHeightInDom: &#39;setWidthInDom&#39;,
                getScrollLeft: &#39;getScrollTop&#39;,
                setScrollLeft: &#39;setScrollTop&#39;,
                scrollTo: &#39;scrollTo&#39;
            },

            sizePolicy: {
                flex: {
                    &#39;&#39;: {
                        readsWidth : 1,
                        readsHeight: 0,
                        setsWidth  : 0,
                        setsHeight : 1
                    },
                    stretch: {
                        readsWidth : 0,
                        readsHeight: 0,
                        setsWidth  : 1,
                        setsHeight : 1
                    },
                    stretchmax: {
                        readsWidth : 1,
                        readsHeight: 0,
                        setsWidth  : 1,
                        setsHeight : 1
                    }
                },
                &#39;&#39;: {
                    readsWidth : 1,
                    readsHeight: 1,
                    setsWidth  : 0,
                    setsHeight : 0
                },
                stretch: {
                    readsWidth : 0,
                    readsHeight: 1,
                    setsWidth  : 1,
                    setsHeight : 0
                },
                stretchmax: {
                    readsWidth : 1,
                    readsHeight: 1,
                    setsWidth  : 1,
                    setsHeight : 0
                }
            }
        }
    }
});
</pre>
</body>
</html>
