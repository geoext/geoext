<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-grid-filters-Filters'>/**
</span> * This class is a grid {@link Ext.AbstractPlugin plugin} that adds a simple and flexible
 * presentation for {@link Ext.data.AbstractStore#filters store filters}.
 *
 * Filters can be modified by the end-user using the grid&#39;s column header menu. Through
 * this menu users can configure, enable, and disable filters for each column.
 *
 * # Example Usage
 *
 *     @example
 *     var shows = Ext.create(&#39;Ext.data.Store&#39;, {
 *         fields: [&#39;id&#39;,&#39;show&#39;],
 *         data: [
 *             {id: 0, show: &#39;Battlestar Galactica&#39;},
 *             {id: 1, show: &#39;Doctor Who&#39;},
 *             {id: 2, show: &#39;Farscape&#39;},
 *             {id: 3, show: &#39;Firefly&#39;},
 *             {id: 4, show: &#39;Star Trek&#39;},
 *             {id: 5, show: &#39;Star Wars: Christmas Special&#39;}
 *         ]
 *     });
 *   
 *     Ext.create(&#39;Ext.grid.Panel&#39;, {
 *         renderTo: Ext.getBody(),
 *         title: &#39;Sci-Fi Television&#39;,
 *         height: 250,
 *         width: 250,
 *         store: shows,
 *         plugins: &#39;gridfilters&#39;,
 *         columns: [{
 *             dataIndex: &#39;id&#39;,
 *             text: &#39;ID&#39;,
 *             width: 50
 *         },{
 *             dataIndex: &#39;show&#39;,
 *             text: &#39;Show&#39;,
 *             flex: 1,
 *             filter: {
 *                 // required configs
 *                 type: &#39;string&#39;,
 *                 // optional configs
 *                 value: &#39;star&#39;,  // setting a value makes the filter active. 
 *                 itemDefaults: {
 *                     // any Ext.form.field.Text configs accepted
 *                 }
 *             }
 *         }]
 *     }); 
 *
 * # Features
 *
 * ## Filtering implementations
 *
 * Currently provided filter types are:
 *
 *   * `{@link Ext.grid.filters.filter.Boolean boolean}`
 *   * `{@link Ext.grid.filters.filter.Date date}`
 *   * `{@link Ext.grid.filters.filter.List list}`
 *   * `{@link Ext.grid.filters.filter.Number number}`
 *   * `{@link Ext.grid.filters.filter.String string}`
 *
 * **Note:** You can find inline examples for each filter on its specific filter page. 
 *
 * ## Graphical Indicators
 *
 * Columns that are filtered have {@link #filterCls CSS class} applied to their column
 * headers. This style can be managed using that CSS class or by setting these Sass
 * variables in your theme or application:
 *
 *      $grid-filters-column-filtered-font-style: italic !default;
 *
 *      $grid-filters-column-filtered-font-weight: bold !default;
 *
 * ## Stateful
 *
 * Filter information will be persisted across page loads by specifying a `stateId`
 * in the Grid configuration. In actuality this state is saved by the `store`, but this
 * plugin ensures that saved filters are properly identified and reclaimed on subsequent
 * visits to the page.
 *
 * ## Grid Changes
 *
 * - A `filters` property is added to the Grid using this plugin.
 *
 * # Upgrading From Ext.ux.grid.FilterFeature
 *
 * The biggest change for developers converting from the user extension is most likely the
 * conversion to standard {@link Ext.data.AbstractStore#filters store filters}. In the
 * process, the &quot;like&quot; and &quot;in&quot; operators are now supported by `{@link Ext.util.Filter}`.
 * These filters and all other filters added to the store will be sent in the standard
 * way (using the &quot;filters&quot; parameter by default).
 *
 * Since this plugin now uses actual store filters, the `onBeforeLoad` listener and all
 * helper methods that were used to clean and build the params have been removed. The store
 * will send the filters managed by this plugin along in its normal request.
 */
Ext.define(&#39;Ext.grid.filters.Filters&#39;, {
    extend: &#39;Ext.plugin.Abstract&#39;,
    alias: &#39;plugin.gridfilters&#39;,

    mixins: [
        &#39;Ext.util.StoreHolder&#39;
    ],

    requires: [
        &#39;Ext.grid.filters.filter.*&#39;
    ],

<span id='Ext-grid-filters-Filters-cfg-id'>    id: &#39;gridfilters&#39;,
</span>
<span id='Ext-grid-filters-Filters-property-defaultFilterTypes'>    /**
</span>     * @property {Object} defaultFilterTypes
     * This property maps {@link Ext.data.Model#cfg-fields field type} to the
     * appropriate grid filter type.
     * @private
     */
    defaultFilterTypes: {
        &#39;boolean&#39;: &#39;boolean&#39;,
        &#39;int&#39;: &#39;number&#39;,
        date: &#39;date&#39;,
        number: &#39;number&#39;
    },

<span id='Ext-grid-filters-Filters-property-filterCls'>    /**
</span>     * @property {String} [filterCls=&quot;x-grid-filters-filtered-column&quot;]
     * The CSS applied to column headers with active filters.
     */
    filterCls: Ext.baseCSSPrefix + &#39;grid-filters-filtered-column&#39;,

    //&lt;locale&gt;
<span id='Ext-grid-filters-Filters-cfg-menuFilterText'>    /**
</span>     * @cfg {String} [menuFilterText=&quot;Filters&quot;]
     * The text for the filters menu.
     */
    menuFilterText: &#39;Filters&#39;,
    //&lt;/locale&gt;

<span id='Ext-grid-filters-Filters-cfg-showMenu'>    /**
</span>     * @cfg {Boolean} showMenu
     * Defaults to true, including a filter submenu in the default header menu.
     */
    showMenu: true,

<span id='Ext-grid-filters-Filters-cfg-stateId'>    /**
</span>     * @cfg {String} stateId
     * Name of the value to be used to store state information.
     */
    stateId: undefined,

<span id='Ext-grid-filters-Filters-method-init'>    init: function (grid) {
</span>        var me = this,
            store, headerCt;

        //&lt;debug&gt;
        Ext.Assert.falsey(me.grid);
        //&lt;/debug&gt;

        me.grid = grid;
        grid.filters = me;

        if (me.grid.normalGrid) {
            me.isLocked = true;
        }

        grid.clearFilters = me.clearFilters.bind(me);

        store = grid.store;
        headerCt = grid.headerCt;

        me.headerCtListeners = headerCt.on({
            destroyable: true,
            scope: me,
            add: me.onAdd,
            menucreate: me.onMenuCreate
        });

        me.gridListeners = grid.on({
            destroyable: true,
            scope: me,
            reconfigure: me.onReconfigure
        });

        me.bindStore(store);

        if (grid.stateful) {
            store.statefulFilters = true;
        }

        me.initColumns();
    },

<span id='Ext-grid-filters-Filters-method-initColumns'>    /**
</span>     * Creates the Filter objects for the current configuration.
     * Reconfigure and on add handlers.
     * @private
     */
    initColumns: function () {
        var grid = this.grid,
            store = grid.getStore(),
            columns = grid.columnManager.getColumns(),
            len = columns.length,
            i, column,
            filter, filterCollection;

        // We start with filters defined on any columns.
        for (i = 0; i &lt; len; i++) {
            column = columns[i];
            filter = column.filter;

            if (filter &amp;&amp; !filter.isGridFilter) {
                if (!filterCollection) {
                    filterCollection = store.getFilters();
                    filterCollection.beginUpdate();
                }

                this.createColumnFilter(column);
            }
        }

        if (filterCollection) {
            filterCollection.endUpdate();
        }
    },

<span id='Ext-grid-filters-Filters-method-createColumnFilter'>    createColumnFilter: function (column) {
</span>        var me = this,
            columnFilter = column.filter,
            filter = {
                column: column,
                grid: me.grid,
                owner: me
            },
            field, model, type;

        if (Ext.isString(columnFilter)) {
            filter.type = columnFilter;
        } else {
            Ext.apply(filter, columnFilter);
        }

        if (!filter.type) {
            model = me.store.getModel();
            // If no filter type given, first try to get it from the data field.
            field = model &amp;&amp; model.getField(column.dataIndex);
            type = field &amp;&amp; field.type;

            filter.type = (type &amp;&amp; me.defaultFilterTypes[type]) ||
                           column.defaultFilterType || &#39;string&#39;;
        }

        column.filter = Ext.Factory.gridFilter(filter);
        if (!column.menuDisabled) {
            column.requiresMenu = true;
        }
    },

<span id='Ext-grid-filters-Filters-method-onAdd'>    onAdd: function (headerCt, column, index) {
</span>        var filter = column.filter;

        if (filter &amp;&amp; !filter.isGridFilter) {
            this.createColumnFilter(column);
        }
    },

<span id='Ext-grid-filters-Filters-method-onMenuCreate'>    /**
</span>     * @private
     * Handle creation of the grid&#39;s header menu.
     */
    onMenuCreate: function (headerCt, menu) {
        menu.on({
            beforeshow: this.onMenuBeforeShow,
            scope: this
        });
    },

<span id='Ext-grid-filters-Filters-method-onMenuBeforeShow'>    /**
</span>     * @private
     * Handle showing of the grid&#39;s header menu. Sets up the filter item and menu
     * appropriate for the target column.
     */
    onMenuBeforeShow: function (menu) {
        var me = this,
            menuItem, filter, parentTable, parentTableId;

        if (me.showMenu) {
            // In the case of a locked grid, we need to cache the &#39;Filters&#39; menuItem for each grid since
            // there&#39;s only one Filters instance. Both grids/menus can&#39;t share the same menuItem!
            if (!me.filterMenuItem) {
                me.filterMenuItem = {};
            }

            // Don&#39;t get the owner panel if in a locking grid since we need to get the unique filterMenuItem key.
            // Instead, get a ref to the parent, i.e., lockedGrid, normalGrid, etc.
            parentTable = menu.up(&#39;tablepanel&#39;);
            parentTableId = parentTable.id;

            menuItem = me.filterMenuItem[parentTableId];

            if (!menuItem || menuItem.destroyed) {
                menuItem = me.createMenuItem(menu, parentTableId);
            }

            // Save a ref to the root &quot;Filters&quot; menu item, column filters make use of it.
            me.activeFilterMenuItem = menuItem;

            filter = me.getMenuFilter(parentTable.headerCt);
            if (filter) {
                filter.showMenu(menuItem);
            }

            menuItem.setVisible(!!filter);
            
            if (me.sep) {
                me.sep.setVisible(!!filter);
            }
        }
    },

<span id='Ext-grid-filters-Filters-method-createMenuItem'>    createMenuItem: function (menu, parentTableId) {
</span>        var me = this,
            item;

        // only add separator if there are other menu items
        if (menu.items.length) {
            me.sep = menu.add(&#39;-&#39;);
        }

        item = menu.add({
            checked: false,
            itemId: &#39;filters&#39;,
            text: me.menuFilterText,
            listeners: {
                scope: me,
                checkchange: me.onCheckChange
            }
        });

        return (me.filterMenuItem[parentTableId] = item);
    },

<span id='Ext-grid-filters-Filters-method-destroy'>    destroy: function() {
</span>        var me = this,
            filterMenuItem = me.filterMenuItem,
            item;

        Ext.destroy(me.headerCtListeners, me.gridListeners);

        me.bindStore(null);
        me.sep = Ext.destroy(me.sep);

        for (item in filterMenuItem) {
            filterMenuItem[item].destroy();
        }
        
        this.callParent();
    },

<span id='Ext-grid-filters-Filters-method-onUnbindStore'>    onUnbindStore: function(store) {
</span>        if (store &amp;&amp; !store.destroyed) {
            store.getFilters().un(&#39;remove&#39;, this.onFilterRemove, this);
        }
    },

<span id='Ext-grid-filters-Filters-method-onBindStore'>    onBindStore: function(store, initial, propName) {
</span>        this.local = !store.getRemoteFilter();
        store.getFilters().on(&#39;remove&#39;, this.onFilterRemove, this);
    },

<span id='Ext-grid-filters-Filters-method-onFilterRemove'>    onFilterRemove: function (filterCollection, list) {
</span>        // We need to know when a store filter has been removed by an operation of the gridfilters UI, i.e.,
        // store.clearFilter().  The preventFilterRemoval flag lets us know whether or not this listener has been
        // reached by a filter operation (preventFilterRemoval === true) or by something outside of the UI
        // (preventFilterRemoval === undefined).
        var len = list.items.length,
            columnManager = this.grid.columnManager,
            i, item, header, filter;


        for (i = 0; i &lt; len; i++) {
            item = list.items[i];

            header = columnManager.getHeaderByDataIndex(item.getProperty());
            if (header) {
                // First, we need to make sure there is indeed a filter and that its menu has been created. If not,
                // there&#39;s no point in continuing.
                //
                // Also, even though the store may be filtered by this dataIndex, it doesn&#39;t necessarily mean that
                // it was created via the gridfilters API. To be sure, we need to check the prefix, as this is the
                // only way we can be sure of its provenance (note that we can&#39;t check `operator`).
                //
                // Note that we need to do an indexOf check on the string because TriFilters will contain extra
                // characters specifying its type.
                //
                // TODO: Should we support updating the gridfilters if one or more of its filters have been removed
                // directly by the bound store?
                filter = header.filter;
                if (!filter || !filter.menu || item.getId().indexOf(filter.getBaseIdPrefix()) === -1) {
                    continue;
                }

                if (!filter.preventFilterRemoval) {
                    // This is only called on the filter if called from outside of the gridfilters UI.
                    filter.onFilterRemove(item.getOperator());
                }
            }
        }
    },

<span id='Ext-grid-filters-Filters-method-getMenuFilter'>    /**
</span>     * @private
     * Get the filter menu from the filters MixedCollection based on the clicked header.
     */
    getMenuFilter: function (headerCt) {
        return headerCt.getMenu().activeHeader.filter;
    },

<span id='Ext-grid-filters-Filters-method-onCheckChange'>    /**
</span>     * @private
     *
     */
    onCheckChange: function (item, value) {
        // Locking grids must lookup the correct grid.
        var parentTable = this.isLocked ? item.up(&#39;tablepanel&#39;) : this.grid,
            filter = this.getMenuFilter(parentTable.headerCt);

        filter.setActive(value);
    },

<span id='Ext-grid-filters-Filters-method-getHeaders'>    getHeaders: function () {
</span>        return this.grid.view.headerCt.columnManager.getColumns();
    },

<span id='Ext-grid-filters-Filters-method-isStateful'>    /**
</span>     * Checks the plugin&#39;s grid for statefulness.
     * @return {Boolean}
     */
    isStateful: function () {
        return this.grid.stateful;
    },

<span id='Ext-grid-filters-Filters-method-addFilter'>    /**
</span>     * Adds a filter to the collection and creates a store filter if has a `value` property.
     * @param {Object/Object[]/Ext.util.Filter/Ext.util.Filter[]} filters A filter
     * configuration or a filter object.
     */
    addFilter: function (filters) {
        var me = this,
            grid = me.grid,
            store = me.store,
            hasNewColumns = false,
            suppressNextFilter = true,
            dataIndex, column, i, len, filter, columnFilter;

        if (!Ext.isArray(filters)) {
            filters = [filters];
        }

        for (i = 0, len = filters.length; i &lt; len; i++) {
            filter = filters[i];
            dataIndex = filter.dataIndex;
            column = grid.columnManager.getHeaderByDataIndex(dataIndex);

            // We only create filters that map to an existing column.
            if (column) {
                hasNewColumns = true;

                // Don&#39;t suppress active filters.
                if (filter.value) {
                    suppressNextFilter = false;
                }

                columnFilter = column.filter;

                // If already a gridfilter, let&#39;s destroy it and recreate another from the new config.
                if (columnFilter &amp;&amp; columnFilter.isGridFilter) {
                    columnFilter.deactivate();
                    columnFilter.destroy();

                    if (me.activeFilterMenuItem) {
                        me.activeFilterMenuItem.menu = null;
                    }
                }

                column.filter = filter;
            }
        }

        // Batch initialize all column filters.
        if (hasNewColumns) {
            store.suppressNextFilter = suppressNextFilter;
            me.initColumns();
            store.suppressNextFilter = false;
        }
    },

<span id='Ext-grid-filters-Filters-method-addFilters'>    /**
</span>     * Adds filters to the collection.
     * @param {Array} filters An Array of filter configuration objects.
     */
    addFilters: function (filters) {
        if (filters) {
            this.addFilter(filters);
        }
    },

<span id='Ext-grid-filters-Filters-method-clearFilters'>    /**
</span>     * Turns all filters off. This does not clear the configuration information.
     */
    clearFilters: function () {
        var grid = this.grid,
            columns = grid.columnManager.getColumns(),
            store = grid.store,
            column, filter, i, len, filterCollection;

        // We start with filters defined on any columns.
        for (i = 0, len = columns.length; i &lt; len; i++) {
            column = columns[i];
            filter = column.filter;

            if (filter &amp;&amp; filter.isGridFilter) {
                if (!filterCollection) {
                    filterCollection = store.getFilters();
                    filterCollection.beginUpdate();
                }

                filter.setActive(false);
            }
        }

        if (filterCollection) {
            filterCollection.endUpdate();
        }
    },

<span id='Ext-grid-filters-Filters-method-onReconfigure'>    onReconfigure: function(grid, store, columns, oldStore) {
</span>        var me = this,
            filterMenuItem = me.filterMenuItem,
            changed = oldStore !== store,
            key;

        // The Filters item&#39;s menu should have already been destroyed by the time we get here but
        // we still need to null out the menu reference.
        if (columns) {
            for (key in filterMenuItem) {
                filterMenuItem[key].setMenu(null);
            }
        }

        if (store) {
            if (oldStore &amp;&amp; !oldStore.destroyed &amp;&amp; changed) {
                me.resetFilters(oldStore);
            }

            if (changed) {
                me.bindStore(store);
                me.applyFilters(store);
            }
        }
        me.initColumns();
    },

<span id='Ext-grid-filters-Filters-property-privates'>    privates: {
</span>        applyFilters: function(store) {
            var columns = this.grid.columnManager.getColumns(),
                len = columns.length,
                i, column,
                filter, filterCollection;

            // We start with filters defined on any columns.
            for (i = 0; i &lt; len; i++) {
                column = columns[i];
                filter = column.filter;

                if (filter &amp;&amp; filter.isGridFilter) {
                    if (!filterCollection) {
                        filterCollection = store.getFilters();
                        filterCollection.beginUpdate();
                    }

                    if (filter.active) {
                        filter.activate();
                    }
                }
            }

            if (filterCollection) {
                filterCollection.endUpdate();
            }
        },

        resetFilters: function(store) {
            var filters = store.getFilters(),
                i, updating, filter;

            if (filters) {
                for (i = filters.getCount() - 1; i &gt;= 0; --i) {
                    filter = filters.getAt(i);
                    if (filter.isGridFilter) {
                        if (!updating) {
                            filters.beginUpdate();
                        }
                        filters.remove(filter);
                        updating = true;
                    }
                }

                if (updating) {
                    filters.endUpdate();
                }
            }

        }
    }
});
</pre>
</body>
</html>
