<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-form-field-Time'>/**
</span> * Provides a time input field with a time dropdown and automatic time validation.
 *
 * This field recognizes and uses JavaScript Date objects as its main {@link #value} type (only the time portion of the
 * date is used; the month/day/year are ignored). In addition, it recognizes string values which are parsed according to
 * the {@link #format} and/or {@link #altFormats} configs. These may be reconfigured to use time formats appropriate for
 * the user&#39;s locale.
 *
 * The field may be limited to a certain range of times by using the {@link #minValue} and {@link #maxValue} configs,
 * and the interval between time options in the dropdown can be changed with the {@link #increment} config.
 *
 * Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         title: &#39;Time Card&#39;,
 *         width: 300,
 *         bodyPadding: 10,
 *         renderTo: Ext.getBody(),
 *         items: [{
 *             xtype: &#39;timefield&#39;,
 *             name: &#39;in&#39;,
 *             fieldLabel: &#39;Time In&#39;,
 *             minValue: &#39;6:00 AM&#39;,
 *             maxValue: &#39;8:00 PM&#39;,
 *             increment: 30,
 *             anchor: &#39;100%&#39;
 *         }, {
 *             xtype: &#39;timefield&#39;,
 *             name: &#39;out&#39;,
 *             fieldLabel: &#39;Time Out&#39;,
 *             minValue: &#39;6:00 AM&#39;,
 *             maxValue: &#39;8:00 PM&#39;,
 *             increment: 30,
 *             anchor: &#39;100%&#39;
 *        }]
 *     });
 */
Ext.define(&#39;Ext.form.field.Time&#39;, {
    extend:&#39;Ext.form.field.ComboBox&#39;,
    alias: &#39;widget.timefield&#39;,
    requires: [&#39;Ext.form.field.Date&#39;, &#39;Ext.picker.Time&#39;, &#39;Ext.view.BoundListKeyNav&#39;, &#39;Ext.Date&#39;],
    alternateClassName: [&#39;Ext.form.TimeField&#39;, &#39;Ext.form.Time&#39;],

<span id='Ext-form-field-Time-cfg-triggerCls'>    /**
</span>     * @cfg {String} [triggerCls=&#39;x-form-time-trigger&#39;]
     * An additional CSS class used to style the trigger button. The trigger will always get the {@link Ext.form.trigger.Trigger#baseCls}
     * by default and triggerCls will be **appended** if specified.
     */
    triggerCls: Ext.baseCSSPrefix + &#39;form-time-trigger&#39;,

<span id='Ext-form-field-Time-cfg-minValue'>    /**
</span>     * @cfg {Date/String} minValue
     * The minimum allowed time. Can be either a Javascript date object with a valid time value or a string time in a
     * valid format -- see {@link #format} and {@link #altFormats}.
     */

<span id='Ext-form-field-Time-cfg-maxValue'>    /**
</span>     * @cfg {Date/String} maxValue
     * The maximum allowed time. Can be either a Javascript date object with a valid time value or a string time in a
     * valid format -- see {@link #format} and {@link #altFormats}.
     */

    //&lt;locale&gt;
<span id='Ext-form-field-Time-cfg-minText'>    /**
</span>     * @cfg {String} minText
     * The error text to display when the entered time is before {@link #minValue}.
     */
    minText : &quot;The time in this field must be equal to or after {0}&quot;,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-form-field-Time-cfg-maxText'>    /**
</span>     * @cfg {String} maxText
     * The error text to display when the entered time is after {@link #maxValue}.
     */
    maxText : &quot;The time in this field must be equal to or before {0}&quot;,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-form-field-Time-cfg-invalidText'>    /**
</span>     * @cfg {String} invalidText
     * The error text to display when the time in the field is invalid.
     */
    invalidText : &quot;{0} is not a valid time&quot;,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-form-field-Time-cfg-format'>    /**
</span>     * @cfg {String} [format=undefined]
     * The default time format string which can be overridden for localization support. 
     * The format must be valid according to {@link Ext.Date#parse}.
     *
     * Defaults to `&#39;g:i A&#39;`, e.g., `&#39;3:15 PM&#39;`. For 24-hour time format try `&#39;H:i&#39;` instead.
     */
    format : &quot;g:i A&quot;,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-form-field-Time-cfg-submitFormat'>    /**
</span>     * @cfg {String} [submitFormat=undefined]
     * The date format string which will be submitted to the server. The format must be valid according to
     * {@link Ext.Date#parse}.
     *
     * Defaults to {@link #format}.
     */
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-form-field-Time-cfg-altFormats'>    /**
</span>     * @cfg {String} altFormats
     * Multiple date formats separated by &quot;|&quot; to try when parsing a user input value and it doesn&#39;t match the defined
     * format.
     */
    altFormats : &quot;g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H|gi a|hi a|giA|hiA|gi A|hi A&quot;,
    //&lt;/locale&gt;
    
    //&lt;locale&gt;
    // The default format for the time field is &#39;g:i A&#39;, which is hardly informative
<span id='Ext-form-field-Time-cfg-formatText'>    /**
</span>     * @cfg {String} formatText
     * The format text to be announced by screen readers when the field is focused.
     */
<span id='global-property-formatText'>    /** @ignore */
</span>    formatText: &#39;Expected time format HH:MM space AM or PM&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-field-Time-cfg-increment'>    /**
</span>     * @cfg {Number} [increment=15]
     * The number of minutes between each time value in the list.
     *
     * Note that this only affects the *list of suggested times.*
     *
     * To enforce that only times on the list are valid, use {@link #snapToIncrement}. That will coerce
     * any typed values to the nearest increment point upon blur.
     */
    increment: 15,

<span id='Ext-form-field-Time-cfg-pickerMaxHeight'>    /**
</span>     * @cfg {Number} pickerMaxHeight
     * The maximum height of the {@link Ext.picker.Time} dropdown.
     */
    pickerMaxHeight: 300,

<span id='Ext-form-field-Time-cfg-selectOnTab'>    /**
</span>     * @cfg {Boolean} selectOnTab
     * Whether the Tab key should select the currently highlighted item.
     */
    selectOnTab: true,

<span id='Ext-form-field-Time-cfg-snapToIncrement'>    /**
</span>     * @cfg {Boolean} [snapToIncrement=false]
     * Specify as `true` to enforce that only values on the {@link #increment} boundary are accepted.
     *
     * Typed values will be coerced to the nearest {@link #increment} point on blur.
     */
    snapToIncrement: false,

<span id='Ext-form-field-Time-cfg-valuePublishEvent'>    /**
</span>     * @cfg
     * @inheritdoc
     */
    valuePublishEvent: [&#39;select&#39;, &#39;blur&#39;],

<span id='Ext-form-field-Time-property-initDate'>    /**
</span>     * @private
     * This is the date to use when generating time values in the absence of either minValue
     * or maxValue.  Using the current date causes DST issues on DST boundary dates, so this is an
     * arbitrary &quot;safe&quot; date that can be any date aside from DST boundary dates.
     */
    initDate: &#39;1/1/2008&#39;,
<span id='Ext-form-field-Time-property-initDateParts'>    initDateParts: [2008, 0, 1],
</span><span id='Ext-form-field-Time-property-initDateFormat'>    initDateFormat: &#39;j/n/Y&#39;,
</span>
<span id='Ext-form-field-Time-cfg-queryMode'>    queryMode: &#39;local&#39;,
</span>
<span id='Ext-form-field-Time-cfg-displayField'>    displayField: &#39;disp&#39;,
</span>
<span id='Ext-form-field-Time-cfg-valueField'>    valueField: &#39;date&#39;,
</span>
<span id='Ext-form-field-Time-method-initComponent'>    initComponent: function() {
</span>        var me = this,
            min = me.minValue,
            max = me.maxValue;
        
        if (min) {
            me.setMinValue(min);
        }
        if (max) {
            me.setMaxValue(max);
        }
        me.displayTpl = new Ext.XTemplate(
            &#39;&lt;tpl for=&quot;.&quot;&gt;&#39; +
                &#39;{[typeof values === &quot;string&quot; ? values : this.formatDate(values[&quot;&#39; + me.displayField + &#39;&quot;])]}&#39; +
                &#39;&lt;tpl if=&quot;xindex &lt; xcount&quot;&gt;&#39; + me.delimiter + &#39;&lt;/tpl&gt;&#39; +
            &#39;&lt;/tpl&gt;&#39;, {
            formatDate: me.formatDate.bind(me)
        });

        // Create a store of times.
        me.store = Ext.picker.Time.createStore(me.format, me.increment);

        me.callParent();

        // Ensure time constraints are applied to the store.
        // TimePicker does this on create.
        me.getPicker();
    },
    
<span id='Ext-form-field-Time-method-afterQuery'>    afterQuery: function(queryPlan) {
</span>        var me = this;

        me.callParent([queryPlan]);
        // Check the field for null value (TimeField returns null for invalid dates).
        // If value is null and a rawValue is present, then we we should manually
        // validate the field to display errors.
        if (me.value === null &amp;&amp; me.getRawValue() &amp;&amp; me.validateOnChange) {
            me.validate();
        }
    },

<span id='Ext-form-field-Time-method-isEqual'>    /**
</span>     * @private
     */
    isEqual: function (v1, v2) {
        var fromArray = Ext.Array.from,
            isEqual = Ext.Date.isEqual,
            i, len;

        v1 = fromArray(v1);
        v2 = fromArray(v2);
        len = v1.length;

        if (len !== v2.length) {
            return false;
        }

        for (i = 0; i &lt; len; i++) {
            if (!(v2[i] instanceof Date) || !(v1[i] instanceof Date) || !isEqual(v2[i], v1[i])) {
                return false;
            }
        }

        return true;
    },

<span id='Ext-form-field-Time-method-setMinValue'>    /**
</span>     * Replaces any existing {@link #minValue} with the new time and refreshes the picker&#39;s range.
     * @param {Date/String} value The minimum time that can be selected
     */
    setMinValue: function(value) {
        var me = this,
            picker = me.picker;
        me.setLimit(value, true);
        if (picker) {
            picker.setMinValue(me.minValue);
        }
    },

<span id='Ext-form-field-Time-method-setMaxValue'>    /**
</span>     * Replaces any existing {@link #maxValue} with the new time and refreshes the picker&#39;s range.
     * @param {Date/String} value The maximum time that can be selected
     */
    setMaxValue: function(value) {
        var me = this,
            picker = me.picker;
        me.setLimit(value, false);
        if (picker) {
            picker.setMaxValue(me.maxValue);
        }
    },

<span id='Ext-form-field-Time-method-setLimit'>    /**
</span>     * @private
     * Updates either the min or max value. Converts the user&#39;s value into a Date object whose
     * year/month/day is set to the {@link #initDate} so that only the time fields are significant.
     */
    setLimit: function(value, isMin) {
        var me = this,
            d, val;
        if (Ext.isString(value)) {
            d = me.parseDate(value);
        }
        else if (Ext.isDate(value)) {
            d = value;
        }
        if (d) {
            val = me.getInitDate();
            val.setHours(d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
        }
        // Invalid min/maxValue config should result in a null so that defaulting takes over
        else {
            val = null;
        }
        me[isMin ? &#39;minValue&#39; : &#39;maxValue&#39;] = val;
    },
    
<span id='Ext-form-field-Time-method-getInitDate'>    getInitDate: function (hours, minutes, seconds) {
</span>        var parts = this.initDateParts;

        return new Date(parts[0], parts[1], parts[2], hours || 0, minutes || 0, seconds || 0, 0);    
    },

<span id='Ext-form-field-Time-method-valueToRaw'>    valueToRaw: function(value) {
</span>        return this.formatDate(this.parseDate(value));
    },

<span id='Ext-form-field-Time-method-getErrors'>    /**
</span>     * Runs all of Time&#39;s validations and returns an array of any errors. Note that this first runs Text&#39;s validations,
     * so the returned array is an amalgamation of all field errors. The additional validation checks are testing that
     * the time format is valid, that the chosen time is within the {@link #minValue} and {@link #maxValue} constraints
     * set.
     * @param {Object} [value] The value to get errors for (defaults to the current field value)
     * @return {String[]} All validation errors for this field
     */
    getErrors: function(value) {
        value = arguments.length &gt; 0 ? value : this.getRawValue();

        var me = this,
            format = Ext.String.format,
            errors = me.callParent([value]),
            minValue = me.minValue,
            maxValue = me.maxValue,
            data = me.displayTplData,
            raw = me.getRawValue(),
            i, len, date, item;

        if (data &amp;&amp; data.length &gt; 0) {
            for (i = 0, len = data.length; i &lt; len; i++ ){
                item = data[i];
                item = item.date || item.disp;
                date = me.parseDate(item);

                if (!date) {
                    errors.push(format(me.invalidText, item, Ext.Date.unescapeFormat(me.format)));
                    continue;
                }                
            }
        } else if (raw.length) {
            date = me.parseDate(raw);
            if (!date) {
                // If we don&#39;t have any data &amp; a rawValue, it means an invalid time was entered.
                errors.push(format(me.invalidText, raw, Ext.Date.unescapeFormat(me.format)));
            }
        }
        // if we have a valid date, we need to check if it&#39;s within valid range
        // this is out of the loop because as the user types a date/time, the value
        // needs to be converted before it can be compared to min/max value
        if(!errors.length) {
            if (minValue &amp;&amp; date &lt; minValue) {
                errors.push(format(me.minText, me.formatDate(minValue)));
            }
            if (maxValue &amp;&amp; date &gt; maxValue) {
                errors.push(format(me.maxText, me.formatDate(maxValue)));
            }
        }
        return errors;
    },

<span id='Ext-form-field-Time-method-formatDate'>    formatDate: function(items) {
</span>        var formatted = [],
            i, len;

        items = Ext.Array.from(items);

        for (i = 0, len = items.length; i &lt; len; i++) {
            formatted.push(Ext.form.field.Date.prototype.formatDate.call(this, items[i]));
        }

        return formatted.join(this.delimiter);
    },

<span id='Ext-form-field-Time-method-parseDate'>    /**
</span>     * @private
     * Parses an input value into a valid Date object.
     * @param {String/Date} value
     */
    parseDate: function(value) {
        var me = this,
            val = value,
            altFormats = me.altFormats,
            altFormatsArray = me.altFormatsArray,
            i = 0,
            len;

        if (value &amp;&amp; !Ext.isDate(value)) {
            val = me.safeParse(value, me.format);

            if (!val &amp;&amp; altFormats) {
                altFormatsArray = altFormatsArray || altFormats.split(&#39;|&#39;);
                len = altFormatsArray.length;
                for (; i &lt; len &amp;&amp; !val; ++i) {
                    val = me.safeParse(value, altFormatsArray[i]);
                }
            }
        }

        // If configured to snap, snap resulting parsed Date to the closest increment.
        if (val &amp;&amp; me.snapToIncrement) {
            val = new Date(Ext.Number.snap(val.getTime(), me.increment * 60 * 1000));
        }
        return val;
    },

<span id='Ext-form-field-Time-method-safeParse'>    safeParse: function(value, format){
</span>        var me = this,
            utilDate = Ext.Date,
            parsedDate,
            result = null;

        if (utilDate.formatContainsDateInfo(format)) {
            // assume we&#39;ve been given a full date
            result = utilDate.parse(value, format);
        } else {
            // Use our initial safe date
            parsedDate = utilDate.parse(me.initDate + &#39; &#39; + value, me.initDateFormat + &#39; &#39; + format);
            if (parsedDate) {
                result = parsedDate;
            }
        }
        return result;
    },

<span id='Ext-form-field-Time-method-getSubmitValue'>    /**
</span>     * @private
     */
    getSubmitValue: function() {
        var me = this,
            format = me.submitFormat || me.format,
            value = me.getValue();

        return value ? Ext.Date.format(value, format) : null;
    },

<span id='Ext-form-field-Time-method-createPicker'>    /**
</span>     * @private
     * Creates the {@link Ext.picker.Time}
     */
    createPicker: function() {
        var me = this;

        me.listConfig = Ext.apply({
            xtype: &#39;timepicker&#39;,
            pickerField: me,
            cls: undefined,
            minValue: me.minValue,
            maxValue: me.maxValue,
            increment: me.increment,
            format: me.format,
            maxHeight: me.pickerMaxHeight
        }, me.listConfig);
        return me.callParent();
    },

<span id='Ext-form-field-Time-method-completeEdit'>    completeEdit: function() {
</span>        var me = this,
            val = me.getValue();

        me.callParent(arguments);

        // Only set the raw value if the current value is valid and is not falsy
        if (me.validateValue(val)) {
            me.setValue(val);
        }
    },

<span id='Ext-form-field-Time-method-findRecordByValue'>    /**
</span>     * Finds the record by searching values in the {@link #valueField}.
     * @param {Object/String} value The value to match the field against.
     * @return {Ext.data.Model} The matched record or false.
     */
    findRecordByValue: function (value) {
        if (typeof value === &#39;string&#39;) {
            value = this.parseDate(value);
        }
        return this.callParent([value]);
    },

<span id='Ext-form-field-Time-method-rawToValue'>    rawToValue: function (item) {
</span>        var me = this,
            items, values, i, len;

        if (me.multiSelect) {
            values = [];
            items = Ext.Array.from(item);

            for (i = 0, len = items.length; i &lt; len; i++) {
                values.push(me.parseDate(items[i]));
            }

            return values;
        }

        return me.parseDate(item);
    },

<span id='Ext-form-field-Time-method-setValue'>    setValue: function (v) {
</span>        var me = this;

        // The timefield can get in a loop when creating its picker. For instance, when creating the picker, the
        // timepicker will add a filter (see TimePicker#updateList) which will then trigger the checkValueOnChange
        // listener which in turn calls into here, rinse and repeat.
        if (me.creatingPicker) {
            return;
        }

        // Store MUST be created for parent setValue to function.
        me.getPicker();

        if (Ext.isDate(v)) {
            v = me.getInitDate(v.getHours(), v.getMinutes(), v.getSeconds());
        }

        return me.callParent([v]);
    },

<span id='Ext-form-field-Time-method-getValue'>    getValue: function () {
</span>        return this.rawToValue(this.callParent(arguments));
    }
});
</pre>
</body>
</html>
