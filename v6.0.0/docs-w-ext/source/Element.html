<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-dom-Element'>/**
</span> * @class Ext.dom.Element
 * @alternateClassName Ext.Element
 * @mixins Ext.util.Positionable
 * @mixins Ext.mixin.Observable
 *
 * Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.
 *
 * **Note:** The events included in this Class are the ones we&#39;ve found to be the most commonly used. Many events are
 * not listed here due to the expedient rate of change across browsers. For a more comprehensive list, please visit the
 * following resources:
 *
 * + [Mozilla Event Reference Guide](https://developer.mozilla.org/en-US/docs/Web/Events)
 * + [W3 Pointer Events](http://www.w3.org/TR/pointerevents/)
 * + [W3 Touch Events](http://www.w3.org/TR/touch-events/)
 * + [W3 DOM 2 Events](http://www.w3.org/TR/DOM-Level-2-Events/)
 * + [W3 DOM 3 Events](http://www.w3.org/TR/DOM-Level-3-Events/)
 *
 * ## Usage
 *
 *     // by id
 *     var el = Ext.get(&quot;my-div&quot;);
 *
 *     // by DOM element reference
 *     var el = Ext.get(myDivElement);
 *
 * ## Selecting Descendant Elements
 *
 * Ext.dom.Element instances can be used to select descendant nodes using CSS selectors.
 * There are 3 methods that can be used for this purpose, each with a slightly different
 * twist:
 *
 * - {@link #method-query}
 * - {@link #method-selectNode}
 * - {@link #method-select}
 *
 * These methods can accept any valid CSS selector since they all use
 * [querySelectorAll](http://www.w3.org/TR/css3-selectors/) under the hood. The primary
 * difference between these three methods is their return type:
 *
 * To get an array of HTMLElement instances matching the selector &#39;.foo&#39; use the query
 * method:
 *
 *     element.query(&#39;.foo&#39;);
 *
 * This can easily be transformed into an array of Ext.dom.Element instances by setting
 * the `asDom` parameter to `false`:
 *
 *     element.query(&#39;.foo&#39;, false);
 *
 * If the desired result is only the first matching HTMLElement use the selectNode method:
 *
 *     element.selectNode(&#39;.foo&#39;);
 *
 * Once again, the dom node can be wrapped in an Ext.dom.Element by setting the `asDom`
 * parameter to `false`:
 *
 *     element.selectNode(&#39;.foo&#39;, false);
 *
 * The `select` method is used when the desired return type is a {@link
 * Ext.CompositeElementLite CompositeElementLite} or a {@link Ext.CompositeElement
 * CompositeElement}.  These are collections of elements that can be operated on as a
 * group using any of the methods of Ext.dom.Element.  The only difference between the two
 * is that CompositeElementLite is a collection of HTMLElement instances, while
 * CompositeElement is a collection of Ext.dom.Element instances.  To retrieve a
 * CompositeElementLite that represents a collection of HTMLElements for selector &#39;.foo&#39;:
 *
 *     element.select(&#39;.foo&#39;);
 *
 * For a {@link Ext.CompositeElement CompositeElement} simply pass `true` as the
 * `composite` parameter:
 *
 *     element.select(&#39;.foo&#39;, true);
 *
 * The query selection methods can be used even if you don&#39;t have a Ext.dom.Element to
 * start with For example to select an array of all HTMLElements in the document that match the
 * selector &#39;.foo&#39;, simply wrap the document object in an Ext.dom.Element instance using
 * {@link Ext#fly}:
 *
 *     Ext.fly(document).query(&#39;.foo&#39;);
 *
 * # Animations
 *
 * When an element is manipulated, by default there is no animation.
 *
 *     var el = Ext.get(&quot;my-div&quot;);
 *
 *     // no animation
 *     el.setWidth(100);
 *
 * specified as boolean (true) for default animation effects.
 *
 *     // default animation
 *     el.setWidth(100, true);
 *
 * To configure the effects, an object literal with animation options to use as the Element animation configuration
 * object can also be specified. Note that the supported Element animation configuration options are a subset of the
 * {@link Ext.fx.Anim} animation options specific to Fx effects. The supported Element animation configuration options
 * are:
 *
 *     Option    Default   Description
 *     --------- --------  ---------------------------------------------
 *     duration  350       The duration of the animation in milliseconds
 *     easing    easeOut   The easing method
 *     callback  none      A function to execute when the anim completes
 *     scope     this      The scope (this) of the callback function
 *
 * Usage:
 *
 *     // Element animation options object
 *     var opt = {
 *         duration: 1000,
 *         easing: &#39;elasticIn&#39;,
 *         callback: this.foo,
 *         scope: this
 *     };
 *     // animation with some options set
 *     el.setWidth(100, opt);
 *
 * The Element animation object being used for the animation will be set on the options object as &quot;anim&quot;, which allows
 * you to stop or manipulate the animation. Here is an example:
 *
 *     // using the &quot;anim&quot; property to get the Anim object
 *     if(opt.anim.isAnimated()){
 *         opt.anim.stop();
 *     }
 */
Ext.define(&#39;Ext.dom.Element&#39;, function(Element) {
    var WIN = window,
        DOC = document,
        docEl = DOC.documentElement,
        TOP = WIN.top,
        elementIdCounter,
        windowId,
        documentId,
        WIDTH = &#39;width&#39;,
        HEIGHT = &#39;height&#39;,
        MIN_WIDTH = &#39;min-width&#39;,
        MIN_HEIGHT = &#39;min-height&#39;,
        MAX_WIDTH = &#39;max-width&#39;,
        MAX_HEIGHT = &#39;max-height&#39;,
        TOP = &#39;top&#39;,
        RIGHT = &#39;right&#39;,
        BOTTOM = &#39;bottom&#39;,
        LEFT = &#39;left&#39;,
        VISIBILITY = &#39;visibility&#39;,
        HIDDEN = &#39;hidden&#39;,
        DISPLAY = &quot;display&quot;,
        NONE = &quot;none&quot;,
        ZINDEX = &quot;z-index&quot;,
        POSITION = &quot;position&quot;,
        RELATIVE = &quot;relative&quot;,
        STATIC = &quot;static&quot;,
        SEPARATOR = &#39;-&#39;,
        wordsRe = /\w/g,
        spacesRe = /\s+/,
        classNameSplitRegex = /[\s]+/,
        transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i,
        adjustDirect2DTableRe = /table-row|table-.*-group/,
        topRe = /top/i,
        borders = {
            t: &#39;border-top-width&#39;,
            r: &#39;border-right-width&#39;,
            b: &#39;border-bottom-width&#39;,
            l: &#39;border-left-width&#39;
        },
        paddings = {
            t: &#39;padding-top&#39;,
            r: &#39;padding-right&#39;,
            b: &#39;padding-bottom&#39;,
            l: &#39;padding-left&#39;
        },
        margins = {
            t: &#39;margin-top&#39;,
            r: &#39;margin-right&#39;,
            b: &#39;margin-bottom&#39;,
            l: &#39;margin-left&#39;
        },
        paddingsTLRB = [paddings.l, paddings.r, paddings.t, paddings.b],
        bordersTLRB = [borders.l,  borders.r,  borders.t,  borders.b],
        numberRe = /\d+$/,
        unitRe = /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i,
        defaultUnit = &#39;px&#39;,
        camelRe = /(-[a-z])/gi,
        cssRe = /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi,
        pxRe = /^\d+(?:\.\d*)?px$/i,
        propertyCache = {},
        ORIGINALDISPLAY = &#39;originalDisplay&#39;,
        camelReplaceFn = function(m, a) {
            return a.charAt(1).toUpperCase();
        },

        clearData = function(node, deep) {
            var childNodes, i, len;

            // Only Element nodes may have _extData and child nodes to clear.
            // IE8 throws an error attempting to set expandos on non-Element nodes.
            if (node.nodeType === 1) {
                node._extData = null;
                if (deep) {
                    childNodes = node.childNodes;
                    for (i = 0, len = childNodes.length; i &lt; len; ++i) {
                        clearData(childNodes[i], deep);
                    }
                }
            }
        },

        visibilityCls = Ext.baseCSSPrefix + &#39;hidden-visibility&#39;,
        displayCls = Ext.baseCSSPrefix + &#39;hidden-display&#39;,
        offsetsCls = Ext.baseCSSPrefix + &#39;hidden-offsets&#39;,
        clipCls = Ext.baseCSSPrefix + &#39;hidden-clip&#39;,
        sizedCls = Ext.baseCSSPrefix + &#39;sized&#39;,
        unsizedCls = Ext.baseCSSPrefix + &#39;unsized&#39;,
        stretchedCls = Ext.baseCSSPrefix + &#39;stretched&#39;,
        CREATE_ATTRIBUTES = {
            style: &#39;style&#39;,
            className: &#39;className&#39;,
            cls: &#39;cls&#39;,
            classList: &#39;classList&#39;,
            text: &#39;text&#39;,
            hidden: &#39;hidden&#39;,
            html: &#39;html&#39;,
            children: &#39;children&#39;
        },
        lastFocusChange = 0,
        lastKeyboardClose = 0,
        editableHasFocus = false,
        isVirtualKeyboardOpen = false,
        visFly, scrollFly, caFly;

    // Cross-origin access might throw an exception
    try {
        elementIdCounter = TOP.__elementIdCounter__;
    }
    catch (e) {
        TOP = WIN;
    }

    TOP.__elementIdCounter = elementIdCounter = (TOP.__elementIdCounter__ || 0) + 1;
    windowId = &#39;ext-window-&#39; + elementIdCounter;
    documentId = &#39;ext-document-&#39; + elementIdCounter;

    return {
        alternateClassName: [ &#39;Ext.Element&#39; ],

        mixins: [
            &#39;Ext.util.Positionable&#39;,
            &#39;Ext.mixin.Observable&#39;
        ],

        requires: [
            &#39;Ext.dom.Shadow&#39;,
            &#39;Ext.dom.Shim&#39;,
            &#39;Ext.dom.ElementEvent&#39;,
            &#39;Ext.event.publisher.Dom&#39;,
            &#39;Ext.event.publisher.Gesture&#39;,
            &#39;Ext.event.publisher.ElementSize&#39;,
            &#39;Ext.event.publisher.ElementPaint&#39;
        ],

        uses: [
            &#39;Ext.dom.Helper&#39;,
            &#39;Ext.dom.CompositeElement&#39;,
            &#39;Ext.dom.Fly&#39;,
            &#39;Ext.dom.TouchAction&#39;,
            &#39;Ext.event.publisher.Focus&#39;
        ],

        observableType: &#39;element&#39;,

        isElement: true,

        skipGarbageCollection: true,

        $applyConfigs: true,

        identifiablePrefix: &#39;ext-element-&#39;,

        styleHooks: {},

        validIdRe: Ext.validIdRe,

        blockedEvents: Ext.supports.EmulatedMouseOver ? {
            // mobile safari emulates a mouseover event on clickable elements such as
            // anchors. This event is useless because it runs after touchend. We block
            // this event to prevent mouseover handlers from running after tap events. It
            // is up to the individual component to determine if it has an analog for
            // mouseover, and implement the appropriate event handlers.
            mouseover: 1
        } : {},

        longpressEvents: {
            longpress: 1,
            taphold: 1
        },

<span id='Ext-dom-Element-property-component'>        /**
</span>         * @property {Ext.Component} component
         * A reference to the `Component` that owns this element. This is `null` if there
         * is no direct owner.
         */

        //  Mouse events
<span id='Ext-dom-Element-event-click'>        /**
</span>         * @event click
         * Fires when a mouse click is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-contextmenu'>        /**
</span>         * @event contextmenu
         * Fires when a right click is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-dblclick'>        /**
</span>         * @event dblclick
         * Fires when a mouse double click is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-mousedown'>        /**
</span>         * @event mousedown
         * Fires when a mousedown is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-mouseup'>        /**
</span>         * @event mouseup
         * Fires when a mouseup is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-mouseover'>        /**
</span>         * @event mouseover
         * Fires when a mouseover is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-mousemove'>        /**
</span>         * @event mousemove
         * Fires when a mousemove is detected with the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-mouseout'>        /**
</span>         * @event mouseout
         * Fires when a mouseout is detected with the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-mouseenter'>        /**
</span>         * @event mouseenter
         * Fires when the mouse enters the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-mouseleave'>        /**
</span>         * @event mouseleave
         * Fires when the mouse leaves the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */

        //  Keyboard events
<span id='Ext-dom-Element-event-keypress'>        /**
</span>         * @event keypress
         * Fires when a keypress is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-keydown'>        /**
</span>         * @event keydown
         * Fires when a keydown is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-keyup'>        /**
</span>         * @event keyup
         * Fires when a keyup is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */

        //  HTML frame/object events
<span id='Ext-dom-Element-event-load'>        /**
</span>         * @event load
         * Fires when the user agent finishes loading all content within the element. Only supported by window, frames,
         * objects and images.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-unload'>        /**
</span>         * @event unload
         * Fires when the user agent removes all content from a window or frame. For elements, it fires when the target
         * element or any of its content has been removed.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-abort'>        /**
</span>         * @event abort
         * Fires when an object/image is stopped from loading before completely loaded.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-error'>        /**
</span>         * @event error
         * Fires when an object/image/frame cannot be loaded properly.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-painted'>        /**
</span>         * @event painted
         * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
         * perform &#39;read&#39; operations on the DOM element, i.e: calculating natural sizes and positioning.
         *
         * __Note:__ This event is not available to be used with event delegation. Instead `painted` only fires if you explicitly
         * add at least one listener to it, for performance reasons.
         *
         * @param {Ext.dom.Element} this The component instance.
         */
<span id='Ext-dom-Element-event-resize'>        /**
</span>         * @event resize
         * Important note: For the best performance on mobile devices, use this only when you absolutely need to monitor
         * a Element&#39;s size.
         *
         * __Note:__ This event is not available to be used with event delegation. Instead `resize` only fires if you explicitly
         * add at least one listener to it, for performance reasons.
         *
         * @param {Ext.dom.Element} this The component instance.
         */
<span id='Ext-dom-Element-event-scroll'>        /**
</span>         * @event scroll
         * Fires when a document view is scrolled.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */

        //  Form events
<span id='Ext-dom-Element-event-select'>        /**
</span>         * @event select
         * Fires when a user selects some text in a text field, including input and textarea.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-change'>        /**
</span>         * @event change
         * Fires when a control loses the input focus and its value has been modified since gaining focus.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-submit'>        /**
</span>         * @event submit
         * Fires when a form is submitted.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-reset'>        /**
</span>         * @event reset
         * Fires when a form is reset.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-focus'>        /**
</span>         * @event focus
         * Fires when an element receives focus either via the pointing device or by tab navigation.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-blur'>        /**
</span>         * @event blur
         * Fires when an element loses focus either via the pointing device or by tabbing navigation.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-focusmove'>        /**
</span>         * @event focusmove
         * Fires when focus is moved *within* an element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {Ext.dom.Element} e.target The {@link Ext.dom.Element} element which *recieved* focus.
         * @param {Ext.dom.Element} e.relatedTarget The {@link Ext.dom.Element} element which *lost* focus.
         * @param {HTMLElement} t The target of the event.
         */

        //  User Interface events
<span id='Ext-dom-Element-event-DOMFocusIn'>        /**
</span>         * @event DOMFocusIn
         * Where supported. Similar to HTML focus event, but can be applied to any focusable element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMFocusOut'>        /**
</span>         * @event DOMFocusOut
         * Where supported. Similar to HTML blur event, but can be applied to any focusable element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMActivate'>        /**
</span>         * @event DOMActivate
         * Where supported. Fires when an element is activated, for instance, through a mouse click or a keypress.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */

        //  DOM Mutation events
<span id='Ext-dom-Element-event-DOMSubtreeModified'>        /**
</span>         * @event DOMSubtreeModified
         * Where supported. Fires when the subtree is modified.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMNodeInserted'>        /**
</span>         * @event DOMNodeInserted
         * Where supported. Fires when a node has been added as a child of another node.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMNodeRemoved'>        /**
</span>         * @event DOMNodeRemoved
         * Where supported. Fires when a descendant node of the element is removed.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMNodeRemovedFromDocument'>        /**
</span>         * @event DOMNodeRemovedFromDocument
         * Where supported. Fires when a node is being removed from a document.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMNodeInsertedIntoDocument'>        /**
</span>         * @event DOMNodeInsertedIntoDocument
         * Where supported. Fires when a node is being inserted into a document.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMAttrModified'>        /**
</span>         * @event DOMAttrModified
         * Where supported. Fires when an attribute has been modified.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
<span id='Ext-dom-Element-event-DOMCharacterDataModified'>        /**
</span>         * @event DOMCharacterDataModified
         * Where supported. Fires when the character data has been modified.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */

<span id='Ext-dom-Element-method-constructor'>        /**
</span>         * @constructor
         * Creates new Element directly by passing an id or the HTMLElement.  This
         * constructor should not be called directly.  Always use {@link Ext#get Ext.get()}
         * or {@link Ext#fly Ext#fly()} instead.
         *
         * In older versions of Ext JS and Sencha Touch this constructor checked to see if
         * there was already an instance of this element in the cache and if so, returned
         * the same instance. As of version 5 this behavior has been removed in order to
         * avoid a redundant cache lookup since the most common path is for the Element
         * constructor to be called from {@link Ext#get Ext.get()}, which has already
         * checked for a cache entry.
         *
         * Correct way of creating a new Ext.dom.Element (or retrieving it from the cache):
         *
         *     var el = Ext.get(&#39;foo&#39;); // by id
         *
         *     var el = Ext.get(document.getElementById(&#39;foo&#39;)); // by DOM reference
         *
         * Incorrect way of creating a new Ext.dom.Element
         *
         *     var el = new Ext.dom.Element(&#39;foo&#39;);
         *
         * For quick and easy access to Ext.dom.Element methods use a flyweight:
         *
         *     Ext.fly(&#39;foo&#39;).addCls(&#39;foo-hovered&#39;);
         *
         * This simply attaches the DOM node with id=&#39;foo&#39; to the global flyweight Element
         * instance to avoid allocating an extra Ext.dom.Element instance.  If, however,
         * the Element instance has already been cached by a previous call to Ext.get(),
         * then Ext.fly() will return the cached Element instance.  For more info see
         * {@link Ext#fly}.
         *
         * @param {String/HTMLElement} element
         * @private
         */
        constructor: function(dom) {
            var me = this,
                id;

            if (typeof dom === &#39;string&#39;) {
                dom = DOC.getElementById(dom);
            }

            if (!dom) {
                //&lt;debug&gt;
                Ext.raise(&quot;Invalid domNode reference or an id of an existing domNode: &quot; + dom);
                //&lt;/debug&gt;
                return null;
            }
            //&lt;debug&gt;
            if (Ext.cache[dom.id]) {
                Ext.raise(&quot;Element cache already contains an entry for id &#39;&quot; +
                    dom.id + &quot;&#39;.  Use Ext.get() to create or retrieve Element instances.&quot;);
            }
            //&lt;/debug&gt;

<span id='Ext-dom-Element-property-dom'>            /**
</span>             * The DOM element
             * @property dom
             * @type HTMLElement
             */
            me.dom = dom;

            id = dom.id;

            if (id) {
                me.id = id;
            } else {
                id = dom.id = me.getUniqueId();
            }

            //&lt;debug&gt;
            if (!me.validIdRe.test(me.id)) {
                Ext.raise(&#39;Invalid Element &quot;id&quot;: &quot;&#39; + me.id + &#39;&quot;&#39;);
            }
            //&lt;/debug&gt;

            // set an &quot;el&quot; property that references &quot;this&quot;.  This allows
            // Ext.util.Positionable methods to operate on this.el.dom since it
            // gets mixed into both Element and Component
            me.el = me;

            Ext.cache[id] = me;

            me.longpressListenerCount = 0;

            me.mixins.observable.constructor.call(me);
        },

        inheritableStatics: {
<span id='Ext-dom-Element-static-property-cache'>            /**
</span>             * @private
             * @static
             * @inheritable
             */
            cache: Ext.cache = {},

<span id='Ext-dom-Element-static-property-editableSelector'>            /**
</span>             * @property
             * @static
             * @private
             * @inheritable
             */
            editableSelector: &#39;input,textarea,[contenteditable=&quot;true&quot;]&#39;,

<span id='Ext-dom-Element-static-property-VISIBILITY'>            /**
</span>             * @property {Number}
             * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
             * Use the CSS &#39;visibility&#39; property to hide the element.
             *
             * Note that in this mode, {@link Ext.dom.Element#isVisible isVisible} may return true
             * for an element even though it actually has a parent element that is hidden. For this
             * reason, and in most cases, using the {@link #OFFSETS} mode is a better choice.
             * @static
             * @inheritable
             */
            VISIBILITY: 1,

<span id='Ext-dom-Element-static-property-DISPLAY'>            /**
</span>             * @property {Number}
             * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
             * Use the CSS &#39;display&#39; property to hide the element.
             * @static
             * @inheritable
             */
            DISPLAY: 2,

<span id='Ext-dom-Element-static-property-OFFSETS'>            /**
</span>             * @property {Number}
             * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
             * Use CSS absolute positioning and top/left offsets to hide the element.
             * @static
             * @inheritable
             */
            OFFSETS: 3,

<span id='Ext-dom-Element-static-property-CLIP'>            /**
</span>             * @property {Number}
             * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
             * Use CSS `clip` property to reduce element&#39;s dimensions to 0px by 0px, effectively
             * making it hidden while not being truly invisible. This is useful when an element
             * needs to be published to the Assistive Technologies such as screen readers.
             * @static
             * @inheritable
             */
            CLIP: 4,

<span id='Ext-dom-Element-static-property-minKeyboardHeight'>            /**
</span>             * @property
             * @static
             * @inheritable
             * @private
             * This property indicates a minimum threshold of vertical resize movement for
             * virtual keyboard detection.
             *
             * On some mobile browsers the framework needs to keep track of whether window
             * resize events were triggered by the opening or closing of a virtual keyboard
             * so that it can prevent unnecessary re-layout of the viewport.  It does this
             * by detecting resize events in the horizontal direction that occur immediately
             * after an editable element is focused or blurred.
             */
            minKeyboardHeight: 100,

            unitRe: unitRe,

<span id='Ext-dom-Element-static-property-useDelegatedEvents'>            /**
</span>             * @property {Boolean}
             * @private
             * @static
             * @inheritable
             * True to globally disable the delegated event system.  The results of
             * setting this to false are unpredictable since the Gesture publisher relies
             * on delegated events in order to work correctly.  Disabling delegated events
             * may cause Gestures to function incorrectly or to stop working completely.
             * Use at your own risk!
             */
            useDelegatedEvents: true,

<span id='Ext-dom-Element-static-property-validNodeTypes'>            /**
</span>             * @property {Object}
             * @private
             * @static
             * @inheritable
             * The list of valid nodeTypes that are allowed to be wrapped
             */
            validNodeTypes: {
                1: 1, // ELEMENT_NODE
                9: 1 // DOCUMENT_NODE
            },

<span id='Ext-dom-Element-static-method-addUnits'>            /**
</span>             * Test if size has a unit, otherwise appends the passed unit string, or the default for this Element.
             * @param {Object} size The size to set.
             * @param {String} units The units to append to a numeric size value.
             * @return {String}
             * @private
             * @static
             * @inheritable
             */
            addUnits: function(size, units) {
                // Most common case first: Size is set to a number
                if (typeof size === &#39;number&#39;) {
                    return size + (units || defaultUnit);
                }

                // Values which mean &quot;auto&quot;
                // - &quot;&quot;
                // - &quot;auto&quot;
                // - undefined
                // - null
                if (size === &quot;&quot; || size === &quot;auto&quot; || size == null) {
                    return size || &#39;&#39;;
                }

                // less common use case: number formatted as a string.  save this case until
                // last to avoid regex execution if possible.
                if (numberRe.test(size)) {
                    return size + (units || defaultUnit);
                }

                // Warn if it&#39;s not a valid CSS measurement
                if (!unitRe.test(size)) {
                    //&lt;debug&gt;
                    Ext.Logger.warn(&quot;Warning, size detected (&quot; + size + &quot;) not a valid property value on Element.addUnits.&quot;);
                    //&lt;/debug&gt;
                    return size || &#39;&#39;;
                }

                return size;
            },

<span id='Ext-dom-Element-static-method-create'>            /**
</span>             * @private
             * Create method to add support for a DomHelper config. Creates
             * and appends elements/children using document.createElement/appendChild.
             * This method is used by the modern toolkit for a significant performance gain
             * in webkit browsers as opposed to using DomQuery which generates HTML
             * markup and sets it as innerHTML.
             *
             * However, the createElement/appendChild
             * method of creating elements is significantly slower in all versions of IE
             * at the time of this writing (6 - 11), so classic toolkit should not use this method,
             * but should instead use DomHelper methods, or Element methods that use
             * DomHelper under the hood (e.g. createChild).
             * see https:*fiddle.sencha.com/#fiddle/tj
             *
             * @static
             * @inheritable
             */
            create: function(attributes, domNode) {
                var me = this,
                    classes, element, elementStyle, tag, value, name, i, ln, tmp;

                attributes = attributes || {};
                if (attributes.isElement) {
                    return domNode ? attributes.dom : attributes;
                } else if (&#39;nodeType&#39; in attributes) {
                    return domNode ? attributes : Ext.get(attributes);
                }

                if (typeof attributes === &#39;string&#39;) {
                    return DOC.createTextNode(attributes);
                }

                tag = attributes.tag;

                if (!tag) {
                    tag = &#39;div&#39;;
                }

                if (attributes.namespace) {
                    element = DOC.createElementNS(attributes.namespace, tag);
                } else {
                    element = DOC.createElement(tag);
                }

                elementStyle = element.style;

                for (name in attributes) {
                    if (name !== &#39;tag&#39;) {
                        value = attributes[name];

                        switch (name) {
                            case CREATE_ATTRIBUTES.style:
                                if (typeof value === &#39;string&#39;) {
                                    element.setAttribute(name, value);
                                }
                                else {
                                    for (i in value) {
                                        if (value.hasOwnProperty(i)) {
                                            elementStyle[i] = value[i];
                                        }
                                    }
                                }
                                break;

                            case CREATE_ATTRIBUTES.className:
                            case CREATE_ATTRIBUTES.cls:
                                tmp = value.split(spacesRe);
                                classes = classes ? classes.concat(tmp) : tmp
                                break;

                            case CREATE_ATTRIBUTES.classList:
                                classes = classes ? classes.concat(value) : value;
                                break;

                            case CREATE_ATTRIBUTES.text:
                                element.textContent = value;
                                break;

                            case CREATE_ATTRIBUTES.html:
                                element.innerHTML = value;
                                break;

                            case CREATE_ATTRIBUTES.hidden:
                                if (classes) {
                                    classes.push(displayCls);
                                } else {
                                    classes = [displayCls];
                                }
                                break;

                            case CREATE_ATTRIBUTES.children:
                                if (value != null) {
                                    for (i = 0,ln = value.length; i &lt; ln; i++) {
                                        element.appendChild(me.create(value[i], true));
                                    }
                                }
                                break;

                            default:
                                if (value != null) { // skip null or undefined values
                                    element.setAttribute(name, value);
                                }
                        }
                    }
                }

                if (classes) {
                    element.className = classes.join(&#39; &#39;);
                }

                if (domNode) {
                    return element;
                } else {
                    return me.get(element);
                }
            },

<span id='Ext-dom-Element-static-method-detach'>            /**
</span>             * @static
             * @inheritable
             * @private
             */
            detach: function() {
                var dom = this.dom;

                if (dom &amp;&amp; dom.parentNode &amp;&amp; dom.tagName !== &#39;BODY&#39;) {
                    dom.parentNode.removeChild(dom);
                }

                return this;
            },

<span id='Ext-dom-Element-static-method-fly'>            /**
</span>             * @inheritdoc Ext#fly
             * @inheritable
             * @static
             */
            fly: function(dom, named) {
                return Ext.fly(dom, named);
            },

<span id='Ext-dom-Element-static-method-fromPoint'>            /**
</span>             * Returns the top Element that is located at the passed coordinates in the current viewport.
             * @static
             * @inheritable
             * @param {Number} x The x coordinate
             * @param {Number} y The y coordinate
             * @param {Boolean} [asDom=false] `true` to return a DOM element.
             * @return {Ext.dom.Element/HTMLElement} The found element.
             */
            fromPoint: (function() {
                // IE has a weird bug where elementFromPoint can fail on the first call when inside an iframe.
                // It seems to happen more consistently on older IE, but sometimes crops up even in IE11.
                // This plays havoc especially while running tests.
                var elementFromPointBug;
                if (Ext.isIE) {
                    try {
                        elementFromPointBug = window.self !== window.top;
                    } catch (e) {
                        elementFromPointBug = true;
                    }
                }

                return function(x, y, asDom) {
                    var el = null;
                    el = DOC.elementFromPoint(x, y);
                    if (!el &amp;&amp; elementFromPointBug) {
                        el = DOC.elementFromPoint(x, y);
                    }
                    return asDom ? el : Ext.get(el);
                };
            })(),

<span id='Ext-dom-Element-static-method-fromPagePoint'>            /**
</span>             * Returns the top Element that is located at the passed coordinates taking into account
             * the scroll position of the document.
             * @static
             * @inheritable
             * @param {Number} x The x coordinate
             * @param {Number} y The y coordinate
             * @param {Boolean} [asDom=false] `true` to return a DOM element.
             * @return {Ext.dom.Element/HTMLElement} The found element.
             *
             * @since 6.2.0
             */
            fromPagePoint: function(x, y, asDom) {
                var scroll = Ext.getDoc().getScroll();
                return Element.fromPoint(x - scroll.left, y - scroll.top, asDom);
            },

<span id='Ext-dom-Element-static-method-get'>            /**
</span>             * Retrieves Ext.dom.Element objects. {@link Ext#get} is alias for {@link Ext.dom.Element#get}.
             *
             * **This method does not retrieve {@link Ext.Component Component}s.** This method retrieves Ext.dom.Element
             * objects which encapsulate DOM elements. To retrieve a Component by its ID, use {@link Ext.ComponentManager#get}.
             *
             * When passing an id, it should not include the `#` character that is used for a css selector.
             *
             *     // For an element with id &#39;foo&#39;
             *     Ext.get(&#39;foo&#39;); // Correct
             *     Ext.get(&#39;#foo&#39;); // Incorrect
             *
             * Uses simple caching to consistently return the same object. Automatically fixes if an object was recreated with
             * the same id via AJAX or DOM.
             *
             * @param {String/HTMLElement/Ext.dom.Element} el The `id` of the node, a DOM Node or an existing Element.
             * @return {Ext.dom.Element} The Element object (or `null` if no matching element was found).
             * @static
             * @inheritable
             */
            get: function(el) {
                var me = this,
                    cache = Ext.cache,
                    nodeType, dom, id, entry, isDoc, isWin, isValidNodeType;

                if (!el) {
                    return null;
                }

                //&lt;debug&gt;
                function warnDuplicate(id) {
                    Ext.raise(&quot;DOM element with id &quot; + id +
                        &quot; in Element cache is not the same as element in the DOM. &quot; +
                        &quot;Make sure to clean up Element instances using destroy()&quot; );
                }
                //&lt;/debug&gt;

                // Ext.get(flyweight) must return an Element instance, not the flyweight
                if (el.isFly) {
                    el = el.dom;
                }

                if (typeof el === &#39;string&#39;) {
                    id = el;
                    if (cache.hasOwnProperty(id)) {
                        entry = cache[id];
                        if (entry.skipGarbageCollection || !Ext.isGarbage(entry.dom)) {
                            //&lt;debug&gt;
                            dom = Ext.getElementById ? Ext.getElementById(id) :
                                DOC.getElementById(id);
                            if (dom &amp;&amp; (dom !== entry.dom)) {
                                warnDuplicate(id);
                            }
                            //&lt;/debug&gt;
                            return entry;
                        } else {
                            entry.destroy();
                        }
                    }

                    if (id === windowId) {
                        return Element.get(WIN);
                    } else if (id === documentId) {
                        return Element.get(DOC);
                    }

                    // using Ext.getElementById() allows us to check the detached
                    // body in addition to the body (Ext JS only).
                    dom = Ext.getElementById ? Ext.getElementById(id) :
                        DOC.getElementById(id);
                    if (dom) {
                        return new Element(dom);
                    }
                }

                nodeType = el.nodeType;

                if (nodeType) {
                    isDoc = (nodeType === 9);
                    isValidNodeType = me.validNodeTypes[nodeType];
                } else {
                    // if an object has a window property that refers to itself we can
                    // reasonably assume that it is a window object.
                    // have to use == instead of === for IE8
                    isWin = (el.window == el);
                }

                // check if we have a valid node type or if the el is a window object before
                // proceeding. This allows elements, document fragments, and document/window
                // objects (even those inside iframes) to be wrapped.
                if (isValidNodeType || isWin) {
                    id = el.id;

                    if (cache.hasOwnProperty(id)) {
                        entry = cache[id];
                        if (entry.skipGarbageCollection || el === entry.dom ||
                            !Ext.isGarbage(entry.dom)) {
                            //&lt;debug&gt;
                            if (el !== entry.dom) {
                                warnDuplicate(id);
                            }
                            //&lt;/debug&gt;
                            return entry;
                        } else {
                            entry.destroy();
                        }
                    }

                    if (el === DOC) {
                        el.id = documentId;
                    }

                    // Must use == here, otherwise IE fails to recognize the window
                    if (el == WIN) {
                        el.id = windowId;
                    }

                    el = new Element(el);

                    if (isWin || isDoc) {
                        // document and window objects can never be garbage
                        el.skipGarbageCollection = true;
                    }
                    return el;
                }

                if (el.isElement) {
                    return el;
                }

                if (el.isComposite) {
                    return el;
                }

                // Test for iterable.
                // Allow the resulting Composite to be based upon an Array or HtmlCollection of nodes.
                if (Ext.isIterable(el)) {
                    return me.select(el);
                }

                return null;
            },

<span id='Ext-dom-Element-static-method-getActiveElement'>            /**
</span>             * Returns the active element in the DOM. If the browser supports activeElement
             * on the document, this is returned. If not, the focus is tracked and the active
             * element is maintained internally.
             * @static
             * @inheritable
             *
             * @param {Boolean} asElement Return Ext.Element instance instead of DOM node.
             *
             * @return {HTMLElement} The active (focused) element in the document.
             */
            getActiveElement: function(asElement) {
                var active = DOC.activeElement;

                // The activeElement can be null, however there also appears to be a very odd
                // and inconsistent bug in IE where the activeElement is simply an empty object
                // literal. Test if the returned active element has focus, if not, we&#39;ve hit the bug
                // so just default back to the document body.
                if (!active || !active.focus) {
                    active = DOC.body;
                }

                return asElement ? Ext.get(active) : active;
            },

<span id='Ext-dom-Element-static-method-getDocumentHeight'>            /**
</span>             * Retrieves the document height
             * @static
             * @inheritable
             * @return {Number} documentHeight
             */
            getDocumentHeight: function() {
                return Math.max(!Ext.isStrict ? DOC.body.scrollHeight : docEl.scrollHeight, this.getViewportHeight());
            },

<span id='Ext-dom-Element-static-method-getDocumentWidth'>            /**
</span>             * Retrieves the document width
             * @static
             * @inheritable
             * @return {Number} documentWidth
             */
            getDocumentWidth: function() {
                return Math.max(!Ext.isStrict ? DOC.body.scrollWidth : docEl.scrollWidth, this.getViewportWidth());
            },

<span id='Ext-dom-Element-static-method-getOrientation'>            /**
</span>             * Retrieves the current orientation of the window. This is calculated by
             * determining if the height is greater than the width.
             * @static
             * @inheritable
             * @return {String} Orientation of window: &#39;portrait&#39; or &#39;landscape&#39;
             */
            getOrientation: function() {
                if (Ext.supports.OrientationChange) {
                    return (WIN.orientation == 0) ? &#39;portrait&#39; : &#39;landscape&#39;;
                }

                return (WIN.innerHeight &gt; WIN.innerWidth) ? &#39;portrait&#39; : &#39;landscape&#39;;
            },

<span id='Ext-dom-Element-static-method-getViewportHeight'>            /**
</span>             * Retrieves the viewport height of the window.
             * @static
             * @inheritable
             * @return {Number} viewportHeight
             */
            getViewportHeight: function() {
                var viewportHeight = Element._viewportHeight;

                //&lt;feature legacyBrowser&gt;
                if (Ext.isIE9m) {
                    return DOC.documentElement.clientHeight;
                }
                //&lt;/feature&gt;

                return (viewportHeight != null) ? viewportHeight : docEl.clientHeight;
            },

<span id='Ext-dom-Element-static-method-getViewportWidth'>            /**
</span>             * Retrieves the viewport width of the window.
             * @static
             * @inheritable
             * @return {Number} viewportWidth
             */
            getViewportWidth: function() {
                var viewportWidth = Element._viewportWidth;

                //&lt;feature legacyBrowser&gt;
                if (Ext.isIE9m) {
                    return DOC.documentElement.clientWidth;
                }
                //&lt;/feature&gt;

                return (viewportWidth != null) ? viewportWidth : docEl.clientWidth;
            },

<span id='Ext-dom-Element-static-method-getViewportScale'>            /**
</span>             * Returns the current zoom level of the viewport as a ratio of page pixels to
             * screen pixels.
             * @private
             * @static
             * @return {Number}
             */
            getViewportScale: function() {
                // on deskop devices, the devicePixel ratio gives us the level of zoom that
                // the user specified using ctrl +/- and or by selecting a zoom level from
                // the menu.
                // On android/iOS devicePixel ratio is a fixed number that represents the
                // screen pixel density (e.g. always &quot;2&quot; on apple retina devices)
                var top = WIN.top;

                return ((Ext.isiOS || Ext.isAndroid) ? 1 :
                    (top.devicePixelRatio || // modern browsers
                        top.screen.deviceXDPI / top.screen.logicalXDPI)) // IE10m
                        * this.getViewportTouchScale();
            },

<span id='Ext-dom-Element-method-getViewportTouchScale'>            /**
</span>             * On touch-screen devices there may be an additional level of zooming
             * that occurs when the user performs a pinch or double-tap to zoom
             * gesture.  This is separate from and in addition to the
             * devicePixelRatio.  We can detect it by comparing the width
             * of the documentElement to window.innerWidth
             * @private
             */
            getViewportTouchScale: function(forceRead) {
                var scale = 1,
                    hidden = &#39;hidden&#39;,
                    top = WIN.top,
                    cachedScale;

                if (!forceRead) {
                    cachedScale = this._viewportTouchScale;

                    if (cachedScale) {
                        return cachedScale;
                    }
                }

                if (Ext.isIE10p || Ext.isEdge || Ext.isiOS) {
                    scale = docEl.offsetWidth / WIN.innerWidth;
                } else if (Ext.isChromeMobile) {
                    scale = top.outerWidth / top.innerWidth;
                }

                return scale;
            },

<span id='Ext-dom-Element-static-method-getViewSize'>            /**
</span>             * Retrieves the viewport size of the window.
             * @static
             * @inheritable
             * @return {Object} object containing width and height properties
             */
            getViewSize: function() {
                return {
                    width: Element.getViewportWidth(),
                    height: Element.getViewportHeight()
                };
            },

<span id='Ext-dom-Element-method-maskIframes'>            /**
</span>             * Mask iframes when shim is true. See {@link Ext.util.Floating#shim}.
             * @private
             */
            maskIframes: function() {
                var iframes = document.getElementsByTagName(&#39;iframe&#39;);

                Ext.each(iframes, function(iframe) {
                    var myMask;

                    myMask = Ext.fly(iframe.parentNode).mask();
                    myMask.setStyle(&#39;background-color&#39;,&#39;transparent&#39;);
                });
            },

<span id='Ext-dom-Element-static-method-normalize'>            /**
</span>             * Normalizes CSS property keys from dash delimited to camel case JavaScript Syntax.
             * For example:
             *
             * - border-width -&gt; borderWidth
             * - padding-top -&gt; paddingTop
             *
             * @static
             * @inheritable
             * @param {String} prop The property to normalize
             * @return {String} The normalized string
             */
            normalize: function(prop) {
                return propertyCache[prop] || (propertyCache[prop] = prop.replace(camelRe, camelReplaceFn));
            },


<span id='Ext-dom-Element-static-method-_onWindowFocusChange'>            /**
</span>             * @private
             * @static
             * @inheritable
             */
            _onWindowFocusChange: function(e) {
                // Tracks the timestamp of focus entering or leaving an editable element
                // so that we can compare this timestamp to the time of the next window
                // resize for the purpose of determining if the virtual keyboard is displayed
                // see _onWindowResize for more details
                if (Ext.fly(e.target).is(Element.editableSelector)) {
                    lastFocusChange = new Date();
                    editableHasFocus = (e.type === &#39;focusin&#39; || e.type === &#39;pointerup&#39;);
                }
            },

<span id='Ext-dom-Element-static-method-_onWindowResize'>            /**
</span>             * @private
             * @static
             * @inheritable
             */
            _onWindowResize: function() {
                var documentWidth = docEl.clientWidth,
                    documentHeight = docEl.clientHeight,
                    now = new Date(),
                    threshold = 1000,
                    deltaX, deltaY;

                deltaX = documentWidth - Element._documentWidth;
                deltaY = documentHeight - Element._documentHeight;

                Element._windowWidth = documentWidth;
                Element._windowHeight = documentHeight;

                // If the focus entered or left an editable element within a brief threshold
                // of time, then this resize event MAY be due to a virtual keyboard being
                // shown or hidden.  Let&#39;s do some additional checking to find out.
                if (((now - lastFocusChange) &lt; threshold) || ((now - lastKeyboardClose) &lt; threshold)) {
                    // If the resize is ONLY in the vertical direction, and an editable
                    // element has the focus, and the vertical movement was significant,
                    // we can be reasonably certain that the resize event was due to
                    // a virtual keyboard being opened.
                    if (deltaX === 0 &amp;&amp; (editableHasFocus &amp;&amp; (deltaY &lt;= -Element.minKeyboardHeight))) {
                        isVirtualKeyboardOpen = true;
                        return;
                    }
                }

                if (isVirtualKeyboardOpen &amp;&amp; (deltaX === 0) &amp;&amp; (deltaY &gt;= Element.minKeyboardHeight)) {
                    isVirtualKeyboardOpen = false;
                    // when windows tablets are rotated while keyboard is open, the keyboard closes
                    // and then immediately reopens.  Track the timestamp of the last keyboard
                    // close so that we can detect a successive resize event that might indicate
                    // reopening
                    lastKeyboardClose = new Date();
                }

                if (isVirtualKeyboardOpen) {
                    return;
                }

                // These cached variables are used by getViewportWidth and getViewportHeight
                // They do not get updated if we returned early due to detecting  that the
                // resize event was triggered by virtual keyboard.
                Element._viewportWidth = documentWidth;
                Element._viewportHeight = documentHeight;
            },

<span id='Ext-dom-Element-static-method-parseBox'>            /**
</span>             * Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
             * (e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)
             * @static
             * @inheritable
             * @param {Number/String} box The encoded margins
             * @return {Object} An object with margin sizes for top, right, bottom and left containing the unit
             */
            parseBox: function(box) {
                box = box || 0;

                var type = typeof box,
                    parts,
                    ln;

                if (type === &#39;number&#39;) {
                    return {
                        top: box,
                        right: box,
                        bottom: box,
                        left: box
                    };
                } else if (type !== &#39;string&#39;) {
                    // If not a number or a string, assume we&#39;ve been given a box config.
                    return box;
                }

                parts  = box.split(&#39; &#39;);
                ln = parts.length;

                if (ln === 1) {
                    parts[1] = parts[2] = parts[3] = parts[0];
                } else if (ln === 2) {
                    parts[2] = parts[0];
                    parts[3] = parts[1];
                } else if (ln === 3) {
                    parts[3] = parts[1];
                }

                return {
                    top: parseFloat(parts[0]) || 0,
                    right: parseFloat(parts[1]) || 0,
                    bottom: parseFloat(parts[2]) || 0,
                    left: parseFloat(parts[3]) || 0
                };
            },

<span id='Ext-dom-Element-static-method-parseStyles'>            /**
</span>             * Converts a CSS string into an object with a property for each style.
             *
             * The sample code below would return an object with 2 properties, one
             * for background-color and one for color.
             *
             *     var css = &#39;background-color: red; color: blue;&#39;;
             *     console.log(Ext.dom.Element.parseStyles(css));
             *
             * @static
             * @inheritable
             * @param {String} styles A CSS string
             * @return {Object} styles
             */
            parseStyles: function(styles) {
                var out = {},
                    matches;

                if (styles) {
                    // Since we&#39;re using the g flag on the regex, we need to set the lastIndex.
                    // This automatically happens on some implementations, but not others, see:
                    // http://stackoverflow.com/questions/2645273/javascript-regular-expression-literal-persists-between-function-calls
                    // http://blog.stevenlevithan.com/archives/fixing-javascript-regexp
                    cssRe.lastIndex = 0;
                    while ((matches = cssRe.exec(styles))) {
                        out[matches[1]] = matches[2] || &#39;&#39;;
                    }
                }
                return out;
            },

<span id='Ext-dom-Element-static-method-select'>            /**
</span>             * Selects elements based on the passed CSS selector to enable
             * {@link Ext.dom.Element Element} methods to be applied to many related
             * elements in one statement through the returned
             * {@link Ext.dom.CompositeElementLite CompositeElementLite} object.
             * @static
             * @inheritable
             * @param {String/HTMLElement[]} selector The CSS selector or an array of
             * elements
             * @param {Boolean} [composite=false] Return a CompositeElement as opposed to
             * a CompositeElementLite. Defaults to false.
             * @param {HTMLElement/String} [root] The root element of the query or id of
             * the root
             * @return {Ext.dom.CompositeElementLite/Ext.dom.CompositeElement}
             */
            select: function(selector, composite, root) {
                return Ext.fly(root || DOC).select(selector, composite);
            },

<span id='Ext-dom-Element-static-method-query'>            /**
</span>             * Selects child nodes of a given root based on the passed CSS selector.
             * @static
             * @inheritable
             * @param {String} selector The CSS selector.
             * @param {Boolean} [asDom=true] `false` to return an array of Ext.dom.Element
             * @param {HTMLElement/String} [root] The root element of the query or id of
             * the root
             * @return {HTMLElement[]/Ext.dom.Element[]} An Array of elements that match
             * the selector.  If there are no matches, an empty Array is returned.
             */
            query: function(selector, asDom, root) {
                return Ext.fly(root || DOC).query(selector, asDom);
            },

<span id='Ext-dom-Element-static-method-unitizeBox'>            /**
</span>             * Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
             * (e.g. 10, &quot;10&quot;, &quot;10 10&quot;, &quot;10 10 10&quot; and &quot;10 10 10 10&quot; are all valid options and would return the same result)
             * @static
             * @inheritable
             * @param {Number/String/Object} box The encoded margins, or an object with top, right,
             * @param {String} units The type of units to add
             * @return {String} An string with unitized (px if units is not specified) metrics for top, right, bottom and left
             */
            unitizeBox: function(box, units) {
                var me = this;
                box = me.parseBox(box);

                return me.addUnits(box.top, units) + &#39; &#39; +
                    me.addUnits(box.right, units) + &#39; &#39; +
                    me.addUnits(box.bottom, units) + &#39; &#39; +
                    me.addUnits(box.left, units);
            },

<span id='Ext-dom-Element-method-unmaskIframes'>            /**
</span>             * Unmask iframes when shim is true. See {@link Ext.util.Floating#shim}.
             * @private
             */
            unmaskIframes: function() {
                var iframes = document.getElementsByTagName(&#39;iframe&#39;);

                Ext.each(iframes, function(iframe) {
                    Ext.fly(iframe.parentNode).unmask();
                });
            },

<span id='Ext-dom-Element-static-method-serializeForm'>            /**
</span>             * Serializes a DOM form into a url encoded string
             * @param {Object} form The form
             * @return {String} The url encoded form
             * @static
             * @inheritable
             */
            serializeForm: function(form) {
                var fElements = form.elements || (DOC.forms[form] || Ext.getDom(form)).elements,
                    hasSubmit = false,
                    encoder = encodeURIComponent,
                    data = &#39;&#39;,
                    eLen = fElements.length,
                    element, name, type, options, hasValue, e,
                    o, oLen, opt;

                for (e = 0; e &lt; eLen; e++) {
                    element = fElements[e];
                    name = element.name;
                    type = element.type;
                    options = element.options;

                    if (!element.disabled &amp;&amp; name) {
                        if (/select-(one|multiple)/i.test(type)) {
                            oLen = options.length;
                            for (o = 0; o &lt; oLen; o++) {
                                opt = options[o];
                                if (opt.selected) {
                                    hasValue = opt.hasAttribute(&#39;value&#39;);
                                    data += Ext.String.format(&#39;{0}={1}&amp;&#39;, encoder(name), encoder(hasValue ? opt.value : opt.text));
                                }
                            }
                        } else if (!(/file|undefined|reset|button/i.test(type))) {
                            if (!(/radio|checkbox/i.test(type) &amp;&amp; !element.checked) &amp;&amp; !(type == &#39;submit&#39; &amp;&amp; hasSubmit)) {
                                data += encoder(name) + &#39;=&#39; + encoder(element.value) + &#39;&amp;&#39;;
                                hasSubmit = /submit/i.test(type);
                            }
                        }
                    }
                }
                return data.substr(0, data.length - 1);
            },

<span id='Ext-dom-Element-static-method-getCommonAncestor'>            /**
</span>             * Returns the common ancestor of the two passed elements.
             * @static
             * @inheritable
             *
             * @param {Ext.dom.Element/HTMLElement} nodeA
             * @param {Ext.dom.Element/HTMLElement} nodeB
             * @param {Boolean} returnDom Pass `true` to return a DOM element. Otherwise An {@link Ext.dom.Element Element} will be returned.
             * @return {Ext.dom.Element/HTMLElement} The common ancestor.
             */
            getCommonAncestor: function(nodeA, nodeB, returnDom) {
                caFly = caFly || new Ext.dom.Fly();
                caFly.attach(Ext.getDom(nodeA));
                while (!caFly.isAncestor(nodeB)) {
                    if (caFly.dom.parentNode) {
                        caFly.attach(caFly.dom.parentNode);
                    }
                    // If Any of the nodes in in a detached state, have to use the document.body
                    else {
                        caFly.attach(DOC.body);
                        break;
                    }
                }
                return returnDom ? caFly.dom : Ext.get(caFly);
            }
        }, // statics

<span id='Ext-dom-Element-method-addCls'>        /**
</span>         * Adds the given CSS class(es) to this Element.
         * @param {String/String[]} names The CSS classes to add separated by space,
         * or an array of classes
         * @param {String} [prefix] Prefix to prepend to each class. The separator `-` will be 
         * appended to the prefix.
         * @param {String} [suffix] Suffix to append to each class. The separator `-` will be 
         * prepended to the suffix.
         * @return {Ext.dom.Element} this
         */
        addCls: function(names, prefix, suffix) {
            var me = this,
                elementData = me.getData(),
                hasNewCls, dom, map, classList, i, ln, name;

            if (!names) {
                return me;
            }

            if (!elementData.isSynchronized) {
                me.synchronize();
            }

            dom = me.dom;
            map = elementData.classMap;
            classList = elementData.classList;

            prefix = prefix ? prefix + SEPARATOR : &#39;&#39;;
            suffix = suffix ? SEPARATOR + suffix : &#39;&#39;;

            if (typeof names === &#39;string&#39;) {
                names = names.split(spacesRe);
            }

            for (i = 0, ln = names.length; i &lt; ln; i++) {
                name = names[i];
                // Check name here, we may have a leading/trailing space in a string or an empty value
                if (name) {
                    name = prefix + name + suffix;

                    if (!map[name]) {
                        map[name] = true;
                        classList.push(name);
                        hasNewCls = true;
                    }
                }
            }

            if (hasNewCls) {
                dom.className = classList.join(&#39; &#39;);
            }

            return me;
        },

<span id='Ext-dom-Element-method-addClsOnClick'>        /**
</span>         * Sets up event handlers to add and remove a css class when the mouse is down and then up on this element (a click effect)
         * @param {String} className The class to add
         * @param {Function} [testFn] A test function to execute before adding the class. The passed parameter
         * will be the Element instance. If this functions returns false, the class will not be added.
         * @param {Object} [scope] The scope to execute the testFn in.
         * @return {Ext.dom.Element} this
         */
        addClsOnClick: function(className, testFn, scope) {
            var me = this,
                dom = me.dom,
                hasTest = Ext.isFunction(testFn);

            me.on(&quot;mousedown&quot;, function() {
                if (hasTest &amp;&amp; testFn.call(scope || me, me) === false) {
                    return false;
                }
                Ext.fly(dom).addCls(className);
                var d = Ext.getDoc(),
                    fn = function() {
                        Ext.fly(dom).removeCls(className);
                        d.removeListener(&quot;mouseup&quot;, fn);
                    };
                d.on(&quot;mouseup&quot;, fn);
            });
            return me;
        },

<span id='Ext-dom-Element-method-addClsOnFocus'>        /**
</span>         * Sets up event handlers to add and remove a css class when this element has the focus
         * @param {String} className The class to add
         * @param {Function} [testFn] A test function to execute before adding the class. The passed parameter
         * will be the Element instance. If this functions returns false, the class will not be added.
         * @param {Object} [scope] The scope to execute the testFn in.
         * @return {Ext.dom.Element} this
         */
        addClsOnFocus: function(className, testFn, scope) {
            var me = this,
                dom = me.dom,
                hasTest = Ext.isFunction(testFn);

            me.on(&quot;focus&quot;, function() {
                if (hasTest &amp;&amp; testFn.call(scope || me, me) === false) {
                    return false;
                }
                Ext.fly(dom).addCls(className);
            });
            me.on(&quot;blur&quot;, function() {
                Ext.fly(dom).removeCls(className);
            });
            return me;
        },

<span id='Ext-dom-Element-method-addClsOnOver'>        /**
</span>         * Sets up event handlers to add and remove a css class when the mouse is over this element
         * @param {String} className The class to add
         * @param {Function} [testFn] A test function to execute before adding the class. The passed parameter
         * will be the Element instance. If this functions returns false, the class will not be added.
         * @param {Object} [scope] The scope to execute the testFn in.
         * @return {Ext.dom.Element} this
         */
        addClsOnOver: function(className, testFn, scope) {
            var me = this,
                dom = me.dom,
                hasTest = Ext.isFunction(testFn);

            me.hover(
                function() {
                    if (hasTest &amp;&amp; testFn.call(scope || me, me) === false) {
                        return;
                    }
                    Ext.fly(dom).addCls(className);
                },
                function() {
                    Ext.fly(dom).removeCls(className);
                }
            );
            return me;
        },

        addStyles: function(sides, styles){
            var totalSize = 0,
                sidesArr = (sides || &#39;&#39;).match(wordsRe),
                i,
                len = sidesArr.length,
                side,
                styleSides = [];

            if (len === 1) {
                totalSize = Math.abs(parseFloat(this.getStyle(styles[sidesArr[0]])) || 0);
            } else if (len) {
                for (i = 0; i &lt; len; i++) {
                    side = sidesArr[i];
                    styleSides.push(styles[side]);
                }
                //Gather all at once, returning a hash
                styleSides = this.getStyle(styleSides);

                for (i=0; i &lt; len; i++) {
                    side = sidesArr[i];
                    totalSize += parseFloat(styleSides[styles[side]]) || 0;
                }
            }

            return totalSize;
        },

        addUnits: function(size, units) {
            return Element.addUnits(size, units);
        },

<span id='Ext-dom-Element-method-adjustDirect2DDimension'>        /**
</span>         * @private
         * Returns the fractional portion of this element&#39;s measurement in the given dimension.
         * (IE9+ only)
         * @return {Number}
         */
        adjustDirect2DDimension: function(dimension) {
            var me = this,
                dom = me.dom,
                display = me.getStyle(&#39;display&#39;),
                inlineDisplay = dom.style.display,
                inlinePosition = dom.style.position,
                originIndex = dimension === WIDTH ? 0 : 1,
                currentStyle = dom.currentStyle,
                floating;

            if (display === &#39;inline&#39;) {
                dom.style.display = &#39;inline-block&#39;;
            }

            dom.style.position = display.match(adjustDirect2DTableRe) ? &#39;absolute&#39; : &#39;static&#39;;

            // floating will contain digits that appears after the decimal point
            // if height or width are set to auto we fallback to msTransformOrigin calculation

            // Use currentStyle here instead of getStyle. In some difficult to reproduce 
            // instances it resets the scrollWidth of the element
            floating = (parseFloat(currentStyle[dimension]) || parseFloat(currentStyle.msTransformOrigin.split(&#39; &#39;)[originIndex]) * 2) % 1;

            dom.style.position = inlinePosition;

            if (display === &#39;inline&#39;) {
                dom.style.display = inlineDisplay;
            }

            return floating;
        },

        // The following 3 methods add just enough of an animation api to make the scroller work
        // in Sencha Touch
        // TODO: unify touch/ext animations
        animate: function(animation) {
            animation = new Ext.fx.Animation(animation);
            animation.setElement(this);
            this._activeAnimation = animation;
            animation.on({
                animationend: this._onAnimationEnd,
                scope: this
            });
            Ext.Animator.run(animation);
            return animation;
        },

        _onAnimationEnd: function() {
            this._activeAnimation = null;
        },

        getActiveAnimation: function() {
            return this._activeAnimation;
        },

        append: function() {
            this.appendChild.apply(this, arguments);
        },

<span id='Ext-dom-Element-method-appendChild'>        /**
</span>         * Appends the passed element(s) to this element
         * @param {String/HTMLElement/Ext.dom.Element/Object} el The id or element to insert
         * or a DomHelper config
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead
         * of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The inserted Ext.dom.Element (or 
         * HTMLElement if _returnDom_ is _true_).
         */
        appendChild: function(el, returnDom) {
            var me = this,
                insertEl,
                eLen, e;

            if (el.nodeType || el.dom || typeof el === &#39;string&#39;) { // element
                el = Ext.getDom(el);
                me.dom.appendChild(el);
                return !returnDom ? Ext.get(el) : el;
            } else if (el.length) {
                // append all elements to a documentFragment
                insertEl = Ext.fly(DOC.createDocumentFragment());
                eLen = el.length;

                for (e = 0; e &lt; eLen; e++) {
                    insertEl.appendChild(el[e], returnDom);
                }
                el = Ext.Array.toArray(insertEl.dom.childNodes);
                me.dom.appendChild(insertEl.dom);
                return returnDom ? el : new Ext.dom.CompositeElementLite(el);
            }
            else { // dh config
                return me.createChild(el, null, returnDom);
            }
        },

<span id='Ext-dom-Element-method-appendTo'>        /**
</span>         * Appends this element to the passed element.
         * @param {String/HTMLElement/Ext.dom.Element} el The new parent element.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} This element.
         */
        appendTo: function(el) {
            Ext.getDom(el).appendChild(this.dom);
            return this;
        },

<span id='Ext-dom-Element-method-applyStyles'>        /**
</span>         * More flexible version of {@link #setStyle} for setting style properties.
         * 
         * Styles in object form should be a valid DOM element style property.  
         * [Valid style property names](http://www.w3schools.com/jsref/dom_obj_style.asp) 
         * (_along with the supported CSS version for each_)
         * 
         *     // &lt;div id=&quot;my-el&quot;&gt;Phineas Flynn&lt;/div&gt;
         *     
         *     var el = Ext.get(&#39;my-el&#39;);
         *     
         *     el.applyStyles(&#39;color: white;&#39;);
         *     
         *     el.applyStyles({
         *         fontWeight: &#39;bold&#39;,
         *         backgroundColor: &#39;gray&#39;,
         *         padding: &#39;10px&#39;
         *     });
         *     
         *     el.applyStyles(function () {
         *         if (name.initialConfig.html === &#39;Phineas Flynn&#39;) {
         *             return &#39;font-style: italic;&#39;;
         *             // OR return { fontStyle: &#39;italic&#39; };
         *         }
         *     });
         * 
         * @param {String/Object/Function} styles A style specification string, e.g. &quot;width:100px&quot;, or object in the form `{width:&quot;100px&quot;}`, or
         * a function which returns such a specification.
         * @return {Ext.dom.Element} this
         */
        applyStyles: function(styles) {
            if (styles) {
                if (typeof styles === &quot;function&quot;) {
                    styles = styles.call();
                }
                if (typeof styles === &quot;string&quot;) {
                    styles = Element.parseStyles(styles);
                }
                if (typeof styles === &quot;object&quot;) {
                    this.setStyle(styles);
                }
            }
            return this;
        },

<span id='Ext-dom-Element-method-blur'>        /**
</span>         * Tries to blur the element. Any exceptions are caught and ignored.
         * @return {Ext.dom.Element} this
         */
        blur: function() {
            var me = this,
                dom = me.dom;
            // In IE, blurring the body can cause the browser window to hide.
            // Blurring the body is redundant, so instead we just focus it
            if (dom !== DOC.body) {
                try {
                    dom.blur();
                } catch(e) {
                }
                return me;
            } else {
                return me.focus(undefined, dom);
            }
        },

<span id='Ext-dom-Element-method-cacheScrollValues'>        /**
</span>         * When an element is moved around in the DOM, or is hidden using `display:none`, it loses layout, and therefore
         * all scroll positions of all descendant elements are lost.
         *
         * This function caches them, and returns a function, which when run will restore the cached positions.
         * In the following example, the Panel is moved from one Container to another which will cause it to lose all scroll positions:
         *
         *     var restoreScroll = myPanel.el.cacheScrollValues();
         *     myOtherContainer.add(myPanel);
         *     restoreScroll();
         *
         * @return {Function} A function which will restore all descendant elements of this Element to their scroll
         * positions recorded when this function was executed. Be aware that the returned function is a closure which has
         * captured the scope of `cacheScrollValues`, so take care to dereference it as soon as not needed - if is it is a `var`
         * it will drop out of scope, and the reference will be freed.
         */
        cacheScrollValues: function() {
            var me = this,
                scrollValues = [],
                scrolledDescendants = [],
                descendants, descendant, i, len;

            scrollFly = scrollFly || new Ext.dom.Fly();

            descendants = me.query(&#39;*&#39;);
            for (i = 0, len = descendants.length; i &lt; len; i++) {
                descendant = descendants[i];
                // use !== 0 for scrollLeft because it can be a negative number
                // in RTL mode in some browsers.
                if (descendant.scrollTop &gt; 0 || descendant.scrollLeft !== 0) {
                    scrolledDescendants.push(descendant);
                    scrollValues.push(scrollFly.attach(descendant).getScroll());
                }
            }

            return function() {
                var scroll, i, len;

                for (i = 0, len = scrolledDescendants.length; i &lt; len; i++) {
                    scroll = scrollValues[i];
                    scrollFly.attach(scrolledDescendants[i]);
                    scrollFly.setScrollLeft(scroll.left);
                    scrollFly.setScrollTop(scroll.top);
                }
            };
        },

<span id='Ext-dom-Element-method-center'>        /**
</span>         * Centers the Element in either the viewport, or another Element.
         * @param {String/HTMLElement/Ext.dom.Element} centerIn element in
         * which to center the element.
         * @return {Ext.dom.Element} This element
         *
         * @chainable
         */
        center: function(centerIn){
            return this.alignTo(centerIn || DOC, &#39;c-c&#39;);
        },

<span id='Ext-dom-Element-method-child'>        /**
</span>         * Selects a single *direct* child based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector.
         * @param {Boolean} [returnDom=false] `true` to return the DOM node instead of Ext.dom.Element.
         * @return {HTMLElement/Ext.dom.Element} The child Ext.dom.Element (or DOM node if `returnDom` is `true`)
         */
        child: function(selector, returnDom) {
            var me = this,
            // Pull the ID from the DOM (Ext.id also ensures that there *is* an ID).
            // If this object is a Flyweight, it will not have an ID
                id = Ext.get(me).id;

            return me.selectNode(Ext.makeIdSelector(id) + &quot; &gt; &quot; + selector, !!returnDom);
        },

<span id='Ext-dom-Element-method-clone'>        /**
</span>         * Clone this element.
         * @param {Boolean} [deep=false] `true` if the children of the node should also be cloned.
         * @param {Boolean} [returnDom=false] `true` to return the DOM node instead of Ext.dom.Element.
         * @return {HTMLElement/Ext.dom.Element} The newly cloned Ext.dom.Element (or DOM node if `returnDom` is `true`).
         */
        clone: function(deep, returnDom) {
            var clone = this.dom.cloneNode(deep);
            if (Ext.supports.CloneNodeCopiesExpando) {
                clearData(clone, deep);
            }
            return returnDom ? clone : Ext.get(clone);
        },

        constrainScrollLeft: function(left) {
            var dom = this.dom;
            return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
        },

        constrainScrollTop: function(top) {
            var dom = this.dom;
            return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
        },

<span id='Ext-dom-Element-method-createChild'>        /**
</span>         * Creates the passed DomHelper config and appends it to this element or optionally
         * inserts it before the passed child element.
         * @param {Object} config DomHelper element config object.  If no tag is specified
         * (e.g., {tag:&#39;input&#39;}) then a div will be automatically generated with the specified
         * attributes.
         * @param {HTMLElement} [insertBefore] a child element of this element
         * @param {Boolean} [returnDom=false] true to return the dom node instead of creating
         * an Element
         * @return {Ext.dom.Element/HTMLElement} The new child element (or HTMLElement if 
         * _returnDom_ is _true_)
         */
        createChild: function(config, insertBefore, returnDom) {
            config = config || {tag:&#39;div&#39;};
            if (insertBefore) {
                return Ext.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
            }
            else {
                return Ext.DomHelper.append(this.dom, config,  returnDom !== true);
            }
        },

<span id='Ext-dom-Element-method-contains'>        /**
</span>         * Returns `true` if this element is an ancestor of the passed element, or is
         * the element.
         * @param {String/HTMLElement/Ext.dom.Element} element The dom element, 
         * Ext.dom.Element, or id (string) of the dom element to check.
         * @return {Boolean} True if this element is an ancestor of el or the el itself, else false
         */
        contains: function(element) {
            if (!element) {
                return false;
            }

            var me = this,
                dom = Ext.getDom(element);

            // we need el-contains-itself logic here because isAncestor does not do that:
            // https://developer.mozilla.org/en-US/docs/Web/API/Node.contains
            return (dom === me.dom) || me.isAncestor(dom);
        },

<span id='Ext-dom-Element-method-destroy'>        /**
</span>         * Destroys this element by removing it from the cache, removing its DOM reference,
         * and removing all of its event listeners.
         */
        destroy: function() {
            var me = this,
                dom = me.dom;

            //&lt;debug&gt;
            if (me.destroyed) {
                Ext.Logger.warn(&quot;Cannot destroy Element \&quot;&quot; + me.id + &quot;\&quot;. Already destroyed.&quot;);
                return;
            }

            if (dom) {
                if (dom === DOC.body) {
                    Ext.raise(&quot;Cannot destroy body element.&quot;);
                } else if (dom === DOC) {
                    Ext.raise(&quot;Cannot destroy document object.&quot;);
                } else if (dom === WIN) {
                    Ext.raise(&quot;Cannot destroy window object&quot;);
                }
            }
            //&lt;/debug&gt;

            if (dom &amp;&amp; dom.parentNode) {
                dom.parentNode.removeChild(dom);
            }

            me.collect();
        },

        detach: function() {
            var dom = this.dom;

            if (dom &amp;&amp; dom.parentNode &amp;&amp; dom.tagName !== &#39;BODY&#39;) {
                dom.parentNode.removeChild(dom);
            }

            return this;
        },

<span id='Ext-dom-Element-method-disableShadow'>        /**
</span>         * Disables the shadow element created by {@link #enableShadow}.
         * @private
         */
        disableShadow: function() {
            var shadow = this.shadow;
            
            if (shadow) {
                shadow.hide();
                shadow.disabled = true;
            }
        },

<span id='Ext-dom-Element-method-disableShim'>        /**
</span>         * Disables the shim element created by {@link #enableShim}.
         * @private
         */
        disableShim: function() {
            var shim = this.shim;

            if (shim) {
                shim.hide();
                shim.disabled = true;
            }
        },

<span id='Ext-dom-Element-method-doReplaceWith'>        /**
</span>         * @private
         */
        doReplaceWith: function(element) {
            var dom = this.dom;
            dom.parentNode.replaceChild(Ext.getDom(element), dom);
        },

<span id='Ext-dom-Element-method-doScrollIntoView'>        /**
</span>         * @private
         * A scrollIntoView implementation for scrollIntoView/rtlScrollIntoView to call 
         * after current scrollX has been determined.
         */
        doScrollIntoView: function(container, hscroll, animate, highlight, getScrollX, scrollTo) {
            scrollFly = scrollFly || new Ext.dom.Fly();

            var me = this,
                dom = me.dom,
                scrollX = scrollFly.attach(container)[getScrollX](),
                scrollY = container.scrollTop,
                position = me.getScrollIntoViewXY(container, scrollX, scrollY),
                newScrollX = position.x,
                newScrollY = position.y;

            // Highlight upon end of scroll
            if (highlight) {
                if (animate) {
                    animate = Ext.apply({
                        listeners: {
                            afteranimate: function() {
                                scrollFly.attach(dom).highlight();
                            }
                        }
                    }, animate);
                } else {
                    scrollFly.attach(dom).highlight();
                }
            }

            if (newScrollY !== scrollY) {
                scrollFly.attach(container).scrollTo(&#39;top&#39;, newScrollY, animate);
            }

            if (hscroll !== false  &amp;&amp; (newScrollX !== scrollX)) {
                scrollFly.attach(container)[scrollTo](&#39;left&#39;, newScrollX, animate);
            }
            return me;
        },

<span id='Ext-dom-Element-method-down'>        /**
</span>         * Selects a single child at any depth below this element based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} [returnDom=false] `true` to return the DOM node instead of Ext.dom.Element
         * @return {HTMLElement/Ext.dom.Element} The child Ext.dom.Element (or DOM node if `returnDom` is `true`)
         */
        down: function(selector, returnDom) {
            return this.selectNode(selector, !!returnDom);
        },

<span id='Ext-dom-Element-method-enableShadow'>        /**
</span>         * Enables a shadow element that will always display behind this element
         * @param {Object} [options] Configuration options for the shadow
         * @param {Number} [options.offset=4] Number of pixels to offset the shadow
         * @param {String} [options.mode=&#39;sides&#39;] The shadow display mode.  Supports the following
         * options:
         *
         *     - `&#39;sides&#39;`: Shadow displays on both sides and bottom only
         *     - `&#39;frame&#39;`: Shadow displays equally on all four sides
         *     - `&#39;drop&#39;`: Traditional bottom-right drop shadow
         *     - `&#39;bottom&#39;`: Shadow is offset to the bottom
         *
         * @param {Boolean} [options.animate=false] `true` to animate the shadow while
         * the element is animating.  By default the shadow will be hidden during animation.
         * @private
         */
        enableShadow: function(options, /* private */ isVisible) {
            var me = this,
                shadow = me.shadow || (me.shadow = new Ext.dom.Shadow(Ext.apply({
                    target: me
                }, options))),
                shim = me.shim;

            if (shim) {
                shim.offsets = shadow.outerOffsets;
                shim.shadow = shadow;
                shadow.shim = shim;
            }

            // Components pass isVisible to avoid the extra dom read to determine
            // whether or not this element is visible.
            if (isVisible === true || (isVisible !== false &amp;&amp; me.isVisible())) {
                // the shadow element may have just been retrieved from an OverlayPool, so
                // we need to explicitly show it to be sure hidden styling is removed
                shadow.show();
            } else {
                shadow.hide();
            }

            shadow.disabled = false;
        },

<span id='Ext-dom-Element-method-enableShim'>        /**
</span>         * Enables an iframe shim for this element to keep windowed objects from
         * showing through.  The position, size, and visibility of the shim will be
         * automatically synchronized as the position, size, and visibility of this
         * Element are changed.
         * @param {Object} [options] Configuration options for the shim
         * @return {Ext.dom.Shim} The new Shim
         * @private
         */
        enableShim: function(options, /* private */ isVisible) {
            var me = this,
                shim = me.shim || (me.shim = new Ext.dom.Shim(Ext.apply({
                    target: me
                }, options))),
                shadow = me.shadow;

            if (shadow) {
                shim.offsets = shadow.outerOffsets;
                shim.shadow = shadow;
                shadow.shim = shim;
            }

            // Components pass isVisible to avoid the extra dom read to determine
            // whether or not this element is visible.
            if (isVisible === true || (isVisible !== false &amp;&amp; me.isVisible())) {
                // the shim element may have just been retrieved from an OverlayPool, so
                // we need to explicitly show it to be sure hidden styling is removed
                shim.show();
            } else {
                shim.hide();
            }

            shim.disabled = false;
            return shim;
        },

<span id='Ext-dom-Element-method-findParent'>        /**
</span>         * Looks at this node and then at parent nodes for a match of the passed simple selector.
         * @param {String} selector The simple selector to test. See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Number/String/HTMLElement/Ext.dom.Element} [limit]
         * The max depth to search as a number or an element which causes the upward traversal to stop
         * and is **not** considered for inclusion as the result. (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnEl=false] True to return a Ext.dom.Element object instead of DOM node
         * @return {HTMLElement/Ext.dom.Element} The matching DOM node (or 
         * Ext.dom.Element if _returnEl_ is _true_).  Or null if no match was found.
         */
        findParent: function(simpleSelector, limit, returnEl) {
            var me = this,
                target = me.dom,
                topmost = docEl,
                depth = 0;

            if (limit || limit === 0) {
                if (typeof limit !== &#39;number&#39;) {
                    topmost = Ext.getDom(limit);
                    limit = Number.MAX_VALUE;
                }
            } else {
                // No limit passed, default to 50
                limit = 50;
            }

            while (target &amp;&amp; target.nodeType === 1 &amp;&amp; depth &lt; limit &amp;&amp; target !== topmost) {
                if (Ext.fly(target).is(simpleSelector)) {
                    return returnEl ? Ext.get(target) : target;
                }
                depth++;
                target = target.parentNode;
            }
            return null;
        },

<span id='Ext-dom-Element-method-findParentNode'>        /**
</span>         * Looks at parent nodes for a match of the passed simple selector.
         * @param {String} selector The simple selector to test. See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Number/String/HTMLElement/Ext.dom.Element} [limit]
         * The max depth to search as a number or an element which causes the upward traversal to stop
         * and is **not** considered for inclusion as the result. (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnEl=false] True to return a Ext.dom.Element object instead of DOM node
         * @return {HTMLElement/Ext.dom.Element} The matching DOM node (or 
         * Ext.dom.Element if _returnEl_ is _true_).  Or null if no match was found.
         */
        findParentNode: function(simpleSelector, limit, returnEl) {
            var p = Ext.fly(this.dom.parentNode);
            return p ? p.findParent(simpleSelector, limit, returnEl) : null;
        },

<span id='Ext-dom-Element-method-first'>        /**
</span>         * Gets the first child, skipping text nodes
         * @param {String} [selector] Find the next sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] `true` to return a raw DOM node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The first child or null
         */
        first: function(selector, returnDom) {
            return this.matchNode(&#39;nextSibling&#39;, &#39;firstChild&#39;, selector, returnDom);
        },

<span id='Ext-dom-Element-method-focus'>        /**
</span>         * Try to focus the element either immediately or after a timeout
         * if `defer` argument is specified.
         *
         * @param {Number} [defer] Milliseconds to defer the focus
         *
         * @return {Ext.dom.Element} this
         */
        focus: function(defer, /* private */ dom) {
            var me = this;

            dom = dom || me.dom;
            
            if (Number(defer)) {
                Ext.defer(me.focus, defer, me, [null, dom]);
            }
            else {
                Ext.GlobalEvents.fireEvent(&#39;beforefocus&#39;, dom);
                dom.focus();
            }
            
            return me;
        },

<span id='Ext-dom-Element-method-collect'>        /**
</span>         * @private
         * Removes the element from the cache and removes listeners.
         * Used for cleaning up orphaned elements after they have been removed from the dom.
         * Similar to {@link #destroy} except it assumes the element has already been
         * removed from the dom.
         */
        collect: function() {
            var me = this,
                dom = me.dom,
                shadow = me.shadow,
                shim = me.shim;

            // The parent destroy sets the destroy to emptyFn, which we don&#39;t
            // want on a shared fly
            if (!me.isFly) {
                me.mixins.observable.destroy.call(me);
                delete Ext.cache[me.id];
                me.el = null;
            }

            if (dom) {
                dom._extData = me.dom = null;
            }

            // we do not destroy the shadow and shim because they are returned to their
            // OverlayPools for reuse.
            if (shadow) {
                shadow.hide();
                me.shadow = null;
            }

            if (shim) {
                shim.hide();
                me.shim = null;
            }
        },

        getAnchorToXY: function(el, anchor, local, mySize) {
            return el.getAnchorXY(anchor, local, mySize);
        },

<span id='Ext-dom-Element-method-getAttribute'>        /**
</span>         * Returns the value of an attribute from the element&#39;s underlying DOM node.
         * @param {String} name The attribute name.
         * @param {String} [namespace] The namespace in which to look for the attribute.
         * @return {String} The attribute value.
         */
        getAttribute: function(name, namespace) {
            var dom = this.dom;

            return namespace ?
                (dom.getAttributeNS(namespace, name) || dom.getAttribute(namespace + &quot;:&quot; + name)) :
                (dom.getAttribute(name) || dom[name] || null);
        },
        
<span id='Ext-dom-Element-method-getAttributes'>        /**
</span>         * Returns an object containing a map of all attributes of this element&#39;s DOM node.
         * 
         * @return {Object} Key/value pairs of attribute names and their values.
         */
        getAttributes: function() {
            var attributes = this.dom.attributes,
                result = {},
                attr, i, len;
            
            for (i = 0, len = attributes.length; i &lt; len; i++) {
                attr = attributes[i];
                
                result[attr.name] = attr.value;
            }
            
            return result;
        },

<span id='Ext-dom-Element-method-getBottom'>        /**
</span>         * Gets the bottom Y coordinate of the element (element Y position + element height)
         * @param {Boolean} local True to get the local css position instead of page
         * coordinate
         * @return {Number}
         */
        getBottom: function(local) {
            return (local ? this.getLocalY() : this.getY()) + this.getHeight();
        },

<span id='Ext-dom-Element-method-getById'>        /**
</span>         * Returns a child element of this element given its `id`.
         * @param {String} id The id of the desired child element.
         * @param {Boolean} [asDom=false] True to return the DOM element, false to return a
         * wrapped Element object.
         * @return {Ext.dom.Element/HTMLElement} The child element (or HTMLElement if 
         * _asDom_ is _true_).  Or null if no match was found.
         */
        getById: function (id, asDom) {
            // for normal elements getElementById is the best solution, but if the el is
            // not part of the document.body, we have to resort to querySelector
            var dom = DOC.getElementById(id) ||
                this.dom.querySelector(Ext.makeIdSelector(id));
            return asDom ? dom : (dom ? Ext.get(dom) : null);
        },

        getBorderPadding: function() {
            var paddingWidth = this.getStyle(paddingsTLRB),
                bordersWidth = this.getStyle(bordersTLRB);

            return {
                beforeX: (parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0),
                afterX: (parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0),
                beforeY: (parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0),
                afterY: (parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)
            };
        },

<span id='Ext-dom-Element-method-getBorders'>        /**
</span>         * @private
         */
        getBorders: function() {
            var bordersWidth = this.getStyle(bordersTLRB);

            return {
                beforeX: (parseFloat(bordersWidth[borders.l]) || 0),
                afterX: (parseFloat(bordersWidth[borders.r]) || 0),
                beforeY: (parseFloat(bordersWidth[borders.t]) || 0),
                afterY: (parseFloat(bordersWidth[borders.b]) || 0)
            };
        },

<span id='Ext-dom-Element-method-getBorderWidth'>        /**
</span>         * Gets the width of the border(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add
         * multiple values. For example, passing `&#39;lr&#39;` would get the border **l**eft
         * width + the border **r**ight width.
         * @return {Number} The width of the sides passed added together
         */
        getBorderWidth: function(side) {
            return this.addStyles(side, borders);
        },

        getData: function(preventCreate) {
            var dom = this.dom,
                data;

            if (dom) {
                data = dom._extData;
                if (!data &amp;&amp; !preventCreate) {
                    dom._extData = data = {};
                }
            }
            return data;
        },

        getFirstChild: function() {
            return Ext.get(this.dom.firstElementChild);
        },

<span id='Ext-dom-Element-method-getHeight'>        /**
</span>         * Returns the offset height of the element.
         * @param {Boolean} [contentHeight] `true` to get the height minus borders and padding.
         * @return {Number} The element&#39;s height.
         */
        getHeight: function(contentHeight, preciseHeight) {
            var me = this,
                dom = me.dom,
                hidden = me.isStyle(&#39;display&#39;, &#39;none&#39;),
                height,
                floating;

            if (hidden) {
                return 0;
            }

            // Use the viewport height if they are asking for body height
            if (dom.nodeName === &#39;BODY&#39;) {
                height = Element.getViewportHeight();
            } else {
                height = dom.offsetHeight;

                // SVG nodes do not have offsetHeight, so use boundingClientRect instead.
                if (height == null) {
                    height = dom.getBoundingClientRect().height;
                }
            }

            // IE9/10 Direct2D dimension rounding bug
            if (Ext.supports.Direct2DBug) {
                floating = me.adjustDirect2DDimension(HEIGHT);
                if (preciseHeight) {
                    height += floating;
                }
                else if (floating &gt; 0 &amp;&amp; floating &lt; 0.5) {
                    height++;
                }
            }

            if (contentHeight) {
                height -= me.getBorderWidth(&quot;tb&quot;) + me.getPadding(&quot;tb&quot;);
            }

            return (height &lt; 0) ? 0 : height;
        },

<span id='Ext-dom-Element-method-getHtml'>        /**
</span>         * Returns the `innerHTML` of an Element or an empty string if the element&#39;s
         * dom no longer exists.
         * @return {String}
         */
        getHtml: function() {
            return this.dom ? this.dom.innerHTML : &#39;&#39;;
        },

<span id='Ext-dom-Element-method-getLeft'>        /**
</span>         * Gets the left X coordinate
         * @param {Boolean} local True to get the local css position instead of
         * page coordinate
         * @return {Number}
         */
        getLeft: function(local) {
            return local ? this.getLocalX() : this.getX();
        },

        getLocalX: function() {
            var me = this,
                offsetParent,
                x = me.getStyle(&#39;left&#39;);

            if (!x || x === &#39;auto&#39;) {
                x = 0;
            } else if (pxRe.test(x)) {
                x = parseFloat(x);
            } else {
                x = me.getX();

                // Reading offsetParent causes forced async layout.
                // Do not do it unless needed.
                offsetParent = me.dom.offsetParent;
                if (offsetParent) {
                    x -= Ext.fly(offsetParent).getX();
                }
            }

            return x;
        },

        getLocalXY: function() {
            var me = this,
                offsetParent,
                style = me.getStyle([&#39;left&#39;, &#39;top&#39;]),
                x = style.left,
                y = style.top;

            if (!x || x === &#39;auto&#39;) {
                x = 0;
            } else if (pxRe.test(x)) {
                x = parseFloat(x);
            } else {
                x = me.getX();

                // Reading offsetParent causes forced async layout.
                // Do not do it unless needed.
                offsetParent = me.dom.offsetParent;
                if (offsetParent) {
                    x -= Ext.fly(offsetParent).getX();
                }
            }

            if (!y || y === &#39;auto&#39;) {
                y = 0;
            } else if (pxRe.test(y)) {
                y = parseFloat(y);
            } else {
                y = me.getY();

                // Reading offsetParent causes forced async layout.
                // Do not do it unless needed.
                offsetParent = me.dom.offsetParent;
                if (offsetParent) {
                    y -= Ext.fly(offsetParent).getY();
                }
            }

            return [x, y];
        },

        getLocalY: function() {
            var me = this,
                offsetParent,
                y = me.getStyle(&#39;top&#39;);

            if (!y || y === &#39;auto&#39;) {
                y = 0;
            } else if (pxRe.test(y)) {
                y = parseFloat(y);
            } else {
                y = me.getY();

                // Reading offsetParent causes forced async layout.
                // Do not do it unless needed.
                offsetParent = me.dom.offsetParent;
                if (offsetParent) {
                    y -= Ext.fly(offsetParent).getY();
                }
            }

            return y;
        },

<span id='Ext-dom-Element-method-getMargin'>        /**
</span>         * @method
         *
         * Returns an object with properties top, left, right and bottom representing the margins of this element unless sides is passed,
         * then it returns the calculated width of the sides (see {@link #getPadding}).
         * @param {String} [sides] Any combination of &#39;l&#39;, &#39;r&#39;, &#39;t&#39;, &#39;b&#39; to get the sum of those sides.
         * @return {Object/Number}
         */
        getMargin: (function() {
            var hash = {t: &quot;top&quot;, l: &quot;left&quot;, r: &quot;right&quot;, b: &quot;bottom&quot;},
                allMargins = [&#39;margin-top&#39;, &#39;margin-left&#39;, &#39;margin-right&#39;, &#39;margin-bottom&#39;];

            return function(side) {
                var me = this,    
                    style, key, o;

                if (!side) {
                    style = me.getStyle(allMargins);
                    o = {};
                    if (style &amp;&amp; typeof style === &#39;object&#39;) {
                        o = {};
                        for (key in margins) {
                            o[key] = o[hash[key]] = parseFloat(style[margins[key]]) || 0;
                        }
                    }
                } else {
                    o = me.addStyles(side, margins);
                }
                return o;
            };
        })(),

<span id='Ext-dom-Element-method-getPadding'>        /**
</span>         * Gets the width of the padding(s) for the specified side(s).
         * @param {String} side Can be t, l, r, b or any combination of those to add
         * multiple values. For example, passing `&#39;lr&#39;` would get the padding **l**eft +
         * the padding **r**ight.
         * @return {Number} The padding of the sides passed added together.
         */
        getPadding: function(side) {
            return this.addStyles(side, paddings);
        },

        getParent: function() {
            return Ext.get(this.dom.parentNode);
        },

<span id='Ext-dom-Element-method-getRight'>        /**
</span>         * Gets the right X coordinate of the element (element X position + element width)
         * @param {Boolean} local True to get the local css position instead of page
         * coordinates
         * @return {Number}
         */
        getRight: function(local) {
            return (local ? this.getLocalX() : this.getX()) + this.getWidth();
        },

<span id='Ext-dom-Element-method-getScroll'>        /**
</span>         * Returns the current scroll position of the element.
         * @return {Object} An object containing the scroll position in the format
         * `{left: (scrollLeft), top: (scrollTop)}`
         */
        getScroll: function() {
            var me = this,
                dom = me.dom,
                docElement = docEl,
                left, top,
                body = DOC.body;

            if (dom === DOC || dom === body) {
                // the scrollLeft/scrollTop may be either on the body or documentElement,
                // depending on browser. It is possible to use window.pageXOffset/pageYOffset
                // in most modern browsers but this complicates things when in rtl mode because
                // pageXOffset does not always behave the same as scrollLeft when direction is
                // rtl. (e.g. pageXOffset can be an offset from the right, while scrollLeft
                // is offset from the left, one can be positive and the other negative, etc.)
                // To avoid adding an extra layer of feature detection in rtl mode to deal with
                // these differences, it&#39;s best just to always use scrollLeft/scrollTop
                left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
                top = docElement.scrollTop || (body ? body.scrollTop : 0);
            } else {
                left = dom.scrollLeft;
                top = dom.scrollTop;
            }

            return {
                left: left,
                top: top
            };
        },

<span id='Ext-dom-Element-method-getScrollIntoViewXY'>        /**
</span>         * Gets the x and y coordinates needed for scrolling an element into view within
         * a given container.  These coordinates translate into the scrollLeft and scrollTop
         * positions that will need to be set on an ancestor of the element in order to make
         * this element visible within its container.
         * @param {String/HTMLElement/Ext.Element} container The container
         * @param {Number} scrollX The container&#39;s current scroll position on the x axis
         * @param {Number} scrollY The container&#39;s current scroll position on the y axis
         * @return {Object} An object with &quot;x&quot; and &quot;y&quot; properties
         * @private
         */
        getScrollIntoViewXY: function(container, scrollX, scrollY) {
            var dom = this.dom,
                ct = Ext.getDom(container),
                offsets = this.getOffsetsTo(ct),

                width = dom.offsetWidth,
                height = dom.offsetHeight,
                left = offsets[0] + scrollX,
                top = offsets[1] + scrollY,
                bottom = top + height,
                right = left + width,

                viewHeight = ct.clientHeight,
                viewWidth = ct.clientWidth,
                viewLeft = scrollX,
                viewTop = scrollY,
                viewBottom = viewTop + viewHeight,
                viewRight = viewLeft + viewWidth;


            if (height &gt; viewHeight || top &lt; viewTop) {
                scrollY = top;
            } else if (bottom &gt; viewBottom) {
                scrollY = bottom - viewHeight;
            }

            if (width &gt; viewWidth || left &lt; viewLeft) {
                scrollX = left;
            } else if (right &gt; viewRight) {
                scrollX = right - viewWidth;
            }

            return {
                x: scrollX,
                y: scrollY
            };
        },

<span id='Ext-dom-Element-method-getScrollLeft'>        /**
</span>         * Gets the left scroll position
         * @return {Number} The left scroll position
         */
        getScrollLeft: function() {
            var dom = this.dom;

            if (dom === DOC || dom === DOC.body) {
                return this.getScroll().left;
            } else {
                return dom.scrollLeft;
            }
        },

<span id='Ext-dom-Element-method-getScrollTop'>        /**
</span>         * Gets the top scroll position
         * @return {Number} The top scroll position
         */
        getScrollTop: function(){
            var dom = this.dom;

            if (dom === DOC || dom === DOC.body) {
                return this.getScroll().top;
            } else {
                return dom.scrollTop;
            }
        },

<span id='Ext-dom-Element-method-getSize'>        /**
</span>         * Returns the size of the element.
         * @param {Boolean} [contentSize] `true` to get the width/size minus borders and padding.
         * @return {Object} An object containing the element&#39;s size:
         * @return {Number} return.width
         * @return {Number} return.height
         */
        getSize: function(contentSize) {
            return {width: this.getWidth(contentSize), height: this.getHeight(contentSize)};
        },

<span id='Ext-dom-Element-method-getStyle'>        /**
</span>         * Returns a named style property based on computed/currentStyle (primary) and
         * inline-style if primary is not available.
         *
         * @param {String/String[]} property The style property (or multiple property names
         * in an array) whose value is returned.
         * @param {Boolean} [inline=false] if `true` only inline styles will be returned.
         * @return {String/Object} The current value of the style property for this element
         * (or a hash of named style values if multiple property arguments are requested).
         * @method
         */
        getStyle: function (property, inline) {
            var me = this,
                dom = me.dom,
                multiple = typeof property !== &#39;string&#39;,
                hooks = me.styleHooks,
                prop = property,
                props = prop,
                len = 1,
                domStyle, camel, values, hook, out, style, i;

            if (multiple) {
                values = {};
                prop = props[0];
                i = 0;
                if (!(len = props.length)) {
                    return values;
                }
            }

            if (!dom || dom.documentElement) {
                return values || &#39;&#39;;
            }

            domStyle = dom.style;

            if (inline) {
                style = domStyle;
            } else {
                // Caution: Firefox will not render &quot;presentation&quot; (i.e. computed styles) in
                // iframes that are display:none or those inheriting display:none. Similar
                // issues with legacy Safari.
                //
                style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);

                // fallback to inline style if rendering context not available
                if (!style) {
                    inline = true;
                    style = domStyle;
                }
            }

            do {
                hook = hooks[prop];

                if (!hook) {
                    hooks[prop] = hook = { name: Element.normalize(prop) };
                }

                if (hook.get) {
                    out = hook.get(dom, me, inline, style);
                } else {
                    camel = hook.name;
                    out = style[camel];
                }

                if (!multiple) {
                    return out;
                }

                values[prop] = out;
                prop = props[++i];
            } while (i &lt; len);

            return values;
        },

        getStyleValue: function(name) {
            return this.dom.style.getPropertyValue(name);
        },

<span id='Ext-dom-Element-method-getTop'>        /**
</span>         * Gets the top Y coordinate
         * @param {Boolean} local True to get the local css position instead of page
         * coordinates
         * @return {Number}
         */
        getTop: function(local) {
            return local ? this.getLocalY() : this.getY();
        },

<span id='Ext-dom-Element-method-getTouchAction'>        /**
</span>         * Returns this element&#39;s touch action.  (see {@link #setTouchAction})
         *
         * The returned object is shared and should not be mutated.
         *
         * @returns {Object}
         */
        getTouchAction: function() {
            return Ext.dom.TouchAction.get(this.dom);
        },

<span id='Ext-dom-Element-method-getValue'>        /**
</span>         * Returns the value of the `value` attribute.
         * @param {Boolean} asNumber `true` to parse the value as a number.
         * @return {String/Number}
         */
        getValue: function(asNumber) {
            var value = this.dom.value;

            return asNumber ? parseInt(value, 10) : value;
        },

<span id='Ext-dom-Element-method-getViewSize'>        /**
</span>         * Returns the dimensions of the element available to lay content out in.  For
         * most elements this is the clientHeight/clientWidth.  If the element is
         * the document/document.body the window&#39;s innerHeight/innerWidth is returned
         *
         * If the element (or any ancestor element) has CSS style `display: none`, the
         * dimensions will be zero.
         *
         * @return {Object} Object describing width and height.
         * @return {Number} return.width
         * @return {Number} return.height
         */
        getViewSize: function() {
            var dom = this.dom;

            if (dom === DOC || dom === DOC.body) {
                return {
                    width: Element.getViewportWidth(),
                    height: Element.getViewportHeight()
                };
            }
            else {
                return {
                    width: dom.clientWidth,
                    height: dom.clientHeight
                };
            }
        },

        getVisibilityMode: function() {
            var me = this,
                data = me.getData(),
                mode = data.visibilityMode;

            if (mode === undefined) {
                data.visibilityMode = mode = Element.DISPLAY;
            }

            return mode;
        },

<span id='Ext-dom-Element-method-getWidth'>        /**
</span>         * Returns the offset width of the element.
         * @param {Boolean} [contentWidth] `true` to get the width minus borders and padding.
         * @return {Number} The element&#39;s width.
         */
        getWidth: function(contentWidth, preciseWidth) {
            var me = this,
                dom = me.dom,
                hidden = me.isStyle(&#39;display&#39;, &#39;none&#39;),
                rect, width, floating;

            if (hidden) {
                return 0;
            }

            // Gecko will in some cases report an offsetWidth that is actually less than the width of the
            // text contents, because it measures fonts with sub-pixel precision but rounds the calculated
            // value down. Using getBoundingClientRect instead of offsetWidth allows us to get the precise
            // subpixel measurements so we can force them to always be rounded up. See
            // https://bugzilla.mozilla.org/show_bug.cgi?id=458617
            // Rounding up ensures that the width includes the full width of the text contents.
            if (Ext.supports.BoundingClientRect) {
                rect = dom.getBoundingClientRect();
                width = (me.vertical &amp;&amp; !Ext.supports.RotatedBoundingClientRect) ?
                        (rect.bottom - rect.top) : (rect.right - rect.left);
                width = preciseWidth ? width : Math.ceil(width);
            } else {
                width = dom.offsetWidth;
            }

            // IE9/10 Direct2D dimension rounding bug: https://sencha.jira.com/browse/EXTJSIV-603
            // there is no need make adjustments for this bug when the element is vertically
            // rotated because the width of a vertical element is its rotated height
            if (Ext.supports.Direct2DBug &amp;&amp; !me.vertical) {
                // get the fractional portion of the sub-pixel precision width of the element&#39;s text contents
                floating = me.adjustDirect2DDimension(WIDTH);
                if (preciseWidth) {
                    width += floating;
                }
                // IE9 also measures fonts with sub-pixel precision, but unlike Gecko, instead of rounding the offsetWidth down,
                // it rounds to the nearest integer. This means that in order to ensure that the width includes the full
                // width of the text contents we need to increment the width by 1 only if the fractional portion is less than 0.5
                else if (floating &gt; 0 &amp;&amp; floating &lt; 0.5) {
                    width++;
                }
            }

            if (contentWidth) {
                width -= me.getBorderWidth(&quot;lr&quot;) + me.getPadding(&quot;lr&quot;);
            }

            return (width &lt; 0) ? 0 : width;
        },

<span id='Ext-dom-Element-method-getX'>        /**
</span>         * Gets element X position in page coordinates
         *
         * @return {Number}
         */
        getX: function() {
            return this.getXY()[0];
        },

<span id='Ext-dom-Element-method-getXY'>        /**
</span>         * Gets element X and Y positions in page coordinates
         *
         * @return {Array} [x, y]
         */
        getXY: function() {
            var round = Math.round,
                dom = this.dom,
                body = DOC.body,
                x = 0,
                y = 0,
                bodyRect, rect;

            if(dom !== DOC &amp;&amp; dom !== body){
                // IE (including IE10) throws an error when getBoundingClientRect
                // is called on an element not attached to dom
                try {
                    bodyRect = body.getBoundingClientRect();
                    rect = dom.getBoundingClientRect();

                    x = rect.left - bodyRect.left;
                    y = rect.top - bodyRect.top;
                } catch (ex) {}
            }

            return [round(x), round(y)];
        },

<span id='Ext-dom-Element-method-getY'>        /**
</span>         * Gets element Y position in page coordinates
         *
         * @return {Number}
         */
        getY: function() {
            return this.getXY()[1];
        },

<span id='Ext-dom-Element-method-getZIndex'>        /**
</span>         * Returns this element&#39;s z-index
         * @return {Number}
         */
        getZIndex: function() {
            return parseInt(this.getStyle(&#39;z-index&#39;), 10);
        },

<span id='Ext-dom-Element-method-hasCls'>        /**
</span>         * Checks if the specified CSS class exists on this element&#39;s DOM node.
         * @param {String} name The CSS class to check for.
         * @return {Boolean} `true` if the class exists, else `false`.
         */
        hasCls: function(name) {
            var elementData = this.getData();

            if (!elementData.isSynchronized) {
                this.synchronize();
            }

            return elementData.classMap.hasOwnProperty(name);
        },

<span id='Ext-dom-Element-method-hide'>        /**
</span>         * Hide this element - Uses display mode to determine whether to use &quot;display&quot;,
         * &quot;visibility&quot;, or &quot;offsets&quot;. See {@link #setVisible}.
         * @return {Ext.dom.Element} this
         */
        hide: function() {
            this.setVisible(false);
            return this;
        },

<span id='Ext-dom-Element-method-insertAfter'>        /**
</span>         * Inserts this element after the passed element in the DOM.
         * @param {String/HTMLElement/Ext.dom.Element} el The element to insert after.
         * The `id` of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} This element.
         */
        insertAfter: function(el) {
            el = Ext.getDom(el);
            el.parentNode.insertBefore(this.dom, el.nextSibling);
            return this;
        },

<span id='Ext-dom-Element-method-insertBefore'>        /**
</span>         * Inserts this element before the passed element in the DOM.
         * @param {String/HTMLElement/Ext.dom.Element} el The element before which this element will be inserted.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} This element.
         */
        insertBefore: function(el) {
            el = Ext.getDom(el);
            el.parentNode.insertBefore(this.dom, el);
            return this;
        },

<span id='Ext-dom-Element-method-insertFirst'>        /**
</span>         * Inserts (or creates) an element as the first child of this element
         * @param {String/HTMLElement/Ext.dom.Element/Object} el The id or element to insert
         * or a DomHelper config to create and insert
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead
         * of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The new child element (or HTMLElement if 
         * _returnDom_ is _true_).
         */
        insertFirst: function(el, returnDom) {
            el = el || {};
            if (el.nodeType || el.dom || typeof el === &#39;string&#39;) { // element
                el = Ext.getDom(el);
                this.dom.insertBefore(el, this.dom.firstChild);
                return !returnDom ? Ext.get(el) : el;
            }
            else { // dh config
                return this.createChild(el, this.dom.firstChild, returnDom);
            }
        },

<span id='Ext-dom-Element-method-insertHtml'>        /**
</span>         * Inserts an html fragment into this element
         * @param {String} where Where to insert the html in relation to this element - beforeBegin, afterBegin, beforeEnd, afterEnd.
         * See {@link Ext.dom.Helper#insertHtml} for details.
         * @param {String} html The HTML fragment
         * @param {Boolean} [returnEl=false] True to return an Ext.dom.Element
         * @return {HTMLElement/Ext.dom.Element} The inserted node (or nearest related if more than 1 inserted)
         */
        insertHtml: function(where, html, returnEl) {
            var el = Ext.DomHelper.insertHtml(where, this.dom, html);
            return returnEl ? Ext.get(el) : el;
        },

<span id='Ext-dom-Element-method-insertSibling'>        /**
</span>         * Inserts (or creates) the passed element (or DomHelper config) as a sibling of this element
         * @param {String/HTMLElement/Ext.dom.Element/Object/Array} el The id, element to insert or a DomHelper config
         * to create and insert *or* an array of any of those.
         * @param {String} [where=&#39;before&#39;] &#39;before&#39; or &#39;after&#39;
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The inserted Ext.dom.Element (or 
         * HTMLElement if _returnDom_ is _true_). If an array is passed, the last 
         * inserted element is returned.
         */
        insertSibling: function(el, where, returnDom) {
            var me        = this,
                DomHelper = Ext.DomHelper,
                isAfter   = (where || &#39;before&#39;).toLowerCase() === &#39;after&#39;,
                rt, insertEl, eLen, e;

            if (Ext.isIterable(el)) {
                eLen = el.length;
                insertEl = Ext.fly(DOC.createDocumentFragment());

                // append all elements to a documentFragment               
                if (Ext.isArray(el)) {

                    for (e = 0; e &lt; eLen; e++) {
                        rt = insertEl.appendChild(el[e], returnDom);
                    }
                }
                // Iterable, but not an Array, must be an HtmlCollection
                else {
                    for (e = 0; e &lt; eLen; e++) {
                        insertEl.dom.appendChild(rt = el[0]);
                    }
                    if (returnDom === false) {
                        rt = Ext.get(rt);
                    }
                }

                // Insert fragment into document
                me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
                return rt;
            }

            el = el || {};

            if (el.nodeType || el.dom) {
                rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
                if (!returnDom) {
                    rt = Ext.get(rt);
                }
            } else {
                if (isAfter &amp;&amp; !me.dom.nextSibling) {
                    rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
                } else {
                    rt = DomHelper[isAfter ? &#39;insertAfter&#39; : &#39;insertBefore&#39;](me.dom, el, !returnDom);
                }
            }
            return rt;
        },

<span id='Ext-dom-Element-method-is'>        /**
</span>         * Returns `true` if this element matches the passed simple selector
         * (e.g. &#39;div.some-class&#39; or &#39;span:first-child&#39;).
         * @param {String/Function} selector The simple selector to test or a function which is passed
         * candidate nodes, and should return `true` for nodes which match.
         * @return {Boolean} `true` if this element matches the selector, else `false`.
         */
        is: function(selector) {
            var dom = this.dom,
                is;

            if (!selector) {
                // In Ext 4 is() called through to DomQuery methods, and would always
                // return true if the selector was &#39;&#39;.  The new query() method in v5 uses
                // querySelector/querySelectorAll() which consider &#39;&#39; to be an invalid
                // selector and throw an error as a result.  To maintain compatibility
                // with the various users of is() we have to return true if the selector
                // is an empty string.  For example: el.up(&#39;&#39;) should return the element&#39;s
                // direct parent.
                is = true;
            } else if (!dom.tagName) {
                // document and window objects can never match a selector
                is = false;
            } else if (Ext.isFunction(selector)) {
                is = selector(dom);
            } else {
                is = dom[Ext.supports.matchesSelector](selector);
            }

            return is;
        },

<span id='Ext-dom-Element-method-isAncestor'>        /**
</span>         * Returns `true` if this element is an ancestor of the passed element
         * @param {String/HTMLElement/Ext.dom.Element} el The element or id of the element
         * to search for in this elements descendants.
         * @return {Boolean}
         */
        isAncestor: function(el) {
            var ret = false,
                dom = this.dom,
                child = Ext.getDom(el);

            if (dom &amp;&amp; child) {
                if (dom.contains) {
                    return dom.contains(child);
                } else if (dom.compareDocumentPosition) {
                    return !!(dom.compareDocumentPosition(child) &amp; 16);
                } else {
                    while ((child = child.parentNode)) {
                        ret = child === dom || ret;
                    }
                }
            }
            return ret;
        },

        isPainted: (function() {
            return !Ext.browser.is.IE ? function() {
                var dom = this.dom;
                return Boolean(dom &amp;&amp; dom.offsetParent);
            } : function() {
                var dom = this.dom;
                return Boolean(dom &amp;&amp; (dom.offsetHeight !== 0 &amp;&amp; dom.offsetWidth !== 0));
            };
        })(),

<span id='Ext-dom-Element-method-isScrollable'>        /**
</span>         * Returns true if this element is scrollable.
         * @return {Boolean}
         */
        isScrollable: function() {
            var dom = this.dom;
            return dom.scrollHeight &gt; dom.clientHeight || dom.scrollWidth &gt; dom.clientWidth;
        },

<span id='Ext-dom-Element-method-isStyle'>        /**
</span>         * Checks if the current value of a style is equal to a given value.
         * @param {String} style property whose value is returned.
         * @param {String} value to check against.
         * @return {Boolean} `true` for when the current value equals the given value.
         */
        isStyle: function(style, val) {
            return this.getStyle(style) === val;
        },

<span id='Ext-dom-Element-method-isVisible'>        /**
</span>         * Checks whether the element is currently visible using both visibility and display properties.
         * @param {Boolean} [deep=false] True to walk the dom and see if parent elements are hidden.
         * If false, the function only checks the visibility of the element itself and it may return
         * `true` even though a parent is not visible.
         * @return {Boolean} `true` if the element is currently visible, else `false`
         */
        isVisible: function(deep) {
            var dom = this.dom,
                end;

            if (!dom) {
                return false;
            }
            if (!visFly) {
                visFly = new Ext.dom.Fly();
            }

            for (end = dom.ownerDocument.documentElement; dom !== end; dom = dom.parentNode) {
                // We&#39;re invisible if we hit a nonexistent parentNode or a document
                // fragment or computed style visibility:hidden or display:none
                if (!dom || dom.nodeType === 11 || (visFly.attach(dom)).isStyle(VISIBILITY, HIDDEN) || visFly.isStyle(DISPLAY, NONE)) {
                    return false;
                }
                // Quit now unless we are being asked to check parent nodes.
                if (!deep) {
                    break;
                }
            }

            return true;
        },

<span id='Ext-dom-Element-method-last'>        /**
</span>         * Gets the last child, skipping text nodes
         * @param {String} [selector] Find the previous sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] `true` to return a raw DOM node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The last child Ext.dom.Element (or 
         * HTMLElement if _returnDom_ is _true_).  Or null if no match is found.
         */
        last: function(selector, returnDom) {
            return this.matchNode(&#39;previousSibling&#39;, &#39;lastChild&#39;, selector, returnDom);
        },

<span id='Ext-dom-Element-cfg-listeners'>        /**
</span>         * @cfg listeners
         * @hide
         */
        matchNode: function(dir, start, selector, returnDom) {
            var dom = this.dom,
                n;

            if (!dom) {
                return null;
            }

            n = dom[start];
            while (n) {
                if (n.nodeType === 1 &amp;&amp; (!selector || Ext.fly(n, &#39;_matchNode&#39;).is(selector))) {
                    return !returnDom ? Ext.get(n) : n;
                }
                n = n[dir];
            }
            return null;
        },

<span id='Ext-dom-Element-method-monitorMouseLeave'>        /**
</span>         * Monitors this Element for the mouse leaving. Calls the function after the specified delay only if
         * the mouse was not moved back into the Element within the delay. If the mouse *was* moved
         * back in, the function is not called.
         * @param {Number} delay The delay **in milliseconds** to wait for possible mouse re-entry before calling the handler function.
         * @param {Function} handler The function to call if the mouse remains outside of this Element for the specified time.
         * @param {Object} [scope] The scope (`this` reference) in which the handler function executes. Defaults to this Element.
         * @return {Object} The listeners object which was added to this element so that monitoring can be stopped. Example usage:
         *
         *     // Hide the menu if the mouse moves out for 250ms or more
         *     this.mouseLeaveMonitor = this.menuEl.monitorMouseLeave(250, this.hideMenu, this);
         *
         *     ...
         *     // Remove mouseleave monitor on menu destroy
         *     this.mouseLeaveMonitor.destroy();
         *
         */
        monitorMouseLeave: function(delay, handler, scope) {
            var me = this,
                timer,
                listeners = {
                    mouseleave: function(e) {
                        if (Ext.isIE9m) {
                            e.enableIEAsync();
                        }
                        timer = Ext.defer(handler, delay, scope || me, [
                            e
                        ]);
                    },
                    mouseenter: function() {
                        clearTimeout(timer);
                    },
                    destroy: function() {
                        clearTimeout(timer);
                        me.un(listeners);
                    }
                };
            me.on(listeners);
            return listeners;
        },

<span id='Ext-dom-Element-method-next'>        /**
</span>         * Gets the next sibling, skipping text nodes
         * @param {String} [selector] Find the next sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] `true` to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The next sibling Ext.dom.Element (or 
         * HTMLElement if _asDom_ is _true_).  Or null if no match is found.
         */
        next: function(selector, returnDom) {
            return this.matchNode(&#39;nextSibling&#39;, &#39;nextSibling&#39;, selector, returnDom);
        },

<span id='Ext-dom-Element-method-parent'>        /**
</span>         * Gets the parent node for this element, optionally chaining up trying to match a selector
         * @param {String} [selector] Find a parent node that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] True to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The parent node (Ext.dom.Element or 
         * HTMLElement if _returnDom_ is _true_).  Or null if no match is found.
         */
        parent: function(selector, returnDom) {
            return this.matchNode(&#39;parentNode&#39;, &#39;parentNode&#39;, selector, returnDom);
        },

<span id='Ext-dom-Element-method-position'>        /**
</span>         * Initializes positioning on this element. If a desired position is not passed,
         * it will make the the element positioned relative IF it is not already positioned.
         * @param {String} [pos] Positioning to use &quot;relative&quot;, &quot;absolute&quot; or &quot;fixed&quot;
         * @param {Number} [zIndex] The zIndex to apply
         * @param {Number} [x] Set the page X position
         * @param {Number} [y] Set the page Y position
         */
        position: function(pos, zIndex, x, y) {
            var me = this;

            if (me.dom.tagName !== &#39;BODY&#39;) {
                if (!pos &amp;&amp; me.isStyle(POSITION, STATIC)) {
                    me.setStyle(POSITION, RELATIVE);
                } else if (pos) {
                    me.setStyle(POSITION, pos);
                }
                if (zIndex) {
                    me.setStyle(ZINDEX, zIndex);
                }
                if (x || y) {
                    me.setXY([x || false, y || false]);
                }
            }
        },

<span id='Ext-dom-Element-method-prev'>        /**
</span>         * Gets the previous sibling, skipping text nodes
         * @param {String} [selector] Find the previous sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] `true` to return a raw DOM node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The previous sibling (Ext.dom.Element or 
         * HTMLElement if _returnDom_ is _true_).  Or null if no match is found.
         */
        prev: function(selector, returnDom) {
            return this.matchNode(&#39;previousSibling&#39;, &#39;previousSibling&#39;, selector, returnDom);
        },

<span id='Ext-dom-Element-method-query'>        /**
</span>         * Selects child nodes based on the passed CSS selector.
         * Delegates to document.querySelectorAll. More information can be found at
         * [http://www.w3.org/TR/css3-selectors/](http://www.w3.org/TR/css3-selectors/)
         *
         * All selectors, attribute filters and pseudos below can be combined infinitely
         * in any order. For example `div.foo:nth-child(odd)[@foo=bar].bar:first` would be
         * a perfectly valid selector.
         *
         * ## Element Selectors:
         *
         * * \* any element
         * * E an element with the tag E
         * * E F All descendant elements of E that have the tag F
         * * E &gt; F or E/F all direct children elements of E that have the tag F
         * * E + F all elements with the tag F that are immediately preceded by an element with the tag E
         * * E ~ F all elements with the tag F that are preceded by a sibling element with the tag E
         *
         * ## Attribute Selectors:
         *
         * The use of @ and quotes are optional. For example, div[@foo=&#39;bar&#39;] is also a valid attribute selector.
         *
         * * E[foo] has an attribute &quot;foo&quot;
         * * E[foo=bar] has an attribute &quot;foo&quot; that equals &quot;bar&quot;
         * * E[foo^=bar] has an attribute &quot;foo&quot; that starts with &quot;bar&quot;
         * * E[foo$=bar] has an attribute &quot;foo&quot; that ends with &quot;bar&quot;
         * * E[foo*=bar] has an attribute &quot;foo&quot; that contains the substring &quot;bar&quot;
         * * E[foo%=2] has an attribute &quot;foo&quot; that is evenly divisible by 2
         * * E[foo!=bar] has an attribute &quot;foo&quot; that does not equal &quot;bar&quot;
         *
         * ## Pseudo Classes:
         *
         * * E:first-child E is the first child of its parent
         * * E:last-child E is the last child of its parent
         * * E:nth-child(n) E is the nth child of its parent (1 based as per the spec)
         * * E:nth-child(odd) E is an odd child of its parent
         * * E:nth-child(even) E is an even child of its parent
         * * E:only-child E is the only child of its parent
         * * E:checked E is an element that is has a checked attribute that is true (e.g. a radio or checkbox)
         * * E:first the first E in the resultset
         * * E:last the last E in the resultset
         * * E:nth(n) the nth E in the resultset (1 based)
         * * E:odd shortcut for :nth-child(odd)
         * * E:even shortcut for :nth-child(even)
         * * E:not(S) an E element that does not match simple selector S
         * * E:has(S) an E element that has a descendant that matches simple selector S
         * * E:next(S) an E element whose next sibling matches simple selector S
         * * E:prev(S) an E element whose previous sibling matches simple selector S
         * * E:any(S1|S2|S2) an E element which matches any of the simple selectors S1, S2 or S3//\\
         *
         * ## CSS Value Selectors:
         *
         * * E{display=none} CSS value &quot;display&quot; that equals &quot;none&quot;
         * * E{display^=none} CSS value &quot;display&quot; that starts with &quot;none&quot;
         * * E{display$=none} CSS value &quot;display&quot; that ends with &quot;none&quot;
         * * E{display*=none} CSS value &quot;display&quot; that contains the substring &quot;none&quot;
         * * E{display%=2} CSS value &quot;display&quot; that is evenly divisible by 2
         * * E{display!=none} CSS value &quot;display&quot; that does not equal &quot;none&quot;
         *
         * @param {String} selector The CSS selector.
         * @param {Boolean} [asDom=true] `false` to return an array of Ext.dom.Element
         * @return {HTMLElement[]/Ext.dom.Element[]} An Array of elements (
         * HTMLElement or Ext.dom.Element if _asDom_ is _false_) that match the selector.  
         * If there are no matches, an empty Array is returned.
         */
        query: function(selector, asDom, /* private */ single) {
            var dom = this.dom,
                results, len, nlen, node, nodes, i, j;

            if (!dom) {
                return null;
            }

            asDom = (asDom !== false);

            selector = selector.split(&quot;,&quot;);

            if (!single) {
                // only allocate the results array if the full result set is being
                // requested.  selectNode() uses the &#39;single&#39; param.
                results = [];
            }

            for (i = 0, len = selector.length; i &lt;  len; i++) {
                if (typeof selector[i] === &#39;string&#39;) {
                    if (single) {
                        // take the &quot;fast path&quot; if single was requested (selectNode)
                        node = dom.querySelector(selector[i]);
                        return asDom ? node : Ext.get(node);
                    }

                    nodes = dom.querySelectorAll(selector[i]);

                    for (j = 0, nlen = nodes.length; j &lt; nlen; j++) {
                        results.push(asDom ? nodes[j] : Ext.get(nodes[j]));
                    }
                }
            }

            return results;
        },

<span id='Ext-dom-Element-method-radioCls'>        /**
</span>         * Adds one or more CSS classes to this element and removes the same class(es) from all siblings.
         * @param {String/String[]} className The CSS class to add, or an array of classes.
         * @return {Ext.dom.Element} this
         */
        radioCls: function(className) {
            var cn = this.dom.parentNode.childNodes,
                v;

            className = Ext.isArray(className) ? className : [className];
            for (var i = 0, len = cn.length; i &lt; len; i++) {
                v = cn[i];
                if (v &amp;&amp; v.nodeType === 1) {
                    Ext.fly(v).removeCls(className);
                }
            }
            return this.addCls(className);
        },

        redraw: function() {
            var dom = this.dom,
                domStyle = dom.style;

            domStyle.display = &#39;none&#39;;
            dom.offsetHeight;
            domStyle.display = &#39;&#39;;
        },

<span id='Ext-dom-Element-method-remove'>        /**
</span>         * @inheritdoc Ext.dom.Element#destroy
         * @deprecated 5.0.0 Please use {@link #destroy} instead.
         */
        remove: function () {
            this.destroy();
        },

        removeChild: function(element) {
            this.dom.removeChild(Ext.getDom(element));

            return this;
        },

<span id='Ext-dom-Element-method-removeCls'>        /**
</span>         * Removes the given CSS class(es) from this Element.
         * @param {String/String[]} names The CSS classes to remove separated by space,
         * or an array of classes
         * @param {String} [prefix] Prefix to prepend to each class. The separator `-` will be 
         * appended to the prefix.
         * @param {String} [suffix] Suffix to append to each class. The separator `-` will be 
         * prepended to the suffix.
         * return {Ext.dom.Element} this
         */
        removeCls: function(names, prefix, suffix) {
            var me = this,
                elementData = me.getData(),
                hasNewCls, dom, map, classList, i, ln, name;

            if (!names) {
                return me;
            }

            if (!elementData.isSynchronized) {
                me.synchronize();
            }

            dom = me.dom;
            map = elementData.classMap;
            classList = elementData.classList;

            prefix = prefix ? prefix + SEPARATOR : &#39;&#39;;
            suffix = suffix ? SEPARATOR + suffix : &#39;&#39;;

            if (typeof names === &#39;string&#39;) {
                names = names.split(spacesRe);
            }

            for (i = 0, ln = names.length; i &lt; ln; i++) {
                name = names[i];
                if (name) {
                    name = prefix + name + suffix;

                    if (map[name]) {
                        delete map[name];
                        Ext.Array.remove(classList, name);
                        hasNewCls = true;
                    }
                }
            }

            if (hasNewCls) {
                dom.className = classList.join(&#39; &#39;);
            }

            return me;
        },

<span id='Ext-dom-Element-method-repaint'>        /**
</span>         * Forces the browser to repaint this element.
         * @return {Ext.dom.Element} this
         */
        repaint: function() {
            var me = this;
            me.addCls(Ext.baseCSSPrefix + &#39;repaint&#39;);
            Ext.defer(function() {
                if(me.dom) {  //may have been removed already on slower UAs
                    Ext.fly(me.dom).removeCls(Ext.baseCSSPrefix + &#39;repaint&#39;);
                }
            }, 1);
            return me;
        },

<span id='Ext-dom-Element-method-replace'>        /**
</span>         * Replaces the passed element with this element
         * @param {String/HTMLElement/Ext.dom.Element} el The element to replace.
         * The id of the node, a DOM Node or an existing Element.
         * @param {Boolean} [destroy=true] `false` to prevent destruction of the replaced
         * element
         * @return {Ext.dom.Element} This element
         */
        replace: function(el, destroy) {
            el = Ext.getDom(el);
            var parentNode = el.parentNode,
                id = el.id,
                dom = this.dom;

            //&lt;debug&gt;
            if (!parentNode) {
                Ext.raise(&#39;Cannot replace element &quot;&#39; + id +
                    &#39;&quot;. It is not attached to a parent node.&#39;);
            }
            //&lt;/debug&gt;

            if (destroy !== false &amp;&amp; id &amp;&amp; Ext.cache[id]) {
                parentNode.insertBefore(dom, el);
                Ext.get(el).destroy();
            } else {
                parentNode.replaceChild(dom, el);
            }

            return this;
        },

<span id='Ext-dom-Element-method-replaceCls'>        /**
</span>         * Replaces a CSS class on the element with another.
         * If the old name does not exist, the new name will simply be added.
         * @param {String} oldName The CSS class to replace.
         * @param {String} newName The replacement CSS class.
         * @param {String} [prefix=&#39;&#39;] Prefix to prepend to each class to be replaced.
         * @param {String} [suffix=&#39;&#39;] Suffix to append to each class to be replaced.
         * @return {Ext.dom.Element} this
         */
        replaceCls: function(oldName, newName, prefix, suffix) {
            var me = this,
                dom, map, classList, i, ln, name,
                elementData = me.getData(),
                change;

            if (!oldName &amp;&amp; !newName) {
                return me;
            }

            oldName = oldName || [];
            newName = newName || [];

            if (!elementData.isSynchronized) {
                me.synchronize();
            }

            if (!suffix) {
                suffix = &#39;&#39;;
            }

            dom = me.dom;
            map = elementData.classMap;
            classList = elementData.classList;

            prefix = prefix ? prefix + SEPARATOR : &#39;&#39;;
            suffix = suffix ? SEPARATOR + suffix : &#39;&#39;;

            if (typeof oldName === &#39;string&#39;) {
                oldName = oldName.split(spacesRe);
            }
            if (typeof newName === &#39;string&#39;) {
                newName = newName.split(spacesRe);
            }

            for (i = 0, ln = oldName.length; i &lt; ln; i++) {
                name = prefix + oldName[i] + suffix;

                if (map[name]) {
                    delete map[name];
                    change = true;
                }
            }

            for (i = 0, ln = newName.length; i &lt; ln; i++) {
                name = prefix + newName[i] + suffix;

                if (!map[name]) {
                    map[name] = true;
                    change = true;
                }
            }

            if (change) {
                elementData.classList = classList = Ext.Object.getKeys(map);
                dom.className = classList.join(&#39; &#39;);
            }

            return me;
        },

<span id='Ext-dom-Element-method-replaceWith'>        /**
</span>         * Replaces this element with the passed element
         * @param {String/HTMLElement/Ext.dom.Element/Object} el The new element (id of the
         * node, a DOM Node or an existing Element) or a DomHelper config of an element to create
         * @return {Ext.dom.Element} This element
         */
        replaceWith: function(el){
            var me = this,
                dom = me.dom,
                parent = dom.parentNode,
                cache = Ext.cache,
                newDom;

            me.clearListeners();

            if (el.nodeType || el.dom || typeof el === &#39;string&#39;) {
                el = Ext.get(el);
                newDom = parent.insertBefore(el.dom, dom);
            } else {
                // domhelper config
                newDom = Ext.DomHelper.insertBefore(dom, el);
            }
            parent.removeChild(dom);

            me.dom = newDom;
            if (!me.isFly) {
                delete cache[me.id];
                cache[me.id = Ext.id(newDom)] = me;
            }

            return me;
        },

        resolveListenerScope: function (defaultScope) {
            // Override this to pass along to our owning component (if we have one).
            var component = this.component;
            return component ? component.resolveListenerScope(defaultScope) : this;
        },

<span id='Ext-dom-Element-method-scroll'>        /**
</span>         * Scrolls this element the specified direction. Does bounds checking to make sure the scroll is
         * within this element&#39;s scrollable range.
         * @param {String} direction Possible values are:
         *
         * - `&quot;l&quot;` (or `&quot;left&quot;`)
         * - `&quot;r&quot;` (or `&quot;right&quot;`)
         * - `&quot;t&quot;` (or `&quot;top&quot;`, or `&quot;up&quot;`)
         * - `&quot;b&quot;` (or `&quot;bottom&quot;`, or `&quot;down&quot;`)
         *
         * @param {Number} distance How far to scroll the element in pixels
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @return {Boolean} Returns true if a scroll was triggered or false if the element
         * was scrolled as far as it could go.
         */
        scroll: function(direction, distance, animate) {
            if (!this.isScrollable()) {
                return false;
            }

            // Allow full word, or initial to be sent.
            // (Ext.dd package uses full word)
            direction = direction.charAt(0);
            var me = this,
                dom = me.dom,
                side = direction === &#39;r&#39; || direction === &#39;l&#39; ? &#39;left&#39; : &#39;top&#39;,
                scrolled = false,
                currentScroll, constrainedScroll;

            if (direction === &#39;l&#39; || direction === &#39;t&#39; || direction === &#39;u&#39;) {
                distance = -distance;
            }

            if (side === &#39;left&#39;) {
                currentScroll = dom.scrollLeft;
                constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
            } else {
                currentScroll = dom.scrollTop;
                constrainedScroll = me.constrainScrollTop(currentScroll + distance);
            }

            if (constrainedScroll !== currentScroll) {
                this.scrollTo(side, constrainedScroll, animate);
                scrolled = true;
            }

            return scrolled;
        },

<span id='Ext-dom-Element-method-scrollBy'>        /**
</span>         * Scrolls this element by the passed delta values, optionally animating.
         *
         * All of the following are equivalent:
         *
         *      el.scrollBy(10, 10, true);
         *      el.scrollBy([10, 10], true);
         *      el.scrollBy({ x: 10, y: 10 }, true);
         *
         * @param {Number/Number[]/Object} deltaX Either the x delta, an Array specifying x and y deltas or
         * an object with &quot;x&quot; and &quot;y&quot; properties.
         * @param {Number/Boolean/Object} deltaY Either the y delta, or an animate flag or config object.
         * @param {Boolean/Object} animate Animate flag/config object if the delta values were passed separately.
         * @return {Ext.dom.Element} this
         */
        scrollBy: function(deltaX, deltaY, animate) {
            var me = this,
                dom = me.dom;

            // Extract args if deltas were passed as an Array.
            if (deltaX.length) {
                animate = deltaY;
                deltaY = deltaX[1];
                deltaX = deltaX[0];
            } else if (typeof deltaX != &#39;number&#39;) { // or an object
                animate = deltaY;
                deltaY = deltaX.y;
                deltaX = deltaX.x;
            }

            if (deltaX) {
                me.scrollTo(&#39;left&#39;, me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
            }
            if (deltaY) {
                me.scrollTo(&#39;top&#39;, me.constrainScrollTop(dom.scrollTop + deltaY), animate);
            }

            return me;
        },

<span id='Ext-dom-Element-method-scrollChildIntoView'>        /**
</span>         * @private
         */
        scrollChildIntoView: function(child, hscroll) {
            // scrollFly is used inside scrollInfoView, must use a method-unique fly here
            Ext.fly(child).scrollIntoView(this, hscroll);
        },

<span id='Ext-dom-Element-method-scrollIntoView'>        /**
</span>         * Scrolls this element into view within the passed container.
         *
         *       Ext.create(&#39;Ext.data.Store&#39;, {
         *           storeId:&#39;simpsonsStore&#39;,
         *           fields:[&#39;name&#39;, &#39;email&#39;, &#39;phone&#39;],
         *           data:{&#39;items&#39;:[
         *               { &#39;name&#39;: &#39;Lisa&#39;,  &quot;email&quot;:&quot;lisa@simpsons.com&quot;,  &quot;phone&quot;:&quot;555-111-1224&quot;  },
         *               { &#39;name&#39;: &#39;Bart&#39;,  &quot;email&quot;:&quot;bart@simpsons.com&quot;,  &quot;phone&quot;:&quot;555-222-1234&quot; },
         *               { &#39;name&#39;: &#39;Homer&#39;, &quot;email&quot;:&quot;homer@simpsons.com&quot;,  &quot;phone&quot;:&quot;555-222-1244&quot;  },
         *               { &#39;name&#39;: &#39;Marge&#39;, &quot;email&quot;:&quot;marge@simpsons.com&quot;, &quot;phone&quot;:&quot;555-222-1254&quot;  },
         *               { &#39;name&#39;: &#39;Milhouse&#39;, &quot;email&quot;:&quot;milhouse@simpsons.com&quot;,  &quot;phone&quot;:&quot;555-222-1244&quot;  },
         *               { &#39;name&#39;: &#39;Willy&#39;, &quot;email&quot;:&quot;willy@simpsons.com&quot;, &quot;phone&quot;:&quot;555-222-1254&quot;  },
         *               { &#39;name&#39;: &#39;Skinner&#39;, &quot;email&quot;:&quot;skinner@simpsons.com&quot;,  &quot;phone&quot;:&quot;555-222-1244&quot;  },
         *               { &#39;name&#39;: &#39;Hank (last row)&#39;, &quot;email&quot;:&quot;hank@simpsons.com&quot;, &quot;phone&quot;:&quot;555-222-1254&quot;  }
         *           ]},
         *           proxy: {
         *               type: &#39;memory&#39;,
         *               reader: {
         *                   type: &#39;json&#39;,
         *                   rootProperty: &#39;items&#39;
         *               }
         *           }
         *       });
         *
         *       var grid = Ext.create(&#39;Ext.grid.Panel&#39;, {
         *           title: &#39;Simpsons&#39;,
         *           store: Ext.data.StoreManager.lookup(&#39;simpsonsStore&#39;),
         *           columns: [
         *               { text: &#39;Name&#39;,  dataIndex: &#39;name&#39;, width: 125 },
         *               { text: &#39;Email&#39;, dataIndex: &#39;email&#39;, flex: 1 },
         *               { text: &#39;Phone&#39;, dataIndex: &#39;phone&#39; }
         *           ],
         *           height: 190,
         *           width: 400,
         *           renderTo: Ext.getBody(),
         *           tbar: [{
         *               text: &#39;Scroll row 7 into view&#39;,
         *               handler: function () {
         *                   var view = grid.getView();
         *
         *                   Ext.get(view.getRow(7)).scrollIntoView(view.getEl(), null, true);
         *               }
         *           }]
         *       });
         *
         * @param {String/HTMLElement/Ext.Element} [container=document.body] The container element
         * to scroll.  Should be a string (id), dom node, or Ext.Element.
         * @param {Boolean} [hscroll=true] False to disable horizontal scroll.
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @param {Boolean} [highlight=false] true to {@link #highlight} the element when it is in view.
         * @return {Ext.dom.Element} this
         */
        scrollIntoView: function(container, hscroll, animate, highlight) {
            container = Ext.getDom(container) || Ext.getBody().dom;

            return this.doScrollIntoView(
                container,
                hscroll,
                animate,
                highlight,
                &#39;getScrollLeft&#39;,
                &#39;scrollTo&#39;
            );
        },

<span id='Ext-dom-Element-method-scrollTo'>        /**
</span>         * Scrolls this element the specified scroll point. It does NOT do bounds checking so
         * if you scroll to a weird value it will try to do it. For auto bounds checking, use #scroll.
         * @param {String} side Either &quot;left&quot; for scrollLeft values or &quot;top&quot; for scrollTop values.
         * @param {Number} value The new scroll value
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @return {Ext.dom.Element} this
         */
        scrollTo: function(side, value, animate) {
            //check if we&#39;re scrolling top or left
            var top = topRe.test(side),
                me = this,
                prop = top ? &#39;scrollTop&#39; : &#39;scrollLeft&#39;,
                dom = me.dom,
                animCfg;

            if (!animate || !me.anim) {
                // just setting the value, so grab the direction
                dom[prop] = value;
                // corrects IE, other browsers will ignore
                dom[prop] = value;
            } else {
                animCfg = {
                    to: {}
                };
                animCfg.to[prop] = value;
                if (Ext.isObject(animate)) {
                    Ext.applyIf(animCfg, animate);
                }
                me.animate(animCfg);
            }
            return me;
        },

<span id='Ext-dom-Element-method-select'>        /**
</span>         * Selects descendant elements of this element based on the passed CSS selector to
         * enable {@link Ext.dom.Element Element} methods to be applied to many related
         * elements in one statement through the returned
         * {@link Ext.dom.CompositeElementLite CompositeElementLite} object.
         *
         * @param {String/HTMLElement[]} selector The CSS selector or an array of elements
         * @param {Boolean} composite Return a CompositeElement as opposed to a
         * CompositeElementLite. Defaults to false.
         * @return {Ext.dom.CompositeElementLite/Ext.dom.CompositeElement}
         */
        select: function(selector, composite) {
            var isElementArray, elements;

            if (typeof selector === &quot;string&quot;) {
                elements = this.query(selector, !composite);
            }
            //&lt;debug&gt;
            else if (selector.length === undefined) {
                Ext.raise(&quot;Invalid selector specified: &quot; + selector);
            }
            //&lt;/debug&gt;
            else {
                // if selector is not a string, assume it is already an array of
                // HTMLElement
                elements = selector;
                isElementArray = true;
            }

            // if the selector parameter was a string we will have called through
            // to query, and it will have constructed either an array of
            // HTMLElement or Ext.Element, depending on the composite param we gave
            // it.  If this is the case we can take the fast path through the 
            // CompositeElementLite constructor to avoid calling getDom() or get()
            // on every element in the array.
            return composite ? new Ext.CompositeElement(elements, !isElementArray) :
                new Ext.CompositeElementLite(elements, true);
        },

<span id='Ext-dom-Element-method-selectNode'>        /**
</span>         * Selects a single descendant element of this element using a CSS selector
         * (see {@link #query}).
         * @param {String} selector The selector query
         * @param {Boolean} [asDom=true] `false` to return an Ext.dom.Element
         * @return {HTMLElement/Ext.dom.Element} The DOM element (or Ext.dom.Element if 
         * _asDom_ is _false_) which matched the selector.
         */
        selectNode: function(selector, asDom) {
            return this.query(selector, asDom, true);
        },

<span id='Ext-dom-Element-method-set'>        /**
</span>         * Sets the passed attributes as attributes of this element (a `style` attribute 
         * can be a string, object or function).
         * 
         * Example component (though any Ext.dom.Element would suffice):
         * 
         *     var cmp = Ext.create({
         *         xtype: &#39;component&#39;,
         *         html: &#39;test&#39;,
         *         renderTo: Ext.getBody()
         *     });
         * 
         * Once the component is rendered, you can fetch a reference to its outer 
         * element to use `set`:
         * 
         *     cmp.el.set({
         *         foo: &#39;bar&#39;
         *     });
         * 
         * This sets an attribute on the element of **foo=&quot;bar&quot;**:
         * 
         *     &lt;div class=&quot;x-component x-component-default x-border-box&quot; id=&quot;component-1009&quot; foo=&quot;bar&quot;&gt;test&lt;/div&gt;
         * 
         * To remove the attribute pass a value of **undefined**:
         * 
         *     cmp.el.set({
         *         foo: undefined
         *     });
         * 
         * **Note:**
         * 
         *  - You cannot remove an attribute by passing `undefined` when the 
         * `expandos` param is set to **false**.
         *  - Passing an attribute of `style` results in the request being handed off to 
         * {@link #method-applyStyles}.
         *  - Passing an attribute of `cls` results in the element&#39;s dom&#39;s 
         * [className](http://www.w3schools.com/jsref/prop_html_classname.asp) property 
         * being set directly.  For additional flexibility when setting / removing 
         * classes see: 
         *     - {@link #method-addCls}
         *     - {@link #method-removeCls}
         *     - {@link #method-replaceCls}
         *     - {@link #method-setCls}
         *     - {@link #method-toggleCls}
         * 
         * @param {Object} attributes The object with the attributes.
         * @param {Boolean} [useSet=true] `false` to override the default `setAttribute` 
         * to use [expandos](http://help.dottoro.com/ljvovanq.php).
         * @return {Ext.dom.Element} this
         */
        set: function(attributes, useSet) {
            var me = this,
                dom = me.dom,
                attribute, value;

            for (attribute in attributes) {
                if (attributes.hasOwnProperty(attribute)) {
                    value = attributes[attribute];

                    if (attribute === &#39;style&#39;) {
                        me.applyStyles(value);
                    }
                    else if (attribute === &#39;cls&#39;) {
                        dom.className = value;
                    }
                    else if (useSet !== false) {
                        if (value === undefined) {
                            dom.removeAttribute(attribute);
                        } else {
                            dom.setAttribute(attribute, value);
                        }
                    }
                    else {
                        dom[attribute] = value;
                    }
                }
            }

            return me;
        },

<span id='Ext-dom-Element-method-setBottom'>        /**
</span>         * Sets the element&#39;s CSS bottom style.
         * @param {Number/String} bottom Number of pixels or CSS string value to set as
         * the bottom CSS property value
         * @return {Ext.dom.Element} this
         */
        setBottom: function(bottom) {
            this.dom.style[BOTTOM] = Element.addUnits(bottom);
            return this;
        },

<span id='Ext-dom-Element-method-setCls'>        /**
</span>         * Sets the specified CSS class on this element&#39;s DOM node.
         * @param {String/String[]} className The CSS class to set on this element.
         */
        setCls: function(className) {
            var me = this,
                elementData = me.getData(),
                i, ln, name, map, classList;

            if (!elementData.isSynchronized) {
                me.synchronize();
            }

            if (typeof className === &#39;string&#39;) {
                className = className.split(spacesRe);
            }

            elementData.classList = classList = className.slice();
            elementData.classMap = map = {};

            for (i = 0, ln = classList.length; i &lt; ln; i++) {
                map[classList[i]] = true;
            }
            me.dom.className = classList.join(&#39; &#39;);
        },

<span id='Ext-dom-Element-method-setDisplayed'>        /**
</span>         * Sets the CSS display property. Uses originalDisplay if the specified value is a
         * boolean true.
         * @param {Boolean/String} value Boolean value to display the element using its
         * default display, or a string to set the display directly.
         * @return {Ext.dom.Element} this
         */
        setDisplayed: function(value) {
            var me = this;

            if (typeof value === &quot;boolean&quot;){
                value = value ? me._getDisplay() : NONE;
            }
            me.setStyle(DISPLAY, value);

            if (me.shadow || me.shim) {
                me.setUnderlaysVisible(value !== NONE);
            }

            return me;
        },

<span id='Ext-dom-Element-method-setHeight'>        /**
</span>         * Set the height of this Element.
         * @param {Number/String} height The new height.
         * @return {Ext.dom.Element} this
         */
        setHeight: function(height) {
            var me = this;

            me.dom.style[HEIGHT] = Element.addUnits(height);

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

<span id='Ext-dom-Element-method-setHtml'>        /**
</span>         * Sets the `innerHTML` of this element.
         * @param {String} html The new HTML.
         * @return {Ext.dom.Element} this
         */
        setHtml: function(html) {
            if (this.dom) {
                this.dom.innerHTML = html;
            }
            return this;
        },

        setId: function(id) {
            var me = this,
                currentId = me.id,
                cache = Ext.cache;

            if (currentId) {
                delete cache[currentId];
            }

            me.dom.id = id;

<span id='Ext-dom-Element-property-id'>            /**
</span>             * The DOM element ID
             * @property id
             * @type String
             */
            me.id = id;

            cache[id] = me;

            return me;
        },

<span id='Ext-dom-Element-method-setLeft'>        /**
</span>         * Sets the element&#39;s left position directly using CSS style
         * (instead of {@link #setX}).
         * @param {Number/String} left Number of pixels or CSS string value to
         * set as the left CSS property value
         * @return {Ext.dom.Element} this
         */
        setLeft: function(left) {
            var me = this;

            me.dom.style[LEFT] = Element.addUnits(left);

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

        setLocalX: function(x) {
            var me = this,
                style = me.dom.style;

            // clear right style just in case it was previously set by rtlSetLocalXY
            style.right = &#39;auto&#39;;
            style.left = (x === null) ? &#39;auto&#39; : x + &#39;px&#39;;

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

        setLocalXY: function(x, y) {
            var me = this,
                style = me.dom.style;

            // clear right style just in case it was previously set by rtlSetLocalXY
            style.right = &#39;auto&#39;;

            if (x &amp;&amp; x.length) {
                y = x[1];
                x = x[0];
            }

            if (x === null) {
                style.left = &#39;auto&#39;;
            } else if (x !== undefined) {
                style.left = x + &#39;px&#39;;
            }

            if (y === null) {
                style.top = &#39;auto&#39;;
            } else if (y !== undefined) {
                style.top = y + &#39;px&#39;;
            }

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

        setLocalY: function(y) {
            var me = this;

            me.dom.style.top = (y === null) ? &#39;auto&#39; : y + &#39;px&#39;;

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

        setMargin: function(margin) {
            var me = this,
                domStyle = me.dom.style;

            if (margin || margin === 0) {
                margin = me.self.unitizeBox((margin === true) ? 5 : margin);
                domStyle.setProperty(&#39;margin&#39;, margin, &#39;important&#39;);
            }
            else {
                domStyle.removeProperty(&#39;margin-top&#39;);
                domStyle.removeProperty(&#39;margin-right&#39;);
                domStyle.removeProperty(&#39;margin-bottom&#39;);
                domStyle.removeProperty(&#39;margin-left&#39;);
            }
        },

<span id='Ext-dom-Element-method-setMaxHeight'>        /**
</span>         * Set the maximum height of this Element.
         * @param {Number/String} height The new maximum height.
         * @return {Ext.dom.Element} this
         */
        setMaxHeight: function(height) {
            this.dom.style[MAX_HEIGHT] = Element.addUnits(height);
            return this;
        },

<span id='Ext-dom-Element-method-setMaxWidth'>        /**
</span>         * Set the maximum width of this Element.
         * @param {Number/String} width The new maximum width.
         * @return {Ext.dom.Element} this
         */
        setMaxWidth: function(width) {
            this.dom.style[MAX_WIDTH] = Element.addUnits(width);
            return this;
        },

<span id='Ext-dom-Element-method-setMinHeight'>        /**
</span>         * Set the minimum height of this Element.
         * @param {Number/String} height The new minimum height.
         * @return {Ext.dom.Element} this
         */
        setMinHeight: function(height) {
            this.dom.style[MIN_HEIGHT] = Element.addUnits(height);
            return this;
        },

<span id='Ext-dom-Element-method-setMinWidth'>        /**
</span>         * Set the minimum width of this Element.
         * @param {Number/String} width The new minimum width.
         * @return {Ext.dom.Element} this
         */
        setMinWidth: function(width) {
            this.dom.style[MIN_WIDTH] = Element.addUnits(width);
            return this;
        },

<span id='Ext-dom-Element-method-setOpacity'>        /**
</span>         * Set the opacity of the element
         * @param {Number} opacity The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
         * @return {Ext.dom.Element} this
         */
        setOpacity: function(opacity) {
            var me = this;

            if (me.dom) {
                me.setStyle(&#39;opacity&#39;, opacity);
            }

            return me;
        },

        setPadding: function(padding) {
            var me = this,
                domStyle = me.dom.style;

            if (padding || padding === 0) {
                padding = me.self.unitizeBox((padding === true) ? 5 : padding);
                domStyle.setProperty(&#39;padding&#39;, padding, &#39;important&#39;);
            }
            else {
                domStyle.removeProperty(&#39;padding-top&#39;);
                domStyle.removeProperty(&#39;padding-right&#39;);
                domStyle.removeProperty(&#39;padding-bottom&#39;);
                domStyle.removeProperty(&#39;padding-left&#39;);
            }
        },

<span id='Ext-dom-Element-method-setRight'>        /**
</span>         * Sets the element&#39;s CSS right style.
         * @param {Number/String} right Number of pixels or CSS string value to
         * set as the right CSS property value
         * @return {Ext.dom.Element} this
         */
        setRight: function(right) {
            this.dom.style[RIGHT] = Element.addUnits(right);
            return this;
        },

<span id='Ext-dom-Element-method-setScrollLeft'>        /**
</span>         * Sets the left scroll position
         * @param {Number} left The left scroll position
         * @return {Ext.dom.Element} this
         */
        setScrollLeft: function(left) {
            this.dom.scrollLeft = left;
            return this;
        },

<span id='Ext-dom-Element-method-setScrollTop'>        /**
</span>         * Sets the top scroll position
         * @param {Number} top The top scroll position
         * @return {Ext.dom.Element} this
         */
        setScrollTop: function(top) {
            this.dom.scrollTop = top;
            return this;
        },

<span id='Ext-dom-Element-method-setSize'>        /**
</span>         * Set the size of this Element.
         *
         * @param {Number/String} width The new width. This may be one of:
         *
         * - A Number specifying the new width in pixels.
         * - A String used to set the CSS width style. Animation may **not** be used.
         * - A size object in the format `{width: widthValue, height: heightValue}`.
         *
         * @param {Number/String} height The new height. This may be one of:
         *
         * - A Number specifying the new height in pixels.
         * - A String used to set the CSS height style. Animation may **not** be used.
         * @return {Ext.dom.Element} this
         */
        setSize: function(width, height) {
            var me = this,
                style = me.dom.style;

            if (Ext.isObject(width)) {
                // in case of object from getSize()
                height = width.height;
                width = width.width;
            }

            style.width = Element.addUnits(width);
            style.height = Element.addUnits(height);

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

        setSizeState: function(state) {
            var me = this,
                add, remove;

            if (state === true) {
                add = sizedCls;
                remove = [unsizedCls, stretchedCls];
            } else if (state === false) {
                add = unsizedCls;
                remove = [sizedCls, stretchedCls];
            } else if (state === null) {
                add = stretchedCls;
                remove = [sizedCls, unsizedCls];
            } else {
                remove = [sizedCls, unsizedCls, stretchedCls];
            }

            if (add) {
                me.addCls(add);
            }
            me.removeCls(remove);
            return me;
        },

<span id='Ext-dom-Element-method-setStyle'>        /**
</span>         * Wrapper for setting style properties, also takes single object parameter of 
         * multiple styles.
         * 
         * Styles should be a valid DOM element style property.  
         * [Valid style property names](http://www.w3schools.com/jsref/dom_obj_style.asp) 
         * (_along with the supported CSS version for each_)
         * 
         *     // &lt;div id=&quot;my-el&quot;&gt;Phineas Flynn&lt;/div&gt;
         *     
         *     var el = Ext.get(&#39;my-el&#39;);
         *     
         *     // two-param syntax
         *     el.setStyle(&#39;color&#39;, &#39;white&#39;);
         *     
         *     // single-param syntax
         *     el.setStyle({
         *         fontWeight: &#39;bold&#39;,
         *         backgroundColor: &#39;gray&#39;,
         *         padding: &#39;10px&#39;
         *     });
         * 
         * @param {String/Object} property The style property to be set, or an object of 
         * multiple styles.
         * @param {String} [value] The value to apply to the given property, or null if 
         * an object was passed.
         * @return {Ext.dom.Element} this
         */
        setStyle: function(prop, value) {
            var me = this,
                dom = me.dom,
                hooks = me.styleHooks,
                style = dom.style,
                name = prop,
                hook;

            // we don&#39;t promote the 2-arg form to object-form to avoid the overhead...
            if (typeof name === &#39;string&#39;) {
                hook = hooks[name];
                if (!hook) {
                    hooks[name] = hook = { name: Element.normalize(name) };
                }
                value = (value == null) ? &#39;&#39; : value; // map null &amp;&amp; undefined to &#39;&#39;
                if (hook.set) {
                    hook.set(dom, value, me);
                } else {
                    style[hook.name] = value;
                }
                if (hook.afterSet) {
                    hook.afterSet(dom, value, me);
                }
            } else {
                for (name in prop) {
                    if (prop.hasOwnProperty(name)) {
                        hook = hooks[name];
                        if (!hook) {
                            hooks[name] = hook = { name: Element.normalize(name) };
                        }
                        value = prop[name];
                        value = (value == null) ? &#39;&#39; : value; // map null &amp;&amp; undefined to &#39;&#39;
                        if (hook.set) {
                            hook.set(dom, value, me);
                        } else {
                            style[hook.name] = value;
                        }
                        if (hook.afterSet) {
                            hook.afterSet(dom, value, me);
                        }
                    }
                }
            }

            return me;
        },

        setText: function(text) {
            this.dom.textContent = text;
        },

<span id='Ext-dom-Element-method-setTop'>        /**
</span>         * Sets the element&#39;s top position directly using CSS style
         * (instead of {@link #setY}).
         * @param {Number/String} top Number of pixels or CSS string value to
         * set as the top CSS property value
         * @return {Ext.dom.Element} this
         */
        setTop: function(top) {
            var me = this;

            me.dom.style[TOP] = Element.addUnits(top);

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

<span id='Ext-dom-Element-method-setTouchAction'>        /**
</span>         * Sets the CSS {@link https://www.w3.org/TR/pointerevents/#the-touch-action-css-property touch-action}
         * property on this element and emulates its behavior on browsers where touch-action
         * is not supported.
         *
         * @param {Object} touchAction An object with touch-action names as the keys, and
         * boolean values to enable or disable specific touch actions. Accepted keys are:
         *
         * - `panX`
         * - `panY`
         * - `pinchZoom`
         * - `doubleTapZoom`
         *
         * All touch actions are enabled (`true`) by default, so it is usually only necessary
         * to specify which touch actions to disable.  For example, the following disables
         * only vertical scrolling and double-tap-zoom on an element
         *
         *     element.setTouchAction({
         *         panY: false,
         *         doubleTapZoom: false
         *     });
         *
         * @return {Ext.dom.Element} this
         */
        setTouchAction: function(touchAction) {
            Ext.dom.TouchAction.set(this.dom, touchAction);
        },

        setUnderlaysVisible: function(visible) {
            var shadow = this.shadow,
                shim = this.shim;

            if (shadow &amp;&amp; !shadow.disabled) {
                if (visible) {
                    shadow.show();
                } else {
                    shadow.hide();
                }
            }

            if (shim &amp;&amp; !shim.disabled) {
                if (visible) {
                    shim.show();
                } else {
                    shim.hide();
                }
            }
        },

<span id='Ext-dom-Element-method-setVisibility'>        /**
</span>         * @private
         */
        setVisibility: function(isVisible) {
            var domStyle = this.dom.style;

            if (isVisible) {
                domStyle.removeProperty(&#39;visibility&#39;);
            }
            else {
                domStyle.setProperty(&#39;visibility&#39;, &#39;hidden&#39;, &#39;important&#39;);
            }
        },

<span id='Ext-dom-Element-method-setVisibilityMode'>        /**
</span>         * Use this to change the visibility mode between {@link #VISIBILITY}, 
         * {@link #DISPLAY}, {@link #OFFSETS}, or {@link #CLIP}.
         *
         * @param {Ext.dom.Element.VISIBILITY/Ext.dom.Element.DISPLAY/Ext.dom.Element.OFFSETS/Ext.dom.Element.CLIP} mode
         * The method by which the element will be {@link #hide hidden} (you can
         * also use the {@link #setVisible} or {@link #toggle} method to toggle element 
         * visibility).
         *
         * @return {Ext.dom.Element} this
         */
        setVisibilityMode: function(mode) {
            //&lt;debug&gt;
            if (mode !== 1 &amp;&amp; mode !== 2 &amp;&amp; mode !== 3 &amp;&amp; mode !== 4) {
                Ext.raise(&quot;visibilityMode must be one of the following: &quot; +
                    &quot;Ext.Element.DISPLAY, Ext.Element.VISIBILITY, Ext.Element.OFFSETS, &quot; +
                    &quot;or Ext.Element.CLIP&quot;);
            }
            //&lt;/debug&gt;
            this.getData().visibilityMode = mode;
            return this;
        },

<span id='Ext-dom-Element-method-setVisible'>        /**
</span>         * Sets the visibility of the element based on the current visibility mode. Use
         * {@link #setVisibilityMode} to switch between the following visibility modes:
         *
         * - {@link #DISPLAY} (the default)
         * - {@link #VISIBILITY}
         * - {@link #OFFSETS}
         * - {@link #CLIP}
         *
         * @param {Boolean} visible Whether the element is visible.
         * @return {Ext.dom.Element} this
         */
        setVisible: function(visible) {
            var me = this,
                mode = me.getVisibilityMode(),
                addOrRemove = visible ? &#39;removeCls&#39; : &#39;addCls&#39;;

            switch (mode) {
                case Element.DISPLAY:
                    me.removeCls([visibilityCls, offsetsCls, clipCls]);
                    me[addOrRemove](displayCls);
                    break;

                case Element.VISIBILITY:
                    me.removeCls([displayCls, offsetsCls, clipCls]);
                    me[addOrRemove](visibilityCls);
                    break;

                case Element.OFFSETS:
                    me.removeCls([visibilityCls, displayCls, clipCls]);
                    me[addOrRemove](offsetsCls);
                    break;
                
                case Element.CLIP:
                    me.removeCls([visibilityCls, displayCls, offsetsCls]);
                    me[addOrRemove](clipCls);
                    break;
            }

            if (me.shadow || me.shim) {
                me.setUnderlaysVisible(visible);
            }

            return me;
        },

<span id='Ext-dom-Element-method-setWidth'>        /**
</span>         * Set the width of this Element.
         * @param {Number/String} width The new width.
         * @return {Ext.dom.Element} this
         */
        setWidth: function(width) {
            var me = this;

            me.dom.style[WIDTH] = Element.addUnits(width);

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

<span id='Ext-dom-Element-method-setX'>        /**
</span>         * Sets this Element&#39;s page-level x coordinate
         * @param {Number} x
         * @return {Ext.dom.Element} this
         */
        setX: function(x) {
            return this.setXY([x, false]);
        },

<span id='Ext-dom-Element-method-setXY'>        /**
</span>         * Sets this Element&#39;s page-level x and y coordinates
         * @param {Number[]} xy
         * @return {Ext.dom.Element} this
         */
        setXY: function(xy) {
            var me = this,
                pts = me.translatePoints(xy),
                style = me.dom.style,
                pos;

            me.position();

            // right position may have been previously set by rtlSetLocalXY 
            // so clear it here just in case.
            style.right = &#39;auto&#39;;
            for (pos in pts) {
                if (!isNaN(pts[pos])) {
                    style[pos] = pts[pos] + &#39;px&#39;;
                }
            }

            if (me.shadow || me.shim) {
                me.syncUnderlays();
            }

            return me;
        },

<span id='Ext-dom-Element-method-setY'>        /**
</span>         * Sets this Element&#39;s page-level y coordinate
         * @param {Number} y
         * @return {Ext.dom.Element} this
         */
        setY: function(y) {
            return this.setXY([false, y]);
        },

<span id='Ext-dom-Element-method-setZIndex'>        /**
</span>         * Sets the z-index of this Element and synchronizes the z-index of shadow and/or
         * shim if present.
         *
         * @param {Number} zindex The new z-index to set
         * @return {Ext.dom.Element} this
         */
        setZIndex: function(zindex) {
            var me = this;

            if (me.shadow) {
                me.shadow.setZIndex(zindex);
            }

            if (me.shim) {
                me.shim.setZIndex(zindex);
            }

            return me.setStyle(&#39;z-index&#39;, zindex);
        },

<span id='Ext-dom-Element-method-show'>        /**
</span>         * Show this element - Uses display mode to determine whether to use &quot;display&quot;,
         * &quot;visibility&quot;, &quot;offsets&quot;, or &quot;clip&quot;. See {@link #setVisible}.
         *
         * @return {Ext.dom.Element} this
         */
        show: function() {
            this.setVisible(true);
            return this;
        },

<span id='Ext-dom-Element-method-swapCls'>        /**
</span>         * @private
         * @param {String} firstClass
         * @param {String} secondClass
         * @param {Boolean} flag
         * @param {String} prefix
         * @return {Mixed}
         */
        swapCls: function(firstClass, secondClass, flag, prefix) {
            if (flag === undefined) {
                flag = true;
            }

            var me = this,
                addedClass = flag ? firstClass : secondClass,
                removedClass = flag ? secondClass : firstClass;

            if (removedClass) {
                me.removeCls(prefix ? prefix + &#39;-&#39; + removedClass : removedClass);
            }

            if (addedClass) {
                me.addCls(prefix ? prefix + &#39;-&#39; + addedClass : addedClass);
            }

            return me;
        },

<span id='Ext-dom-Element-method-synchronize'>        /**
</span>         * @private
         */
        synchronize: function() {
            var me = this,
                dom = me.dom,
                hasClassMap = {},
                className = dom.className,
                classList, i, ln, name,
                elementData = me.getData();

            if (className &amp;&amp; className.length &gt; 0) {
                classList = dom.className.split(classNameSplitRegex);

                for (i = 0, ln = classList.length; i &lt; ln; i++) {
                    name = classList[i];
                    hasClassMap[name] = true;
                }
            }
            else {
                classList = [];
            }

            elementData.classList = classList;
            elementData.classMap = hasClassMap;
            elementData.isSynchronized = true;

            return me;
        },

<span id='Ext-dom-Element-method-syncUnderlays'>        /**
</span>         * @private
         */
        syncUnderlays: function() {
            var me = this,
                shadow = me.shadow,
                shim = me.shim,
                dom = me.dom,
                xy, x, y, w, h;

            if (me.isVisible()) {
                xy = me.getXY();
                x = xy[0];
                y = xy[1];
                w = dom.offsetWidth;
                h = dom.offsetHeight;

                if (shadow &amp;&amp; !shadow.hidden) {
                    shadow.realign(x, y, w, h);
                }

                if (shim &amp;&amp; !shim.hidden) {
                    shim.realign(x, y, w, h);
                }
            }
        },

<span id='Ext-dom-Element-method-toggleCls'>        /**
</span>         * Toggles the specified CSS class on this element (removes it if it already exists, otherwise adds it).
         * @param {String} className The CSS class to toggle.
         * @param {Boolean} [state] If specified as `true`, causes the class to be added. If specified as `false`, causes
         * the class to be removed.
         * @return {Ext.dom.Element} this
         */
        toggleCls: function(className, state){
            if (typeof state !== &#39;boolean&#39;) {
                state = !this.hasCls(className);
            }

            return state ? this.addCls(className) : this.removeCls(className);
        },

<span id='Ext-dom-Element-method-toggle'>        /**
</span>         * Toggles the element&#39;s visibility, depending on visibility mode.
         * @return {Ext.dom.Element} this
         */
        toggle: function() {
            this.setVisible(!this.isVisible());
            return this;
        },

        translate: function() {
            var transformStyleName = &#39;webkitTransform&#39; in DOC.createElement(&#39;div&#39;).style ? &#39;webkitTransform&#39; : &#39;transform&#39;;

            return function(x, y, z) {

                x = Math.round(x);
                y = Math.round(y);
                z = Math.round(z);
                this.dom.style[transformStyleName] = &#39;translate3d(&#39; + (x || 0) + &#39;px, &#39; + (y || 0) + &#39;px, &#39; + (z || 0) + &#39;px)&#39;;
            };
        }(),

<span id='Ext-dom-Element-method-unwrap'>        /**
</span>         * @private
         */
        unwrap: function() {
            var dom = this.dom,
                parentNode = dom.parentNode,
                grandparentNode,
                activeElement = Ext.fly(Ext.Element.getActiveElement()),
                cached, resumeFocus, grannyFly, tabIndex;

            cached = Ext.cache[activeElement.id];
            
            // If the element is in the cache, we need to get the instance so
            // we can suspend events on it. If it&#39;s not in the cache, it can&#39;t
            // have any events so we don&#39;t need to suspend on it.
            if (cached) {
                activeElement = cached;
            }

            if (this.contains(activeElement)) {
                if (cached) {
                    cached.suspendFocusEvents();
                }
                
                resumeFocus = true;
            }
            
            if (parentNode) {
                grandparentNode = parentNode.parentNode;
                
                // See wrap() for the explanation of this jiggery-trickery
                if (resumeFocus) {
                    tabIndex = grandparentNode.getAttribute(&#39;tabIndex&#39;);
                    
                    grannyFly = Ext.fly(grandparentNode);
                    grannyFly.set({ tabIndex: -1 });
                    grannyFly.suspendFocusEvents();
                    grannyFly.focus();
                }
                
                grandparentNode.insertBefore(dom, parentNode);
                grandparentNode.removeChild(parentNode);
            }
            else {
                grandparentNode = DOC.createDocumentFragment();
                grandparentNode.appendChild(dom);
            }
            
            if (resumeFocus) {
                if (cached) {
                    cached.focus();
                    cached.resumeFocusEvents();
                }
                else {
                    Ext.fly(activeElement).focus();
                }
                
                if (grannyFly) {
                    grannyFly.resumeFocusEvents();
                    grannyFly.set({ tabIndex: tabIndex });
                }
            }

            return this;
        },

<span id='Ext-dom-Element-method-up'>        /**.
</span>         * Walks up the dom looking for a parent node that matches the passed simple selector (e.g. &#39;div.some-class&#39; or &#39;span:first-child&#39;).
         * This is a shortcut for findParentNode() that always returns an Ext.dom.Element.
         * @param {String} selector The simple selector to test. See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Number/String/HTMLElement/Ext.dom.Element} [limit]
         * The max depth to search as a number or an element that causes the upward
         * traversal to stop and is **not** considered for inclusion as the result.
         * (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnDom=false] True to return the DOM node instead of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The matching DOM node (or HTMLElement if 
         * _returnDom_ is _true_).  Or null if no match was found.
         */
        up: function(simpleSelector, limit, returnDom) {
            return this.findParentNode(simpleSelector, limit, !returnDom);
        },

<span id='Ext-dom-Element-method-update'>        /**
</span>         * @inheritdoc Ext.dom.Element#setHtml
         * @deprecated 5.0.0 Please use {@link #setHtml} instead.
         */
        update: function (html) {
            return this.setHtml(html);
        },

<span id='Ext-dom-Element-method-wrap'>        /**
</span>         * Creates and wraps this element with another element
         * @param {Object} [config] DomHelper element config object for the wrapper element or null for an empty div
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead of Ext.dom.Element
         * @param {String} [selector] A CSS selector to select a descendant node within the created element to use as the wrapping element.
         * @return {HTMLElement/Ext.dom.Element} The newly created wrapper element
         */
        wrap: function(config, returnDom, selector) {
            var me = this,
                dom = me.dom,
                newEl = Ext.DomHelper.insertBefore(dom, config || {tag: &quot;div&quot;}, !returnDom),
                target = newEl,
                activeElement = Ext.Element.getActiveElement(),
                cached, resumeFocus, tabIndex;

            cached = Ext.cache[activeElement.id];
            
            // If the element is in the cache, we need to get the instance so
            // we can suspend events on it. If it&#39;s not in the cache, it can&#39;t
            // have any events so we don&#39;t need to suspend on it.
            if (cached) {
                activeElement = cached;
            }

            if (selector) {
                target = newEl.selectNode(selector, returnDom);
            }

            if (me.contains(activeElement)) {
                if (cached) {
                    cached.suspendFocusEvents();
                }
                
                // This is workaround for the nasty IE behavior w/r/t removing and adding
                // DOM nodes that contain focus. When this happens, focus will fall back
                // to the document body *after* the present code execution path finishes,
                // with no way to control this. Instead of trying to refocus the element
                // asynchronously in a callback, we&#39;re focusing the wrapper instead,
                // adding the dom to the wrapper, and then refocusing the dom;
                // all synchronous and dandy.
                // The only side effect of all this focus juggling is that focus/blur
                // events will fire asynchronously after this code path finishes (in IE),
                // but we deal with that by ignoring these events *on particular elements*.
                // Focus event publisher will look for focus suspension flag on the element,
                // and since the flag is cleared asynchronously in the immediate callback,
                // we have enough cycles to ignore unwanted events to get away with it
                // but not too many to step on someone else&#39;s toes (hopefully).
                tabIndex = newEl.dom.getAttribute(&#39;tabIndex&#39;);
                newEl.set({ tabIndex: -1 });
                
                newEl.suspendFocusEvents();
                newEl.focus();
                
                resumeFocus = true;
            }
            
            target.appendChild(dom);
            
            if (resumeFocus) {
                if (cached) {
                    cached.focus();
                    cached.resumeFocusEvents();
                }
                else {
                    Ext.fly(activeElement).focus();
                }
                
                newEl.resumeFocusEvents();
                
                // Most often tabIndex will be undefined, and we don&#39;t want to
                // make the wrapper focusable by accident.
                newEl.set({ tabIndex: tabIndex });
            }
            
            return newEl;
        },

        privates: {
            doAddListener: function(eventName, fn, scope, options, order, caller, manager) {
                var me = this,
                    gesturePublisher = Ext.$gesturePublisher,
                    originalName = eventName,
                    supports = Ext.supports,
                    supportsTouch = supports.TouchEvents,
                    supportsPointer = supports.PointerEvents,
                    observableDoAddListener, additiveEventName,
                    translatedEventName;

                // Even though the superclass method does conversion to lowercase, we need
                // to do it here because we need to use the lowercase name for lookup
                // in the event translation map.
                eventName = Ext.canonicalEventName(eventName);

                // Blocked events (such as emulated mouseover in mobile webkit) are prevented
                // from firing
                if (!me.blockedEvents[eventName]) {
                    observableDoAddListener = me.mixins.observable.doAddListener;
                    options = options || {};

                    if (Element.useDelegatedEvents === false) {
                        options.delegated = options.delegated || false;
                    }

                    if (options.translate !== false) {
                        // translate events where applicable.  This allows applications that
                        // were written for desktop to work on mobile devices and vice versa.
                        additiveEventName = me.additiveEvents[eventName];
                        if (additiveEventName) {
                            // additiveEvents means the translation is &quot;additive&quot; - meaning we
                            // need to attach the original event in addition to the translated
                            // one.  An example of this is devices that have both mousedown
                            // and touchstart
                            options.type = eventName;
                            eventName = additiveEventName;
                            observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager);
                        }

                        translatedEventName = me.eventMap[eventName];
                        if (translatedEventName) {
                            // options.type may have already been set above
                            options.type = options.type || eventName;
                            if (manager) {
                                options.managedName = originalName;
                            }
                            eventName = translatedEventName;
                        }
                    }

                    if (observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager)) {
                        if (me.longpressEvents[eventName] &amp;&amp; (++me.longpressListenerCount === 1)) {
                            me.on(&#39;MSHoldVisual&#39;, &#39;preventMsHoldVisual&#39;, me);
                        }
                    }

                    if (manager &amp;&amp; translatedEventName) {
                        delete options.managedName;
                    }

                    // after the listener has been added to the ListenerStack, it&#39;s original
                    // &quot;type&quot; (for translated events) will be stored on the listener object in
                    // the ListenerStack.  We can now delete type from the options object
                    // since it is not a user-supplied option
                    delete options.type;
                }
            },

            doRemoveListener: function(eventName, fn, scope) {
                var me = this,
                    gesturePublisher = Ext.$gesturePublisher,
                    supports = Ext.supports,
                    supportsTouch = supports.TouchEvents,
                    supportsPointer = supports.PointerEvents,
                    observableDoRemoveListener, translatedEventName, additiveEventName,
                    contextMenuListenerRemover, removed;

                // Even though the superclass method does conversion to lowercase, we need
                // to do it here because we need to use the lowercase name for lookup
                // in the event translation map.
                eventName = Ext.canonicalEventName(eventName);

                // Blocked events (such as emulated mouseover in mobile webkit) are prevented
                // from firing
                if (!me.blockedEvents[eventName]) {
                    observableDoRemoveListener = me.mixins.observable.doRemoveListener;

                    // translate events where applicable.  This allows applications that
                    // were written for desktop to work on mobile devices and vice versa.
                    additiveEventName = me.additiveEvents[eventName];
                    if (additiveEventName) {
                        // additiveEvents means the translation is &quot;additive&quot; - meaning we
                        // need to remove the original event in addition to the translated
                        // one.  An example of this is devices that have both mousedown
                        // and touchstart
                        eventName = additiveEventName;
                        observableDoRemoveListener.call(me, eventName, fn, scope);
                    }

                    translatedEventName = me.eventMap[eventName];
                    if (translatedEventName) {
                        removed = observableDoRemoveListener.call(me, translatedEventName, fn, scope);
                    }

                    // no &quot;else&quot; here because we need to ensure that we remove translate:false
                    // listeners
                    removed = observableDoRemoveListener.call(me, eventName, fn, scope) || removed;

                    if (removed) {
                        if (me.longpressEvents[eventName] &amp;&amp; !--me.longpressListenerCount) {
                            me.un(&#39;MSHoldVisual&#39;, &#39;preventMsHoldVisual&#39;, me);
                        }
                    }
                }
            },

            _initEvent: function(eventName) {
                return (this.events[eventName] = new Ext.dom.ElementEvent(this, eventName));
            },

            _getDisplay: function() {
                var data = this.getData(),
                    display = data[ORIGINALDISPLAY];

                if (display === undefined) {
                    data[ORIGINALDISPLAY] = display = &#39;&#39;;
                }
                return display;
            },

<span id='Ext-dom-Element-method-_getPublisher'>            /**
</span>             * Returns the publisher for a given event
             * @param {String} eventName
             * @private
             * @return {Ext.event.publisher.Publisher}
             */
            _getPublisher: function(eventName) {
                var Publisher = Ext.event.publisher.Publisher,
                    publisher = Publisher.publishersByEvent[eventName];

                // Dom publisher acts as the default publisher for all events that are
                // not explicitly handled by another publisher.
                // ElementSize handles the &#39;resize&#39; event, except on the window
                // object, where it is handled by Dom publisher.
                if (!publisher || (this.dom === window &amp;&amp; eventName === &#39;resize&#39;)) {
                    publisher = Publisher.publishers.dom;
                }

                return publisher;
            },
            
            isFocusSuspended: function() {
                return !!this.getData().suspendFocusEvents;
            },

            preventMsHoldVisual: function(e) {
                e.preventDefault();
            },

            suspendFocusEvents: function() {
                if (!this.isFly) {
                    this.suspendEvent(&#39;focus&#39;, &#39;blur&#39;);
                }
                
                this.getData().suspendFocusEvents = true;
            },

            resumeFocusEvents: function() {
                function resumeFn() {
                    var data;
                    
                    if (!this.destroyed) {
                        data = this.getData();
                        
                        if (data) {
                            data.suspendFocusEvents = false;
                        }
                        
                        if (!this.isFly) {
                            this.resumeEvent(&#39;focus&#39;, &#39;blur&#39;);
                        }
                    }
                }
                
                if (!this.destroyed &amp;&amp; this.getData().suspendFocusEvents) {
                    if (Ext.isIE) {
                        Ext.asap(resumeFn, this);
                    }
                    else {
                        resumeFn.call(this);
                    }
                }
            }
        },

        deprecated: {
            &#39;5.0&#39;: {
                methods: {
<span id='Ext-dom-Element-method-cssTranslate'>                    /**
</span>                     * @method cssTranslate
                     * Translates an element using CSS 3 in 2D.
                     * @removed 5.0.0
                     */
                    cssTranslate: null,

<span id='Ext-dom-Element-method-getHTML'>                    /**
</span>                     * @method getHTML
                     * @inheritdoc Ext.dom.Element#getHtml
                     * @deprecated 5.0.0 Please use {@link #getHtml} instead.
                     */
                    getHTML: &#39;getHtml&#39;,

<span id='Ext-dom-Element-method-getOuterHeight'>                    /**
</span>                     * @method getOuterHeight
                     * Retrieves the height of the element account for the top and bottom margins.
                     * @removed 5.0.0
                     */
                    getOuterHeight: null,

<span id='Ext-dom-Element-method-getOuterWidth'>                    /**
</span>                     * @method getOuterWidth
                     * Retrieves the width of the element accounting for the left and right margins.
                     * @removed 5.0.0
                     */
                    getOuterWidth: null,

<span id='Ext-dom-Element-method-getPageBox'>                    /**
</span>                     * Returns an object defining the area of this Element which can be passed to
                     * {@link Ext.util.Positionable#setBox} to set another Element&#39;s size/location to match this element.
                     *
                     * @param {Boolean} [asRegion] If true an Ext.util.Region will be returned
                     * @return {Object/Ext.util.Region} box An object in the following format:
                     *
                     *     {
                     *         left: &lt;Element&#39;s X position&gt;,
                     *         top: &lt;Element&#39;s Y position&gt;,
                     *         width: &lt;Element&#39;s width&gt;,
                     *         height: &lt;Element&#39;s height&gt;,
                     *         bottom: &lt;Element&#39;s lower bound&gt;,
                     *         right: &lt;Element&#39;s rightmost bound&gt;
                     *     }
                     *
                     * The returned object may also be addressed as an Array where index 0 contains
                     * the X position and index 1 contains the Y position. So the result may also be
                     * used for {@link #setXY}
                     * @deprecated 5.0.0 use {@link Ext.util.Positionable#getBox} to get a box object, and
                     * {@link Ext.util.Positionable#getRegion} to get a {@link Ext.util.Region Region}.
                     */
                    getPageBox: function(getRegion) {
                        var me = this,
                            dom = me.dom,
                            isDoc = dom.nodeName === &#39;BODY&#39;,
                            w = isDoc ? Element.getViewportWidth() : dom.offsetWidth,
                            h = isDoc ? Element.getViewportHeight() : dom.offsetHeight,
                            xy = me.getXY(),
                            t = xy[1],
                            r = xy[0] + w,
                            b = xy[1] + h,
                            l = xy[0];

                        if (getRegion) {
                            return new Ext.util.Region(t, r, b, l);
                        }
                        else {
                            return {
                                left: l,
                                top: t,
                                width: w,
                                height: h,
                                right: r,
                                bottom: b
                            };
                        }
                    },

<span id='Ext-dom-Element-method-getScrollParent'>                    /**
</span>                     * @method getScrollParent
                     * Gets the Scroller instance of the first parent that has one.
                     * @removed 5.0.0
                     */
                    getScrollParent: null,

<span id='Ext-dom-Element-method-isDescendent'>                    /**
</span>                     * @method isDescendent
                     * Determines if this element is a descendant of the passed in Element.
                     * @removed 5.0.0
                     */
                    isDescendent: null,

<span id='Ext-dom-Element-method-isTransparent'>                    /**
</span>                     * Returns `true` if the value of the given property is visually transparent. This
                     * may be due to a &#39;transparent&#39; style value or an rgba value with 0 in the alpha
                     * component.
                     * @param {String} prop The style property whose value is to be tested.
                     * @return {Boolean} `true` if the style property is visually transparent.
                     * @deprecated 5.0.0
                     */
                    isTransparent: function(prop) {
                        var value = this.getStyle(prop);

                        return value ? transparentRe.test(value) : false;
                    },

<span id='Ext-dom-Element-method-purgeAllListeners'>                    /**
</span>                     * @method purgeAllListeners
                     * @inheritdoc Ext.dom.Element#clearListeners
                     * @deprecated 5.0.0 Please use {@link #clearListeners} instead.
                     */
                    purgeAllListeners: &#39;clearListeners&#39;,

<span id='Ext-dom-Element-method-removeAllListeners'>                    /**
</span>                     * @method removeAllListeners
                     * @inheritdoc Ext.dom.Element#clearListeners
                     * @deprecated 5.0.0 Please use {@link #clearListeners} instead.
                     */
                    removeAllListeners: &#39;clearListeners&#39;,

<span id='Ext-dom-Element-method-setHTML'>                    /**
</span>                     * @method setHTML
                     * @inheritdoc Ext.dom.Element#setHtml
                     * @deprecated 5.0.0 Please use {@link #setHtml} instead.
                     */
                    setHTML: &#39;setHtml&#39;,

<span id='Ext-dom-Element-method-setTopLeft'>                    /**
</span>                     * @method setTopLeft
                     * Sets the element&#39;s top and left positions directly using CSS style.
                     * @removed 5.0.0
                     */
                    setTopLeft: null
                }
            }
        }
    };
}, function(Element) {
    var DOC = document,
        docEl = DOC.documentElement,
        prototype = Element.prototype,
        supports = Ext.supports,
        pointerdown = &#39;pointerdown&#39;,
        pointermove = &#39;pointermove&#39;,
        pointerup = &#39;pointerup&#39;,
        pointercancel = &#39;pointercancel&#39;,
        MSPointerDown = &#39;MSPointerDown&#39;,
        MSPointerMove = &#39;MSPointerMove&#39;,
        MSPointerUp = &#39;MSPointerUp&#39;,
        MSPointerCancel = &#39;MSPointerCancel&#39;,
        mousedown = &#39;mousedown&#39;,
        mousemove = &#39;mousemove&#39;,
        mouseup = &#39;mouseup&#39;,
        mouseover = &#39;mouseover&#39;,
        mouseout = &#39;mouseout&#39;,
        mouseenter = &#39;mouseenter&#39;,
        mouseleave = &#39;mouseleave&#39;,
        touchstart = &#39;touchstart&#39;,
        touchmove = &#39;touchmove&#39;,
        touchend = &#39;touchend&#39;,
        touchcancel = &#39;touchcancel&#39;,
        click = &#39;click&#39;,
        dblclick = &#39;dblclick&#39;,
        tap = &#39;tap&#39;,
        doubletap = &#39;doubletap&#39;,
        eventMap = prototype.eventMap = {},
        additiveEvents = prototype.additiveEvents = {},
        oldId = Ext.id,
        eventOptions;

<span id='Ext-method-id'>    /**
</span>     * Generates unique ids. If the element already has an id, it is unchanged
     * @member Ext
     * @param {Object/HTMLElement/Ext.dom.Element} [obj] The element to generate an id for
     * @param {String} prefix (optional) Id prefix (defaults &quot;ext-gen&quot;)
     * @return {String} The generated Id.
     */
    Ext.id = function (obj, prefix) {
        var el = Ext.getDom(obj, true),
            sandboxPrefix, id;

        if (!el) {
            id = oldId(obj, prefix);
        } else if (!(id = el.id)) {
            id = oldId(null, prefix || Element.prototype.identifiablePrefix);

            if (Ext.isSandboxed) {
                sandboxPrefix = Ext.sandboxPrefix ||
                    (Ext.sandboxPrefix = Ext.sandboxName.toLowerCase() + &#39;-&#39;);
                id = sandboxPrefix + id;
            }

            el.id = id;
        }

        return id;
    };

    if (supports.PointerEvents) {
        eventMap[mousedown] = pointerdown;
        eventMap[mousemove] = pointermove;
        eventMap[mouseup] = pointerup;
        eventMap[touchstart] = pointerdown;
        eventMap[touchmove] = pointermove;
        eventMap[touchend] = pointerup;
        eventMap[touchcancel] = pointercancel;

        // On devices that support pointer events we block pointerover, pointerout,
        // pointerenter, and pointerleave when triggered by touch input (see
        // Ext.event.publisher.Dom#blockedPointerEvents).  This is because mouseover
        // behavior is typically not desired when touching the screen.  This covers the
        // use case where user code requested a pointer event, however mouseover/mouseout
        // events are not cancellable, period.
        // http://www.w3.org/TR/pointerevents/#mapping-for-devices-that-do-not-support-hover
        // To ensure mouseover/out handlers don&#39;t fire when touching the screen, we need
        // to translate them to their pointer equivalents
        eventMap[mouseover] = &#39;pointerover&#39;;
        eventMap[mouseout] = &#39;pointerout&#39;;
        eventMap[mouseenter] = &#39;pointerenter&#39;;
        // No decent way to feature detect this, pointerleave relatedTarget is
        // incorrect on IE11, so force it to use mouseleave here.
        // See: https://connect.microsoft.com/IE/feedback/details/851111/ev-relatedtarget-in-pointerleave-indicates-departure-element-not-destination-element
        if (!Ext.isIE11) {
            eventMap[mouseleave] = &#39;pointerleave&#39;;
        }
    } else if (supports.MSPointerEvents) {
        // IE10
        eventMap[pointerdown] = MSPointerDown;
        eventMap[pointermove] = MSPointerMove;
        eventMap[pointerup] = MSPointerUp;
        eventMap[pointercancel] = MSPointerCancel;
        eventMap[mousedown] = MSPointerDown;
        eventMap[mousemove] = MSPointerMove;
        eventMap[mouseup] = MSPointerUp;
        eventMap[touchstart] = MSPointerDown;
        eventMap[touchmove] = MSPointerMove;
        eventMap[touchend] = MSPointerUp;
        eventMap[touchcancel] = MSPointerCancel;

        // translate mouseover/out so they can be prevented on touch screens.
        // (see above comment in the PointerEvents section)
        eventMap[mouseover] = &#39;MSPointerOver&#39;;
        eventMap[mouseout] = &#39;MSPointerOut&#39;;
    } else if (supports.TouchEvents) {
        eventMap[pointerdown] = touchstart;
        eventMap[pointermove] = touchmove;
        eventMap[pointerup] = touchend;
        eventMap[pointercancel] = touchcancel;
        eventMap[mousedown] = touchstart;
        eventMap[mousemove] = touchmove;
        eventMap[mouseup] = touchend;
        eventMap[click] = tap;
        eventMap[dblclick] = doubletap;

        if (Ext.isWebKit &amp;&amp; Ext.os.is.Desktop) {
            // Touch enabled webkit browsers on windows8 fire both mouse events and touch
            // events. so we have to attach listeners for both kinds when either one is
            // requested.  There are a couple rules to keep in mind:
            // 1. When the mouse is used, only a mouse event is fired
            // 2. When interacting with the touch screen touch events are fired.
            // 3. After a touchstart/touchend sequence, if there was no touchmove in
            // between, the browser will fire a mousemove/mousedown/mousup sequence
            // immediately after.  This can cause problems because if we are listening
            // for both kinds of events, handlers may run twice.  To work around this
            // issue we filter out the duplicate emulated mouse events by checking their
            // coordinates and timing (see Ext.event.publisher.Gesture#onDelegatedEvent)
            eventMap[touchstart] = mousedown;
            eventMap[touchmove] = mousemove;
            eventMap[touchend] = mouseup;
            eventMap[touchcancel] = mouseup;

            additiveEvents[mousedown] = mousedown;
            additiveEvents[mousemove] = mousemove;
            additiveEvents[mouseup] = mouseup;
            additiveEvents[touchstart] = touchstart;
            additiveEvents[touchmove] = touchmove;
            additiveEvents[touchend] = touchend;
            additiveEvents[touchcancel] = touchcancel;

            additiveEvents[pointerdown] = mousedown;
            additiveEvents[pointermove] = mousemove;
            additiveEvents[pointerup] = mouseup;
            additiveEvents[pointercancel] = mouseup;
        }
    } else {
        // browser does not support either pointer or touch events, map all pointer and
        // touch events to their mouse equivalents
        eventMap[pointerdown] = mousedown;
        eventMap[pointermove] = mousemove;
        eventMap[pointerup] = mouseup;
        eventMap[pointercancel] = mouseup;
        eventMap[touchstart] = mousedown;
        eventMap[touchmove] = mousemove;
        eventMap[touchend] = mouseup;
        eventMap[touchcancel] = mouseup;
    }

    if (Ext.isWebKit) {
        // These properties were carried forward from touch-2.x. This translation used
        // do be done by DomPublisher.  TODO: do we still need this?
        eventMap.transitionend = Ext.browser.getVendorProperyName(&#39;transitionEnd&#39;);
        eventMap.animationstart = Ext.browser.getVendorProperyName(&#39;animationStart&#39;);
        eventMap.animationend = Ext.browser.getVendorProperyName(&#39;animationEnd&#39;);
    }

    if (!Ext.supports.MouseWheel &amp;&amp; !Ext.isOpera) {
        eventMap.mousewheel = &#39;DOMMouseScroll&#39;;
    }

    eventOptions = prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions);
    eventOptions.translate = eventOptions.capture = eventOptions.delegate = eventOptions.delegated =
            eventOptions.stopEvent = eventOptions.preventDefault = eventOptions.stopPropagation =
            // Ext.Element also needs &quot;element&quot; as one of its event options.  Even though
            // it does not directly process an element option, it may receive a listeners
            // object that was passed through from a Component with the &quot;element&quot; option
            // included. Including &quot;element&quot; in the event options ensures we don&#39;t attempt
            // to process &quot;element&quot; as an event name.
            eventOptions.element = 1;


    prototype.styleHooks.opacity = {
        name: &#39;opacity&#39;,
        afterSet: function(dom, value, el) {
            var shadow = el.shadow;
            if (shadow) {
                shadow.setOpacity(value);
            }
        }
    };

<span id='Ext-dom-Element-property-getTrueXY'>    /**
</span>     * @private
     * Returns the `X,Y` position of this element without regard to any RTL
     * direction settings.
     */
    prototype.getTrueXY = prototype.getXY;

<span id='Ext-method-select'>    /**
</span>     * @member Ext
     * @method select
     */
    Ext.select = Element.select;

<span id='Ext-method-query'>    /**
</span>     * @member Ext
     * @method query
     */
    Ext.query = Element.query;

    Ext.apply(Ext, {
<span id='Ext-method-get'>        /**
</span>         * @member Ext
         * @method get
         */
        get: function(element) {
            return Element.get(element);
        },

<span id='Ext-method-getDom'>        /**
</span>         * @member Ext
         * @method getDom
         * Return the dom node for the passed String (id), dom node, or Ext.Element.
         * Here are some examples:
         *
         *     // gets dom node based on id
         *     var elDom = Ext.getDom(&#39;elId&#39;);
         *
         *     // gets dom node based on the dom node
         *     var elDom1 = Ext.getDom(elDom);
         *
         *     // If we don&#39;t know if we are working with an
         *     // Ext.Element or a dom node use Ext.getDom
         *     function(el){
         *         var dom = Ext.getDom(el);
         *         // do something with the dom node
         *     }
         *
         * __Note:__ the dom node to be found actually needs to exist (be rendered, etc)
         * when this method is called to be successful.
         *
         * @param {String/HTMLElement/Ext.dom.Element} el
         * @return {HTMLElement}
         */
        getDom: function(el) {
            if (!el || !DOC) {
                return null;
            }

            // We could be passed an Element whos dom has been nulled on destruction; use &#39;dom&#39; in rather than truthiness.
            return typeof el === &#39;string&#39; ? Ext.getElementById(el) : &#39;dom&#39; in el ? el.dom : el;
        },

<span id='Ext-method-getBody'>        /**
</span>         * @member Ext
         * Returns the current document body as an {@link Ext.dom.Element}.
         * @return {Ext.dom.Element} The document body.
         */
        getBody: function() {
            if (!Ext._bodyEl) {
                if (!DOC.body) {
                    throw new Error(&quot;[Ext.getBody] document.body does not yet exist&quot;);
                }

                Ext._bodyEl = Ext.get(DOC.body);
            }

            return Ext._bodyEl;
        },

<span id='Ext-method-getHead'>        /**
</span>         * @member Ext
         * Returns the current document head as an {@link Ext.dom.Element}.
         * @return {Ext.dom.Element} The document head.
         */
        getHead: function() {
            if (!Ext._headEl) {
                Ext._headEl = Ext.get(DOC.head || DOC.getElementsByTagName(&#39;head&#39;)[0]);
            }

            return Ext._headEl;
        },

<span id='Ext-method-getDoc'>        /**
</span>         * @member Ext
         * Returns the current HTML document object as an {@link Ext.dom.Element}.
         * Typically used for attaching event listeners to the document.  Note: since
         * the document object is not an HTMLElement many of the Ext.dom.Element methods
         * are not applicable and may throw errors if called on the returned
         * Element instance.
         * @return {Ext.dom.Element} The document.
         */
        getDoc: function() {
            if (!Ext._docEl) {
                Ext._docEl = Ext.get(DOC);
            }

            return Ext._docEl;
        },

<span id='Ext-method-getWin'>        /**
</span>         * @member Ext
         * Returns the current window object as an {@link Ext.dom.Element}.
         * Typically used for attaching event listeners to the window.  Note: since
         * the window object is not an HTMLElement many of the Ext.dom.Element methods
         * are not applicable and may throw errors if called on the returned
         * Element instance.
         * @return {Ext.dom.Element} The window.
         */
        getWin: function() {
            if (!Ext._winEl) {
                Ext._winEl = Ext.get(window);
            }

            return Ext._winEl;
        },

<span id='Ext-method-removeNode'>        /**
</span>         * @member Ext
         * Removes an HTMLElement from the document.  If the HTMLElement was previously
         * cached by a call to Ext.get(), removeNode will call the {@link Ext.Element#destroy
         * destroy} method of the {@link Ext.dom.Element} instance, which removes all DOM
         * event listeners, and deletes the cache reference.
         * @param {HTMLElement} node The node to remove
         * @method
         */
        removeNode: function(node) {
            node = node.dom || node;

            var id = node &amp;&amp; node.id,
                el = Ext.cache[id],
                parent;

            if (el) {
                el.destroy();
            } else if(node &amp;&amp; (node.nodeType === 3 || node.tagName.toUpperCase() !== &#39;BODY&#39;)) {
                parent = node.parentNode;
                if (parent) {
                    parent.removeChild(node);
                }
            }
        }
    });

    // TODO: make @inline work - SDKTOOLS-686
    // @inline
    Ext.isGarbage = function(dom) {
        // determines if the dom element is in the document or in the detached body element
        // use by collectGarbage and Ext.get()
        return dom &amp;&amp;
            // window, document, documentElement, and body can never be garbage.
            dom.nodeType === 1 &amp;&amp; dom.tagName !== &#39;BODY&#39; &amp;&amp; dom.tagName !== &#39;HTML&#39; &amp;&amp;
            // if the element does not have a parent node, it is definitely not in the
            // DOM - we can exit immediately
            (!dom.parentNode ||
            // If the element has an offsetParent we can bail right away, it is
            // definitely in the DOM. If offsetParent is null, the element is detached.
            // If offsetParent is undefined, the element doesn&#39;t support offsetParent
            // (e.g. SVGElement) and is not necessarily garbage; parentNode check above
            // should be sufficient in this case.
            (dom.offsetParent === null &amp;&amp;
            // if the element does not have an offsetParent it can mean the element is
            // either not in the dom or it is hidden.  The next step is to check to see
            // if it can be found by id using either document.all or getElementById(),
            // whichever is faster for the current browser.  Normally we would not
            // include IE-specific checks in the core package, however,  in this
            // case the function will be inlined and therefore cannot be overridden in
            // the ext package.
                ((Ext.isIE8 ? DOC.all[dom.id] : DOC.getElementById(dom.id)) !== dom) &amp;&amp;
                // finally if the element was not found in the dom by id, we need to check
                // the detachedBody element
                !(Ext.detachedBodyEl &amp;&amp; Ext.detachedBodyEl.isAncestor(dom))));
    };

    if (Ext.os.is.Android || (Ext.os.is.Windows &amp;&amp; Ext.supports.Touch)) {
        Ext.onReady(function() {
            // Some mobile devices (android and windows) fire window resize events
            // When the virtual keyboard is displayed. This causes unexpected visual
            // results due to extra layouts of the viewport.  Here we attach a couple
            // of event listeners that will help us detect if the virtual keyboard
            // is open so tha getViewportWidth/getViewportHeight can report the
            // original size as the viewport size while the keyboard is open
            var win = Ext.getWin();

            Element._documentWidth = Element._viewportWidth = docEl.clientWidth;
            Element._documentHeight = Element._viewportHeight = docEl.clientHeight;

            win.on({
                // Focus in/out listeners track the last focus change so we can detect
                // the proximity of the last focus change relative to window resize events
                // alowing us to guess with reasonable certainty that a virtual keyboard
                // is being shown.
                focusin: &#39;_onWindowFocusChange&#39;,
                focusout: &#39;_onWindowFocusChange&#39;,
                // This pointerup listener is needed because in windowsthe virtual keyboard
                // can be hidden manually while the editable element retains focus by tapping
                // a hide button on the virtual keyboard itself. The virtual keyboard can then
                // be re-shown by tapping on the editable element.  In this case the editable
                // element does not fire a focusin event since it already has the focus, but
                // we still need to track that an event occurred which will cause the virtual
                // keyboard to show momentarily.
                pointerup: &#39;_onWindowFocusChange&#39;,
                capture: true,
                delegated: false,
                delay: 1,
                scope: Element
            });

            win.on({
                // Resize listener for tracking virtual keyboard state.
                resize: &#39;_onWindowResize&#39;,
                priority: 2000,
                scope: Element
            });

        });
    }
});
</pre>
</body>
</html>
