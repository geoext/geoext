<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-form-field-HtmlEditor'>/**
</span> * Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be
 * automatically hidden when needed. These are noted in the config options where appropriate.
 *
 * The editor&#39;s toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not
 * enabled by default unless the global {@link Ext.tip.QuickTipManager} singleton is
 * {@link Ext.tip.QuickTipManager#init initialized}.
 *
 * An Editor is a sensitive component that can&#39;t be used in all spots standard fields can be used. Putting an
 * Editor within any element that has display set to &#39;none&#39; can cause problems in Safari and Firefox due to their
 * default iframe reloading bugs.
 *
 * # Example usage
 *
 * Simple example rendered with default options:
 *
 *     @example
 *     Ext.tip.QuickTipManager.init();  // enable tooltips
 *     Ext.create(&#39;Ext.form.HtmlEditor&#39;, {
 *         width: 580,
 *         height: 250,
 *         renderTo: Ext.getBody()
 *     });
 *
 * Passed via xtype into a container and with custom options:
 *
 *     @example
 *     Ext.tip.QuickTipManager.init();  // enable tooltips
 *     new Ext.panel.Panel({
 *         title: &#39;HTML Editor&#39;,
 *         renderTo: Ext.getBody(),
 *         width: 550,
 *         height: 250,
 *         frame: true,
 *         layout: &#39;fit&#39;,
 *         items: {
 *             xtype: &#39;htmleditor&#39;,
 *             enableColors: false,
 *             enableAlignments: false
 *         }
 *     });
 *     
 * # Reflow issues
 * 
 * In some browsers, a layout reflow will cause the underlying editor iframe to be reset. This
 * is most commonly seen when using the editor in collapsed panels with animation. In these cases
 * it is best to avoid animation. More information can be found here: https://bugzilla.mozilla.org/show_bug.cgi?id=90268 
 */
Ext.define(&#39;Ext.form.field.HtmlEditor&#39;, {
    extend: &#39;Ext.form.FieldContainer&#39;,
    mixins: {
        field: &#39;Ext.form.field.Field&#39;
    },
    alias: &#39;widget.htmleditor&#39;,
    alternateClassName: &#39;Ext.form.HtmlEditor&#39;,
    requires: [
        &#39;Ext.tip.QuickTipManager&#39;,
        &#39;Ext.picker.Color&#39;,
        &#39;Ext.layout.container.VBox&#39;,
        &#39;Ext.toolbar.Item&#39;,
        &#39;Ext.toolbar.Toolbar&#39;,
        &#39;Ext.util.Format&#39;,
        &#39;Ext.layout.component.field.HtmlEditor&#39;,
        &#39;Ext.util.TaskManager&#39;,
        &#39;Ext.layout.container.boxOverflow.Menu&#39;
    ],
    
<span id='Ext-form-field-HtmlEditor-property-focusable'>    focusable: true,
</span><span id='Ext-form-field-HtmlEditor-cfg-componentLayout'>    componentLayout: &#39;htmleditor&#39;,
</span>
<span id='Ext-form-field-HtmlEditor-property-textareaCls'>    /**
</span>     * @private
     */
    textareaCls: Ext.baseCSSPrefix + &#39;htmleditor-textarea&#39;,

<span id='Ext-form-field-HtmlEditor-property-componentTpl'>    componentTpl: [
</span>        &#39;{beforeTextAreaTpl}&#39;,
        &#39;&lt;textarea id=&quot;{id}-textareaEl&quot; data-ref=&quot;textareaEl&quot; name=&quot;{name}&quot; tabindex=&quot;-1&quot; {inputAttrTpl}&#39;,
                 &#39; class=&quot;{textareaCls}&quot; autocomplete=&quot;off&quot;&gt;&#39;,
            &#39;{[Ext.util.Format.htmlEncode(values.value)]}&#39;,
        &#39;&lt;/textarea&gt;&#39;,
        &#39;{afterTextAreaTpl}&#39;,
        &#39;{beforeIFrameTpl}&#39;,
        &#39;&lt;iframe id=&quot;{id}-iframeEl&quot; data-ref=&quot;iframeEl&quot; name=&quot;{iframeName}&quot; frameBorder=&quot;0&quot; {iframeAttrTpl}&#39;,
               &#39; src=&quot;{iframeSrc}&quot; class=&quot;{iframeCls}&quot;&gt;&lt;/iframe&gt;&#39;,
        &#39;{afterIFrameTpl}&#39;,
        {
            disableFormats: true
        }
    ],
    
<span id='Ext-form-field-HtmlEditor-property-stretchInputElFixed'>    stretchInputElFixed: true,
</span>
<span id='Ext-form-field-HtmlEditor-property-subTplInsertions'>    subTplInsertions: [
</span><span id='Ext-form-field-HtmlEditor-cfg-beforeTextAreaTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeTextAreaTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * before the textarea element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;beforeTextAreaTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-afterTextAreaTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterTextAreaTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * after the textarea element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;afterTextAreaTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-beforeIFrameTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeIFrameTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * before the iframe element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;beforeIFrameTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-afterIFrameTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterIFrameTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * after the iframe element. If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;afterIFrameTpl&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-iframeAttrTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} iframeAttrTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * inside the iframe element (as attributes). If an `XTemplate` is used, the component&#39;s
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        &#39;iframeAttrTpl&#39;,

        // inherited
        &#39;inputAttrTpl&#39;
    ],

<span id='Ext-form-field-HtmlEditor-cfg-enableFormat'>    /**
</span>     * @cfg {Boolean} enableFormat
     * Enable the bold, italic and underline buttons
     */
    enableFormat: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableFontSize'>    /**
</span>     * @cfg {Boolean} enableFontSize
     * Enable the increase/decrease font size buttons
     */
    enableFontSize: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableColors'>    /**
</span>     * @cfg {Boolean} enableColors
     * Enable the fore/highlight color buttons
     */
    enableColors: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableAlignments'>    /**
</span>     * @cfg {Boolean} enableAlignments
     * Enable the left, center, right alignment buttons
     */
    enableAlignments: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableLists'>    /**
</span>     * @cfg {Boolean} enableLists
     * Enable the bullet and numbered list buttons. Not available in Safari 2.
     */
    enableLists: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableSourceEdit'>    /**
</span>     * @cfg {Boolean} enableSourceEdit
     * Enable the switch to source edit button. Not available in Safari 2.
     */
    enableSourceEdit: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableLinks'>    /**
</span>     * @cfg {Boolean} enableLinks
     * Enable the create link button. Not available in Safari 2.
     */
    enableLinks: true,
<span id='Ext-form-field-HtmlEditor-cfg-enableFont'>    /**
</span>     * @cfg {Boolean} enableFont
     * Enable font selection. Not available in Safari 2.
     */
    enableFont: true,
    //&lt;locale&gt;
<span id='Ext-form-field-HtmlEditor-cfg-createLinkText'>    /**
</span>     * @cfg {String} createLinkText
     * The default text for the create link prompt
     */
    createLinkText: &#39;Please enter the URL for the link:&#39;,
    //&lt;/locale&gt;
<span id='Ext-form-field-HtmlEditor-cfg-defaultLinkValue'>    /**
</span>     * @cfg {String} [defaultLinkValue=&#39;http://&#39;]
     * The default value for the create link prompt
     */
    defaultLinkValue: &#39;http:/&#39;+&#39;/&#39;,
<span id='Ext-form-field-HtmlEditor-cfg-fontFamilies'>    /**
</span>     * @cfg {String[]} fontFamilies
     * An array of available font families
     */
    fontFamilies: [
        &#39;Arial&#39;,
        &#39;Courier New&#39;,
        &#39;Tahoma&#39;,
        &#39;Times New Roman&#39;,
        &#39;Verdana&#39;
    ],
<span id='Ext-form-field-HtmlEditor-cfg-defaultValue'>    /**
</span>     * @cfg {String} defaultValue
     * A default value to be put into the editor to resolve focus issues.
     *
     * Defaults to (Non-breaking space) in Opera,
     * (Zero-width space) in all other browsers.
     */
    defaultValue: Ext.isOpera ? &#39;&amp;#160;&#39; : &#39;&amp;#8203;&#39;,

<span id='Ext-form-field-HtmlEditor-property-extraFieldBodyCls'>    /**
</span>     * @private
     */
    extraFieldBodyCls: Ext.baseCSSPrefix + &#39;html-editor-wrap&#39;,

<span id='Ext-form-field-HtmlEditor-cfg-defaultButtonUI'>    /**
</span>     * @cfg {String} defaultButtonUI
     * A default {@link Ext.Component#ui ui} to use for the HtmlEditor&#39;s toolbar
     * {@link Ext.button.Button buttons}.
     */
    defaultButtonUI: &#39;default-toolbar&#39;,
    
<span id='Ext-form-field-HtmlEditor-cfg-buttonDefaults'>    /**
</span>     * @cfg {Object} buttonDefaults
     * A config object to apply to the toolbar&#39;s {@link Ext.button.Button buttons} to affect how they operate, eg:
     *
     *    buttonDefaults: {
     *        tooltip: {
     *            align: &#39;t-b&#39;,
     *            anchor: true
     *        }
     *    }
     *
     * @since 6.2.0
     */
    buttonDefaults: null,

<span id='Ext-form-field-HtmlEditor-property-initialized'>    /**
</span>     * @private
     */
    initialized: false,

<span id='Ext-form-field-HtmlEditor-property-activated'>    /**
</span>     * @private
     */
    activated: false,

<span id='Ext-form-field-HtmlEditor-property-sourceEditMode'>    /**
</span>     * @private
     */
    sourceEditMode: false,

<span id='Ext-form-field-HtmlEditor-property-iframePad'>    /**
</span>     * @private
     */
    iframePad:3,

<span id='Ext-form-field-HtmlEditor-property-hideMode'>    /**
</span>     * @private
     */
    hideMode:&#39;offsets&#39;,

<span id='Ext-form-field-HtmlEditor-property-maskOnDisable'>    maskOnDisable: true,
</span>
<span id='Ext-form-field-HtmlEditor-property-containerElCls'>    containerElCls: Ext.baseCSSPrefix + &#39;html-editor-container&#39;,
</span>
<span id='Ext-form-field-HtmlEditor-property-reStripQuotes'>    // This will strip any number of single or double quotes (in any order) from a string at the anchors.
</span>    reStripQuotes: /^[&#39;&quot;]*|[&#39;&quot;]*$/g,
    
<span id='Ext-form-field-HtmlEditor-property-textAlignRE'>    textAlignRE: /text-align:(.*?);/i,
</span><span id='Ext-form-field-HtmlEditor-property-safariNonsenseRE'>    safariNonsenseRE: /\sclass=&quot;(?:Apple-style-span|Apple-tab-span|khtml-block-placeholder)&quot;/gi,
</span><span id='Ext-form-field-HtmlEditor-property-nonDigitsRE'>    nonDigitsRE: /\D/g,
</span>
<span id='Ext-form-field-HtmlEditor-event-initialize'>    /**
</span>     * @event initialize
     * Fires when the editor is fully initialized (including the iframe)
     * @param {Ext.form.field.HtmlEditor} this
     */

<span id='Ext-form-field-HtmlEditor-event-activate'>    /**
</span>     * @event activate
     * Fires when the editor is first receives the focus. Any insertion must wait until after this event.
     * @param {Ext.form.field.HtmlEditor} this
     */

<span id='Ext-form-field-HtmlEditor-event-beforesync'>     /**
</span>     * @event beforesync
     * Fires before the textarea is updated with content from the editor iframe. Return false to cancel the
     * sync.
     * @param {Ext.form.field.HtmlEditor} this
     * @param {String} html
     */

<span id='Ext-form-field-HtmlEditor-event-beforepush'>     /**
</span>     * @event beforepush
     * Fires before the iframe editor is updated with content from the textarea. Return false to cancel the
     * push.
     * @param {Ext.form.field.HtmlEditor} this
     * @param {String} html
     */

<span id='Ext-form-field-HtmlEditor-event-sync'>     /**
</span>     * @event sync
     * Fires when the textarea is updated with content from the editor iframe.
     * @param {Ext.form.field.HtmlEditor} this
     * @param {String} html
     */

<span id='Ext-form-field-HtmlEditor-event-push'>     /**
</span>     * @event push
     * Fires when the iframe editor is updated with content from the textarea.
     * @param {Ext.form.field.HtmlEditor} this
     * @param {String} html
     */

<span id='Ext-form-field-HtmlEditor-event-editmodechange'>     /**
</span>     * @event editmodechange
     * Fires when the editor switches edit modes
     * @param {Ext.form.field.HtmlEditor} this
     * @param {Boolean} sourceEdit True if source edit, false if standard editing.
     */

<span id='Ext-form-field-HtmlEditor-method-initComponent'>    /**
</span>     * @private
     */
    initComponent: function(){
        var me = this;

        me.items = [me.createToolbar(), me.createInputCmp()];

        me.layout = {
            type: &#39;vbox&#39;,
            align: &#39;stretch&#39;
        };

        // No value set, we must report empty string
        if (me.value == null) {
            me.value = &#39;&#39;;
        }

        me.callParent(arguments);
        me.initField();
    },
    
<span id='Ext-form-field-HtmlEditor-method-createInputCmp'>    createInputCmp: function(){
</span>        this.inputCmp = Ext.widget(this.getInputCmpCfg());
        return this.inputCmp;
    },
    
<span id='Ext-form-field-HtmlEditor-method-getInputCmpCfg'>    getInputCmpCfg: function(){
</span>        var me = this,
            id = me.id + &#39;-inputCmp&#39;,
            data = {
                id          : id,
                name        : me.name,
                textareaCls : me.textareaCls + &#39; &#39; + Ext.baseCSSPrefix + &#39;hidden&#39;,
                value       : me.value,
                iframeName  : Ext.id(),
                iframeSrc   : Ext.SSL_SECURE_URL,
                iframeCls   : Ext.baseCSSPrefix + &#39;htmleditor-iframe&#39;
            };
            
        me.getInsertionRenderData(data, me.subTplInsertions);
            
        return {
            flex: 1,
            xtype: &#39;component&#39;,
            tpl: me.lookupTpl(&#39;componentTpl&#39;),
            childEls: [&#39;iframeEl&#39;, &#39;textareaEl&#39;],
            id: id, 
            cls: Ext.baseCSSPrefix + &#39;html-editor-input&#39;,
            data: data 
        };    
    },

<span id='Ext-form-field-HtmlEditor-method-createToolbar'>    /**
</span>     * Called when the editor creates its toolbar. Override this method if you need to
     * add custom toolbar buttons.
     * @param {Ext.form.field.HtmlEditor} editor
     * @protected
     */
    createToolbar: function(){
        this.toolbar = Ext.widget(this.getToolbarCfg());
        return this.toolbar;
    },
    
<span id='Ext-form-field-HtmlEditor-method-getToolbarCfg'>    getToolbarCfg: function(){
</span>        var me = this,
            items = [], i,
            tipsEnabled = Ext.quickTipsActive &amp;&amp; Ext.tip.QuickTipManager.isEnabled(),
            baseCSSPrefix = Ext.baseCSSPrefix,
            fontSelectItem, undef;

        function btn(id, toggle, handler){
            return Ext.merge({
                itemId: id,
                cls: baseCSSPrefix + &#39;btn-icon&#39;,
                iconCls: baseCSSPrefix + &#39;edit-&#39;+id,
                enableToggle:toggle !== false,
                scope: me,
                handler:handler||me.relayBtnCmd,
                clickEvent: &#39;mousedown&#39;,
                tooltip: tipsEnabled ? me.buttonTips[id] : undef,
                overflowText: me.buttonTips[id].title || undef,
                tabIndex: -1
            }, me.buttonDefaults);
        }


        if (me.enableFont &amp;&amp; !Ext.isSafari2) {
            fontSelectItem = Ext.widget(&#39;component&#39;, {
                itemId: &#39;fontSelect&#39;,
                renderTpl: [
                    &#39;&lt;select id=&quot;{id}-selectEl&quot; data-ref=&quot;selectEl&quot; class=&quot;&#39; + baseCSSPrefix + &#39;font-select&quot;&gt;&#39;,
                    &#39;&lt;/select&gt;&#39;
                ],
                childEls: [&#39;selectEl&#39;],
                afterRender: function() {
                    me.fontSelect = this.selectEl;
                    Ext.Component.prototype.afterRender.apply(this, arguments);
                },
                onDisable: function() {
                    var selectEl = this.selectEl;
                    if (selectEl) {
                        selectEl.dom.disabled = true;
                    }
                    Ext.Component.prototype.onDisable.apply(this, arguments);
                },
                onEnable: function() {
                    var selectEl = this.selectEl;
                    if (selectEl) {
                        selectEl.dom.disabled = false;
                    }
                    Ext.Component.prototype.onEnable.apply(this, arguments);
                },
                listeners: {
                    change: function() {
                        me.win.focus();
                        me.relayCmd(&#39;fontName&#39;, me.fontSelect.dom.value);
                        me.deferFocus();
                    },
                    element: &#39;selectEl&#39;
                }
            });

            items.push(
                fontSelectItem,
                &#39;-&#39;
            );
        }

        if (me.enableFormat) {
            items.push(
                btn(&#39;bold&#39;),
                btn(&#39;italic&#39;),
                btn(&#39;underline&#39;)
            );
        }

        if (me.enableFontSize) {
            items.push(
                &#39;-&#39;,
                btn(&#39;increasefontsize&#39;, false, me.adjustFont),
                btn(&#39;decreasefontsize&#39;, false, me.adjustFont)
            );
        }

        if (me.enableColors) {
            items.push(
                &#39;-&#39;, Ext.merge({
                    itemId: &#39;forecolor&#39;,
                    cls: baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: baseCSSPrefix + &#39;edit-forecolor&#39;,
                    overflowText: me.buttonTips.forecolor.title,
                    tooltip: tipsEnabled ? me.buttonTips.forecolor || undef : undef,
                    tabIndex:-1,
                    menu: Ext.widget(&#39;menu&#39;, {
                        plain: true,

                        items: [{
                            xtype: &#39;colorpicker&#39;,
                            allowReselect: true,
                            focus: Ext.emptyFn,
                            value: &#39;000000&#39;,
                            plain: true,
                            clickEvent: &#39;mousedown&#39;,
                            handler: function(cp, color) {
                                me.relayCmd(&#39;forecolor&#39;, Ext.isWebKit || Ext.isIE ? &#39;#&#39;+color : color);
                                this.up(&#39;menu&#39;).hide();
                            }
                        }]
                    })
                }, me.buttonDefaults), Ext.merge({
                    itemId: &#39;backcolor&#39;,
                    cls: baseCSSPrefix + &#39;btn-icon&#39;,
                    iconCls: baseCSSPrefix + &#39;edit-backcolor&#39;,
                    overflowText: me.buttonTips.backcolor.title,
                    tooltip: tipsEnabled ? me.buttonTips.backcolor || undef : undef,
                    tabIndex:-1,
                    menu: Ext.widget(&#39;menu&#39;, {
                        plain: true,

                        items: [{
                            xtype: &#39;colorpicker&#39;,
                            focus: Ext.emptyFn,
                            value: &#39;FFFFFF&#39;,
                            plain: true,
                            allowReselect: true,
                            clickEvent: &#39;mousedown&#39;,
                            handler: function(cp, color) {
                                if (Ext.isGecko) {
                                    me.execCmd(&#39;useCSS&#39;, false);
                                    me.execCmd(&#39;hilitecolor&#39;, &#39;#&#39;+color);
                                    me.execCmd(&#39;useCSS&#39;, true);
                                    me.deferFocus();
                                } else {
                                    me.relayCmd(Ext.isOpera ? &#39;hilitecolor&#39; : &#39;backcolor&#39;, Ext.isWebKit || Ext.isIE || Ext.isOpera ? &#39;#&#39;+color : color);
                                }
                                this.up(&#39;menu&#39;).hide();
                            }
                        }]
                    })
                }, me.buttonDefaults)
            );
        }

        if (me.enableAlignments) {
            items.push(
                &#39;-&#39;,
                btn(&#39;justifyleft&#39;),
                btn(&#39;justifycenter&#39;),
                btn(&#39;justifyright&#39;)
            );
        }

        if (!Ext.isSafari2) {
            if (me.enableLinks) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;createlink&#39;, false, me.createLink)
                );
            }

            if (me.enableLists) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;insertorderedlist&#39;),
                    btn(&#39;insertunorderedlist&#39;)
                );
            }
            if (me.enableSourceEdit) {
                items.push(
                    &#39;-&#39;,
                    btn(&#39;sourceedit&#39;, true, function(){
                        me.toggleSourceEdit(!me.sourceEditMode);
                    })
                );
            }
        }
        
        // Everything starts disabled.
        for (i = 0; i &lt; items.length; i++) {
            if (items[i].itemId !== &#39;sourceedit&#39;) {
                items[i].disabled = true;
            }
        }

        // build the toolbar
        // Automatically rendered in Component.afterRender&#39;s renderChildren call
        return {
            xtype: &#39;toolbar&#39;,
            defaultButtonUI: me.defaultButtonUI,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tb&#39;,
            enableOverflow: true,
            items: items,

            // stop form submits
            listeners: {
                click: function(e){
                    e.preventDefault();
                },
                element: &#39;el&#39;
            }
        }; 
    },
    
<span id='Ext-form-field-HtmlEditor-method-getMaskTarget'>    getMaskTarget: function(){
</span>        // Can&#39;t be the body td directly because of issues with absolute positioning
        // inside td&#39;s in FF
        return Ext.isGecko ? this.inputCmp.el : this.bodyEl;
    },

<span id='Ext-form-field-HtmlEditor-method-setReadOnly'>    /**
</span>     * Sets the read only state of this field.
     * @param {Boolean} readOnly Whether the field should be read only.
     */
    setReadOnly: function(readOnly) {
        var me = this,
            textareaEl = me.textareaEl,
            iframeEl = me.iframeEl,
            body;

        me.readOnly = readOnly;

        if (textareaEl) {
            textareaEl.dom.readOnly = readOnly;
        }

        if (me.initialized) {
            body = me.getEditorBody();
            if (Ext.isIE) {
                // Hide the iframe while setting contentEditable so it doesn&#39;t grab focus
                iframeEl.setDisplayed(false);
                body.contentEditable = !readOnly;
                iframeEl.setDisplayed(true);
            } else {
                me.setDesignMode(!readOnly);
            }
            if (body) {
                body.style.cursor = readOnly ? &#39;default&#39; : &#39;text&#39;;
            }
            me.disableItems(readOnly);
        }
    },

<span id='Ext-form-field-HtmlEditor-method-getDocMarkup'>    /**
</span>     * Called when the editor initializes the iframe with HTML contents. Override this method if you
     * want to change the initialization markup of the iframe (e.g. to add stylesheets).
     *
     * **Note:** IE8-Standards has unwanted scroller behavior, so the default meta tag forces IE7 compatibility.
     * Also note that forcing IE7 mode works when the page is loaded normally, but if you are using IE&#39;s Web
     * Developer Tools to manually set the document mode, that will take precedence and override what this
     * code sets by default. This can be confusing when developing, but is not a user-facing issue.
     * @protected
     */
    getDocMarkup: function() {
        var me = this,
            h = me.iframeEl.getHeight() - me.iframePad * 2;

        // - IE9+ require a strict doctype otherwise text outside visible area can&#39;t be selected.
        // - Opera inserts &lt;P&gt; tags on Return key, so P margins must be removed to avoid double line-height.
        // - On browsers other than IE, the font is not inherited by the IFRAME so it must be specified.
        return Ext.String.format(
               &#39;&lt;!DOCTYPE html&gt;&#39; +
               &#39;&lt;html&gt;&lt;head&gt;&lt;style type=&quot;text/css&quot;&gt;&#39; +
               (Ext.isOpera || Ext.isIE ? &#39;p{margin:0;}&#39; : &#39;&#39;) +
               &#39;body{border:0;margin:0;padding:{0}px;direction:&#39; + (me.rtl ? &#39;rtl;&#39; : &#39;ltr;&#39;) +
               (Ext.isIE8 ? Ext.emptyString : &#39;min-&#39;) +
               &#39;height:{1}px;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;cursor:text;background-color:white;&#39; +
               (Ext.isIE ? &#39;&#39; : &#39;font-size:12px;font-family:{2}&#39;) +
               &#39;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;,
            me.iframePad, h, me.defaultFont);
    },

<span id='Ext-form-field-HtmlEditor-method-getEditorBody'>    /**
</span>     * @private
     */
    getEditorBody: function() {
        var doc = this.getDoc();
        return doc.body || doc.documentElement;
    },

<span id='Ext-form-field-HtmlEditor-method-getDoc'>    /**
</span>     * @private
     */
    getDoc: function() {
        return this.iframeEl.dom.contentDocument || this.getWin().document;
    },

<span id='Ext-form-field-HtmlEditor-method-getWin'>    /**
</span>     * @private
     */
    getWin: function() {
        // using window.frames[id] to access the the iframe&#39;s window object in FF creates
        // a global variable with name == id in the global scope that references the iframe
        // window.  This is undesirable for unit testing because that global variable
        // is readonly and cannot be deleted.  To avoid this, we use contentWindow if it
        // is available (and it is in all supported browsers at the time of this writing)
        // and fall back to window.frames if contentWindow is not available.
        return this.iframeEl.dom.contentWindow || window.frames[this.iframeEl.dom.name];
    },
    
<span id='Ext-form-field-HtmlEditor-method-initDefaultFont'>    initDefaultFont: function(){
</span>        // It&#39;s not ideal to do this here since it&#39;s a write phase, but we need to know
        // what the font used in the textarea is so that we can setup the appropriate font
        // options in the select box. The select box will reflow once we populate it, so we want
        // to do so before we layout the first time.
        
        var me = this,
            selIdx = 0,
            fonts, font, select,
            option, i, len, lower;
        
        if (!me.defaultFont) {
            font = me.textareaEl.getStyle(&#39;font-family&#39;);
            font = Ext.String.capitalize(font.split(&#39;,&#39;)[0]);
            fonts = Ext.Array.clone(me.fontFamilies);
            Ext.Array.include(fonts, font);
            fonts.sort();
            me.defaultFont = font;
            
            select = me.down(&#39;#fontSelect&#39;).selectEl.dom;
            for (i = 0, len = fonts.length; i &lt; len; ++i) {
                font = fonts[i];
                lower = font.toLowerCase();
                option = new Option(font, lower);
                if (font === me.defaultFont) {
                    selIdx = i;
                }
                option.style.fontFamily = lower;
                
                if (Ext.isIE) {
                    select.add(option);
                } else {
                    select.options.add(option); 
                }
            }
            // Old IE versions have a problem if we set the selected property
            // in the loop, so set it after.
            select.options[selIdx].selected = true;
        } 
    },
    
<span id='Ext-form-field-HtmlEditor-method-isEqual'>    isEqual: function(value1, value2){
</span>        return this.isEqualAsString(value1, value2);
    },

<span id='Ext-form-field-HtmlEditor-method-afterRender'>    /**
</span>     * @private
     */
    afterRender: function() {
        var me = this,
            inputCmp = me.inputCmp;

        me.callParent(arguments);
          
        me.iframeEl = inputCmp.iframeEl;
        me.textareaEl = inputCmp.textareaEl;
        
        // The input element is interrogated by the layout to extract height when labelAlign is &#39;top&#39;
        // It must be set, and then switched between the iframe and the textarea
        me.inputEl = me.iframeEl;

        if (me.enableFont) {        
            me.initDefaultFont();
        }

        // Start polling for when the iframe document is ready to be manipulated
        me.monitorTask = Ext.TaskManager.start({
            run: me.checkDesignMode,
            scope: me,
            interval: 100
        });
    },

<span id='Ext-form-field-HtmlEditor-method-initFrameDoc'>    initFrameDoc: function() {
</span>        var me = this,
            doc, task;

        Ext.TaskManager.stop(me.monitorTask);

        doc = me.getDoc();
        me.win = me.getWin();

        doc.open();
        doc.write(me.getDocMarkup());
        doc.close();

        task = { // must defer to wait for browser to be ready
            run: function() {
                var doc = me.getDoc();
                if (doc.body || doc.readyState === &#39;complete&#39;) {
                    Ext.TaskManager.stop(task);
                    me.setDesignMode(true);
                    Ext.defer(me.initEditor, 10, me);
                }
            },
            interval: 10,
            duration:10000,
            scope: me
        };
        Ext.TaskManager.start(task);
    },

<span id='Ext-form-field-HtmlEditor-method-checkDesignMode'>    checkDesignMode: function() {
</span>        var me = this,
            doc = me.getDoc();
        if (doc &amp;&amp; (!doc.editorInitialized || me.getDesignMode() !== &#39;on&#39;)) {
            me.initFrameDoc();
        }
    },

<span id='Ext-form-field-HtmlEditor-method-setDesignMode'>    /**
</span>     * @private
     * Sets current design mode. To enable, mode can be true or &#39;on&#39;, off otherwise
     */
    setDesignMode: function(mode) {
        var me = this,
            doc = me.getDoc();
        if (doc) {
            if (me.readOnly) {
                mode = false;
            }
            doc.designMode = (/on|true/i).test(String(mode).toLowerCase()) ?&#39;on&#39;:&#39;off&#39;;
        }
    },

<span id='Ext-form-field-HtmlEditor-method-getDesignMode'>    /**
</span>     * @private
     */
    getDesignMode: function() {
        var doc = this.getDoc();
        return !doc ? &#39;&#39; : String(doc.designMode).toLowerCase();
    },

<span id='Ext-form-field-HtmlEditor-method-disableItems'>    disableItems: function(disabled) {
</span>        var items = this.getToolbar().items.items,
            i,
            iLen  = items.length,
            item;

        for (i = 0; i &lt; iLen; i++) {
            item = items[i];

            if (item.getItemId() !== &#39;sourceedit&#39;) {
                item.setDisabled(disabled);
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-toggleSourceEdit'>    /**
</span>     * Toggles the editor between standard and source edit mode.
     * @param {Boolean} [sourceEditMode] True for source edit, false for standard
     */
    toggleSourceEdit: function(sourceEditMode) {
        var me = this,
            iframe = me.iframeEl,
            textarea = me.textareaEl,
            hiddenCls = Ext.baseCSSPrefix + &#39;hidden&#39;,
            btn = me.getToolbar().getComponent(&#39;sourceedit&#39;);

        if (!Ext.isBoolean(sourceEditMode)) {
            sourceEditMode = !me.sourceEditMode;
        }
        me.sourceEditMode = sourceEditMode;

        if (btn.pressed !== sourceEditMode) {
            btn.toggle(sourceEditMode);
        }
        if (sourceEditMode) {
            me.disableItems(true);
            me.syncValue();
            iframe.addCls(hiddenCls);
            textarea.removeCls(hiddenCls);
            textarea.dom.removeAttribute(&#39;tabIndex&#39;);
            textarea.focus();
            me.inputEl = textarea;
        } else {
            if (me.initialized) {
                me.disableItems(me.readOnly);
            }
            me.pushValue();
            iframe.removeCls(hiddenCls);
            textarea.addCls(hiddenCls);
            textarea.dom.setAttribute(&#39;tabIndex&#39;, -1);
            me.deferFocus();
            me.inputEl = iframe;
        }
        me.fireEvent(&#39;editmodechange&#39;, me, sourceEditMode);
        me.updateLayout();
    },

<span id='Ext-form-field-HtmlEditor-method-createLink'>    /**
</span>     * @private
     */
    createLink: function() {
        var url = prompt(this.createLinkText, this.defaultLinkValue);
        if (url &amp;&amp; url !== &#39;http:/&#39;+&#39;/&#39;) {
            this.relayCmd(&#39;createlink&#39;, url);
        }
    },

<span id='Ext-form-field-HtmlEditor-method-clearInvalid'>    clearInvalid: Ext.emptyFn,
</span>
<span id='Ext-form-field-HtmlEditor-method-setValue'>    setValue: function(value) {
</span>        var me = this,
            textarea = me.textareaEl;

        if (value === null || value === undefined) {
            value = &#39;&#39;;
        }

        // Only update the field if the value has changed
        if (me.value !== value) {
            if (textarea) {
                textarea.dom.value = value;
            }
            me.pushValue();

            if (!me.rendered &amp;&amp; me.inputCmp) {
                me.inputCmp.data.value = value;
            }
            me.mixins.field.setValue.call(me, value);
        }

        return me;
    },

<span id='Ext-form-field-HtmlEditor-method-cleanHtml'>    /**
</span>     * If you need/want custom HTML cleanup, this is the method you should override.
     * @param {String} html The HTML to be cleaned
     * @return {String} The cleaned HTML
     * @protected
     */
    cleanHtml: function(html) {
        html = String(html);
        if (Ext.isWebKit) { // strip safari nonsense
            html = html.replace(this.safariNonsenseRE, &#39;&#39;);
        }

        /*
         * Neat little hack. Strips out all the non-digit characters from the default
         * value and compares it to the character code of the first character in the string
         * because it can cause encoding issues when posted to the server. We need the
         * parseInt here because charCodeAt will return a number.
         */
        if (html.charCodeAt(0) === parseInt(this.defaultValue.replace(this.nonDigitsRE, &#39;&#39;), 10)) {
            html = html.substring(1);
        }
        
        return html;
    },

<span id='Ext-form-field-HtmlEditor-method-syncValue'>    /**
</span>     * Syncs the contents of the editor iframe with the textarea.
     * @protected
     */
    syncValue: function(){
        var me = this,
            body, changed, html, bodyStyle, match, textElDom;

        if (me.initialized) {
            body = me.getEditorBody();
            html = body.innerHTML;
            textElDom = me.textareaEl.dom;

            if (Ext.isWebKit) {
                bodyStyle = body.getAttribute(&#39;style&#39;); // Safari puts text-align styles on the body element!
                match = bodyStyle.match(me.textAlignRE);
                if (match &amp;&amp; match[1]) {
                    html = &#39;&lt;div style=&quot;&#39; + match[0] + &#39;&quot;&gt;&#39; + html + &#39;&lt;/div&gt;&#39;;
                }
            }

            html = me.cleanHtml(html);

            if (me.fireEvent(&#39;beforesync&#39;, me, html) !== false) {
                // Gecko inserts single &lt;br&gt; tag when input is empty
                // and user toggles source mode. See https://sencha.jira.com/browse/EXTJSIV-8542
                if (Ext.isGecko &amp;&amp; textElDom.value === &#39;&#39; &amp;&amp; html === &#39;&lt;br&gt;&#39;) {
                    html = &#39;&#39;;
                }

                if (textElDom.value !== html) {
                    textElDom.value = html;
                    changed = true;
                }

                me.fireEvent(&#39;sync&#39;, me, html);

                if (changed) {
                    // we have to guard this to avoid infinite recursion because getValue
                    // calls this method...
                    me.checkChange();
                }
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-getValue'>    getValue: function() {
</span>        var me = this,
            value;
        if (!me.sourceEditMode) {
            me.syncValue();
        }
        value = me.rendered ? me.textareaEl.dom.value : me.value;
        me.value = value;
        return value;
    },

<span id='Ext-form-field-HtmlEditor-method-pushValue'>    /**
</span>     * Pushes the value of the textarea into the iframe editor.
     * @protected
     */
    pushValue: function() {
        var me = this,
            v;
        if(me.initialized){
            v = me.textareaEl.dom.value || &#39;&#39;;
            if (!me.activated &amp;&amp; v.length &lt; 1) {
                v = me.defaultValue;
            }
            if (me.fireEvent(&#39;beforepush&#39;, me, v) !== false) {
                me.getEditorBody().innerHTML = v;
                if (Ext.isGecko) {
                    // Gecko hack, see: https://bugzilla.mozilla.org/show_bug.cgi?id=232791#c8
                    me.setDesignMode(false);  //toggle off first
                    me.setDesignMode(true);
                }
                me.fireEvent(&#39;push&#39;, me, v);
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-focus'>    focus: function(selectText, delay) {
</span>        var me = this,
            value, focusEl;

        if (delay) {
            if (!me.focusTask) {
                me.focusTask = new Ext.util.DelayedTask(me.focus);
            }
            me.focusTask.delay(Ext.isNumber(delay) ? delay : 10, null, me, [selectText, false]);
        }
        else {
            if (selectText) {
                if (me.textareaEl &amp;&amp; me.textareaEl.dom) {
                    value = me.textareaEl.dom.value;
                }
                if (value &amp;&amp; value.length) {  // Make sure there is content before calling SelectAll, otherwise the caret disappears.
                    me.execCmd(&#39;selectall&#39;, true);
                }
            }
            focusEl = me.getFocusEl();
            if (focusEl &amp;&amp; focusEl.focus) {
                focusEl.focus();
            }
        }
        return me;
    },

<span id='Ext-form-field-HtmlEditor-method-initEditor'>    /**
</span>     * @private
     */
    initEditor: function(){

        var me = this,
            dbody, ss, doc, docEl, fn;

        //Destroying the component during/before initEditor can cause issues.
        if (me.destroying || me.destroyed) {
             return;
        }

        dbody = me.getEditorBody();

        // IE has a null reference when it first comes online.
        if (!dbody) {
            setTimeout(function () {
                me.initEditor();
            }, 10);
            return;
        }

        ss = me.textareaEl.getStyle([&#39;font-size&#39;, &#39;font-family&#39;, &#39;background-image&#39;, &#39;background-repeat&#39;, &#39;background-color&#39;, &#39;color&#39;]);

        ss[&#39;background-attachment&#39;] = &#39;fixed&#39;; // w3c
        dbody.bgProperties = &#39;fixed&#39;; // ie

        Ext.DomHelper.applyStyles(dbody, ss);

        doc = me.getDoc();
        docEl = Ext.get(doc);

        if (docEl) {
            try {
                docEl.clearListeners();
            } catch(e) {}

            /*
             * We need to use createDelegate here, because when using buffer, the delayed task is added
             * as a property to the function. When the listener is removed, the task is deleted from the function.
             * Since onEditorEvent is shared on the prototype, if we have multiple html editors, the first time one of the editors
             * is destroyed, it causes the fn to be deleted from the prototype, which causes errors. Essentially, we&#39;re just anonymizing the function.
             */
            fn = me.onEditorEvent.bind(me);
            docEl.on({
                mousedown: fn,
                dblclick: fn,
                click: fn,
                keyup: fn,
                delegated: false,
                buffer:100
            });

            // These events need to be relayed from the inner document (where they stop
            // bubbling) up to the outer document. This has to be done at the DOM level so
            // the event reaches listeners on elements like the document body. The effected
            // mechanisms that depend on this bubbling behavior are listed to the right
            // of the event.
            fn = me.onRelayedEvent;
            docEl.on({
                mousedown: fn, // menu dismisal (MenuManager) and Window onMouseDown (toFront)
                mousemove: fn, // window resize drag detection
                mouseup: fn,   // window resize termination
                click: fn,     // not sure, but just to be safe
                dblclick: fn,  // not sure again
                delegated: false,
                scope: me
            });

            if (Ext.isGecko) {
                docEl.on(&#39;keypress&#39;, me.applyCommand, me);
            }

            if (me.fixKeys) {
                docEl.on(&#39;keydown&#39;, me.fixKeys, me, {delegated: false});
            }

            if (me.fixKeysAfter) {
                docEl.on(&#39;keyup&#39;, me.fixKeysAfter, me, {delegated: false});
            }

            if (Ext.isIE9) {
                Ext.get(doc.documentElement).on(&#39;focus&#39;, me.focus, me);
            }

            // In old IEs, clicking on a toolbar button shifts focus from iframe
            // and it loses selection. To avoid this, we save current selection
            // and restore it.
            if (Ext.isIE8) {
                docEl.on(&#39;focusout&#39;, function() {
                    me.savedSelection = doc.selection.type !== &#39;None&#39; ? doc.selection.createRange() : null;
                }, me);

                docEl.on(&#39;focusin&#39;, function() {
                    if (me.savedSelection) {
                        me.savedSelection.select();
                    }
                }, me);
            }

            // We need to be sure we remove all our events from the iframe on unload or we&#39;re going to LEAK!
            Ext.getWin().on(&#39;unload&#39;, me.destroyEditor, me);
            doc.editorInitialized = true;

            me.initialized = true;
            me.pushValue();
            me.setReadOnly(me.readOnly);
            me.fireEvent(&#39;initialize&#39;, me);
        }
    },

<span id='Ext-form-field-HtmlEditor-method-destroyEditor'>    /**
</span>     * @private
     */
    destroyEditor: function(){
        var me = this,
            monitorTask = me.monitorTask,
            doc, prop;

        if (monitorTask) {
            Ext.TaskManager.stop(monitorTask);
        }
        if (me.rendered) {
            Ext.getWin().un(&#39;unload&#39;, me.destroyEditor, me);

            doc = me.getDoc();
            if (doc) {
                // removeAll() doesn&#39;t currently know how to handle iframe document,
                // so for now we have to wrap it in an Ext.Element,
                // or else IE6/7 will leak big time when the page is refreshed.
                // TODO: this may not be needed once we find a more permanent fix.
                // see EXTJSIV-5891.
                Ext.get(doc).destroy();

                if (doc.hasOwnProperty) {

                    for (prop in doc) {
                        try {
                            if (doc.hasOwnProperty(prop)) {
                                delete doc[prop];
                            }
                        } catch(e) {
                                // clearing certain props on document MAY throw in IE
                        }
                    }
                }
            }

            delete me.iframeEl;
            delete me.textareaEl;
            delete me.toolbar;
            delete me.inputCmp;
        }
    },

<span id='Ext-form-field-HtmlEditor-method-doDestroy'>    /**
</span>     * @private
     */
    doDestroy: function() {
        this.destroyEditor();
        this.callParent();
    },

<span id='Ext-form-field-HtmlEditor-method-onRelayedEvent'>    /**
</span>     * @private
     */
    onRelayedEvent: function (event) {
        // relay event from the iframe&#39;s document to the document that owns the iframe...

        var iframeEl = this.iframeEl,
            iframeXY = Ext.fly(iframeEl).getTrueXY(),
            originalEventXY = event.getXY(),

            eventXY = event.getXY();

        // the event from the inner document has XY relative to that document&#39;s origin,
        // so adjust it to use the origin of the iframe in the outer document:
        event.xy = [iframeXY[0] + eventXY[0], iframeXY[1] + eventXY[1]];

        event.injectEvent(iframeEl); // blame the iframe for the event...

        event.xy = originalEventXY; // restore the original XY (just for safety)
    },

<span id='Ext-form-field-HtmlEditor-method-onFirstFocus'>    /**
</span>     * @private
     */
    onFirstFocus: function(){
        var me = this,
            selection, range;

        me.activated = true;
        me.disableItems(me.readOnly);
        if (Ext.isGecko) { // prevent silly gecko errors
            me.win.focus();
            selection = me.win.getSelection();

            // If the editor contains a &lt;br&gt; tag, clicking on the editor after the text where
            // the &lt;br&gt; broke the line will produce nodeType === 1 (the body tag).
            // It&#39;s better to check the length of the selection.focusNode&#39;s content.
            //
            // If htmleditor.value = &#39; &#39; (note the space)
            // 1. nodeType === 1
            // 2. nodeName === &#39;BODY&#39;
            // 3. selection.focusNode.textContent.length === 1
            //
            // If htmleditor.value = &#39;&#39; (no chars) nodeType === 3 &amp;&amp; nodeName === &#39;#text&#39;
            // 1. nodeType === 3
            // 2. nodeName === &#39;#text&#39;
            // 3. selection.focusNode.textContent.length === 1 (yes, that&#39;s right, 1)
            //
            // The editor inserts Unicode code point 8203, a zero-width space when
            // htmleditor.value === &#39;&#39; (call selection.focusNode.textContent.charCodeAt(0))
            // http://www.fileformat.info/info/unicode/char/200b/index.htm
            // So, test with framework method to normalize.
            if (selection.focusNode &amp;&amp; !me.getValue().length) {
                range = selection.getRangeAt(0);
                range.selectNodeContents(me.getEditorBody());
                range.collapse(true);
                me.deferFocus();
            }
            try {
                me.execCmd(&#39;useCSS&#39;, true);
                me.execCmd(&#39;styleWithCSS&#39;, false);
            } catch(e) {
                // ignore (why?)
            }
        }
        me.fireEvent(&#39;activate&#39;, me);
    },

<span id='Ext-form-field-HtmlEditor-method-adjustFont'>    /**
</span>     * @private
     */
    adjustFont: function(btn) {
        var adjust = btn.getItemId() === &#39;increasefontsize&#39; ? 1 : -1,
            size = this.getDoc().queryCommandValue(&#39;FontSize&#39;) || &#39;2&#39;,
            isPxSize = Ext.isString(size) &amp;&amp; size.indexOf(&#39;px&#39;) !== -1,
            isSafari;
        size = parseInt(size, 10);
        if (isPxSize) {
            // Safari 3 values
            // 1 = 10px, 2 = 13px, 3 = 16px, 4 = 18px, 5 = 24px, 6 = 32px
            if (size &lt;= 10) {
                size = 1 + adjust;
            }
            else if (size &lt;= 13) {
                size = 2 + adjust;
            }
            else if (size &lt;= 16) {
                size = 3 + adjust;
            }
            else if (size &lt;= 18) {
                size = 4 + adjust;
            }
            else if (size &lt;= 24) {
                size = 5 + adjust;
            }
            else {
                size = 6 + adjust;
            }
            size = Ext.Number.constrain(size, 1, 6);
        } else {
            isSafari = Ext.isSafari;
            if (isSafari) { // safari
                adjust *= 2;
            }
            size = Math.max(1, size + adjust) + (isSafari ? &#39;px&#39; : 0);
        }
        this.relayCmd(&#39;FontSize&#39;, size);
    },

<span id='Ext-form-field-HtmlEditor-method-onEditorEvent'>    /**
</span>     * @private
     */
    onEditorEvent: function() {
        this.updateToolbar();
    },

<span id='Ext-form-field-HtmlEditor-method-updateToolbar'>    /**
</span>     * Triggers a toolbar update by reading the markup state of the current selection in the editor.
     * @protected
     */
    updateToolbar: function() {
        var me = this,
            i, l, btns, doc, name, queriedName, fontSelect,
            toolbarSubmenus;

        if (me.readOnly) {
            return;
        }

        if (!me.activated) {
            me.onFirstFocus();
            return;
        }

        btns = me.getToolbar().items.map;
        doc = me.getDoc();

        if (me.enableFont &amp;&amp; !Ext.isSafari2) {
            // When querying the fontName, Chrome may return an Array of font names
            // with those containing spaces being placed between single-quotes.
            queriedName = doc.queryCommandValue(&#39;fontName&#39;);
            name = (queriedName ? queriedName.split(&quot;,&quot;)[0].replace(me.reStripQuotes, &#39;&#39;) : me.defaultFont).toLowerCase();
            fontSelect = me.fontSelect.dom;
            if (name !== fontSelect.value || name !== queriedName) {
                fontSelect.value = name;
            }
        }

        function updateButtons() {
            var state;
            
            for (i = 0, l = arguments.length, name; i &lt; l; i++) {
                name  = arguments[i];
                
                // Firefox 18+ sometimes throws NS_ERROR_INVALID_POINTER exception
                // See https://sencha.jira.com/browse/EXTJSIV-9766
                try {
                    state = doc.queryCommandState(name);
                }
                catch (e) {
                    state = false;
                }
                
                btns[name].toggle(state);
            }
        }
        if(me.enableFormat){
            updateButtons(&#39;bold&#39;, &#39;italic&#39;, &#39;underline&#39;);
        }
        if(me.enableAlignments){
            updateButtons(&#39;justifyleft&#39;, &#39;justifycenter&#39;, &#39;justifyright&#39;);
        }
        if(!Ext.isSafari2 &amp;&amp; me.enableLists){
            updateButtons(&#39;insertorderedlist&#39;, &#39;insertunorderedlist&#39;);
        }

        // Ensure any of our toolbar&#39;s owned menus are hidden.
        // The overflow menu must control itself.
        toolbarSubmenus = me.toolbar.query(&#39;menu&#39;);
        for (i = 0; i &lt; toolbarSubmenus.length; i++) {
            toolbarSubmenus[i].hide();
        }
        me.syncValue();
    },

<span id='Ext-form-field-HtmlEditor-method-relayBtnCmd'>    /**
</span>     * @private
     */
    relayBtnCmd: function(btn) {
        this.relayCmd(btn.getItemId());
    },

<span id='Ext-form-field-HtmlEditor-method-relayCmd'>    /**
</span>     * Executes a Midas editor command on the editor document and performs necessary focus and toolbar updates.
     * **This should only be called after the editor is initialized.**
     * @param {String} cmd The Midas command
     * @param {String/Boolean} [value=null] The value to pass to the command
     */
    relayCmd: function(cmd, value) {
        Ext.defer(function() {
            var me = this;
            
            if (!this.destroyed) {
                me.win.focus();
                me.execCmd(cmd, value);
                me.updateToolbar();
            }
        }, 10, this);
    },

<span id='Ext-form-field-HtmlEditor-method-execCmd'>    /**
</span>     * Executes a Midas editor command directly on the editor document. For visual commands, you should use
     * {@link #relayCmd} instead. **This should only be called after the editor is initialized.**
     * @param {String} cmd The Midas command
     * @param {String/Boolean} [value=null] The value to pass to the command
     */
    execCmd: function(cmd, value){
        var me = this,
            doc = me.getDoc();
        doc.execCommand(cmd, false, (value === undefined ? null : value));
        me.syncValue();
    },

<span id='Ext-form-field-HtmlEditor-method-applyCommand'>    /**
</span>     * @private
     */
    applyCommand: function(e){
        if (e.ctrlKey) {
            var me = this,
                c = e.getCharCode(), cmd;
            if (c &gt; 0) {
                c = String.fromCharCode(c);
                switch (c) {
                    case &#39;b&#39;:
                        cmd = &#39;bold&#39;;
                    break;
                    case &#39;i&#39;:
                        cmd = &#39;italic&#39;;
                    break;
                    case &#39;u&#39;:
                        cmd = &#39;underline&#39;;
                    break;
                }
                if (cmd) {
                    me.win.focus();
                    me.execCmd(cmd);
                    me.deferFocus();
                    e.preventDefault();
                }
            }
        }
    },

<span id='Ext-form-field-HtmlEditor-method-insertAtCursor'>    /**
</span>     * Inserts the passed text at the current cursor position.
     * __Note:__ the editor must be initialized and activated to insert text.
     * @param {String} text
     */
    insertAtCursor : function(text){
        // adapted from http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div/6691294#6691294
        var me = this,
            win = me.getWin(),
            doc = me.getDoc(),
            sel, range, el, frag, node, lastNode, firstNode;

        if (me.activated) {
            win.focus();
            if (win.getSelection) {
                sel = win.getSelection();
                if (sel.getRangeAt &amp;&amp; sel.rangeCount) {
                    range = sel.getRangeAt(0);
                    range.deleteContents();

                    // Range.createContextualFragment() would be useful here but is
                    // only relatively recently standardized and is not supported in
                    // some browsers (IE9, for one)
                    el = doc.createElement(&quot;div&quot;);
                    el.innerHTML = text;
                    frag = doc.createDocumentFragment();
                    while ((node = el.firstChild)) {
                        lastNode = frag.appendChild(node);
                    }
                    firstNode = frag.firstChild;
                    range.insertNode(frag);

                    // Preserve the selection
                    if (lastNode) {
                        range = range.cloneRange();
                        range.setStartAfter(lastNode);
                        range.collapse(true);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }
            } else if (doc.selection &amp;&amp; sel.type !== &#39;Control&#39;) {
                sel = doc.selection;
                range = sel.createRange();
                range.collapse(true);
                sel.createRange().pasteHTML(text);
            }
            me.deferFocus();
        }
    },

<span id='Ext-form-field-HtmlEditor-property-fixKeys'>    /**
</span>     * @private
     * Load time branching for fastest keydown performance.
     */
    fixKeys: (function () {
        var tag;

        if (Ext.isIE10m) {
            return function (e) {
                var me = this,
                    k = e.getKey(),
                    doc = me.getDoc(),
                    readOnly = me.readOnly,
                    range, target;

                if (k === e.TAB) {
                    e.stopEvent();

                    // TODO: add tab support for IE 11.
                    if (!readOnly) {
                        range = doc.selection.createRange();
                        if (range){
                            if (range.collapse) {
                                range.collapse(true);
                                range.pasteHTML(&#39;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#39;);
                            }

                            me.deferFocus();
                        }
                    }
                }
            };
        }

        if (Ext.isOpera) {
            return function(e) {
                var me = this,
                    k = e.getKey(),
                    readOnly = me.readOnly;

                if (k === e.TAB) {
                    e.stopEvent();

                    if (!readOnly) {
                        me.win.focus();
                        me.execCmd(&#39;InsertHTML&#39;,&#39;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&#39;);
                        me.deferFocus();
                    }
                }
            };
        }

        // Not needed, so null.
        return null;
    }()),

<span id='Ext-form-field-HtmlEditor-property-fixKeysAfter'>    /**
</span>     * @private
     */
    fixKeysAfter: (function () {
        if (Ext.isIE) {
            return function (e) {
                var me = this,
                    k = e.getKey(),
                    doc = me.getDoc(),
                    readOnly = me.readOnly,
                    innerHTML;

                if (!readOnly &amp;&amp; (k === e.BACKSPACE || k === e.DELETE)) {
                    innerHTML = doc.body.innerHTML;

                    // If HtmlEditor had some input and user cleared it, IE inserts &lt;p&gt;&amp;nbsp;&lt;/p&gt;
                    // which makes an impression that there is still some text, and creeps
                    // into source mode when toggled. We don&#39;t want this.
                    //
                    // See https://sencha.jira.com/browse/EXTJSIV-8542
                    //
                    // N.B. There is **small** chance that user could go to source mode,
                    // type &#39;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#39;, switch back to visual mode, type something else
                    // and then clear it -- the code below would clear the &lt;p&gt; tag as well,
                    // which could be considered a bug. However I see no way to distinguish
                    // between offending markup being entered manually and generated by IE,
                    // so this can be considered a nasty corner case.
                    //
                    if (innerHTML === &#39;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&#39; || innerHTML === &#39;&lt;P&gt;&amp;nbsp;&lt;/P&gt;&#39;) {
                        doc.body.innerHTML = &#39;&#39;;
                    }
                }
            };
        }

        return null;
    }()),

<span id='Ext-form-field-HtmlEditor-method-getToolbar'>    /**
</span>     * Returns the editor&#39;s toolbar. **This is only available after the editor has been rendered.**
     * @return {Ext.toolbar.Toolbar}
     */
    getToolbar: function(){
        return this.toolbar;
    },

    //&lt;locale&gt;
<span id='Ext-form-field-HtmlEditor-property-buttonTips'>    /**
</span>     * @property {Object} buttonTips
     * Object collection of toolbar tooltips for the buttons in the editor. The key is the command id associated with
     * that button and the value is a valid QuickTips object. For example:
     *
     *     {
     *         bold: {
     *             title: &#39;Bold (Ctrl+B)&#39;,
     *             text: &#39;Make the selected text bold.&#39;,
     *             cls: &#39;x-html-editor-tip&#39;
     *         },
     *         italic: {
     *             title: &#39;Italic (Ctrl+I)&#39;,
     *             text: &#39;Make the selected text italic.&#39;,
     *             cls: &#39;x-html-editor-tip&#39;
     *         }
     *         // ...
     *     }
     */
    buttonTips: {
        bold: {
            title: &#39;Bold (Ctrl+B)&#39;,
            text: &#39;Make the selected text bold.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        italic: {
            title: &#39;Italic (Ctrl+I)&#39;,
            text: &#39;Make the selected text italic.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        underline: {
            title: &#39;Underline (Ctrl+U)&#39;,
            text: &#39;Underline the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        increasefontsize: {
            title: &#39;Grow Text&#39;,
            text: &#39;Increase the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        decreasefontsize: {
            title: &#39;Shrink Text&#39;,
            text: &#39;Decrease the font size.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        backcolor: {
            title: &#39;Text Highlight Color&#39;,
            text: &#39;Change the background color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        forecolor: {
            title: &#39;Font Color&#39;,
            text: &#39;Change the color of the selected text.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyleft: {
            title: &#39;Align Text Left&#39;,
            text: &#39;Align text to the left.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifycenter: {
            title: &#39;Center Text&#39;,
            text: &#39;Center text in the editor.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        justifyright: {
            title: &#39;Align Text Right&#39;,
            text: &#39;Align text to the right.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertunorderedlist: {
            title: &#39;Bullet List&#39;,
            text: &#39;Start a bulleted list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        insertorderedlist: {
            title: &#39;Numbered List&#39;,
            text: &#39;Start a numbered list.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        createlink: {
            title: &#39;Hyperlink&#39;,
            text: &#39;Make the selected text a hyperlink.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        },
        sourceedit: {
            title: &#39;Source Edit&#39;,
            text: &#39;Switch to source editing mode.&#39;,
            cls: Ext.baseCSSPrefix + &#39;html-editor-tip&#39;
        }
    },
    //&lt;/locale&gt;

    // hide stuff that is not compatible
<span id='Ext-form-field-HtmlEditor-event-blur'>    /**
</span>     * @event blur
     * @private
     */
<span id='Ext-form-field-HtmlEditor-event-focus'>    /**
</span>     * @event focus
     * @private
     */
<span id='Ext-form-field-HtmlEditor-event-specialkey'>    /**
</span>     * @event specialkey
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-fieldCls'>    /**
</span>     * @cfg {String} fieldCls
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-focusCls'>    /**
</span>     * @cfg {String} focusCls
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-autoCreate'>    /**
</span>     * @cfg {String} autoCreate
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-inputType'>    /**
</span>     * @cfg {String} inputType
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-invalidCls'>    /**
</span>     * @cfg {String} invalidCls
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-invalidText'>    /**
</span>     * @cfg {String} invalidText
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-allowDomMove'>    /**
</span>     * @cfg {Boolean} allowDomMove
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-readOnly'>    /**
</span>     * @cfg {String} readOnly
     * @private
     */
<span id='Ext-form-field-HtmlEditor-cfg-tabIndex'>    /**
</span>     * @cfg {String} tabIndex
     * @private
     */
<span id='Ext-form-field-HtmlEditor-method-validate'>    /**
</span>     * @method validate
     * @private
     */

    privates: {
        deferFocus: function(){
            this.focus(false, true);
        },

        getFocusEl: function() {
            return this.sourceEditMode ? this.textareaEl : this.iframeEl;
        }
    }
});

</pre>
</body>
</html>
