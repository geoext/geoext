<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-TreeModel'>/**
</span> * This class is used as a base class from which to derive Models used in Trees.
 */
Ext.define(&#39;Ext.data.TreeModel&#39;, {
    extend: &#39;Ext.data.Model&#39;,
    requires: [
        &#39;Ext.data.NodeInterface&#39;
    ],

    mixins: [
        &#39;Ext.mixin.Queryable&#39;
    ],

<span id='Ext-data-TreeModel-cfg-childType'>    /**
</span>     * @cfg {String} [childType]
     * The class name of child nodes to create when reading child nodes from
     * raw data. By default the type configured into the TreeStore is used.
     *
     * This is one way of creating heterogeneous nodes in a tree.
     *
     * To do this through data types passed from the server, use the {@link Ext.data.reader.Reader#typeProperty}.
     *
     * for example in the case of a hidden root node, you&#39;d use the default type at level zero. See {@link Ext.tree.Panel TreePanel}&#39;s
     * documentation for an example.
     *
     * *Important*
     * If you are using this declaration on your tree models, and have a {@link Ext.tree.Panel#rootVisible hidden root node}, you
     * MUST create a special root model definition which declares the type of its children.
     *
     * If you allow the TreeStore to create a root node of the same type as the first level of *visible* nodes
     * then the reader will atempt to read the wrong type of child node for the root.
     *
     * Example:
     *
     *    Ext.define(&#39;myApp.World&#39;, {
     *        childType: &#39;Territory&#39;
     *    });
     *
     *    ...
     *
     *    store: {
     *        id: &#39;myTreeStore&#39;,
     *        model: &#39;myApp.World&#39; // The hidden root will know to create &#39;Territory&#39; type children.
     *    }
     *
     * If the root is hidden, and the first level of visible nodes are going to be the `myApp.Territory` class,
     * then the hidden root must not be of the `myApp.Territory` class. Otherwise, it would try to read in the
     * territory data as its childType - most likely &#39;Country&#39;.
     *
     */

     getRefItems: function() {
         return this.childNodes;
     },

<span id='Ext-data-TreeModel-method-getRefOwner'>     getRefOwner: function() {
</span>         return this.parentNode;
     },

    statics: {
<span id='Ext-data-TreeModel-static-property-defaultProxy'>        defaultProxy: &#39;memory&#39;
</span>    }
},
function () {
    Ext.data.NodeInterface.decorate(this);
});
</pre>
</body>
</html>
