<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-util-TextMetrics'>/**
</span> * Provides precise pixel measurements for blocks of text so that you can determine 
 * the exact pixel height and width of a block of text. 
 * 
 * **Note:** The TextMetrics tool should only be utilized to measure plain text. Attempting to 
 * measure text that includes HTML may return inaccurate results.
 *
 * This measurement works by copying the relevant font-related CSS styles from the element  
 * param to the TextMetrics&#39; cached measurement element.  This returns the dimensions of the cached
 * element wrapping the text.  By default, the wrapping element is auto-sized.  
 * You must provide a **fixed width** if the passed text is multi-lined.
 *
 * When multiple measurements are being done with the same element styling, you should 
 * create a single, reusable TextMetrics instance.  This is more efficient than using the 
 * static {@link #measure} method.  The element styles are copied to the cached 
 * TextMetrics element once during instantiation versus repeated copying using 
 * _measure()_.
 *
 * The following example demonstrates the recommended use of TextMetrics where the custom 
 * textfield class sets up a reusable TextMetrics instance used to measure the label 
 * width. This example assumes that all instances of _mytextfield_ have the same 
 * {@link Ext.form.Labelable#labelClsExtra labelClsExtra} and 
 * {@link Ext.form.Labelable#labelStyle labelStyle} configs.
 *
 *     Ext.define(&#39;MyApp.view.MyTextField&#39;, {
 *         extend: &#39;Ext.form.field.Text&#39;,
 *         xtype: &#39;mytextfield&#39;,
 *     
 *         initComponent: function () {
 *             var me = this,
 *                 tm = me.getTextMetrics();
 *      
 *             me.labelWidth = tm.getWidth(me.fieldLabel + me.labelSeparator);
 *             me.callParent();
 *         },
 *     
 *         getTextMetrics: function () {
 *             var me = this,
 *                 // Using me.self allows labelCls etc. to vary by derived
 *                 // class, but not by instance.
 *                 cls = me.self,
 *                 tm = cls.measurer,
 *                 el;
 *     
 *             if (!tm) {
 *                 el = Ext.getBody().createChild();
 *                 el.addCls(me.labelCls + &#39; &#39; + me.labelClsExtra).
 *                     applyStyles(me.labelStyle);
 *     
 *                 cls.measurer = tm = new Ext.util.TextMetrics(el);
 *             }
 *     
 *             return tm;
 *         }
 *     });
 *
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         title: &#39;Contact Info&#39;,
 *         width: 600,
 *         bodyPadding: 10,
 *         renderTo: Ext.getBody(),
 *         items: [{
 *             xtype: &#39;mytextfield&#39;,
 *             fieldLabel: &#39;Name&#39;,
 *             labelStyle: &#39;font-size: 10px;&#39;
 *         }, {
 *             xtype: &#39;mytextfield&#39;,
 *             fieldLabel: &#39;Email Address&#39;,
 *             labelStyle: &#39;font-size: 10px;&#39;
 *         }]
 *     });
 *
 * While less efficient than the preceding example, this example allows each instance of 
 * _mytextfield2_ to have unique labelClsExtra and labelStyle configs.  Each custom 
 * textfield instance uses the static TextMetrics measure method which will copy the 
 * label styles repeatedly, thus being less efficient but more versatile.
 *
 *     Ext.define(&#39;MyApp.view.MyTextField2&#39;, {
 *         extend: &#39;Ext.form.field.Text&#39;,
 *         xtype: &#39;mytextfield2&#39;,
 *     
 *         initComponent: function () {
 *             var me = this,
 *                 el = me.getMeasurementEl(),
 *                 tm = Ext.util.TextMetrics;
 *     
 *             me.labelWidth = tm.measure(el, me.fieldLabel + me.labelSeparator).width;
 *             me.callParent();
 *         },
 *        
 *         getMeasurementEl: function () {
 *             var me = this,
 *                 cls = MyApp.view.MyTextField2,
 *                 el = cls.measureEl;
 *     
 *             if (!el) {
 *                 cls.measureEl = el = Ext.getBody().createChild();
 *             }
 *     
 *             el.dom.removeAttribute(&#39;style&#39;);
 *             el.removeCls(el.dom.className).
 *                 addCls(me.labelCls + &#39; &#39; + me.labelClsExtra).
 *                 applyStyles(me.labelStyle);
 *     
 *             return el;
 *         }
 *     });
 *     
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         title: &#39;Contact Info&#39;,
 *         width: 600,
 *         bodyPadding: 10,
 *         renderTo: Ext.getBody(),
 *         items: [{
 *             xtype: &#39;mytextfield2&#39;,
 *             fieldLabel: &#39;Name&#39;,
 *             labelStyle: &#39;font-size: 14px;font-weight: bold;&#39;,
 *             labelClsExtra: &#39;nameLabel&#39;
 *         }, {
 *             xtype: &#39;mytextfield2&#39;,
 *             fieldLabel: &#39;Email Address&#39;,
 *             labelStyle: &#39;font-size: 10px;&#39;,
 *             labelClsExtra: &#39;emailLabel&#39;
 *         }]
 *     });
 */
 Ext.define(&#39;Ext.util.TextMetrics&#39;, {
    requires: [
        &#39;Ext.dom.Element&#39;
    ],

    statics: {
<span id='Ext-util-TextMetrics-static-property-shared'>        shared: null,
</span><span id='Ext-util-TextMetrics-static-method-measure'>        /**
</span>         * Measures the size of the specified text
         * @param {String/HTMLElement} el The element, dom node or id from which to copy existing CSS styles
         * that can affect the size of the rendered text
         * @param {String} text The text to measure
         * @param {Number} fixedWidth (optional) If the text will be multiline, you have to set a fixed width
         * in order to accurately measure the text height
         * @return {Object} An object containing the text&#39;s size `{width: (width), height: (height)}`
         * @static
         */
        measure: function(el, text, fixedWidth){
            var me = this,
                shared = me.shared;
            
            if(!shared){
                shared = me.shared = new me(el, fixedWidth);
            }
            shared.bind(el);
            shared.setFixedWidth(fixedWidth || &#39;auto&#39;);
            return shared.getSize(text);
        },
        
<span id='Ext-util-TextMetrics-static-method-destroy'>        /**
</span>         * Destroy the TextMetrics instance created by {@link #measure}.
         * @static
         */
        destroy: function(){
            var me = this;
            Ext.destroy(me.shared);
            me.shared = null;
        }
    },
    
<span id='Ext-util-TextMetrics-method-constructor'>    /**
</span>     * Creates new TextMetrics.
     * @param {String/HTMLElement/Ext.dom.Element} bindTo The element or its ID to bind to.
     * @param {Number} [fixedWidth] A fixed width to apply to the measuring element.
     */
    constructor: function(bindTo, fixedWidth){
        var me = this,
            measure = Ext.getBody().createChild({
                //&lt;debug&gt;
                // tell the spec runner to ignore this element when checking if the dom is clean 
                &#39;data-sticky&#39;: true,
                //&lt;/debug&gt;
                role: &#39;presentation&#39;,
                cls: Ext.baseCSSPrefix + &#39;textmetrics&#39;
            });

        measure.setVisibilityMode(1);
            
        me.measure = measure; 
        if (bindTo) {
            me.bind(bindTo);
        }
        
        measure.position(&#39;absolute&#39;);
        measure.setLocalXY(-1000, -1000);
        measure.hide();

        if (fixedWidth) {
           measure.setWidth(fixedWidth);
        }
    },
    
<span id='Ext-util-TextMetrics-method-getSize'>    /**
</span>     * Returns the size of the specified text based on the internal element&#39;s style and width properties
     * @param {String} text The text to measure
     * @return {Object} An object containing the text&#39;s size `{width: (width), height: (height)}`
     */
    getSize: function(text){
        var measure = this.measure,
            size;
        
        measure.setHtml(text);
        size = measure.getSize();
        measure.setHtml(&#39;&#39;);
        return size;
    },
    
<span id='Ext-util-TextMetrics-method-bind'>    /**
</span>     * Binds this TextMetrics instance to a new element
     * @param {String/HTMLElement/Ext.dom.Element} el The element or its ID.
     */
    bind: function(el){
        var me = this;
        
        me.el = Ext.get(el);
        me.measure.setStyle(
            me.el.getStyle([&#39;font-size&#39;,&#39;font-style&#39;, &#39;font-weight&#39;, &#39;font-family&#39;,&#39;line-height&#39;, &#39;text-transform&#39;, &#39;letter-spacing&#39;, &#39;word-break&#39;])
        );
    },
    
<span id='Ext-util-TextMetrics-method-setFixedWidth'>    /**
</span>     * Sets a fixed width on the internal measurement element.  If the text will be multiline, you have
     * to set a fixed width in order to accurately measure the text height.
     * @param {Number} width The width to set on the element
     */
     setFixedWidth : function(width){
         this.measure.setWidth(width);
     },
     
<span id='Ext-util-TextMetrics-method-getWidth'>     /**
</span>      * Returns the measured width of the specified text
      * @param {String} text The text to measure
      * @return {Number} width The width in pixels
      */
     getWidth : function(text){
         this.measure.dom.style.width = &#39;auto&#39;;
         return this.getSize(text).width;
     },
     
<span id='Ext-util-TextMetrics-method-getHeight'>     /**
</span>      * Returns the measured height of the specified text
      * @param {String} text The text to measure
      * @return {Number} height The height in pixels
      */
     getHeight : function(text){
         return this.getSize(text).height;
     },
     
<span id='Ext-util-TextMetrics-method-destroy'>     /**
</span>      * Destroy this instance
      */
     destroy: function(){
         var me = this;
         me.el = me.measure = Ext.destroy(me.measure);
         me.callParent();
     }
}, function(){
    Ext.Element.override({
<span id='Ext-dom-Element-method-getTextWidth'>        /**
</span>         * Returns the width in pixels of the passed text, or the width of the text in this Element.
         * @param {String} text The text to measure. Defaults to the innerHTML of the element.
         * @param {Number} [min] The minumum value to return.
         * @param {Number} [max] The maximum value to return.
         * @return {Number} The text width in pixels.
         * @member Ext.dom.Element
         */
        getTextWidth : function(text, min, max){
            return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.valueFrom(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
        }
    });
});
</pre>
</body>
</html>
