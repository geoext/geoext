<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-feature'>/**
</span> * @class Ext.feature
 * @singleton
 *
 * A simple class to verify if a browser feature exists or not on the current device.
 *
 *     if (Ext.feature.has.Canvas) {
 *         // do some cool things with canvas here
 *     }
 *
 * See the {@link #has} property/method for details of the features that can be detected.
 *
 */
Ext.feature = {
// @define Ext.env.Feature
// @define Ext.feature
// @define Ext.supports
// @require Ext.String
// @require Ext.env.Browser
// @require Ext.env.OS

<span id='Ext-feature-method-has'>    /**
</span>     * @method has
     * @member Ext.feature
     * Verifies if a browser feature exists or not on the current device.
     *
     * A &quot;hybrid&quot; property, can be either accessed as a method call, i.e:
     *
     *     if (Ext.feature.has(&#39;Canvas&#39;)) {
     *         // ...
     *     }
     *
     * or as an object with boolean properties, i.e:
     *
     *     if (Ext.feature.has.Canvas) {
     *         // ...
     *     }
     *
     * For possible properties/parameter values see `Ext.supports`.
     *
     * @param {String} name The feature name to check.
     * @return {Boolean}
     */
    has: function (name) {
        return !!this.has[name];
    },

    testElements: {},

    getTestElement: function(tag, createNew) {
        if (tag === undefined) {
            tag = &#39;div&#39;;
        }
        else if (typeof tag !== &#39;string&#39;) {
            return tag;
        }

        if (createNew) {
            return document.createElement(tag);
        }

        if (!this.testElements[tag]) {
            this.testElements[tag] = document.createElement(tag);
        }

        return this.testElements[tag];
    },

    isStyleSupported: function(name, tag) {
        var elementStyle = this.getTestElement(tag).style,
            cName = Ext.String.capitalize(name);

        if (typeof elementStyle[name] !== &#39;undefined&#39; ||
            typeof elementStyle[Ext.browser.getStylePrefix(name) + cName] !== &#39;undefined&#39;) {
            return true;
        }

        return false;
    },

    isStyleSupportedWithoutPrefix: function(name, tag) {
        var elementStyle = this.getTestElement(tag).style;

        if (typeof elementStyle[name] !== &#39;undefined&#39;) {
            return true;
        }

        return false;
    },

    isEventSupported: function(name, tag) {
        if (tag === undefined) {
            tag = window;
        }

        var element = this.getTestElement(tag),
            eventName = &#39;on&#39; + name.toLowerCase(),
            isSupported = (eventName in element);

        if (!isSupported) {
            if (element.setAttribute &amp;&amp; element.removeAttribute) {
                element.setAttribute(eventName, &#39;&#39;);
                isSupported = typeof element[eventName] === &#39;function&#39;;

                if (typeof element[eventName] !== &#39;undefined&#39;) {
                    element[eventName] = undefined;
                }

                element.removeAttribute(eventName);
            }
        }

        return isSupported;
    },

    // This is a local copy of certain logic from Element.getStyle
    // to break a dependancy between the supports mechanism and Element
    // use this instead of element references to check for styling info
    getStyle: function (element, styleName) {
        var view = element.ownerDocument.defaultView,
            style = (view ? view.getComputedStyle(element, null) : element.currentStyle);

        return (style || element.style)[styleName];
    },

    getSupportedPropertyName: function(object, name) {
        var vendorName = Ext.browser.getVendorProperyName(name);

        if (vendorName in object) {
            return vendorName;
        }
        else if (name in object) {
            return name;
        }

        return null;
    },

<span id='Ext-feature-method-detect'>    /**
</span>     * Runs feature detection routines and sets the various flags. This is called when
     * the scripts loads (very early) and again at {@link Ext#onReady}. Some detections
     * can be run immediately. Others that require the document body will not run until
     * domready (these have the `ready` flag set).
     *
     * Each test is run only once, so calling this method from an onReady function is safe
     * and ensures that all flags have been set.
     * @private
     */
    detect: function (isReady) {
        var me = this,
            doc = document,
            toRun = me.toRun || me.tests,
            n = toRun.length,
            div = doc.createElement(&#39;div&#39;),
            notRun = [],
            supports = Ext.supports,
            has = me.has,
            name, names, test, vector, value;

        //&lt;feature legacyBrowser&gt;
        // Only the legacy browser tests use this div so clip this out if we don&#39;t need
        // to use it.
        div.innerHTML =
            &#39;&lt;div style=&quot;height:30px;width:50px;&quot;&gt;&#39; +
                &#39;&lt;div style=&quot;height:20px;width:20px;&quot;&gt;&lt;/div&gt;&#39; +
            &#39;&lt;/div&gt;&#39; +
            &#39;&lt;div style=&quot;width: 200px; height: 200px; position: relative; padding: 5px;&quot;&gt;&#39; +
                &#39;&lt;div style=&quot;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&quot;&gt;&lt;/div&gt;&#39; +
            &#39;&lt;/div&gt;&#39; +
            &#39;&lt;div style=&quot;position: absolute; left: 10%; top: 10%;&quot;&gt;&lt;/div&gt;&#39; +
            &#39;&lt;div style=&quot;float:left; background-color:transparent;&quot;&gt;&lt;/div&gt;&#39;;
        if (isReady) {
            doc.body.appendChild(div);
        }
        //&lt;/feature&gt;

        vector = me.preDetected[Ext.browser.identity] || [];
        while (n--) {
            test = toRun[n];
            value = vector[n];
            name = test.name;
            names = test.names;

            if (value === undefined) {
                if (!isReady &amp;&amp; test.ready) {
                    // test requires domready state
                    notRun.push(test);
                    continue;
                }

                value = test.fn.call(me, doc, div);
            }

            // Store test results on Ext.supports and Ext.feature.has
            if (name) {
                supports[name] = has[name] = value;
            } else if (names) {
                while (names.length) {
                    name = names.pop();
                    supports[name] = has[name] = value;
                }
            }
        }

        if (isReady) {
            doc.body.removeChild(div);
        }

        me.toRun = notRun;
    },

    //&lt;/debug&gt;
    report: function () {
        var values = [],
            len = this.tests.length,
            i;

        for (i = 0; i &lt; len; ++i) {
            values.push(this.has[this.tests[i].name] ? 1 : 0);
        }

        Ext.log(Ext.browser.identity + &#39;: [&#39; + values.join(&#39;,&#39;) + &#39;]&#39;);
    },
    //&lt;/debug&gt;

    preDetected: {
        // TODO
    },

<span id='Ext-supports'>    /**
</span>     * @class Ext.supports
     *
     * Contains information about features supported in the current environment as well
     * as bugs detected.
     *
     * @singleton
     */
    tests: [{
<span id='Ext-supports-property-CloneNodeCopiesExpando'>        /**
</span>         * @property CloneNodeCopiesExpando `true` if the native DOM cloneNode method copies
         * expando properties to the newly cloned node.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;CloneNodeCopiesExpando&#39;,
        fn: function() {
            var el = document.createElement(&#39;div&#39;);
            el.expandoProp = {};
            return el.cloneNode().expandoProp === el.expandoProp;
        }
    }, {
<span id='Ext-supports-property-CSSPointerEvents'>        /**
</span>         * @property CSSPointerEvents `true` if document environment supports the CSS3
         * pointer-events style.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;CSSPointerEvents&#39;,
        fn: function (doc) {
            return &#39;pointerEvents&#39; in doc.documentElement.style;
        }
    },{
<span id='Ext-supports-property-CSS3BoxShadow'>        /**
</span>         * @property CSS3BoxShadow `true` if document environment supports the CSS3
         * box-shadow style.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;CSS3BoxShadow&#39;,
        fn: function (doc) {
            return &#39;boxShadow&#39; in doc.documentElement.style || &#39;WebkitBoxShadow&#39; in doc.documentElement.style || &#39;MozBoxShadow&#39; in doc.documentElement.style;
        }
    }, {
        name: &#39;CSS3NegationSelector&#39;,
        fn: function(doc) {
            try {
                doc.querySelectorAll(&quot;foo:not(bar)&quot;);
            }
            catch (e) {
                return false;
            }

            return true;
        }
    },{
<span id='Ext-supports-property-ClassList'>        /**
</span>         * @property ClassList `true` if document environment supports the HTML5
         * classList API.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;ClassList&#39;,
        fn: function (doc) {
            return !!doc.documentElement.classList;
        }
    },{
<span id='Ext-supports-property-Canvas'>        /**
</span>         * @property Canvas `true` if the device supports Canvas.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;Canvas&#39;,
        fn: function() {
            var element = this.getTestElement(&#39;canvas&#39;);
            return !!(element &amp;&amp; element.getContext &amp;&amp; element.getContext(&#39;2d&#39;));
        }
    },{
<span id='Ext-supports-property-Svg'>        /**
</span>         * @property Svg `true` if the device supports SVG.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;Svg&#39;,
        fn: function(doc) {
            return !!(doc.createElementNS &amp;&amp; !!doc.createElementNS(&quot;http:/&quot; + &quot;/www.w3.org/2000/svg&quot;, &quot;svg&quot;).createSVGRect);
        }
    },{
<span id='Ext-supports-property-Vml'>        /**
</span>         * @property Vml `true` if the device supports VML.
         * @type {Boolean}
         *
         * This property is available at application boot time, before document ready.
         */
        name: &#39;Vml&#39;,
        fn: function() {
            var element = this.getTestElement(),
                ret = false;

            element.innerHTML = &quot;&lt;!--[if vml]&gt;&lt;br&gt;&lt;![endif]--&gt;&quot;;
            ret = (element.childNodes.length === 1);
            element.innerHTML = &quot;&quot;;

            return ret;
        }
    },{
<span id='Ext-supports-property-Touch'>        /**
</span>         * @property Touch `true` if the browser supports touch input.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;Touch&#39;,
        fn: function() {
            // IE10 uses a vendor-prefixed maxTouchPoints property
            var maxTouchPoints = navigator.msMaxTouchPoints || navigator.maxTouchPoints;
            // if the browser has touch events we can be reasonably sure the device has
            // a touch screen
            // browsers that use pointer event have maxTouchPoints &gt; 1 if the
            // device supports touch input
            // Chrome Desktop &lt; 39 reports maxTouchPoints === 1 even if there is no
            // touch support on the device
            // http://www.w3.org/TR/pointerevents/#widl-Navigator-maxTouchPoints
            // Chrome Desktop &gt; 39 properly reports maxTouchPoints === 0 and
            // Chrome Desktop Device Emulation mode reports maxTouchPoints === 1
            if (Ext.browser.is.Chrome &amp;&amp; Ext.browser.version.isLessThanOrEqual(39)) {
                return (Ext.supports.TouchEvents &amp;&amp; maxTouchPoints !== 1) ||
                    maxTouchPoints &gt; 1;
            } else {
                return Ext.supports.TouchEvents || maxTouchPoints &gt; 0;
            }
        }
    },{
<span id='Ext-supports-property-TouchEvents'>        /**
</span>         * @property TouchEvents `true` if the device supports touch events (`touchstart`,
         * `touchmove`, `touchend`).
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;TouchEvents&#39;,
        fn: function() {
            return this.isEventSupported(&#39;touchend&#39;);
        }
    },{
        name: &#39;PointerEvents&#39;,
        fn: function() {
            return navigator.pointerEnabled;
        }
    },{
        name: &#39;MSPointerEvents&#39;,
        fn: function() {
            return navigator.msPointerEnabled;
        }
    },{
<span id='Ext-supports-property-Orientation'>        /**
</span>         * @property Orientation `true` if the device supports different orientations.
         * @type {Boolean}
         *
         * This property is available at application boot time, before document ready.
         */
        name: &#39;Orientation&#39;,
        fn: function() {
            return (&#39;orientation&#39; in window) &amp;&amp; this.isEventSupported(&#39;orientationchange&#39;);
        }
    },{
<span id='Ext-supports-property-OrientationChange'>        /**
</span>         * @property OrientationChange `true` if the device supports the `orientationchange`
         * event.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;OrientationChange&#39;,
        fn: function() {
            return this.isEventSupported(&#39;orientationchange&#39;);
        }
    },{
<span id='Ext-supports-property-DeviceMotion'>        /**
</span>         * @property DeviceMotion `true` if the device supports device motion (acceleration
         * and rotation rate).
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;DeviceMotion&#39;,
        fn: function() {
            return this.isEventSupported(&#39;devicemotion&#39;);
        }
    },{
<span id='Ext-supports-property-Geolocation'>        /**
</span>         * @property Geolocation `true` if the device supports GeoLocation.
         * @type {Boolean}
         *
         * This property is available at application boot time, before document ready.
         */
<span id='Ext-supports-property-GeoLocation'>        /**
</span>         * @property GeoLocation `true` if the device supports Geo-location.
         * @type {Boolean}
         * @deprecated Use `Geolocation` instead (notice the lower-casing of &#39;L&#39;).
         */
        names: [ &#39;Geolocation&#39;, &#39;GeoLocation&#39; ],
        fn: function() {
            return &#39;geolocation&#39; in window.navigator;
        }
    },{
        name: &#39;SqlDatabase&#39;,
        fn: function() {
            return &#39;openDatabase&#39; in window;
        }
    },{
        name: &#39;WebSockets&#39;,
        fn: function() {
            return &#39;WebSocket&#39; in window;
        }
    },{
<span id='Ext-supports-property-Range'>        /**
</span>         * @property Range `true` if browser support document.createRange native method.
         * See https://developer.mozilla.org/en/DOM/range.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;Range&#39;,
        fn: function() {
            return !!document.createRange;
        }
    },{
<span id='Ext-supports-property-CreateContextualFragment'>        /**
</span>         * @property CreateContextualFragment `true` if browser support CreateContextualFragment
         * range native methods.
         * See https://developer.mozilla.org/en/DOM/range.createContextualFragment
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;CreateContextualFragment&#39;,
        fn: function() {
            var range = !!document.createRange ? document.createRange() : false;
            return range &amp;&amp; !!range.createContextualFragment;
        }
    },{
<span id='Ext-supports-property-History'>        /**
</span>         * @property History `true` if the device supports HTML5 history. See
         * https://developer.mozilla.org/en/DOM/Manipulating_the_browser_history
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;History&#39;,
        fn: function() {
            return (&#39;history&#39; in window &amp;&amp; &#39;pushState&#39; in window.history);
        }
    },{
<span id='Ext-supports-property-Css3DTransforms'>        /**
</span>         * @property Css3DTransforms `true` if the device supports CSS3DTransform.
         * @type {Boolean}
         *
         * This property is available at application boot time, before document ready.
         */
        name: &#39;Css3dTransforms&#39;,
        fn: function() {
            // See https://sencha.jira.com/browse/TOUCH-1544
            return this.has(&#39;CssTransforms&#39;) &amp;&amp; this.isStyleSupported(&#39;perspective&#39;);
            // TODO - double check vs Ext JS flavor:
            //return (typeof WebKitCSSMatrix != &#39;undefined&#39; &amp;&amp; new WebKitCSSMatrix().hasOwnProperty(&#39;m41&#39;));
        }
    },{
        // Important that this goes after Css3dTransforms, since tests are run in reverse order
        name: &#39;CssTransforms&#39;,
        fn: function() {
            return this.isStyleSupported(&#39;transform&#39;);
        }
    },{
        name: &#39;CssTransformNoPrefix&#39;,
        fn: function() {
            return this.isStyleSupportedWithoutPrefix(&#39;transform&#39;);
        }
    },{
        name: &#39;CssAnimations&#39;,
        fn: function() {
            return this.isStyleSupported(&#39;animationName&#39;);
        }
    },{
<span id='Ext-supports-property-Transitions'>        /**
</span>         * @property Transitions `true` if the device supports CSS3 Transitions.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        names: [ &#39;CssTransitions&#39;, &#39;Transitions&#39; ],
        fn: function() {
            return this.isStyleSupported(&#39;transitionProperty&#39;);
        }
    },{
<span id='Ext-supports-property-Audio'>        /**
</span>         * @property Audio `true` if the device supports the HTML5 `audio` tag.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
<span id='Ext-supports-property-AudioTag'>        /**
</span>         * @property AudioTag `true` if the device supports the HTML5 `audio` tag.
         * @type {Boolean}
         * @deprecated Use `Audio` instead.
         */
        names: [ &#39;Audio&#39;, &#39;AudioTag&#39; ],
        fn: function() {
            return !!this.getTestElement(&#39;audio&#39;).canPlayType;
        }
    },{
<span id='Ext-supports-property-Video'>        /**
</span>         * @property Video `true` if the device supports the HTML5 `video` tag.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;Video&#39;,
        fn: function() {
            return !!this.getTestElement(&#39;video&#39;).canPlayType;
        }
    },{
<span id='Ext-supports-property-LocalStorage'>        /**
</span>         * @property LocalStorage `true` if localStorage is supported.
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;LocalStorage&#39;,
        fn: function() {
            try {
                // IE10/Win8 throws &quot;Access Denied&quot; accessing window.localStorage, so
                // this test needs to have a try/catch
                if (&#39;localStorage&#39; in window &amp;&amp; window[&#39;localStorage&#39;] !== null) { // jshint ignore:line
                    //this should throw an error in private browsing mode in iOS as well
                    localStorage.setItem(&#39;sencha-localstorage-test&#39;, &#39;test success&#39;);
                    //clean up if setItem worked
                    localStorage.removeItem(&#39;sencha-localstorage-test&#39;);
                    return true;
                }
            } catch ( e ) {
                // ignore
            }

            return false;
        }
    },{
<span id='Ext-supports-property-XHR2'>        /**
</span>         * @property XHR2 `true` if the browser supports XMLHttpRequest
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;XHR2&#39;,
        fn: function() {
          return window.ProgressEvent &amp;&amp; window.FormData &amp;&amp; window.XMLHttpRequest &amp;&amp;
              (&#39;withCredentials&#39; in new XMLHttpRequest());
        }
    }, {
<span id='Ext-supports-property-XHRUploadProgress'>        /**
</span>         * @property XHRUploadProgress `true` if the browser supports XMLHttpRequest
         * upload progress info
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;XHRUploadProgress&#39;,
        fn: function() {
            if(window.XMLHttpRequest &amp;&amp; !Ext.browser.is.AndroidStock) {
                var xhr = new XMLHttpRequest();
                return xhr &amp;&amp; (&#39;upload&#39; in xhr) &amp;&amp; (&#39;onprogress&#39; in xhr.upload);
            }
            return false;
        }
    }, {
<span id='Ext-supports-property-NumericInputPlaceHolder'>        /**
</span>         * @property NumericInputPlaceHolder `true` if the browser supports placeholders
         * on numeric input fields
         *
         * This property is available at application boot time, before document ready.
         * @type {Boolean}
         */
        name: &#39;NumericInputPlaceHolder&#39;,
        fn: function() {
            return !(Ext.browser.is.AndroidStock4 &amp;&amp; Ext.os.version.getMinor() &lt; 2);
        }
    },

<span id='Ext-supports-property-matchesSelector'>    /**
</span>     * @property {String} matchesSelector
     * The method name which matches an element against a selector if implemented in this environment.
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;matchesSelector&#39;,
        fn: function() {
            var el = document.documentElement,
                w3 = &#39;matches&#39;,
                wk = &#39;webkitMatchesSelector&#39;,
                ms = &#39;msMatchesSelector&#39;,
                mz = &#39;mozMatchesSelector&#39;;

            return el[w3] ? w3 : el[wk] ? wk : el[ms] ? ms : el[mz] ? mz : null;
        }
    },

    //&lt;feature legacyBrowser&gt;
<span id='Ext-supports-property-RightMargin'>    /**
</span>     * @property RightMargin `true` if the device supports right margin.
     * See https://bugs.webkit.org/show_bug.cgi?id=13343 for why this is needed.
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     * @type {Boolean}
     */
    {
        name: &#39;RightMargin&#39;,
        ready: true,
        fn: function(doc, div) {
            var view = doc.defaultView;
            return !(view &amp;&amp; view.getComputedStyle(div.firstChild.firstChild, null).marginRight !== &#39;0px&#39;);
        }
    },

<span id='Ext-supports-property-DisplayChangeInputSelectionBug'>    /**
</span>     * @property DisplayChangeInputSelectionBug `true` if INPUT elements lose their
     * selection when their display style is changed. Essentially, if a text input
     * has focus and its display style is changed, the I-beam disappears.
     *
     * This bug is encountered due to the work around in place for the {@link #RightMargin}
     * bug. This has been observed in Safari 4.0.4 and older, and appears to be fixed
     * in Safari 5. It&#39;s not clear if Safari 4.1 has the bug, but it has the same WebKit
     * version number as Safari 5 (according to http://unixpapa.com/js/gecko.html).
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;DisplayChangeInputSelectionBug&#39;,
        fn: function() {
            var webKitVersion = Ext.webKitVersion;
            // WebKit but older than Safari 5 or Chrome 6:
            return 0 &lt; webKitVersion &amp;&amp; webKitVersion &lt; 533;
        }
    },

<span id='Ext-supports-property-DisplayChangeTextAreaSelectionBug'>    /**
</span>     * @property DisplayChangeTextAreaSelectionBug `true` if TEXTAREA elements lose their
     * selection when their display style is changed. Essentially, if a text area has
     * focus and its display style is changed, the I-beam disappears.
     *
     * This bug is encountered due to the work around in place for the {@link #RightMargin}
     * bug. This has been observed in Chrome 10 and Safari 5 and older, and appears to
     * be fixed in Chrome 11.
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;DisplayChangeTextAreaSelectionBug&#39;,
        fn: function() {
            var webKitVersion = Ext.webKitVersion;

            /*
            Has bug w/textarea:

            (Chrome) Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_7; en-US)
                        AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.127
                        Safari/534.16
            (Safari) Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_7; en-us)
                        AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5
                        Safari/533.21.1

            No bug:

            (Chrome) Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7)
                        AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.57
                        Safari/534.24
            */
            return 0 &lt; webKitVersion &amp;&amp; webKitVersion &lt; 534.24;
        }
    },

<span id='Ext-supports-property-TransparentColor'>    /**
</span>     * @property TransparentColor `true` if the device supports transparent color.
     * @type {Boolean}
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     */
    {
        name: &#39;TransparentColor&#39;,
        ready: true,
        fn: function(doc, div, view) {
            view = doc.defaultView;
            return !(view &amp;&amp; view.getComputedStyle(div.lastChild, null).backgroundColor !== &#39;transparent&#39;);
        }
    },

<span id='Ext-supports-property-ComputedStyle'>    /**
</span>     * @property ComputedStyle `true` if the browser supports document.defaultView.getComputedStyle().
     * @type {Boolean}
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     */
    {
        name: &#39;ComputedStyle&#39;,
        ready: true,
        fn: function(doc, div, view) {
            view = doc.defaultView;
            return view &amp;&amp; view.getComputedStyle;
        }
    },

<span id='Ext-supports-property-Float'>    /**
</span>     * @property Float `true` if the device supports CSS float.
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;Float&#39;,
        fn: function(doc) {
            return &#39;cssFloat&#39; in doc.documentElement.style;
        }
    },

<span id='Ext-supports-property-CSS3BorderRadius'>    /**
</span>     * @property CSS3BorderRadius `true` if the device supports CSS3 border radius.
     * @type {Boolean}
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     */
    {
        name: &#39;CSS3BorderRadius&#39;,
        ready: true,
        fn: function(doc) {
            var domPrefixes = [&#39;borderRadius&#39;, &#39;BorderRadius&#39;, &#39;MozBorderRadius&#39;,
                               &#39;WebkitBorderRadius&#39;, &#39;OBorderRadius&#39;, &#39;KhtmlBorderRadius&#39;],
                pass = false,
                i;
            for (i = 0; i &lt; domPrefixes.length; i++) {
                if (doc.documentElement.style[domPrefixes[i]] !== undefined) {
                    pass = true;
                }
            }
            return pass &amp;&amp; !Ext.isIE9;
        }
    },

<span id='Ext-supports-property-CSS3LinearGradient'>    /**
</span>     * @property CSS3LinearGradient `true` if the device supports CSS3 linear gradients.
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;CSS3LinearGradient&#39;,
        fn: function(doc, div) {
            var property = &#39;background-image:&#39;,
                webkit   = &#39;-webkit-gradient(linear, left top, right bottom, from(black), to(white))&#39;,
                w3c      = &#39;linear-gradient(left top, black, white)&#39;,
                moz      = &#39;-moz-&#39; + w3c,
                ms       = &#39;-ms-&#39; + w3c,
                opera    = &#39;-o-&#39; + w3c,
                options  = [property + webkit, property + w3c, property + moz, property + ms, property + opera];

            div.style.cssText = options.join(&#39;;&#39;);

            return ((&quot;&quot; + div.style.backgroundImage).indexOf(&#39;gradient&#39;) !== -1) &amp;&amp; !Ext.isIE9;
        }
    },

<span id='Ext-supports-property-MouseEnterLeave'>    /**
</span>     * @property MouseEnterLeave `true` if the browser supports mouseenter and mouseleave events
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;MouseEnterLeave&#39;,
        fn: function(doc){
            return (&#39;onmouseenter&#39; in doc.documentElement &amp;&amp; &#39;onmouseleave&#39; in doc.documentElement);
        }
    },

<span id='Ext-supports-property-MouseWheel'>    /**
</span>     * @property MouseWheel `true` if the browser supports the mousewheel event
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;MouseWheel&#39;,
        fn: function(doc) {
            return (&#39;onmousewheel&#39; in doc.documentElement);
        }
    },

<span id='Ext-supports-property-Opacity'>    /**
</span>     * @property Opacity `true` if the browser supports normal css opacity
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;Opacity&#39;,
        fn: function(doc, div){
            // Not a strict equal comparison in case opacity can be converted to a number.
            if (Ext.isIE8) {
                return false;
            }
            div.firstChild.style.cssText = &#39;opacity:0.73&#39;;
            return div.firstChild.style.opacity == &#39;0.73&#39;; // jshint ignore:line
        }
    },

<span id='Ext-supports-property-Placeholder'>    /**
</span>     * @property Placeholder `true` if the browser supports the HTML5 placeholder attribute on inputs
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;Placeholder&#39;,
        fn: function(doc) {
            return &#39;placeholder&#39; in doc.createElement(&#39;input&#39;);
        }
    },

<span id='Ext-supports-property-Direct2DBug'>    /**
</span>     * @property Direct2DBug `true` if when asking for an element&#39;s dimension via offsetWidth or offsetHeight,
     * getBoundingClientRect, etc. the browser returns the subpixel width rounded to the nearest pixel.
     *
     * This property is available at application boot time, before document ready.
     * @type {Boolean}
     */
    {
        name: &#39;Direct2DBug&#39;,
        fn: function(doc) {
            return Ext.isString(doc.documentElement.style.msTransformOrigin) &amp;&amp; Ext.isIE9m;
        }
    },

<span id='Ext-supports-property-BoundingClientRect'>    /**
</span>     * @property BoundingClientRect `true` if the browser supports the getBoundingClientRect method on elements
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;BoundingClientRect&#39;,
        fn: function(doc) {
            return &#39;getBoundingClientRect&#39; in doc.documentElement;
        }
    },

<span id='Ext-supports-property-RotatedBoundingClientRect'>    /**
</span>     * @property RotatedBoundingClientRect `true` if the BoundingClientRect is
     * rotated when the element is rotated using a CSS transform.
     * @type {Boolean}
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     */
    {
        name: &#39;RotatedBoundingClientRect&#39;,
        ready: true,
        fn: function(doc) {
            var body = doc.body,
                supports = false,
                el = doc.createElement(&#39;div&#39;),
                style = el.style;

            if (el.getBoundingClientRect) {
                // If the document body already has child nodes (text nodes etc) we can end
                // up with subpixel rounding errors in IE11 when measuring the height.
                // Absolute positioning prevents this.
                style.position = &#39;absolute&#39;;
                style.top = &quot;0&quot;;
                style.WebkitTransform = style.MozTransform = style.msTransform =
                    style.OTransform = style.transform = &#39;rotate(90deg)&#39;;
                style.width = &#39;100px&#39;;
                style.height = &#39;30px&#39;;
                body.appendChild(el);

                supports = el.getBoundingClientRect().height !== 100;
                body.removeChild(el);
            }

            return supports;
        }
    },
<span id='Ext-supports-property-ChildContentClearedWhenSettingInnerHTML'>    /**
</span>     * @property ChildContentClearedWhenSettingInnerHTML `true` if created child elements
     * lose their innerHTML when modifying the innerHTML of the parent element.
     * @type {Boolean}
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     */
    {
        name: &#39;ChildContentClearedWhenSettingInnerHTML&#39;,
        ready: true,
        fn: function() {
            var el = this.getTestElement(),
                child;

            el.innerHTML = &#39;&lt;div&gt;a&lt;/div&gt;&#39;;
            child = el.firstChild;
            el.innerHTML = &#39;&lt;div&gt;b&lt;/div&gt;&#39;;
            return child.innerHTML !== &#39;a&#39;;

        }
    },
    {
        name: &#39;IncludePaddingInWidthCalculation&#39;,
        ready: true,
        fn: function(doc, div){
            return div.childNodes[1].firstChild.offsetWidth === 210;
        }
    },
    {
        name: &#39;IncludePaddingInHeightCalculation&#39;,
        ready: true,
        fn: function(doc, div){
            return div.childNodes[1].firstChild.offsetHeight === 210;
        }
    },

<span id='Ext-supports-property-TextAreaMaxLength'>    /**
</span>     * @property TextAreaMaxLength `true` if the browser supports maxlength on textareas.
     * @type {Boolean}
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;TextAreaMaxLength&#39;,
        fn: function(doc){
            return (&#39;maxlength&#39; in doc.createElement(&#39;textarea&#39;));
        }
    },
<span id='Ext-supports-property-GetPositionPercentage'>    /**
</span>     * @property GetPositionPercentage `true` if the browser will return the left/top/right/bottom
     * position as a percentage when explicitly set as a percentage value.
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     * @type {Boolean}
     */
    // Related bug: https://bugzilla.mozilla.org/show_bug.cgi?id=707691#c7
    {
        name: &#39;GetPositionPercentage&#39;,
        ready: true,
        fn: function(doc, div){
           return Ext.feature.getStyle(div.childNodes[2], &#39;left&#39;) === &#39;10%&#39;;
        }
    },
<span id='Ext-supports-property-PercentageHeightOverflowBug'>    /**
</span>     * @property {Boolean} PercentageHeightOverflowBug
     * In some browsers (IE quirks, IE6, IE7, IE9, chrome, safari and opera at the time
     * of this writing) a percentage-height element ignores the horizontal scrollbar
     * of its parent element.  This method returns true if the browser is affected
     * by this bug.
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     * @private
     */
    {
        name: &#39;PercentageHeightOverflowBug&#39;,
        ready: true,
        fn: function(doc) {
            var hasBug = false,
                style, el;

            if (Ext.getScrollbarSize().height) {
                // must have space-consuming scrollbars for bug to be possible
                el = this.getTestElement();
                style = el.style;
                style.height = &#39;50px&#39;;
                style.width = &#39;50px&#39;;
                style.overflow = &#39;auto&#39;;
                style.position = &#39;absolute&#39;;

                el.innerHTML = [
                    &#39;&lt;div style=&quot;display:table;height:100%;&quot;&gt;&#39;,
                        // The element that causes the horizontal overflow must be 
                        // a child of the element with the 100% height, otherwise
                        // horizontal overflow is not triggered in webkit quirks mode
                        &#39;&lt;div style=&quot;width:51px;&quot;&gt;&lt;/div&gt;&#39;,
                    &#39;&lt;/div&gt;&#39;
                ].join(&#39;&#39;);
                doc.body.appendChild(el);
                if (el.firstChild.offsetHeight === 50) {
                    hasBug = true;
                }
                doc.body.removeChild(el);
            }

            return hasBug;
        }
    },

<span id='Ext-supports-property-xOriginBug'>    /**
</span>     * @property {Boolean} xOriginBug
     * In Chrome 24.0, an RTL element which has vertical overflow positions its right X origin incorrectly.
     * It skips a non-existent scrollbar which has been moved to the left edge due to the RTL setting.
     *
     * http://code.google.com/p/chromium/issues/detail?id=174656
     *
     * This method returns true if the browser is affected by this bug.
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     * @private
     */
    {
        name: &#39;xOriginBug&#39;,
        ready: true,
        fn: function(doc, div) {
           div.innerHTML = &#39;&lt;div id=&quot;b1&quot; style=&quot;height:100px;width:100px;direction:rtl;position:relative;overflow:scroll&quot;&gt;&#39; +
                &#39;&lt;div id=&quot;b2&quot; style=&quot;position:relative;width:100%;height:20px;&quot;&gt;&lt;/div&gt;&#39; +
                &#39;&lt;div id=&quot;b3&quot; style=&quot;position:absolute;width:20px;height:20px;top:0px;right:0px&quot;&gt;&lt;/div&gt;&#39; +
            &#39;&lt;/div&gt;&#39;;

            var outerBox = document.getElementById(&#39;b1&#39;).getBoundingClientRect(),
                b2 = document.getElementById(&#39;b2&#39;).getBoundingClientRect(),
                b3 = document.getElementById(&#39;b3&#39;).getBoundingClientRect();

            return (b2.left !== outerBox.left &amp;&amp; b3.right !== outerBox.right);
        }
    },

<span id='Ext-supports-property-ScrollWidthInlinePaddingBug'>    /**
</span>     * @property {Boolean} ScrollWidthInlinePaddingBug
     * In some browsers the right padding of an overflowing element is not accounted
     * for in its scrollWidth.  The result can vary depending on whether or not
     * The element contains block-level children.  This method tests the effect
     * of padding on scrollWidth when there are no block-level children inside the
     * overflowing element.
     *
     * This method returns true if the browser is affected by this bug.
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     */
    {
        name: &#39;ScrollWidthInlinePaddingBug&#39;,
        ready: true,
        fn: function(doc) {
            var hasBug = false,
                style, el;

            el = doc.createElement(&#39;div&#39;);
            style = el.style;
            style.height = &#39;50px&#39;;
            style.width = &#39;50px&#39;;
            style.padding = &#39;10px&#39;;
            style.overflow = &#39;hidden&#39;;
            style.position = &#39;absolute&#39;;

            el.innerHTML =
                &#39;&lt;span style=&quot;display:inline-block;zoom:1;height:60px;width:60px;&quot;&gt;&lt;/span&gt;&#39;;
            doc.body.appendChild(el);
            if (el.scrollWidth === 70) {
                hasBug = true;
            }
            doc.body.removeChild(el);

            return hasBug;
        }
    },

<span id='Ext-supports-property-rtlVertScrollbarOnRight'>    /**
</span>     * @property {Boolean} rtlVertScrollbarOnRight
     * Safari, in RTL mode keeps the scrollbar at the right side.
     * This means that when two elements must keep their left/right positions synched, if one has no vert
     * scrollbar, it must have some extra padding.
     * See https://sencha.jira.com/browse/EXTJSIV-11245
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     * @private
     */
    {
        name: &#39;rtlVertScrollbarOnRight&#39;,
        ready: true,
        fn: function(doc, div) {
           div.innerHTML = &#39;&lt;div style=&quot;height:100px;width:100px;direction:rtl;overflow:scroll&quot;&gt;&#39; +
                &#39;&lt;div style=&quot;width:20px;height:200px;&quot;&gt;&lt;/div&gt;&#39; +
            &#39;&lt;/div&gt;&#39;;

            var outerBox = div.firstChild,
                innerBox = outerBox.firstChild;

            return (innerBox.offsetLeft + innerBox.offsetWidth !== outerBox.offsetLeft + outerBox.offsetWidth);
        }
    },

<span id='Ext-supports-property-rtlVertScrollbarOverflowBug'>    /**
</span>     * @property {Boolean} rtlVertScrollbarOverflowBug
     * In Chrome, in RTL mode, horizontal overflow only into the vertical scrollbar does NOT trigger horizontal scrollability.
     * See https://code.google.com/p/chromium/issues/detail?id=179332
     * We need to detect this for when a grid header needs to have exactly the same horizontal scrolling range as its table view.
     * See {@link Ext.grid.ColumnLayout#publishInnerCtSize}
     * TODO: Remove this when all supported Chrome versions are fixed.
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     * @private
     */
    {
        name: &#39;rtlVertScrollbarOverflowBug&#39;,
        ready: true,
        fn: function(doc, div) {
           div.innerHTML = &#39;&lt;div style=&quot;height:100px;width:100px;direction:rtl;overflow:auto&quot;&gt;&#39; +
                &#39;&lt;div style=&quot;width:95px;height:200px;&quot;&gt;&lt;/div&gt;&#39; +
            &#39;&lt;/div&gt;&#39;;

            // If the bug is present, the 95 pixel wide inner div, encroaches into the
            // vertical scrollbar, but does NOT trigger horizontal overflow, so the clientHeight remains
            // equal to the offset height.
            var outerBox = div.firstChild;
            return outerBox.clientHeight === outerBox.offsetHeight;
        }
    },
    {
        identity: &#39;defineProperty&#39;,
        fn: function () {
            if (Ext.isIE8m) {
                Ext.Object.defineProperty = Ext.emptyFn;
                return false;
            }
            return true;
        }
    },
    {
        identify: &#39;nativeXhr&#39;,
        fn: function () {
            if (typeof XMLHttpRequest !== &#39;undefined&#39;) {
                return true;
            }

            // Apply a polyfill:
            XMLHttpRequest = function() { // jshint ignore:line
                try {
                    return new ActiveXObject(&#39;MSXML2.XMLHTTP.3.0&#39;); // jshint ignore:line
                }
                catch (ex) {
                    return null;
                }
            };
            return false;
        }
    },

<span id='Ext-supports-property-SpecialKeyDownRepeat'>    /**
</span>     * @property {Boolean} SpecialKeyDownRepeat
     * True if the browser fires the keydown event on specialkey autorepeat
     *
     * note 1: IE fires ONLY the keydown event on specialkey autorepeat
     * note 2: Safari &lt; 3.1, Gecko (Mac/Linux) &amp; Opera fire only the keypress event on
     * specialkey autorepeat (research done by Jan Wolter at
     * http://unixpapa.com/js/key.html)
     * note 3: Opera 12 behaves like other modern browsers so this workaround does not
     * work anymore
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;SpecialKeyDownRepeat&#39;,
        fn: function() {
            return Ext.isWebKit ?
                parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) &gt;= 525 :
                !(!(Ext.isGecko || Ext.isIE) || (Ext.isOpera &amp;&amp; Ext.operaVersion &lt; 12));
        }
    },
<span id='Ext-supports-property-EmulatedMouseOver'>    /**
</span>     * @property {Boolean} EmulatedMouseOver
     * True if the browser emulates a mouseover event on tap (mobile safari)
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;EmulatedMouseOver&#39;,
        fn: function() {
            // TODO: is it possible to feature detect this?
            return Ext.os.is.iOS;
        }
    },

<span id='Ext-supports-property-Hashchange'>    /**
</span>     * @property Hashchange True if the user agent supports the hashchange event
     *
     * This property is available at application boot time, before document ready.
     * @type {Boolean}
     */
    {
<span id='Ext-supports-property-name'>        // support Vector 12
</span>        name: &#39;Hashchange&#39;,
        fn: function() {
            // Note that IE8 in IE7 compatibility mode reports true for &#39;onhashchange&#39; in window, so also test documentMode
            var docMode = document.documentMode;
            return &#39;onhashchange&#39; in window &amp;&amp; (docMode === undefined || docMode &gt; 7);
        }
    },

<span id='Ext-supports-property-FixedTableWidthBug'>    /**
</span>     * @property FixedTableWidthBug
     * @private
     * @type {Boolean}
     * `true` if the browser has this bug: https://bugs.webkit.org/show_bug.cgi?id=130239
     *
     * This property is *NOT* available at application boot time. Only after the document ready event.
     */
    {
        name: &#39;FixedTableWidthBug&#39;,
        ready: true,
        fn: function() {
            if (Ext.isIE8) {
                // IE8 incorrectly detects that we have this bug.
                return false;
            }
            var outer = document.createElement(&#39;div&#39;),
                inner = document.createElement(&#39;div&#39;),
                width;

            outer.setAttribute(&#39;style&#39;, &#39;display:table;table-layout:fixed;&#39;);
            inner.setAttribute(&#39;style&#39;, &#39;display:table-cell;min-width:50px;&#39;);

            outer.appendChild(inner);
            document.body.appendChild(outer);

            // must poke offsetWidth to trigger a reflow before setting width
            outer.offsetWidth; // jshint ignore:line

            outer.style.width = &#39;25px&#39;;

            width = outer.offsetWidth;

            document.body.removeChild(outer);

            return width === 50;
        }
    },

<span id='Ext-supports-property-FocusinFocusoutEvents'>    /**
</span>     * @property FocusinFocusoutEvents
     * @private
     * @type {Boolean}
     * `true` if the browser supports focusin and focusout events:
     * https://developer.mozilla.org/en-US/docs/Web/Events/focusin
     * At this point, only Firefox does not, see this bug:
     * https://bugzilla.mozilla.org/show_bug.cgi?id=687787
     *
     * This property is available at application boot time, before document ready.
     */
    {
        name: &#39;FocusinFocusoutEvents&#39;,
        fn: function() {
            // There is no reliable way to feature detect focusin/focusout event support.
            // window.onfocusin will return undefined both in Chrome (where it is supported)
            // and in Firefox (where it is not supported); adding an element and trying to
            // focus it will fail when the browser window itself is not focused.
            return !Ext.isGecko;
        }
    },

<span id='Ext-supports-property-AsyncFocusEvents'>    /**
</span>     * @property {Boolean} AsyncFocusEvents
     * `true` if the browser fires focus events (focus, blur, focusin, focusout)
     * asynchronously, i.e. in a separate event loop invocation. This is only true
     * for all versions Internet Explorer; Microsoft Edge and other browsers fire
     * focus events synchronously.
     */
    {
        name: &#39;AsyncFocusEvents&#39;,
        fn: function() {
            // The sad part is that we can&#39;t feature detect this because the focus
            // event won&#39;t be fired when the browser window itself is not focused.

            // Private shortcut for brevity
            return Ext.asyncFocus = !!Ext.isIE;
        }
    },

    //&lt;/feature&gt;

<span id='Ext-supports-property-HighContrastMode'>    /**
</span>     * @property {Boolean} HighContrastMode `true` if the browser is currently
     * running in Windows High Contrast accessibility mode.
     *
     * @property {Object} accessibility Accessibility features.
     *
     * @property {Boolean} accessibility.Images `true` if the browser is configured
     * to display images.
     *
     * @property {Boolean} accessibility.BackgroundImages `true` if the browser
     * is configured to display background images.
     *
     * @property {Boolean} accessibility.BorderColors `true` if the browser
     * is configured to honor CSS styling for border colors.
     *
     * @property {Boolean} accessibility.LightOnDark `true` if the browser
     * is currently using reverse colors in light-on-dark accessibility mode.
     */
    {
        name: &#39;accessibility&#39;,
        ready: true,
        fn: function(doc) {
            var body = doc.body,
                div, img, style, supports, bgImg;

            function getColor(colorTxt) {
                var values = [],
                    colorValue = 0,
                    regex, match;

                if (colorTxt.indexOf(&#39;rgb(&#39;) !== -1) {
                    values = colorTxt.replace(&#39;rgb(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;).split(&#39;, &#39;);
                }
                else if (colorTxt.indexOf(&#39;#&#39;) !== -1) {
                    regex = colorTxt.length === 7 ? /^#(\S\S)(\S\S)(\S\S)$/ : /^#(\S)(\S)(\S)$/;
                    match = colorTxt.match(regex);

                    if (match) {
                        values = [&#39;0x&#39; + match[1], &#39;0x&#39; + match[2], &#39;0x&#39; + match[3]];
                    }
                }

                for (var i = 0; i &lt; values.length; i++) {
                    colorValue += parseInt(values[i]);
                }

                return colorValue;
            }

            div = doc.createElement(&#39;div&#39;);
            img = doc.createElement(&#39;img&#39;);

            style = div.style;

            Ext.apply(style, {
                width: &#39;2px&#39;,
                position: &#39;absolute&#39;,
                clip: &#39;rect(1px,1px,1px,1px)&#39;,
                borderWidth: &#39;1px&#39;,
                borderStyle: &#39;solid&#39;,
                borderTopTolor: &#39;#f00&#39;,
                borderRightColor: &#39;#ff0&#39;,
                backgroundColor: &#39;#fff&#39;,
                backgroundImage: &#39;url(&#39; + Ext.BLANK_IMAGE_URL + &#39;)&#39;
            });

            img.alt = &#39;&#39;;
            img.src = Ext.BLANK_IMAGE_URL;

            div.appendChild(img);
            body.appendChild(div);

            // Now check if the styles were indeed honored
            style = div.currentStyle || div.style;
            bgImg = style.backgroundImage;

            supports = {
                // In IE it is possible to untick &quot;Show pictures&quot; option in Advanced
                // settings; this will result in img element reporting its readyState
                // as &#39;uninitialized&#39;.
                // See http://www.paciellogroup.com/blog/2011/10/detecting-if-images-are-disabled-in-browsers/
                Images: img.offsetWidth === 1 &amp;&amp; img.readyState !== &#39;uninitialized&#39;,
                BackgroundImages: !(bgImg !== null &amp;&amp;
                                   (bgImg === &quot;none&quot; || bgImg === &quot;url(invalid-url:)&quot;)),
                BorderColors: style.borderTopColor !== style.borderRightColor,
                LightOnDark: getColor(style.color) - getColor(style.backgroundColor) &gt; 0
            };

            Ext.supports.HighContrastMode = !supports.BackgroundImages;

            body.removeChild(div);
            div = img = null;

            return supports;
        }
    },
    {
<span id='Ext-supports-property-ViewportUnits'>        /**
</span>         * @property ViewportUnits `true` if the device supports ViewportUnits.
         * @type {Boolean}
         *
         */
        name: &#39;ViewportUnits&#39;,
        ready: true,
        fn: function(doc) {
            //&lt;feature legacyBrowser&gt;
            // Even attempting to detect the feature throws a fatal error on IE8
            if (Ext.isIE8) {
                return false;
            }
            //&lt;/feature&gt;
            var body = doc.body,
                div = document.createElement(&#39;div&#39;),
                style = div.currentStyle || div.style, width, divWidth;

            body.appendChild(div);

            Ext.apply(style, {width: &#39;50vw&#39;});

            width = parseInt(window.innerWidth / 2, 10);
            divWidth = parseInt((window.getComputedStyle ?
                getComputedStyle(div, null) :
                div.currentStyle).width, 10);

            body.removeChild(div);
            div = null;
            return width === divWidth;
        }
    },
    {
        name: &#39;CSSVariables&#39;,
        ready: false,
        fn: function(doc) {
            //&lt;feature legacyBrowser&gt;
            // Legacy browsers do not have this method.
            if (!window.getComputedStyle) {
                return false;
            }
            //&lt;/feature&gt;
            var style = window.getComputedStyle(doc.documentElement);

            return style.getPropertyValue &amp;&amp; !!style.getPropertyValue(&#39;--x-supports-variables&#39;);
        }
    },
    {
<span id='Ext-supports-property-Selectors2'>        /**
</span>         * @property Selectors2 `true` if the browser supports the CSS selector API level 2.
         * https://dev.w3.org/2006/webapi/selectors-api2/
         * @type {Boolean}
         *
         */
        name: &#39;Selectors2&#39;,
        ready: false,
        fn: function(doc) {
            try {
                return !!doc.querySelectorAll(&#39;:scope&#39;);
            } catch (e) {
                return false;
            }
        }
    },
    {
<span id='Ext-supports-property-CSSScrollSnap'>        /**
</span>         * @property CSSScrollSnap
         * @private
         * @type {Boolean}
         */
        name: &#39;CSSScrollSnap&#39;,
        ready: false,
        fn: function(doc) {
            var style = doc.documentElement.style;

            return &#39;scrollSnapType&#39; in style || &#39;webkitScrollSnapType&#39; in style || &#39;msScrollSnapType&#39; in style;
        }
    },

    0] // placeholder so legacy browser detectors can come/go cleanly
};

Ext.feature.tests.pop(); // remove the placeholder

Ext.supports = {};

Ext.feature.detect();
</pre>
</body>
</html>
