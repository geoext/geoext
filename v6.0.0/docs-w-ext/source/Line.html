<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-sparkline-Line'>/**
</span> * @class Ext.sparkline.Line
 *
 * Plots a line graph based upon the input {@link #values} array.
 *
 * See {@link Ext.sparkline.Base the base class} for a simple example.
 */
Ext.define(&#39;Ext.sparkline.Line&#39;, {
    extend: &#39;Ext.sparkline.Base&#39;,
    requires: [
        &#39;Ext.sparkline.RangeMap&#39;
    ],

    alias: &#39;widget.sparklineline&#39;,

    config: {

<span id='Ext-sparkline-Line-cfg-fillColor'>        /**
</span>         * @cfg {String} [fillColor=#def] The hex value for fill color.
         */
        fillColor: &#39;#def&#39;,

<span id='Ext-sparkline-Line-cfg-spotColor'>        /**
</span>         * @cfg {String} [spotColor=#f80] The colour of the final value marker. Set to false or an empty string to hide it.
         */
        spotColor: &#39;#f80&#39;,
        
<span id='Ext-sparkline-Line-cfg-highlightSpotColor'>        /**
</span>         * @cfg {String} [highlightSpotColor=#5f5] The colour of value marker spots when mouseovered.
         */
        highlightSpotColor: &#39;#5f5&#39;,
        
<span id='Ext-sparkline-Line-cfg-highlightLineColor'>        /**
</span>         * @cfg {String} [highlightLineColor=#f22] The colour of value line shown when the graph is mouseovered.
         */
        highlightLineColor: &#39;#f22&#39;,
        
<span id='Ext-sparkline-Line-cfg-spotRadius'>        /**
</span>         * @cfg {Number} [spotRadius=1.5] The pixel radius of min, max and final value dots.
         */
        spotRadius: 1.5,
        
<span id='Ext-sparkline-Line-cfg-minSpotColor'>        /**
</span>         * @cfg {String} [minSpotColor=#f80] The colour of the mimimum value marker. Set to false or an empty string to hide it.
         */
        minSpotColor: &#39;#f80&#39;,
        
<span id='Ext-sparkline-Line-cfg-maxSpotColor'>        /**
</span>         * @cfg {String} [maxSpotColor=#f80] The colour of the maximum value marker. Set to false or an empty string to hide it.
         */
        maxSpotColor: &#39;#f80&#39;,
        
<span id='Ext-sparkline-Line-cfg-lineWidth'>        /**
</span>         * @cfg {Number} [lineWidth=1] The pixel width of the line plotted.
         */
        lineWidth: 1,
        
<span id='Ext-sparkline-Line-cfg-normalRangeMin'>        /**
</span>         * @cfg {Number} [normalRangeMin] See {@link #normalRangeMax} The minimum value to overlay a &quot;normal range bar&quot; over the graph using the {@link #normalRangeColor}.
         */
        normalRangeMin: null,
        
<span id='Ext-sparkline-Line-cfg-normalRangeMax'>        /**
</span>         * @cfg {Number} [normalRangeMax] See {@link #normalRangeMin} The maximum value to overlay a &quot;normal range bar&quot; over the graph using the {@link #normalRangeColor}.
         */
        normalRangeMax: null,
        
<span id='Ext-sparkline-Line-cfg-normalRangeColor'>        /**
</span>         * @cfg {String} [normalRangeColor=#ccc] See {@link #normalRangeMin} and {@link #normalRangeMax} The color of the undererlayed &quot;normal range bar&quot;.
         */
        normalRangeColor: &#39;#ccc&#39;,
        
<span id='Ext-sparkline-Line-cfg-drawNormalOnTop'>        /**
</span>         * @cfg {Boolean} [drawNormalOnTop=false] Configure as `true` to draw the normal range overlaying the chart.
         */
        drawNormalOnTop: false,
        
<span id='Ext-sparkline-Line-cfg-chartRangeMin'>        /**
</span>         * @cfg {Number} [chartRangeMin] The minimum value to use for the range of Y values of the chart - Defaults to the minimum value supplied.
         */
        chartRangeMin: null,
        
<span id='Ext-sparkline-Line-cfg-chartRangeMax'>        /**
</span>         * @cfg {Number} [chartRangeMax] The maximum value to use for the range of Y values of the chart - Defaults to the minimum value supplied.
         */
        chartRangeMax: null,
        
<span id='Ext-sparkline-Line-cfg-chartRangeMinX'>        /**
</span>         * @cfg {Number} [chartRangeMinX] The minimum value to use for the X value of the chart.
         */
        chartRangeMinX: null,
        
<span id='Ext-sparkline-Line-cfg-chartRangeMaxX'>        /**
</span>         * @cfg {Number} [chartRangeMaxX] The maximum value to use for the X value of the chart.
         */
        chartRangeMaxX: null,
        
<span id='Ext-sparkline-Line-cfg-valueSpots'>        /**
</span>         * @cfg {Object} [valueSpots] An object which uses range specifiers as keys to indicate spot color values
         * for range of values. A range specifier is of the form `[number]:[number]` indicating start and end range.
         * Omitting aither means an open ended range. For example to render green spots on all values less than 50
         * and red on values higher than 50 use:
         *
         *    {
         *        // Open ended range, with max value 49
         *        &quot;:49&quot;: &quot;green&quot;,
         *
         *        // Open ended range, with min value 50
         *        &quot;50:&quot;: &quot;red&quot;
         *    }
         */
        valueSpots: null
    },

<span id='Ext-sparkline-Line-cfg-tipTpl'>    tipTpl: &#39;&amp;#9679; {prefix}{y}{suffix}&#39;,
</span>
<span id='Ext-sparkline-Line-method-applyValueSpots'>    applyValueSpots: function(valueSpots) {
</span>        if (valueSpots &amp;&amp; !valueSpots.get) {
            valueSpots = new Ext.sparkline.RangeMap(valueSpots);
        }
        this.applyConfigChange();
        return valueSpots;
    },

<span id='Ext-sparkline-Line-method-onUpdate'>    onUpdate: function () {
</span>        this.vertices = [];
        this.regionMap = [];
        this.xvalues = [];
        this.yvalues = [];
        this.yminmax = [];
    },

<span id='Ext-sparkline-Line-method-getRegion'>    getRegion: function(x, y) {
</span>        var i,
            regionMap = this.regionMap; // maps regions to value positions

        for (i = regionMap.length; i--;) {
            if (regionMap[i] !== null &amp;&amp; x &gt;= regionMap[i][0] &amp;&amp; x &lt;= regionMap[i][1]) {
                return regionMap[i][2];
            }
        }
        return undefined;
    },

<span id='Ext-sparkline-Line-method-getRegionFields'>    getRegionFields: function(region) {
</span>        return {
            isNull: this.yvalues[region] === null,
            x: this.xvalues[region],
            y: this.yvalues[region],
            color: this.getLineColor(),
            fillColor: this.getFillColor(),
            offset: region
        };
    },

<span id='Ext-sparkline-Line-method-renderHighlight'>    renderHighlight: function(region) {
</span>        var me = this,
            canvas = me.canvas,
            vertex = me.vertices[region],
            spotRadius = me.getSpotRadius(),
            highlightSpotColor = me.getHighlightSpotColor(),
            highlightLineColor = me.getHighlightLineColor();

        if (!vertex) {
            return;
        }
        if (spotRadius &amp;&amp; highlightSpotColor) {
            canvas.drawCircle(vertex[0], vertex[1], spotRadius, null, highlightSpotColor).append();
        }
        if (highlightLineColor) {
            canvas.drawLine(vertex[0], me.canvasTop, vertex[0], me.canvasTop + me.getHeight(), highlightLineColor).append();
        }
    },

<span id='Ext-sparkline-Line-method-scanValues'>    scanValues: function () {
</span>        var me = this,
            values = me.values,
            valcount = values.length,
            xvalues = me.xvalues,
            yvalues = me.yvalues,
            yminmax = me.yminmax,
            i, val, isStr, isArray, sp;

        for (i = 0; i &lt; valcount; i++) {
            val = values[i];
            isStr = typeof(values[i]) === &#39;string&#39;;
            isArray = typeof(values[i]) === &#39;object&#39; &amp;&amp; values[i] instanceof Array;
            sp = isStr &amp;&amp; values[i].split(&#39;:&#39;);

            if (isStr &amp;&amp; sp.length === 2) { // x:y
                xvalues.push(Number(sp[0]));
                yvalues.push(Number(sp[1]));
                yminmax.push(Number(sp[1]));
            } else if (isArray) {
                xvalues.push(val[0]);
                yvalues.push(val[1]);
                yminmax.push(val[1]);
            } else {
                xvalues.push(i);
                if (values[i] === null || values[i] === &#39;null&#39;) {
                    yvalues.push(null);
                } else {
                    yvalues.push(Number(val));
                    yminmax.push(Number(val));
                }
            }
        }
        if (me.xvalues) {
            xvalues = me.xvalues;
        }

        me.maxy = me.maxyorg = Math.max.apply(Math, yminmax);
        me.miny = me.minyorg = Math.min.apply(Math, yminmax);

        me.maxx = Math.max.apply(Math, xvalues);
        me.minx = Math.min.apply(Math, xvalues);

        me.xvalues = xvalues;
        me.yvalues = yvalues;
        me.yminmax = yminmax;
    },

<span id='Ext-sparkline-Line-method-processRangeOptions'>    processRangeOptions: function () {
</span>        var me = this,
            normalRangeMin = me.getNormalRangeMin(),
            normalRangeMax = me.getNormalRangeMax(),
            chartRangeMin = me.getChartRangeMin(),
            chartRangeMinX = me.getChartRangeMinX(),
            chartRangeMax = me.getChartRangeMax(),
            chartRangeMaxX = me.getChartRangeMaxX();

        if (normalRangeMin != null) {
            if (normalRangeMin &lt; me.miny) {
                me.miny = normalRangeMin;
            }
            if (normalRangeMax &gt; me.maxy) {
                me.maxy = normalRangeMax;
            }
        }
        if (chartRangeMin != null &amp;&amp; (me.chartRangeClip || chartRangeMin &lt; me.miny)) {
            me.miny = chartRangeMin;
        }
        if (chartRangeMax != null &amp;&amp; (me.chartRangeClip || chartRangeMax &gt; me.maxy)) {
            this.maxy = chartRangeMax;
        }
        if (chartRangeMinX != null &amp;&amp; (me.chartRangeClipX || chartRangeMinX &lt; me.minx)) {
            me.minx = chartRangeMinX;
        }
        if (chartRangeMaxX != null &amp;&amp; (me.chartRangeClipX || chartRangeMaxX &gt; me.maxx)) {
            me.maxx = chartRangeMaxX;
        }

    },

<span id='Ext-sparkline-Line-method-drawNormalRange'>    drawNormalRange: function (canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {
</span>        var normalRangeMin = this.getNormalRangeMin(),
            normalRangeMax = this.getNormalRangeMax(),
            ytop = canvasTop + Math.round(canvasHeight - (canvasHeight * ((normalRangeMax - this.miny) / rangey))),
            height = Math.round((canvasHeight * (normalRangeMax - normalRangeMin)) / rangey);
        this.canvas.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.normalRangeColor).append();
    },

<span id='Ext-sparkline-Line-method-renderGraph'>    renderGraph: function () {
</span>        var me = this,
            canvas = me.canvas,
            canvasWidth = me.getWidth(),
            canvasHeight = me.getHeight(),
            vertices = me.vertices,
            spotRadius = me.getSpotRadius(),
            regionMap = me.regionMap,
            rangeX, Y, yvallast,
            canvasTop, canvasLeft,
            vertex, path, paths, x, y, xNext, xPos, xPosNext,
            last, next, yValCount, lineShapes, fillShapes, plen,
            valueSpots = me.getValueSpots(), hlSpotsEnabled, color, xValues, yValues, i,
            spotColor = me.getSpotColor(),
            minSpotColor = me.getMinSpotColor(),
            maxSpotColor = me.getMaxSpotColor(),
            normalRangeMin = me.getNormalRangeMin(),
            drawNormalOnTop = me.getDrawNormalOnTop();

        if (!me.callParent()) {
            return;
        }

        me.scanValues();
        me.processRangeOptions();

        xValues = me.xvalues;
        yValues = me.yvalues;

        if (!me.yminmax.length || me.yvalues.length &lt; 2) {
            // empty or all null valuess
            return;
        }

        canvasTop = canvasLeft = 0;

        rangeX = me.maxx - me.minx === 0 ? 1 : me.maxx - me.minx;
        Y = me.maxy - me.miny === 0 ? 1 : me.maxy - me.miny;
        yvallast = me.yvalues.length - 1;

        if (spotRadius &amp;&amp; (canvasWidth &lt; (spotRadius * 4) || canvasHeight &lt; (spotRadius * 4))) {
            spotRadius = 0;
        }
        if (spotRadius) {
            // adjust the canvas size as required so that spots will fit
            hlSpotsEnabled = me.getHighlightSpotColor() &amp;&amp;  !me.disableInteraction;
            if (hlSpotsEnabled || minSpotColor || (spotColor &amp;&amp; yValues[yvallast] === me.miny)) {
                canvasHeight -= Math.ceil(spotRadius);
            }
            if (hlSpotsEnabled || maxSpotColor || (spotColor &amp;&amp; yValues[yvallast] === me.maxy)) {
                canvasHeight -= Math.ceil(spotRadius);
                canvasTop += Math.ceil(spotRadius);
            }
            if (hlSpotsEnabled ||
                    ((minSpotColor || maxSpotColor) &amp;&amp; (yValues[0] === me.miny || yValues[0] === me.maxy))) {
                canvasLeft += Math.ceil(spotRadius);
                canvasWidth -= Math.ceil(spotRadius);
            }
            if (hlSpotsEnabled || spotColor ||
                (minSpotColor || maxSpotColor &amp;&amp;
                    (yValues[yvallast] === me.miny || yValues[yvallast] === me.maxy))) {
                canvasWidth -= Math.ceil(spotRadius);
            }
        }

        canvasHeight--;

        if (normalRangeMin != null &amp;&amp; !drawNormalOnTop) {
            me.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, Y);
        }

        path = [];
        paths = [path];
        last = next = null;
        yValCount = yValues.length;
        for (i = 0; i &lt; yValCount; i++) {
            x = xValues[i];
            xNext = xValues[i + 1];
            y = yValues[i];
            xPos = canvasLeft + Math.round((x - me.minx) * (canvasWidth / rangeX));
            xPosNext = i &lt; yValCount - 1 ? canvasLeft + Math.round((xNext - me.minx) * (canvasWidth / rangeX)) : canvasWidth;
            next = xPos + ((xPosNext - xPos) / 2);
            regionMap[i] = [last || 0, next, i];
            last = next;
            if (y === null) {
                if (i) {
                    if (yValues[i - 1] !== null) {
                        path = [];
                        paths.push(path);
                    }
                    vertices.push(null);
                }
            } else {
                if (y &lt; me.miny) {
                    y = me.miny;
                }
                if (y &gt; me.maxy) {
                    y = me.maxy;
                }
                if (!path.length) {
                    // previous value was null
                    path.push([xPos, canvasTop + canvasHeight]);
                }
                vertex = [xPos, canvasTop + Math.round(canvasHeight - (canvasHeight * ((y - this.miny) / Y)))];
                path.push(vertex);
                vertices.push(vertex);
            }
        }

        lineShapes = [];
        fillShapes = [];
        plen = paths.length;
        for (i = 0; i &lt; plen; i++) {
            path = paths[i];
            if (path.length) {
                if (me.fillColor) {
                    path.push([path[path.length - 1][0], (canvasTop + canvasHeight)]);
                    fillShapes.push(path.slice(0));
                    path.pop();
                }
                // if there&#39;s only a single point in this path, then we want to display it
                // as a vertical line which means we keep path[0]  as is
                if (path.length &gt; 2) {
                    // else we want the first value
                    path[0] = [path[0][0], path[1][1]];
                }
                lineShapes.push(path);
            }
        }

        // draw the fill first, then optionally the normal range, then the line on top of that
        plen = fillShapes.length;
        for (i = 0; i &lt; plen; i++) {
            canvas.drawShape(fillShapes[i],
                me.fillColor, me.fillColor).append();
        }

        if (normalRangeMin != null &amp;&amp; drawNormalOnTop) {
            me.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, Y);
        }

        plen = lineShapes.length;
        for (i = 0; i &lt; plen; i++) {
            canvas.drawShape(lineShapes[i], me.getLineColor(), null, me.getLineWidth()).append();
        }

        if (spotRadius &amp;&amp; valueSpots) {
            if (valueSpots.get == null) {
                valueSpots = new Ext.sparkline.RangeMap(valueSpots);
            }
            for (i = 0; i &lt; yValCount; i++) {
                color = valueSpots.get(yValues[i]);
                if (color) {
                    canvas.drawCircle(canvasLeft + Math.round((xValues[i] - me.minx) * (canvasWidth / rangeX)),
                        canvasTop + Math.round(canvasHeight - (canvasHeight * ((yValues[i] - me.miny) / Y))),
                        spotRadius, null,
                        color).append();
                }
            }

        }
        if (spotRadius &amp;&amp; spotColor &amp;&amp; yValues[yvallast] != null) {
            canvas.drawCircle(canvasLeft + Math.round((xValues[xValues.length - 1] - me.minx) * (canvasWidth / rangeX)),
                canvasTop + Math.round(canvasHeight - (canvasHeight * ((yValues[yvallast] - me.miny) / Y))),
                spotRadius, null,
                spotColor).append();
        }
        if (me.maxy !== me.minyorg) {
            if (spotRadius &amp;&amp; minSpotColor) {
                x = xValues[Ext.Array.indexOf(yValues, me.minyorg)];
                canvas.drawCircle(canvasLeft + Math.round((x - me.minx) * (canvasWidth / rangeX)),
                    canvasTop + Math.round(canvasHeight - (canvasHeight * ((me.minyorg - me.miny) / Y))),
                    spotRadius, null,
                    minSpotColor).append();
            }
            if (spotRadius &amp;&amp; maxSpotColor) {
                x = xValues[Ext.Array.indexOf(yValues, me.maxyorg)];
                canvas.drawCircle(canvasLeft + Math.round((x - me.minx) * (canvasWidth / rangeX)),
                    canvasTop + Math.round(canvasHeight - (canvasHeight * ((me.maxyorg - me.miny) / Y))),
                    spotRadius, null,
                    maxSpotColor).append();
            }
        }

        me.canvasTop = canvasTop;

        // If mouse is over, apply the highlight
        if (me.currentPageXY &amp;&amp; me.el.getRegion().contains(me.currentPageXY)) {
            me.updateDisplay();
        }
        canvas.render();
    }
});</pre>
</body>
</html>
