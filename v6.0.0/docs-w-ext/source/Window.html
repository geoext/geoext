<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-window-Window'>/**
</span> * A specialized panel intended for use as an application window. Windows are floated, {@link #resizable}, and
 * {@link #cfg-draggable} by default. Windows can be {@link #maximizable maximized} to fill the viewport, restored to
 * their prior size, and can be {@link #method-minimize}d.
 *
 * Windows can also be linked to a {@link Ext.ZIndexManager} or managed by the {@link Ext.WindowManager} to provide
 * grouping, activation, to front, to back and other application-specific behavior.
 *
 * By default, Windows will be rendered to document.body. To {@link #constrain} a Window to another element specify
 * {@link Ext.Component#renderTo renderTo}.
 *
 * **As with all {@link Ext.container.Container Container}s, it is important to consider how you want the Window to size
 * and arrange any child Components. Choose an appropriate {@link #layout} configuration which lays out child Components
 * in the required manner.**
 *
 *     @example
 *     Ext.create(&#39;Ext.window.Window&#39;, {
 *         title: &#39;Hello&#39;,
 *         height: 200,
 *         width: 400,
 *         layout: &#39;fit&#39;,
 *         items: {  // Let&#39;s put an empty grid in just to illustrate fit layout
 *             xtype: &#39;grid&#39;,
 *             border: false,
 *             columns: [{header: &#39;World&#39;}],                 // One header just for show. There&#39;s no data,
 *             store: Ext.create(&#39;Ext.data.ArrayStore&#39;, {}) // A dummy empty data store
 *         }
 *     }).show();
 */
Ext.define(&#39;Ext.window.Window&#39;, {
    extend: &#39;Ext.panel.Panel&#39;,

    alternateClassName: &#39;Ext.Window&#39;,

    requires: [
        &#39;Ext.util.ComponentDragger&#39;,
        &#39;Ext.util.Region&#39;
    ],

    alias: &#39;widget.window&#39;,

<span id='Ext-window-Window-cfg-x'>    /**
</span>     * @cfg {Number} x
     * The X position of the left edge of the window on initial showing. Defaults to centering the Window within the
     * width of the Window&#39;s container {@link Ext.dom.Element Element} (The Element that the Window is rendered to).
     */

<span id='Ext-window-Window-cfg-y'>    /**
</span>     * @cfg {Number} y
     * The Y position of the top edge of the window on initial showing. Defaults to centering the Window within the
     * height of the Window&#39;s container {@link Ext.dom.Element Element} (The Element that the Window is rendered to).
     */

<span id='Ext-window-Window-cfg-animateTarget'>    /**
</span>     * @cfg {String/Ext.dom.Element/Ext.Component/Boolean} [animateTarget=null]
     * Id, Component element, or Component from which the window should animate when
     * shown or hidden.
     *
     * You may also pass true to have the Window animate when maximizing and restoring
     * using the maximize / restore tools created via the {@link #maximizable} config.
     *
     *     var btn, win;
     *
     *     btn = Ext.create({
     *         xtype: &#39;button&#39;,
     *         renderTo: Ext.getBody(),
     *         text: &#39;Show Window&#39;,
     *         handler: function() {
     *             win.show();
     *         }
     *     });
     *
     *     win = Ext.create({
     *         xtype: &#39;window&#39;,
     *         title: &#39;Animate from the Show Window Button&#39;,
     *         height: 300,
     *         width: 400,
     *         modal: true,
     *         closeAction: &#39;hide&#39;,
     *         animateTarget: btn
     *         // or btn.getId()
     *         // or btn.getEl()
     *         // or true (when maximizable is true)
     *     });
     */

<span id='Ext-window-Window-cfg-ghost'>    /**
</span>     * @cfg {Boolean/Function} ghost
     * Set to false to disable the ghost panel during dragging the window.
     * Do note that you should not set this to true, by default it is a function.
     */

<span id='Ext-window-Window-cfg-defaultFocus'>    /**
</span>     * @cfg {String/Number/Ext.Component} defaultFocus
     * Specifies a Component to receive focus when this Window is focused.
     *
     * If a String is provided, the Component will be resolved using the {@link #down} method which uses {@link Ext.ComponentQuery}.
     * If the string begins with an alphanumeric value, it will first attempt to find the Component based on the {@link Ext.Component#id} or {@link Ext.Component#itemId}.
     * If a matching component is not found via id, then an attempt to do a query to find a matching component.
     *
     * An example of finding the Component with an id/itemId:
     *
     *     Ext.create(&#39;Ext.window.Window&#39;, {
     *         autoShow     : true,
     *         width        : 300,
     *         title        : &#39;Login&#39;,
     *         defaultFocus : &#39;username&#39;,
     *         items        : [
     *             {
     *                 xtype      : &#39;textfield&#39;,
     *                 fieldLabel : &#39;Username&#39;,
     *                 itemId     : &#39;username&#39;,
     *                 name       : &#39;username&#39;
     *             },
     *             {
     *                 xtype      : &#39;textfield&#39;,
     *                 inputType  : &#39;password&#39;,
     *                 fieldLabel : &#39;Password&#39;,
     *                 itemId     : &#39;password&#39;,
     *                 name       : &#39;password&#39;
     *             }
     *         ]
     *     });
     *
     * If a Number is provided, this will resolve an {@link Ext.button.Button} at that index. This is very useful if
     * the window has buttons in the {@link #buttons} config and you want to provide default focus to one of them.
     *
     * An example of this would be:
     *
     *     Ext.create(&#39;Ext.window.Window&#39;, {
     *         autoShow     : true,
     *         width        : 300,
     *         title        : &#39;Login&#39;,
     *         defaultFocus : 1,
     *         items        : [
     *             {
     *                 xtype      : &#39;textfield&#39;,
     *                 fieldLabel : &#39;Username&#39;,
     *                 name       : &#39;username&#39;
     *            },
     *            {
     *                 xtype      : &#39;textfield&#39;,
     *                 inputType  : &#39;password&#39;,
     *                 fieldLabel : &#39;Password&#39;,
     *                 name       : &#39;password&#39;
     *             }
     *         ],
     *         buttons      : [
     *             {
     *                 text : &#39;Cancel&#39;
     *             },
     *             {
     *                 text : &#39;Login&#39;
     *             }
     *         ]
     *     });
     *
     * In summary, defaultFocus may be one of:
     *
     *   - The index of a footer Button.
     *   - The id or {@link Ext.Component#itemId} of a descendant Component.
     *   - A {@link Ext.ComponentQuery query} to find a {@link Ext.Component}.
     *   - A descendant {@link Ext.Component}.
     */

<span id='Ext-window-Window-cfg-onEsc'>    /**
</span>     * @cfg {Function} onEsc
     * Allows override of the built-in processing for the escape key. Default action is to close the Window (performing
     * whatever action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is
     * pressed, specify this as {@link Ext#emptyFn Ext.emptyFn}.
     */

<span id='Ext-window-Window-cfg-collapsed'>    /**
</span>     * @cfg {Boolean} [collapsed=false]
     * True to render the window collapsed, false to render it expanded. Note that if {@link #expandOnShow}
     * is true (the default) it will override the `collapsed` config and the window will always be
     * expanded when shown.
     */

<span id='Ext-window-Window-cfg-maximized'>    /**
</span>     * @cfg {Boolean} [maximized=false]
     * True to initially display the window in a maximized state.
     */

<span id='Ext-window-Window-cfg-hideShadowOnDeactivate'>    /**
</span>     * @cfg {Boolean} [hideShadowOnDeactivate=false]
     * True to hide this Window&#39;s shadow when another floating item in the same z-index stack is activated.
     */

<span id='Ext-window-Window-cfg-baseCls'>    /**
</span>    * @cfg {String} [baseCls=&#39;x-window&#39;]
    * The base CSS class to apply to this panel&#39;s element.
    */
    baseCls: Ext.baseCSSPrefix + &#39;window&#39;,

<span id='Ext-window-Window-cfg-resizable'>    /**
</span>     * @cfg {Boolean/Object} resizable
     * Specify as `true` to allow user resizing at each edge and corner of the window, false to disable resizing.
     *
     * This may also be specified as a config object to Ext.resizer.Resizer
     */
    resizable: true,

<span id='Ext-window-Window-cfg-draggable'>    /**
</span>     * @cfg {Boolean} draggable
     * True to allow the window to be dragged by the header bar, false to disable dragging. Note that
     * by default the window will be centered in the viewport, so if dragging is disabled the window may need to be
     * positioned programmatically after render (e.g., `myWindow.setPosition(100, 100);`).
     */
    draggable: true,

<span id='Ext-window-Window-cfg-constrain'>    /**
</span>     * @cfg {Boolean} constrain
     * True to constrain the window within its containing element, false to allow it to fall outside of its containing
     * element. By default the window will be rendered to `document.body`. To render and constrain the window within
     * another element specify {@link #renderTo}. Optionally the header only can be constrained
     * using {@link #constrainHeader}.
     */
    constrain: false,

<span id='Ext-window-Window-cfg-constrainHeader'>    /**
</span>     * @cfg {Boolean} constrainHeader
     * True to constrain the window header within its containing element (allowing the window body to fall outside of
     * its containing element) or false to allow the header to fall outside its containing element.
     * Optionally the entire window can be constrained using {@link #constrain}.
     */
    constrainHeader: false,

<span id='Ext-window-Window-cfg-simpleDrag'>    /**
</span>     * @cfg simpleDrag
     * @hide
     */

<span id='Ext-window-Window-cfg-plain'>    /**
</span>     * @cfg {Boolean} plain
     * True to render the window body with a transparent background so that it will blend into the framing elements,
     * false to add a lighter background color to visually highlight the body element and separate it more distinctly
     * from the surrounding frame.
     */
    plain: false,

<span id='Ext-window-Window-cfg-minimizable'>    /**
</span>     * @cfg {Boolean} minimizable
     * True to display the &#39;minimize&#39; tool button and allow the user to minimize the window, false to hide the button
     * and disallow minimizing the window. Note that this button provides no implementation -- the
     * behavior of minimizing a window is implementation-specific, so the minimize event must be handled and a custom
     * minimize behavior implemented for this option to be useful.
     */
    minimizable: false,

<span id='Ext-window-Window-cfg-maximizable'>    /**
</span>     * @cfg {Boolean} maximizable
     * True to display the &#39;maximize&#39; tool button and allow the user to maximize the window, false to hide the button
     * and disallow maximizing the window. Note that when a window is maximized, the tool button
     * will automatically change to a &#39;restore&#39; button with the appropriate behavior already built-in that will restore
     * the window to its previous size.
     */
    maximizable: false,

<span id='Ext-window-Window-cfg-minHeight'>    minHeight: 50,
</span>
<span id='Ext-window-Window-cfg-minWidth'>    minWidth: 50,
</span>
<span id='Ext-window-Window-cfg-expandOnShow'>    /**
</span>     * @cfg {Boolean} expandOnShow
     * True to always expand the window when it is displayed, false to keep it in its current state (which may be
     * {@link #collapsed}) when displayed.
     */
    expandOnShow: true,

<span id='Ext-window-Window-cfg-collapsible'>    collapsible: false,
</span>
<span id='Ext-window-Window-cfg-closable'>    /**
</span>     * @cfg {Boolean} closable
     * True to display the &#39;close&#39; tool button and allow the user to close the window, false to hide the button and
     * disallow closing the window.
     *
     * By default, when close is requested by either clicking the close button in the header or pressing ESC when the
     * Window has focus, the {@link #method-close} method will be called. This will _{@link Ext.Component#method-destroy destroy}_ the
     * Window and its content meaning that it may not be reused.
     *
     * To make closing a Window _hide_ the Window so that it may be reused, set {@link #closeAction} to &#39;hide&#39;.
     */
    closable: true,

<span id='Ext-window-Window-cfg-monitorResize'>    /**
</span>     * @cfg {Boolean} monitorResize
     * `true` to listen to the viewport resize event and perform any layout updating if necessary.
     * This is useful if using sizes as percentages for the window.
     */

<span id='Ext-window-Window-cfg-hidden'>    /**
</span>     * @cfg {Boolean} hidden
     * Render this Window hidden. If `true`, the {@link #method-hide} method will be called internally.
     */
    hidden: true,

<span id='Ext-window-Window-cfg-autoRender'>    /**
</span>     * @cfg {Boolean}
     * @inheritdoc
     * Windows render to the body on first show.
     */
    autoRender: true,

<span id='Ext-window-Window-cfg-hideMode'>    /**
</span>     * @cfg {String}
     * @inheritdoc
     * Windows hide using offsets in order to preserve the scroll positions of their descendants.  You may review
     * other configuration options here: {@link Ext.Component#hideMode}.
     */
    hideMode: &#39;offsets&#39;,

<span id='Ext-window-Window-cfg-floating'>    /**
</span>     * @cfg {Boolean} [floating=true]
     * @inheritdoc Ext.Component
     */
    floating: true,

<span id='Ext-window-Window-cfg-alignOnScroll'>    alignOnScroll: false,
</span>
<span id='Ext-window-Window-cfg-stateEvents'>    /**
</span>     * @cfg stateEvents
     * @inheritdoc Ext.state.Stateful#cfg-stateEvents
     * @localdoc By default the following stateEvents are added:
     *
     *  - {@link #event-resize} - _(added by Ext.Component)_
     *  - {@link #event-collapse} - _(added by Ext.panel.Panel)_
     *  - {@link #event-expand} - _(added by Ext.panel.Panel)_
     *  - {@link #event-maximize}
     *  - {@link #event-restore}
     *  - {@link #event-resize}
     *  - {@link #event-dragend}
     */

    itemCls: Ext.baseCSSPrefix + &#39;window-item&#39;,

<span id='Ext-window-Window-cfg-overlapHeader'>    overlapHeader: true,
</span>
<span id='Ext-window-Window-property-ignoreHeaderBorderManagement'>    ignoreHeaderBorderManagement: true,
</span>
<span id='Ext-window-Window-property-alwaysFramed'>    // Flag to Renderable to always look up the framing styles for this Component
</span>    alwaysFramed: true,

<span id='Ext-window-Window-property-isRootCfg'>    // Buffer this so we don&#39;t recreate the same object
</span>    isRootCfg: {
        isRoot: true
    },

<span id='Ext-window-Window-property-isWindow'>    /**
</span>     * @property {Boolean} isWindow
     * `true` in this class to identify an object as an instantiated Window, or subclass thereof.
     */
    isWindow: true,

<span id='Ext-window-Window-property-ariaRole'>    ariaRole: &#39;dialog&#39;,
</span><span id='Ext-window-Window-property-focusable'>    focusable: true,
</span><span id='Ext-window-Window-cfg-tabGuard'>    tabGuard: true,
</span>    
<span id='Ext-window-Window-cfg-closeToolText'>    //&lt;locale&gt;
</span>    closeToolText: &#39;Close dialog&#39;,
<span id='Ext-window-Window-cfg-keyMap'>    //&lt;/locale&gt;
</span>
    keyMap: {
        scope: &#39;this&#39;,
        ESC: &#39;onEsc&#39;
    },
    
<span id='Ext-window-Window-cfg-maskClickAction'>    /**
</span>     * @cfg {String} [maskClickAction=focus]
     * The method to call when the window&#39;s modal mask is clicked or tapped:
     *
     * - **`&#39;{@link #method-focus}&#39;`** :
     *
     *   The default. Focus the window, which will then pass focus into its {@link #cfg-defaultFocus} delegate.
     *
     * - **`&#39;{@link #method-destroy}&#39;`** :
     *
     *   Remove  the window from the DOM and {@link Ext.Component#method-destroy destroy} it and all descendant
     *   Components. The window will **not** be available to be redisplayed via the {@link #method-show} method.
     *
     * - **`&#39;{@link #method-hide}&#39;`** :
     *
     *   {@link #method-hide} the window by setting visibility to hidden and applying negative offsets. The window will be
     *   available to be redisplayed via the {@link #method-show} method.
     *   @since 6.2.0
     */
    maskClickAction: &#39;focus&#39;,

<span id='Ext-window-Window-event-activate'>    /**
</span>     * @event activate
     * Fires after the window has been visually activated via {@link #setActive}.
     * @param {Ext.window.Window} this
     */

<span id='Ext-window-Window-event-deactivate'>    /**
</span>     * @event deactivate
     * Fires after the window has been visually deactivated via {@link #setActive}.
     * @param {Ext.window.Window} this
     */

<span id='Ext-window-Window-event-maskclick'>    /**
</span>     * @event maskclick
     * Fires when this Window&#39;s modal mask is clicked or tapped. Returning `false` from 
     * a handler will veto the subsequent preocessing of the {@link #cfg-maskClickAction}..
     * @param {Ext.window.Window} this
     */

<span id='Ext-window-Window-event-resize'>    /**
</span>     * @event resize
     * Fires after the window has been resized.
     * @param {Ext.window.Window} this
     * @param {Number} width The window&#39;s new width
     * @param {Number} height The window&#39;s new height
     */

<span id='Ext-window-Window-event-maximize'>    /**
</span>     * @event maximize
     * Fires after the window has been maximized.
     * @param {Ext.window.Window} this
     */

<span id='Ext-window-Window-event-minimize'>    /**
</span>     * @event minimize
     * Fires after the window has been minimized.
     * @param {Ext.window.Window} this
     */

<span id='Ext-window-Window-event-restore'>    /**
</span>     * @event restore
     * Fires after the window has been restored to its original size after being maximized.
     * @param {Ext.window.Window} this
     */
    
    disableCloseToolFocus: true,

<span id='Ext-window-Window-method-initComponent'>    /**
</span>     * @private
     */
    initComponent: function() {
        var me = this;

        // Explicitly set frame to false, since alwaysFramed is
        // true, we only want to lookup framing in a specific instance
        me.frame = false;

        me.callParent();

        if (me.plain) {
            me.addClsWithUI(&#39;plain&#39;);
        }

        me.addStateEvents([&#39;maximize&#39;, &#39;restore&#39;, &#39;resize&#39;, &#39;dragend&#39;]);
    },

<span id='Ext-window-Window-method-getElConfig'>    getElConfig: function () {
</span>        var me = this,
            elConfig;

        elConfig = me.callParent();
        elConfig.tabIndex = -1;
        return elConfig;
    },

<span id='Ext-window-Window-method-getFocusEl'>    /**
</span>     * @protected
     * Returns the focus holder element associated with this Window.
     * By default, this is the Window&#39;s element; this can be overridden
     * by setting {@link #defaultFocus} property.
     *
     * @return {Ext.dom.Element/Ext.Component} the focus holding element or Component.
     */
    getFocusEl: function() {
        return this.getDefaultFocus() || this.el;
    },

    // State Management

<span id='Ext-window-Window-method-getState'>    /**
</span>     * @private
     */
    getState: function() {
        var me = this,
            state = me.callParent() || {},
            maximized = !!me.maximized,
            ghostBox = me.ghostBox,
            pos;


        state.maximized = maximized;
        if (maximized) {
            pos = me.restorePos;
        } else if (ghostBox) {
            // If we&#39;re animating a show, it will be from offscreen, so
            // grab the position from the final box
            pos = [ghostBox.x, ghostBox.y];
        } else {
            pos = me.getPosition(true);
        }
        Ext.apply(state, {
            size: maximized ? me.restoreSize : me.getSize(),
            pos: pos
        });
        return state;
    },

<span id='Ext-window-Window-method-applyState'>    applyState: function(state){
</span>        var me = this;

        if (state) {
            me.maximized = state.maximized;
            if (me.maximized) {
                me.hasSavedRestore = true;
                me.restoreSize = state.size;
                me.restorePos = state.pos;
            } else {
                Ext.apply(me, {
                    width: state.size.width,
                    height: state.size.height,
                    x: state.pos[0],
                    y: state.pos[1]
                });
            }
        }
    },

<span id='Ext-window-Window-method-onRender'>    onRender: function(ct, position) {
</span>        var me = this;

        me.callParent(arguments);

        // Single clicking a header will focus the defaultFocus child
        if (me.header) {
            me.header.on({
                scope: me,
                click: me.onHeaderClick
            });
        }

        // Double clicking a header will toggleMaximize
        if (me.maximizable) {
            me.header.on({
                scope: me,
                dblclick: me.toggleMaximize
            });
        }
    },

<span id='Ext-window-Window-method-afterRender'>    afterRender: function() {
</span>        var me = this,
            header = me.header;

        // Initialize
        if (me.maximized) {
            me.maximized = false;
            me.maximize(null, true);
            if (header) {
                header.removeCls(header.indicateDragCls);
            }
        }

        me.callParent();
        
        me.initTabGuards();
    },

<span id='Ext-window-Window-method-onEsc'>    /**
</span>     * @private
     */
    onEsc: function(e) {
        e.stopEvent();
        this.close();
    },

<span id='Ext-window-Window-method-doDestroy'>    doDestroy: function() {
</span>        var me = this;
        
        if (me.rendered) {
            Ext.un(&#39;resize&#39;, me.onWindowResize, me);
            delete me.animateTarget;
            me.hide();
        }
        
        me.callParent();
    },

<span id='Ext-window-Window-method-addTools'>    /**
</span>     * @private
     * Contribute class-specific tools to the header.
     *
     * Called by Panel&#39;s initTools at initialization time.
     *
     * Implementations should jst add new tool config objects to `this.tools`
     */
    addTools: function() {
        var me = this,
            tools = [];

        // Call Panel&#39;s addTools
        me.callParent();

        if (me.minimizable) {
            tools.push({
                type: &#39;minimize&#39;,
                handler: &#39;minimize&#39;,
                scope:  me
            });
        }
        if (me.maximizable) {
            tools.push({
                type: &#39;maximize&#39;,
                handler: &#39;toggleMaximize&#39;,
                scope: me
            });
        }

        if (tools.length) {
            me.addTool(tools);
        }
    },
    
<span id='Ext-window-Window-method-addTool'>    addTool: function(tools) {
</span>        var me = this;
        
        me.callParent([tools]);
        
        if (me.rendered &amp;&amp; me.tabGuard) {
            me.initTabGuards();
        }
    },
    
<span id='Ext-window-Window-method-add'>    add: function() {
</span>        var me = this,
            ret;
        
        ret = me.callParent(arguments);
        
        if (me.rendered &amp;&amp; me.tabGuard) {
            me.initTabGuards();
        }
        
        return ret;
    },
    
<span id='Ext-window-Window-method-remove'>    remove: function() {
</span>        var me = this,
            ret;
        
        ret = me.callParent(arguments);
        
        if (me.rendered &amp;&amp; me.tabGuard) {
            me.initTabGuards();
        }
        
        return ret;
    },
    
<span id='Ext-window-Window-method-addDocked'>    addDocked: function() {
</span>        var me = this,
            ret;
        
        ret = me.callParent(arguments);
        
        if (me.rendered &amp;&amp; me.tabGuard) {
            me.initTabGuards();
        }
        
        return ret;
    },
    
<span id='Ext-window-Window-method-removeDocked'>    removeDocked: function() {
</span>        var me = this,
            ret;
        
        ret = me.callParent(arguments);
        
        if (me.rendered &amp;&amp; me.tabGuard) {
            me.initTabGuards();
        }
        
        return ret;
    },

<span id='Ext-window-Window-method-onShow'>    onShow: function() {
</span>        var me = this;

        me.callParent(arguments);
        
        if (me.expandOnShow) {
            me.expand(false);
        }
        
        me.syncMonitorWindowResize();
        
        if (me.rendered &amp;&amp; me.tabGuard) {
            me.initTabGuards();
        }
   },

<span id='Ext-window-Window-method-doClose'>    /**
</span>     * @private
     */
    doClose: function() {
        var me = this;

        // Being called as callback after going through the hide call below
        if (me.hidden) {
            me.fireEvent(&#39;close&#39;, me);
            
            // This method can be called from hide() which in turn can be called
            // from destroy()
            if (me.closeAction === &#39;destroy&#39; &amp;&amp; !me.destroying &amp;&amp; !me.destroyed) {
                me.destroy();
            }
        } else {
            // close after hiding
            me.hide(me.animateTarget, me.doClose, me);
        }
    },

<span id='Ext-window-Window-method-afterHide'>    /**
</span>     * @private
     */
    afterHide: function() {
        var me = this;

        // No longer subscribe to resizing now that we&#39;re hidden
        me.syncMonitorWindowResize();

        // Perform superclass&#39;s afterHide tasks.
        me.callParent(arguments);
        
        if (me.rendered &amp;&amp; me.tabGuard) {
            me.initTabGuards();
        }
    },

<span id='Ext-window-Window-method-onWindowResize'>    /**
</span>     * @private
     */
    onWindowResize: function() {
        var me = this,
            sizeModel;

        // This is called on a timer. Window may have been destroyed in the interval.
        if (!me.destroyed) {
            if (me.maximized) {
                me.fitContainer();
            } else {
                sizeModel = me.getSizeModel();
                if (sizeModel.width.natural || sizeModel.height.natural) {
                    me.updateLayout();
                }
                me.doConstrain();
            }
        }
    },

<span id='Ext-window-Window-method-minimize'>    /**
</span>     * Placeholder method for minimizing the window. By default, this method simply fires the {@link #event-minimize} event
     * since the behavior of minimizing a window is application-specific. To implement custom minimize behavior, either
     * the minimize event can be handled or this method can be overridden.
     * @return {Ext.window.Window} this
     */
    minimize: function() {
        this.fireEvent(&#39;minimize&#39;, this);
        return this;
    },

<span id='Ext-window-Window-method-resumeHeaderLayout'>    resumeHeaderLayout: function(changed) {
</span>        this.header.resumeLayouts(changed ? this.isRootCfg : null);
    },

<span id='Ext-window-Window-method-afterCollapse'>    afterCollapse: function() {
</span>        var me = this,
            header = me.header,
            tools = me.tools;

        if (header &amp;&amp; me.maximizable) {
            header.suspendLayouts();
            tools.maximize.hide();
            this.resumeHeaderLayout(true);
        }
        if (me.resizer) {
            me.resizer.disable();
        }
        me.callParent(arguments);
    },

<span id='Ext-window-Window-method-afterExpand'>    afterExpand: function() {
</span>        var me = this,
            header = me.header,
            tools = me.tools,
            changed;


        if (header) {
            header.suspendLayouts();
            if (me.maximizable) {
                tools.maximize.show();
                changed = true;
            }
            this.resumeHeaderLayout(changed);
        }
        if (me.resizer) {
            me.resizer.enable();
        }
        me.callParent(arguments);
    },

<span id='Ext-window-Window-method-maximize'>    /**
</span>     * Fits the window within its current container and automatically replaces the {@link #maximizable &#39;maximize&#39; tool
     * button} with the &#39;restore&#39; tool button. Also see {@link #toggleMaximize}.
     * @param {Boolean} [animate=false] Pass `true` to animate this Window to full size.
     * @return {Ext.window.Window} this
     */
    maximize: function(animate, /* private */ initial) {
        var me = this,
            header = me.header,
            tools = me.tools,
            width = me.width,
            height = me.height,
            restore, changed;

        if (!me.maximized &amp;&amp; !me.maximizing) {
            me.maximizing = true;
            me.expand(false);
            if (!me.hasSavedRestore) {
                restore = me.restoreSize = {
                    width: width ? width : null,
                    height: height ? height : null
                };

                // If we&#39;re not positioned yet, default back to 0,0
                if (initial) {
                    me.restorePos = [me.x || 0, me.y || 0];
                } else {
                    me.restorePos = me.getPosition();
                }
            }

            // Manipulate visibility of header tools if there is a header
            if (header) {
                header.suspendLayouts();
                if (tools.maximize) {
                    tools.maximize.setType(&#39;restore&#39;);
                }
                if (me.collapseTool) {
                    me.collapseTool.hide();
                    changed = true;
                }
                me.resumeHeaderLayout(changed);
            }

            me.el.disableShadow();

            if (me.dd) {
                me.dd.disable();
                if (header) {
                   header.removeCls(header.indicateDragCls);
                }
            }
            if (me.resizer) {
                me.resizer.disable();
            }

            me.el.addCls(Ext.baseCSSPrefix + &#39;window-maximized&#39;);
            me.container.addCls(Ext.baseCSSPrefix + &#39;window-maximized-ct&#39;);

            me.syncMonitorWindowResize();
            me.fitContainer(animate = (animate || !!me.animateTarget) ? {
                callback: function() {
                    me.maximizing = false;
                    me.maximized = true;
                    if (!initial) {
                        me.fireEvent(&#39;maximize&#39;, me);
                    }
                }
            } : null);
            if (!animate) {
                me.maximizing = false;
                me.maximized = true;
                if (!initial) {
                    me.fireEvent(&#39;maximize&#39;, me);
                }
            }
        }
        return me;
    },

<span id='Ext-window-Window-method-restore'>    /**
</span>     * Restores a {@link #maximizable maximized} window back to its original size and position prior to being maximized
     * and also replaces the &#39;restore&#39; tool button with the &#39;maximize&#39; tool button. Also see {@link #toggleMaximize}.
     * @param {Boolean} [animate=false] Pass `true` to animate the restore.
     * @return {Ext.window.Window} this
     */
    restore: function(animate) {
        var me = this,
            tools = me.tools,
            header = me.header,
            newBox = me.restoreSize,
            changed;

        if (me.maximized) {
            me.hasSavedRestore = null;
            me.removeCls(Ext.baseCSSPrefix + &#39;window-maximized&#39;);

            // Manipulate visibility of header tools if there is a header
            if (header) {
                header.suspendLayouts();
                if (tools.maximize) {
                    tools.maximize.setType(&#39;maximize&#39;);
                }
                if (me.collapseTool) {
                    me.collapseTool.show();
                    changed = true;
                }
                me.resumeHeaderLayout(changed);
            }

            // Restore the position/sizing
            newBox.x = me.restorePos[0];
            newBox.y = me.restorePos[1];
            me.setBox(newBox, animate = (animate || !!me.animateTarget) ? {
                callback: function() {
                    me.el.enableShadow(null, true);
                    me.maximized = false;
                    me.fireEvent(&#39;restore&#39;, me);
                }
            } : null);

            // Unset old position/sizing
            me.restorePos = me.restoreSize = null;

            // Allow users to drag and drop again
            if (me.dd) {
                me.dd.enable();
                if (header) {
                    header.addCls(header.indicateDragCls);
                }
            }

            if (me.resizer) {
                me.resizer.enable();
            }

            me.container.removeCls(Ext.baseCSSPrefix + &#39;window-maximized-ct&#39;);

            me.syncMonitorWindowResize();

            if (!animate) {
                me.el.enableShadow(null, true);
                me.maximized = false;
                me.fireEvent(&#39;restore&#39;, me);
            }
        }
        return me;
    },

<span id='Ext-window-Window-method-syncMonitorWindowResize'>    /**
</span>     * Synchronizes the presence of our listener for window resize events. This method
     * should be called whenever this status might change.
     * @private
     */
    syncMonitorWindowResize: function () {
        var me = this,
            currentlyMonitoring = me._monitoringResize,
            // all the states where we should be listening to window resize:
            yes = me.monitorResize || me.constrain || me.constrainHeader || me.maximized,
            // all the states where we veto this:
            veto = me.hidden || me.destroying || me.destroyed;

        if (yes &amp;&amp; !veto) {
            // we should be listening...
            if (!currentlyMonitoring) {
                // but we aren&#39;t, so set it up.
                // Delay so that we jump over any Viewport resize activity
                Ext.on(&#39;resize&#39;, me.onWindowResize, me, {buffer: 1});
                me._monitoringResize = true;
            }
        } else if (currentlyMonitoring) {
            // we should not be listening, but we are, so tear it down
            Ext.un(&#39;resize&#39;, me.onWindowResize, me);
            me._monitoringResize = false;
        }
    },

<span id='Ext-window-Window-method-toggleMaximize'>    /**
</span>     * A shortcut method for toggling between {@link #method-maximize} and {@link #method-restore} based on the current maximized
     * state of the window.
     * @return {Ext.window.Window} this
     */
    toggleMaximize: function() {
        return this[this.maximized ? &#39;restore&#39;: &#39;maximize&#39;]();
    },

<span id='Ext-window-Window-method-createGhost'>    createGhost: function() {
</span>        var ghost = this.callParent(arguments);
        ghost.xtype = &#39;window&#39;;
        ghost.focusOnToFront = false;
        return ghost;
    },

<span id='Ext-window-Window-method-getDefaultFocus'>    /**
</span>     * Gets the configured default focus item.  If a {@link #defaultFocus} is set, it will
     * receive focus when the Window&#39;s `focus` method is called, otherwise the
     * Window itself will receive focus.
     */
    getDefaultFocus: function() {
        var me = this,
            result,
            defaultComp = me.defaultFocus,
            selector;

        if (defaultComp !== undefined) {
            // Number is index of Button
            if (Ext.isNumber(defaultComp)) {
                result = me.query(&#39;button&#39;)[defaultComp];
            }
            // String is ID or CQ selector
            else if (Ext.isString(defaultComp)) {
                selector = defaultComp;

                // Try id/itemId match if selector begins with alphanumeric
                // and is not compound xtype/id selector with # in the middle
                // (https://sencha.jira.com/browse/EXTJS-14925)
                if (Ext.validIdRe.test(selector)) {
                    result = me.down(Ext.makeIdSelector(selector));
                }
                // If not found, use as selector
                if (!result) {
                    result = me.down(selector);
                }
            }
            // Otherwise, if it&#39;s got a focus method, use it
            else if (defaultComp.focus) {
                result = defaultComp;
            }
        }

        return result;
    },

<span id='Ext-window-Window-property-privates'>    privates: {
</span>        // Override. Windows are always simple draggable, they do not use Ext.Panel.DDs
        // The dd property in a Window is always a ComponentDragger
        initDraggable: function() {
<span id='Ext-window-Window-property-dd'>            /**
</span>             * @property {Ext.util.ComponentDragger} dd
             * If this Window is configured {@link #cfg-draggable}, this property will contain an instance of
             * {@link Ext.util.ComponentDragger} (A subclass of {@link Ext.dd.DragTracker DragTracker}) which handles dragging
             * the Window&#39;s DOM Element, and constraining according to the {@link #constrain} and {@link #constrainHeader} .
             *
             * This has implementations of `onBeforeStart`, `onDrag` and `onEnd` which perform the dragging action. If
             * extra logic is needed at these points, use {@link Ext.Function#createInterceptor createInterceptor} or
             * {@link Ext.Function#createSequence createSequence} to augment the existing implementations.
             */
            this.initSimpleDraggable();
        },

        onHeaderClick: function(header, e) {
            var delegate;

            if (header.el.contains(e.getTarget())) {
                delegate = this.getDefaultFocus();

                if (delegate) {
                    delegate.focus();
                }
            }
        },

        initResizable: function(resizable) {
            var me = this;
            me.callParent([resizable]);
            if (me.maximized || me.maximizing) {
                me.resizer.disable();
            }
        },

        initSimpleDraggable: function() {
            var me = this,
                dd;

            me.callParent();
            dd = me.dd;
            if (dd &amp;&amp; me.maximized || me.maximizing) {
                dd.disable();
            }
        },
        
        onTabGuardFocusEnter: function(e, target) {
            var me = this,
                el = me.el,
                beforeGuard = me.tabGuardBeforeEl,
                afterGuard = me.tabGuardAfterEl,
                from = e.relatedTarget,
                nodes, forward, nextFocus;

            nodes = el.findTabbableElements({
                skipSelf: true
            });
            
            // Tabbables might include two tab guards, so remove them
            if (nodes[0] === beforeGuard.dom) {
                nodes.shift();
            }
            
            if (nodes[nodes.length - 1] === afterGuard.dom) {
                nodes.pop();
            }
            
            // Totally possible not to have anything tabbable within the window
            // but we have to do something so focus back the window el. At least
            // in that case the user will be able to press Escape key to close it.
            if (nodes.length === 0) {
                nextFocus = el;
            }
            // The window itself was focused, possibly by clicking or programmatically;
            // but this time we do have something tabbable to choose from.
            else if (from === el.dom) {
                forward = target === beforeGuard.dom;
            }
            // Focus was within the window and is trying to escape; 
            // for topmost guard we need to bounce focus back to the last tabbable
            // element in the window, and vice versa for the bottom guard.
            else if (el.contains(from)) {
                forward = !!e.forwardTab;
            }
            // It is entirely possible that focus was outside the window and
            // the user tabbed into the window. In that case we forward the focus
            // to the next available element in the natural tab order, i.e. the element
            // after the topmost guard, or the element before the bottom guard.
            else {
                forward = target === beforeGuard.dom;
            }
            
            nextFocus = nextFocus || (forward ? nodes[0] : nodes[nodes.length - 1]);
            
            if (nextFocus) {
                nextFocus.focus();
            }
        }
    }
});
</pre>
</body>
</html>
