<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-button-Button'>/**
</span> * Create simple buttons with this component. Customizations include {@link #iconAlign aligned}
 * {@link #iconCls icons}, {@link #cfg-menu dropdown menus}, {@link #tooltip tooltips}
 * and {@link #scale sizing options}. Specify a {@link #handler handler} to run code when
 * a user clicks the button, or use {@link #listeners listeners} for other events such as
 * {@link #mouseover mouseover}. Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.Button&#39;, {
 *         text: &#39;Click me&#39;,
 *         renderTo: Ext.getBody(),
 *         handler: function() {
 *             alert(&#39;You clicked the button!&#39;);
 *         }
 *     });
 *
 * The {@link #handler} configuration can also be updated dynamically using the {@link #setHandler}
 * method.  Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.Button&#39;, {
 *         text    : &#39;Dynamic Handler Button&#39;,
 *         renderTo: Ext.getBody(),
 *         handler : function() {
 *             // this button will spit out a different number every time you click it.
 *             // so firstly we must check if that number is already set:
 *             if (this.clickCount) {
 *                 // looks like the property is already set, so lets just add 1 to that number and alert the user
 *                 this.clickCount++;
 *                 alert(&#39;You have clicked the button &quot;&#39; + this.clickCount + &#39;&quot; times.\n\nTry clicking it again..&#39;);
 *             } else {
 *                 // if the clickCount property is not set, we will set it and alert the user
 *                 this.clickCount = 1;
 *                 alert(&#39;You just clicked the button for the first time!\n\nTry pressing it again..&#39;);
 *             }
 *         }
 *     });
 *
 * A button within a container:
 *
 *     @example
 *     Ext.create(&#39;Ext.Container&#39;, {
 *         renderTo: Ext.getBody(),
 *         items   : [
 *             {
 *                 xtype: &#39;button&#39;,
 *                 text : &#39;My Button&#39;
 *             }
 *         ]
 *     });
 *
 * A useful option of Button is the {@link #scale} configuration. This configuration has three different options:
 *
 * - `&#39;small&#39;`
 * - `&#39;medium&#39;`
 * - `&#39;large&#39;`
 *
 * Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.Button&#39;, {
 *         renderTo: document.body,
 *         text    : &#39;Click me&#39;,
 *         scale   : &#39;large&#39;
 *     });
 *
 * Buttons can also be toggled. To enable this, you simple set the {@link #enableToggle} property to `true`.
 * Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.Button&#39;, {
 *         renderTo: Ext.getBody(),
 *         text: &#39;Click Me&#39;,
 *         enableToggle: true
 *     });
 *
 * You can assign a menu to a button by using the {@link #cfg-menu} configuration. This standard configuration
 * can either be a reference to a {@link Ext.menu.Menu menu} object, a {@link Ext.menu.Menu menu} id or a
 * {@link Ext.menu.Menu menu} config blob. When assigning a menu to a button, an arrow is automatically
 * added to the button.  You can change the alignment of the arrow using the {@link #arrowAlign} configuration
 * on button.  Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.Button&#39;, {
 *         text      : &#39;Menu button&#39;,
 *         renderTo  : Ext.getBody(),
 *         arrowAlign: &#39;bottom&#39;,
 *         menu      : [
 *             {text: &#39;Item 1&#39;},
 *             {text: &#39;Item 2&#39;},
 *             {text: &#39;Item 3&#39;},
 *             {text: &#39;Item 4&#39;}
 *         ]
 *     });
 *
 * Using listeners, you can easily listen to events fired by any component, using the {@link #listeners}
 * configuration or using the {@link #addListener} method.  Button has a variety of different listeners:
 *
 * - `click`
 * - `toggle`
 * - `mouseover`
 * - `mouseout`
 * - `mouseshow`
 * - `menuhide`
 * - `menutriggerover`
 * - `menutriggerout`
 *
 * Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.Button&#39;, {
 *         text     : &#39;Button&#39;,
 *         renderTo : Ext.getBody(),
 *         listeners: {
 *             click: function() {
 *                 // this == the button, as we are in the local scope
 *                 this.setText(&#39;I was clicked!&#39;);
 *             },
 *             mouseover: function() {
 *                 // set a new config which says we moused over, if not already set
 *                 if (!this.mousedOver) {
 *                     this.mousedOver = true;
 *                     alert(&#39;You moused over a button!\n\nI wont do this again.&#39;);
 *                 }
 *             }
 *         }
 *     });
 */
Ext.define(&#39;Ext.button.Button&#39;, {

    /* Begin Definitions */
    alias: &#39;widget.button&#39;,
    extend: &#39;Ext.Component&#39;,

    requires: [
        &#39;Ext.dom.ButtonElement&#39;,
        &#39;Ext.button.Manager&#39;,
        &#39;Ext.menu.Manager&#39;,
        &#39;Ext.util.ClickRepeater&#39;,
        &#39;Ext.util.TextMetrics&#39;,
        &#39;Ext.Glyph&#39;
    ],

    mixins: [
        &#39;Ext.mixin.Queryable&#39;
    ],

    alternateClassName: &#39;Ext.Button&#39;,

    config: {
<span id='Ext-button-Button-cfg-iconAlign'>        /**
</span>         * @cfg {String} iconAlign
         * The side of the Button box to render the icon. Four values are allowed:
         *
         * - &#39;top&#39;
         * - &#39;right&#39;
         * - &#39;bottom&#39;
         * - &#39;left&#39;
         */
        iconAlign: &#39;left&#39;,

<span id='Ext-button-Button-cfg-text'>        /**
</span>         * @cfg {String}
         * The button text to be used as innerHTML (html tags are accepted).
         */
        text: null,

<span id='Ext-button-Button-cfg-textAlign'>        /**
</span>         * @cfg {String}
         * The text alignment for this button (center, left, right).
         */
        textAlign: &#39;center&#39;,

<span id='Ext-button-Button-cfg-arrowVisible'>        /**
</span>         * @cfg {Boolean}
         * `false` to hide the button arrow.  Only applicable for {@link Ext.button.Split
         * Split Buttons} and buttons configured with a {@link #cfg-menu}.
         */
        arrowVisible: true,

<span id='Ext-button-Button-cfg-glyph'>        /**
</span>         * @cfg {Number/String} glyph
         * @inheritdoc Ext.panel.Header#glyph
         */
        glyph: null

    },

    /* End Definitions */

<span id='Ext-button-Button-property-isButton'>    /**
</span>     * @property {Boolean}
     * `true` in this class to identify an object as an instantiated Button, or subclass thereof.
     */
    isButton: true,

    //&lt;feature legacyBrowser&gt;
<span id='Ext-button-Button-property-_syncFrameHeight'>    /**
</span>     * @property {Boolean}
     * @private
     * `true` to keep height of the frame&#39;s &quot;MC&quot; element in sync.  This is needed in IE8
     * so that the button&#39;s inner element(s) can use height:100% to fill the button when
     * it not in shrinkWrap mode
     */
    _syncFrameHeight: true,
    //&lt;/feature&gt;

<span id='Ext-button-Button-property-liquidLayout'>    /**
</span>     * @private
     * @readonly
     */
    liquidLayout: true,

<span id='Ext-button-Button-property-hidden'>    /**
</span>     * @property {Boolean} hidden
     * True if this button is hidden.
     * @readonly
     */
    hidden: false,

<span id='Ext-button-Button-property-disabled'>    /**
</span>     * @property {Boolean} disabled
     * True if this button is disabled.
     * @readonly
     */
    disabled: false,

<span id='Ext-button-Button-property-pressed'>    /**
</span>     * @property {Boolean} pressed
     * True if this button is pressed (only if enableToggle = true).
     * @readonly
     */
    pressed: false,

<span id='Ext-button-Button-cfg-icon'>    /**
</span>     * @cfg {String} icon
     * @inheritdoc Ext.panel.Header#icon
     */

<span id='Ext-button-Button-cfg-handler'>    /**
</span>     * @cfg {Function/String} handler
     * A function called when the button is clicked (can be used instead of click event).
     *
     * See also {@link #clickEvent}
     * @param {Ext.button.Button} button This button.
     * @param {Ext.event.Event} e The click event.
     * @controllable
     */

<span id='Ext-button-Button-cfg-minWidth'>    /**
</span>     * @cfg {Number} minWidth
     * The minimum width for this button (used to give a set of buttons a common width).
     * See also {@link Ext.panel.Panel}.{@link Ext.panel.Panel#minButtonWidth minButtonWidth}.
     */

<span id='Ext-button-Button-cfg-tooltip'>    /**
</span>     * @cfg {String/Object} tooltip
     * The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or
     * QuickTips config object.
     */

<span id='Ext-button-Button-cfg-hidden'>    /**
</span>     * @cfg {Boolean} [hidden=false]
     * True to start hidden.
     */

<span id='Ext-button-Button-cfg-disabled'>    /**
</span>     * @cfg {Boolean} [disabled=false]
     * True to start disabled.
     */

<span id='Ext-button-Button-cfg-padding'>    /**
</span>     * @cfg padding
     * @inheritdoc
     * @removed Use the $button-*-padding CSS Vars within a custom theme instead.
     */

<span id='Ext-button-Button-cfg-pressed'>    /**
</span>     * @cfg {Boolean} [pressed=false]
     * True to start pressed (only if enableToggle = true)
     */

<span id='Ext-button-Button-cfg-toggleGroup'>    /**
</span>     * @cfg {String} toggleGroup
     * The group this toggle button is a member of (only 1 per group can be pressed). If a toggleGroup
     * is specified, the {@link #enableToggle} configuration will automatically be set to true.
     */

<span id='Ext-button-Button-cfg-repeat'>    /**
</span>     * @cfg {Boolean/Object} [repeat=false]
     * True to repeat fire the click event while the mouse is down. This can also be a
     * {@link Ext.util.ClickRepeater ClickRepeater} config object.
     */

<span id='Ext-button-Button-cfg-tabIndex'>    /**
</span>     * @cfg {Number} tabIndex
     * Sets a DOM tabIndex for this button. tabIndex may be set to `-1` in order to remove
     * the button from the tab rotation.
     */
    tabIndex: 0,

<span id='Ext-button-Button-cfg-allowDepress'>    /**
</span>     * @cfg {Boolean} [allowDepress=true]
     * False to not allow a pressed Button to be depressed. Only valid when {@link #enableToggle} is true.
     */

<span id='Ext-button-Button-cfg-enableToggle'>    /**
</span>     * @cfg {Boolean} [enableToggle=false]
     * True to enable pressed/not pressed toggling. If a {@link #toggleGroup} is specified, this
     * option will be set to true.
     */
    enableToggle: false,

<span id='Ext-button-Button-cfg-toggleHandler'>    /**
</span>     * @cfg {Function/String} toggleHandler
     * Function called when a Button with {@link #enableToggle} set to true is clicked.
     * @cfg {Ext.button.Button} toggleHandler.button This button.
     * @cfg {Boolean} toggleHandler.state The next state of the Button, true means pressed.
     * @controllable
     */

<span id='Ext-button-Button-cfg-menu'>    /**
</span>     * @cfg {Ext.menu.Menu/String/Object} menu
     * Standard menu attribute consisting of a reference to a menu object, a menu id
     * or a menu config blob. Note that using menus with handlers or click event listeners
     * violates WAI-ARIA 1.0 requirements for accessible Web applications, and is not
     * recommended.
     */

<span id='Ext-button-Button-cfg-menuAlign'>    /**
</span>     * @cfg {String} menuAlign
     * The position to align the menu to (see {@link Ext.util.Positionable#alignTo} for more details).
     */
    menuAlign: &#39;tl-bl?&#39;,

<span id='Ext-button-Button-cfg-showEmptyMenu'>    /**
</span>     * @cfg {Boolean} showEmptyMenu
     * True to force an attached {@link #cfg-menu} with no items to be shown when clicking
     * this button. By default, the menu will not show if it is empty.
     */
    showEmptyMenu: false,

<span id='Ext-button-Button-cfg-overflowText'>    /**
</span>     * @cfg {String} overflowText
     * If used in a {@link Ext.toolbar.Toolbar Toolbar}, the text to be used if this item is shown in the overflow menu.
     * See also {@link Ext.toolbar.Item}.`{@link Ext.toolbar.Item#overflowText overflowText}`.
     */

<span id='Ext-button-Button-cfg-iconCls'>    /**
</span>     * @cfg {String} iconCls
     * @inheritdoc Ext.panel.Header#cfg-iconCls
     */

<span id='Ext-button-Button-cfg-clickEvent'>    /**
</span>     * @cfg {String} clickEvent
     * The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu).
     */
    clickEvent: &#39;click&#39;,

<span id='Ext-button-Button-cfg-preventDefault'>    /**
</span>     * @cfg {Boolean} preventDefault
     * Is set to `true` to prevent the default action when the {@link #clickEvent} is processed.
     * This provides focus control for clicks and stops scrolling on some devices when using the keyboard
     * to simulate clicks. Set this to `false` if you need to listen directly to element events (for
     * example, to use `window.open()` in response to a click).
     */
    preventDefault: true,

<span id='Ext-button-Button-cfg-handleMouseEvents'>    /**
</span>     * @cfg {Boolean} handleMouseEvents
     * False to disable visual cues on mouseover, mouseout and mousedown.
     */
    handleMouseEvents: true,

<span id='Ext-button-Button-cfg-tooltipType'>    /**
</span>     * @cfg {String} tooltipType
     * The type of tooltip to use. Either &#39;qtip&#39; for QuickTips or &#39;title&#39; for title attribute.
     */
    tooltipType: &#39;qtip&#39;,

<span id='Ext-button-Button-cfg-baseCls'>    /**
</span>     * @cfg {String} [baseCls=&#39;x-btn&#39;]
     * The base CSS class to add to all buttons.
     */
    baseCls: Ext.baseCSSPrefix + &#39;btn&#39;,

<span id='Ext-button-Button-cfg-href'>    /**
</span>     * @cfg {String} href
     * The URL to open when the button is clicked. Specifying this config causes the Button to be
     * rendered with the specified URL as the `href` attribute of its `&lt;a&gt;` Element.
     *
     * This is better than specifying a click handler of
     *
     *     function() { window.location = &quot;http://www.sencha.com&quot; }
     *
     * because the UI will provide meaningful hints to the user as to what to expect upon clicking
     * the button, and will also allow the user to open in a new tab or window, bookmark or drag the URL, or directly save
     * the URL stream to disk.
     *
     * See also the {@link #hrefTarget} config.
     */

<span id='Ext-button-Button-cfg-hrefTarget'>    /**
</span>      * @cfg {String} [hrefTarget=&quot;_blank&quot;]
      * The target attribute to use for the underlying anchor. Only used if the {@link #href}
      * property is specified.
      */
     hrefTarget: &#39;_blank&#39;,

<span id='Ext-button-Button-cfg-destroyMenu'>     /**
</span>     * @cfg {Boolean} [destroyMenu=true]
     * Whether or not to destroy any associated menu when this button is destroyed.
     * In addition, a value of `true` for this config will destroy the currently bound menu when a new
     * menu is set in {@link #setMenu} unless overridden by that method&#39;s destroyMenu function argument.
     */
     destroyMenu: true,

<span id='Ext-button-Button-cfg-baseParams'>    /**
</span>     * @cfg {Object} baseParams
     * An object literal of parameters to pass to the url when the {@link #href} property is specified.
     */

<span id='Ext-button-Button-cfg-params'>    /**
</span>     * @cfg {Object} params
     * An object literal of parameters to pass to the url when the {@link #href} property is specified. Any params
     * override {@link #baseParams}. New params can be set using the {@link #setParams} method.
     */

<span id='Ext-button-Button-cfg-value'>    /**
</span>     * @cfg {String/Number} value
     * The value of this button.  Only applicable when used as an item of a {@link Ext.button.Segmented Segmented Button}.
     */

    focusable: true,
<span id='Ext-button-Button-property-ariaRole'>    ariaRole: &#39;button&#39;,
</span>
<span id='Ext-button-Button-cfg-keyMap'>    keyMap: {
</span>        scope: &#39;this&#39;,
        SPACE: &#39;onEnterKey&#39;,
        ENTER: &#39;onEnterKey&#39;,
        DOWN: &#39;onDownKey&#39;
    },

<span id='Ext-button-Button-property-defaultBindProperty'>    defaultBindProperty: &#39;text&#39;,
</span>
<span id='Ext-button-Button-cfg-childEls'>    childEls: [
</span>        &#39;btnEl&#39;, &#39;btnWrap&#39;, &#39;btnInnerEl&#39;, &#39;btnIconEl&#39;, &#39;arrowEl&#39;
    ],

<span id='Ext-button-Button-cfg-publishes'>    publishes: {
</span>        pressed: 1
    },

<span id='Ext-button-Button-property-_btnWrapCls'>    /**
</span>     * @private
     */
    _btnWrapCls: Ext.baseCSSPrefix + &#39;btn-wrap&#39;,
<span id='Ext-button-Button-property-_btnCls'>    _btnCls: Ext.baseCSSPrefix + &#39;btn-button&#39;,
</span><span id='Ext-button-Button-property-_baseIconCls'>    _baseIconCls: Ext.baseCSSPrefix + &#39;btn-icon-el&#39;,
</span><span id='Ext-button-Button-property-_glyphCls'>    _glyphCls: Ext.baseCSSPrefix + &#39;btn-glyph&#39;,
</span><span id='Ext-button-Button-property-_innerCls'>    _innerCls: Ext.baseCSSPrefix + &#39;btn-inner&#39;,
</span><span id='Ext-button-Button-property-_textCls'>    _textCls: Ext.baseCSSPrefix + &#39;btn-text&#39;,
</span><span id='Ext-button-Button-property-_noTextCls'>    _noTextCls: Ext.baseCSSPrefix + &#39;btn-no-text&#39;,
</span><span id='Ext-button-Button-property-_hasIconCls'>    _hasIconCls: Ext.baseCSSPrefix + &#39;btn-icon&#39;,
</span><span id='Ext-button-Button-property-_pressedCls'>    _pressedCls: Ext.baseCSSPrefix + &#39;btn-pressed&#39;,
</span><span id='Ext-button-Button-cfg-overCls'>    overCls: Ext.baseCSSPrefix + &#39;btn-over&#39;,
</span><span id='Ext-button-Button-property-_disabledCls'>    _disabledCls: Ext.baseCSSPrefix + &#39;btn-disabled&#39;,
</span><span id='Ext-button-Button-property-_menuActiveCls'>    _menuActiveCls: Ext.baseCSSPrefix + &#39;btn-menu-active&#39;,
</span><span id='Ext-button-Button-property-_arrowElCls'>    _arrowElCls: Ext.baseCSSPrefix + &#39;btn-arrow-el&#39;,
</span><span id='Ext-button-Button-property-_focusCls'>    _focusCls: Ext.baseCSSPrefix + &#39;btn-focus&#39;,
</span><span id='Ext-button-Button-property-_arrowFocusCls'>    _arrowFocusCls: Ext.baseCSSPrefix + &#39;arrow-focus&#39;,
</span>
<span id='Ext-button-Button-cfg-renderTpl'>    // We have to keep &quot;unselectable&quot; attribute on all elements because it&#39;s not inheritable.
</span>    // Without it, clicking anywhere on a button disrupts current selection and cursor position
    // in HtmlEditor.
    renderTpl:
        &#39;&lt;span id=&quot;{id}-btnWrap&quot; data-ref=&quot;btnWrap&quot; role=&quot;presentation&quot; unselectable=&quot;on&quot; style=&quot;{btnWrapStyle}&quot; &#39; +
                &#39;class=&quot;{btnWrapCls} {btnWrapCls}-{ui} {splitCls}{childElCls}&quot;&gt;&#39; +
            &#39;&lt;span id=&quot;{id}-btnEl&quot; data-ref=&quot;btnEl&quot; role=&quot;presentation&quot; unselectable=&quot;on&quot; style=&quot;{btnElStyle}&quot; &#39; +
                    &#39;class=&quot;{btnCls} {btnCls}-{ui} {textCls} {noTextCls} {hasIconCls} &#39; +
                    &#39;{iconAlignCls} {textAlignCls} {btnElAutoHeightCls}{childElCls}&quot;&gt;&#39; +
                &#39;&lt;tpl if=&quot;iconBeforeText&quot;&gt;{[values.$comp.renderIcon(values)]}&lt;/tpl&gt;&#39; +
                &#39;&lt;span id=&quot;{id}-btnInnerEl&quot; data-ref=&quot;btnInnerEl&quot; unselectable=&quot;on&quot; &#39; +
                    &#39;class=&quot;{innerCls} {innerCls}-{ui}{childElCls}&quot;&gt;{text}&lt;/span&gt;&#39; +
                &#39;&lt;tpl if=&quot;!iconBeforeText&quot;&gt;{[values.$comp.renderIcon(values)]}&lt;/tpl&gt;&#39; +
            &#39;&lt;/span&gt;&#39; +
        &#39;&lt;/span&gt;&#39; +
        &#39;{[values.$comp.getAfterMarkup ? values.$comp.getAfterMarkup(values) : &quot;&quot;]}&#39; +
        // if &quot;closable&quot; (tab) add a close element icon
        &#39;&lt;tpl if=&quot;closable&quot;&gt;&#39; +
            &#39;&lt;span id=&quot;{id}-closeEl&quot; data-ref=&quot;closeEl&quot; class=&quot;{baseCls}-close-btn&quot;&gt;&#39; +
                &#39;&lt;tpl if=&quot;closeText&quot;&gt;&#39; +
                    &#39; {closeText}&#39; +
                &#39;&lt;/tpl&gt;&#39; +
            &#39;&lt;/span&gt;&#39; +
        &#39;&lt;/tpl&gt;&#39; +
        // Split buttons have additional tab stop for the arrow element
        &#39;&lt;tpl if=&quot;split&quot;&gt;&#39; +
            &#39;&lt;span id=&quot;{id}-arrowEl&quot; class=&quot;{arrowElCls}&quot; data-ref=&quot;arrowEl&quot; &#39; +
                &#39;role=&quot;button&quot; hidefocus=&quot;on&quot; unselectable=&quot;on&quot;&#39; +
                &#39;&lt;tpl if=&quot;tabIndex != null&quot;&gt; tabindex=&quot;{tabIndex}&quot;&lt;/tpl&gt;&#39; +
                &#39;&lt;tpl foreach=&quot;arrowElAttributes&quot;&gt; {$}=&quot;{.}&quot;&lt;/tpl&gt;&#39; +
                &#39; style=&quot;{arrowElStyle}&quot;&#39; +
            &#39;&gt;{arrowElText}&lt;/span&gt;&#39; +
        &#39;&lt;/tpl&gt;&#39;,

<span id='Ext-button-Button-property-iconTpl'>    iconTpl:
</span>        &#39;&lt;span id=&quot;{id}-btnIconEl&quot; data-ref=&quot;btnIconEl&quot; role=&quot;presentation&quot; unselectable=&quot;on&quot; class=&quot;{baseIconCls} &#39; +
                &#39;{baseIconCls}-{ui} {iconCls} {glyphCls}{childElCls}&quot; style=&quot;&#39; +
            &#39;&lt;tpl if=&quot;iconUrl&quot;&gt;background-image:url({iconUrl});&lt;/tpl&gt;&#39; +
            &#39;&lt;tpl if=&quot;glyph&quot;&gt;&#39; +
                &#39;&lt;tpl if=&quot;glyphFontFamily&quot;&gt;&#39; +
                    &#39;font-family:{glyphFontFamily};&#39; +
                &#39;&lt;/tpl&gt;&#39; +
                &#39;&quot;&gt;{glyph}&#39; +
            &#39;&lt;tpl else&gt;&#39; +
                &#39;&quot;&gt;&#39; +
            &#39;&lt;/tpl&gt;&#39; +
        &#39;&lt;/span&gt;&#39;,

<span id='Ext-button-Button-cfg-scale'>    /**
</span>     * @cfg {&quot;small&quot;/&quot;medium&quot;/&quot;large&quot;} scale
     * The size of the Button. Three values are allowed:
     *
     * - &#39;small&#39; - Results in the button element being 16px high.
     * - &#39;medium&#39; - Results in the button element being 24px high.
     * - &#39;large&#39; - Results in the button element being 32px high.
     */
    scale: &#39;small&#39;,

<span id='Ext-button-Button-property-allowedScales'>    /**
</span>     * @private
     * An array of allowed scales.
     */
    allowedScales: [&#39;small&#39;, &#39;medium&#39;, &#39;large&#39;],

<span id='Ext-button-Button-cfg-scope'>    /**
</span>     * @cfg {Object} scope
     * The scope (**this** reference) in which the `{@link #handler}` and `{@link #toggleHandler}` is executed.
     * Defaults to this Button.
     */


<span id='Ext-button-Button-cfg-arrowAlign'>    /**
</span>     * @cfg {String} arrowAlign
     * The side of the Button box to render the arrow if the button has an associated {@link #cfg-menu}. Two
     * values are allowed:
     *
     * - &#39;right&#39;
     * - &#39;bottom&#39;
     */
    arrowAlign: &#39;right&#39;,

<span id='Ext-button-Button-cfg-arrowCls'>    /**
</span>     * @cfg {String} arrowCls
     * The className used for the inner arrow element if the button has a menu.
     */
    arrowCls: &#39;arrow&#39;,

<span id='Ext-button-Button-property-template'>    /**
</span>     * @property {Ext.Template} template
     * A {@link Ext.Template Template} used to create the Button&#39;s DOM structure.
     *
     * Instances, or subclasses which need a different DOM structure may provide a different template layout in
     * conjunction with an implementation of {@link #getTemplateArgs}.
     */

<span id='Ext-button-Button-cfg-cls'>    /**
</span>     * @cfg {String} cls
     * A CSS class string to apply to the button&#39;s main element.
     */

<span id='Ext-button-Button-property-menu'>    /**
</span>     * @property {Ext.menu.Menu} menu
     * The {@link Ext.menu.Menu Menu} object associated with this Button when configured with the {@link #cfg-menu} config
     * option.
     */

    maskOnDisable: false,

<span id='Ext-button-Button-cfg-shrinkWrap'>    shrinkWrap: 3,
</span>
<span id='Ext-button-Button-cfg-frame'>    frame: true,
</span>
<span id='Ext-button-Button-cfg-autoEl'>    autoEl: {
</span>        tag: &#39;a&#39;,
        hidefocus: &#39;on&#39;,
        unselectable: &#39;on&#39;
    },

<span id='Ext-button-Button-method-hasFrameTable'>    hasFrameTable: function () {
</span>        // Instead of browser sniffing, it&#39;s easier to check for the presence of frameTable.
        // If present, we know that it&#39;s a browser that doesn&#39;t support CSS3BorderRadius.
        return this.href &amp;&amp; this.frameTable;
    },

<span id='Ext-button-Button-method-frameTableListener'>    frameTableListener: function () {
</span>        if (!this.disabled) {
            this.doNavigate();
        }
    },

<span id='Ext-button-Button-method-doNavigate'>    doNavigate: function () {
</span>        // Non-HTML5 browsers don&#39;t support a block element inside an A tag.
        // http://stackoverflow.com/questions/5682048/putting-a-table-inside-a-hyperlink-not-working-in-ie
        // Note use this.getHref() to append any params to the url.
        if (this.hrefTarget === &#39;_blank&#39;) {
            window.open(this.getHref(), this.hrefTarget);
        } else {
            location.href = this.getHref();
        }
    },

<span id='Ext-button-Button-property-_triggerRegion'>    // A reusable object used by getTriggerRegion to avoid excessive object creation.
</span>    _triggerRegion: {},

<span id='Ext-button-Button-event-click'>    /**
</span>     * @event click
     * Fires when this button is clicked, before the configured {@link #handler} is invoked. Execution of the
     * {@link #handler} may be vetoed by returning `false` to this event.
     * @param {Ext.button.Button} this
     * @param {Event} e The click event
     */

<span id='Ext-button-Button-event-beforetoggle'>    /**
</span>     * @event beforetoggle
     * Fires before the &#39;pressed&#39; state of this button changes (only if enableToggle = true)
     * If a handler returns `false`, the toggle is vetoed.
     * @param {Ext.button.Button} this
     * @param {Boolean} pressed
     */

<span id='Ext-button-Button-event-toggle'>    /**
</span>     * @event toggle
     * Fires when the &#39;pressed&#39; state of this button changes (only if enableToggle = true)
     * @param {Ext.button.Button} this
     * @param {Boolean} pressed
     */

<span id='Ext-button-Button-event-mouseover'>    /**
</span>     * @event mouseover
     * Fires when the mouse hovers over the button
     * @param {Ext.button.Button} this
     * @param {Event} e The event object
     */

<span id='Ext-button-Button-event-mouseout'>    /**
</span>     * @event mouseout
     * Fires when the mouse exits the button
     * @param {Ext.button.Button} this
     * @param {Event} e The event object
     */

<span id='Ext-button-Button-event-menushow'>    /**
</span>     * @event menushow
     * If this button has a menu, this event fires when it is shown
     * @param {Ext.button.Button} this
     * @param {Ext.menu.Menu} menu
     */

<span id='Ext-button-Button-event-menuhide'>    /**
</span>     * @event menuhide
     * If this button has a menu, this event fires when it is hidden
     * @param {Ext.button.Button} this
     * @param {Ext.menu.Menu} menu
     */

<span id='Ext-button-Button-event-menutriggerover'>    /**
</span>     * @event menutriggerover
     * If this button has a menu, this event fires when the mouse enters the menu triggering element
     * @param {Ext.button.Button} this
     * @param {Ext.menu.Menu} menu
     * @param {Event} e
     */

<span id='Ext-button-Button-event-menutriggerout'>    /**
</span>     * @event menutriggerout
     * If this button has a menu, this event fires when the mouse leaves the menu triggering element
     * @param {Ext.button.Button} this
     * @param {Ext.menu.Menu} menu
     * @param {Event} e
     */

<span id='Ext-button-Button-event-textchange'>    /**
</span>     * @event textchange
     * Fired when the button&#39;s text is changed by the {@link #setText} method.
     * @param {Ext.button.Button} this
     * @param {String} oldText
     * @param {String} newText
     */

<span id='Ext-button-Button-event-iconchange'>    /**
</span>     * @event iconchange
     * Fired when the button&#39;s icon is changed by the {@link #setIcon} or {@link #setIconCls} methods.
     * @param {Ext.button.Button} this
     * @param {String} oldIcon
     * @param {String} newIcon
     */

<span id='Ext-button-Button-event-glyphchange'>    /**
</span>     * @event glyphchange
     * Fired when the button&#39;s glyph is changed by the {@link #setGlyph} method.
     * @param {Ext.button.Button} this
     * @param {Number/String} newGlyph
     * @param {Number/String} oldGlyph
     */

    initComponent: function() {
        var me = this;

        // WAI-ARIA spec requires that menu buttons react to Space and Enter keys
        // by showing the menu while leaving focus on the button, and to Down Arrow key
        // by showing the menu and selecting first menu item. This behavior may conflict
        // with historical Ext JS menu button behavior if a handler or a click listener
        // is set on a button; in that case Space or Enter key would activate
        // the handler/click listener, and only Down Arrow key would open the menu.
        // To avoid the ambiguity, we check if the button has both menu *and* handler
        // or click event listener, and warn the developer in that case.
        // Note that this check does not apply to Split buttons because those now have
        // two tab stops and can effectively combine both menu and toggling/href/handler.
        //&lt;debug&gt;
        if (!me.isSplitButton &amp;&amp; me.menu) {
            if (me.enableToggle || me.toggleGroup) {
                Ext.ariaWarn(me,
                    &quot;According to WAI-ARIA 1.0 Authoring guide &quot; +
                    &quot;(http://www.w3.org/TR/wai-aria-practices/#menubutton), &quot; +
                    &quot;menu button &#39;&quot; + me.id + &quot;&#39; behavior will conflict with &quot; +
                    &quot;toggling.&quot;
                );
            }

            if (me.href) {
                Ext.ariaWarn(me,
                    &quot;According to WAI-ARIA 1.0 Authoring guide &quot; +
                    &quot;(http://www.w3.org/TR/wai-aria-practices/#menubutton), &quot; +
                    &quot;menu button &#39;&quot; + me.id + &quot;&#39; cannot behave as a link.&quot;
                );
            }

            // Only check listeners of the component instance; there could be other
            // listeners on the EventBus inherited via hasListeners prototype.
            if (me.handler || me.hasListeners.hasOwnProperty(&#39;click&#39;)) {
                Ext.ariaWarn(me,
                    &quot;According to WAI-ARIA 1.0 Authoring guide &quot; +
                    &quot;(http://www.w3.org/TR/wai-aria-practices/#menubutton), &quot; +
                    &quot;menu button &#39;&quot; + me.id + &quot;&#39; should display the menu &quot; +
                    &quot;on SPACE and ENTER keys, which will conflict with the &quot; +
                    &quot;button handler.&quot;
                );
            }
        }
        //&lt;/debug&gt;

        // Ensure no selection happens
        me.addCls(Ext.baseCSSPrefix + &#39;unselectable&#39;);

        me.callParent();

        if (me.menu) {
            // Flag that we&#39;ll have a splitCls
            me.split = true;
            me.setMenu(me.menu, /*destroyMenu*/false, true);
        }

        // Accept url as a synonym for href
        if (me.url) {
            me.href = me.url;
        }

        // preventDefault defaults to false for links
        me.configuredWithPreventDefault = me.hasOwnProperty(&#39;preventDefault&#39;);
        if (me.href &amp;&amp; !me.configuredWithPreventDefault) {
            me.preventDefault = false;
        }

        if (Ext.isString(me.toggleGroup) &amp;&amp; me.toggleGroup !== &#39;&#39;) {
            me.enableToggle = true;
        }

        if (me.html &amp;&amp; !me.text) {
            me.text = me.html;
            delete me.html;
        }
    },

<span id='Ext-button-Button-method-getElConfig'>    getElConfig: function() {
</span>        var me = this,
            config = me.callParent(),
            href = me.getHref(),
            hrefTarget = me.hrefTarget;

        if (config.tag === &#39;a&#39;) {
            if (!me.disabled) {
                config.tabIndex = me.tabIndex;
            }
            if (href) {
                // https://sencha.jira.com/browse/EXTJS-11964
                // Disabled links are clickable on iPad, and right clickable on desktop browsers.
                // The only way to completely disable navigation is removing the href
                if (!me.disabled) {
                    config.href = href;
                    if (hrefTarget) {
                       config.target = hrefTarget;
                    }
                }
            }
        }

        if (!me.ariaStaticRoles[me.ariaRole]) {
            // Split buttons render aria-haspopup into arrowEl
            if (me.menu &amp;&amp; !me.isSplitButton) {
                config[&#39;aria-haspopup&#39;] = true;
            }

            if (me.enableToggle) {
                config[&#39;aria-pressed&#39;] = !!me.pressed;
            }
        }

        return config;
    },

<span id='Ext-button-Button-method-beforeRender'>    beforeRender: function() {
</span>        this.callParent();

        if (this.pressed) {
            this.addCls(this._pressedCls);
        }
    },

<span id='Ext-button-Button-method-initRenderData'>    initRenderData: function () {
</span>        return Ext.apply(this.callParent(), this.getTemplateArgs());
    },

<span id='Ext-button-Button-method-getMenu'>    /**
</span>     * Get the {@link #cfg-menu} for this button.
     * @return {Ext.menu.Menu} The menu. `null` if no menu is configured.
     */
    getMenu: function() {
        return this.menu || null;
    },

<span id='Ext-button-Button-method-setMenu'>    /**
</span>     * Sets a new menu for this button. Pass a falsy value to unset the current menu.
     * To destroy the previous menu for this button, explicitly pass `false` as the second argument. If this is not set, the destroy will depend on the
     * value of {@link #cfg-destroyMenu}.
     *
     * @param {Ext.menu.Menu/String/Object/null} menu Accepts a menu component, a menu id or a menu config.
     * @param {Boolean} destroyMenu By default, will destroy the previous set menu and remove it from the menu manager. Pass `false` to prevent the destroy.
     */
    setMenu: function (menu, destroyMenu, /* private */ initial) {
        var me = this,
            oldMenu = me.menu,
            ariaDom = me.isSplitButton ? me.arrowEl &amp;&amp; me.arrowEl.dom : me.ariaEl.dom,
            instanced, ariaAttr;

        if (oldMenu &amp;&amp; !initial) {
            if (destroyMenu !== false &amp;&amp; me.destroyMenu) {
                oldMenu.destroy();
            }
            oldMenu.ownerCmp = null;
        }

        if (menu) {
            instanced = menu.isMenu;
            // Retrieve menu by id or instantiate instance if needed.
            menu = Ext.menu.Manager.get(menu, {
                // Use ownerCmp as the upward link. Menus *must have no ownerCt* - they are global floaters.
                // Upward navigation is done using the up() method.
                ownerCmp: me
            });
            // We need to forcibly set this here because we could be passed an existing menu, which means
            // the config above won&#39;t get applied during creation.
            menu.setOwnerCmp(me, instanced);

            // Menu can&#39;t reshow within 250ms of being hidden.
            // Likewise, must set here in case an instantiated Menu is passed.
            // This is so that clicking on this button when the menu is visible
            // leaves the menu hidden. Mousedown hides it, and the click caused by
            // mouseup should not reshow.
            menu.menuClickBuffer = 250;

            me.mon(menu, {
                scope: me,
                show: me.onMenuShow,
                hide: me.onMenuHide
            });

            // If the button wasn&#39;t initially configured with a menu or has previously been unset then we need
            // to poke the split classes onto the btnWrap dom element.
            if (!oldMenu &amp;&amp; me.getArrowVisible()) {
                me.split = true;
                if (me.rendered) {
                    me._addSplitCls();
                    me.updateLayout();
                }
            }

            me.menu = menu;

            // May not be rendered yet
            if (ariaDom) {
                ariaDom.setAttribute(&#39;aria-haspopup&#39;, true);
                ariaDom.setAttribute(&#39;aria-owns&#39;, menu.id);
            }
            else {
                // We use me.isSplitButton here because me.split can be set to true
                // for ordinary menu buttons. We only render arrowEl for the true Split buttons.
                ariaAttr = me.isSplitButton ? (me.ariaArrowElAttributes || (me.ariaArrowElAttributes = {}))
                         :                    (me.ariaRenderAttributes  || (me.ariaRenderAttributes = {}))
                         ;

                ariaAttr[&#39;aria-haspopup&#39;] = true;
                ariaAttr[&#39;aria-owns&#39;] = menu.id;
            }
        }
        else {
            if (me.rendered) {
                ariaDom.removeAttribute(&#39;aria-haspopup&#39;);
                ariaDom.removeAttribute(&#39;aria-owns&#39;);
                me._removeSplitCls();
                me.updateLayout();
            }
            else {
                ariaAttr = me.isSplitButton ? me.ariaArrowElAttributes : me.ariaRenderAttributes;

                if (ariaAttr) {
                    delete ariaAttr[&#39;aria-haspopup&#39;];
                    delete ariaAttr[&#39;aria-owns&#39;];
                }
            }

            me.split = false;
            me.menu = null;
        }
    },

<span id='Ext-button-Button-method-onRender'>    /**
</span>     * @private
     */
    onRender: function() {
        var me = this,
            addOnclick,
            btn,
            btnListeners;

        me.callParent(arguments);

        // Set btn as a local variable for easy access
        btn = me.el;

        if (me.tooltip) {
            me.setTooltip(me.tooltip, true);
        }

        // Add the mouse events to the button
        if (me.handleMouseEvents) {
            btnListeners = {
                scope: me,
                mouseover: me.onMouseOver,
                mouseout: me.onMouseOut,
                mousedown: me.onMouseDown
            };
            if (me.split) {
                btnListeners.mousemove = me.onMouseMove;
            }
        } else {
            btnListeners = {
                scope: me
            };
        }

        // Touch start events must be preventDefaulted when in disabled state
        if (Ext.supports.Touch) {
            btnListeners.touchstart = me.onTouchStart;
        }

        // Check if it is a repeat button
        if (me.repeat) {
            me.mon(new Ext.util.ClickRepeater(btn, Ext.isObject(me.repeat) ? me.repeat: {}), &#39;click&#39;, me.onRepeatClick, me);
        } else {

            // If the activation event already has a handler, make a note to add the handler later
            if (btnListeners[me.clickEvent]) {
                addOnclick = true;
            } else {
                btnListeners[me.clickEvent] = me.onClick;
            }
        }

        // Add whatever button listeners we need
        me.mon(btn, btnListeners);

        if (me.hasFrameTable()) {
            me.mon(me.frameTable, &#39;click&#39;, me.frameTableListener, me);
        }

        // If the listeners object had an entry for our clickEvent, add a listener now
        if (addOnclick) {
            me.mon(btn, me.clickEvent, me.onClick, me);
        }

        Ext.button.Manager.register(me);
    },

<span id='Ext-button-Button-method-onFocusLeave'>    onFocusLeave: function(e) {
</span>        this.callParent([e]);
        if (this.menu) {
            this.menu.hide();
        }
    },

<span id='Ext-button-Button-method-getTemplateArgs'>    /**
</span>     * This method returns an object which provides substitution parameters for the {@link #renderTpl XTemplate} used to
     * create this Button&#39;s DOM structure.
     *
     * Instances or subclasses which use a different Template to create a different DOM structure may need to provide
     * their own implementation of this method.
     * @protected
     *
     * @return {Object} Substitution data for a Template. The default implementation which provides data for the default
     * {@link #template} returns an Object containing the following properties:
     * @return {String} return.innerCls A CSS class to apply to the button&#39;s text element.
     * @return {String} return.splitCls A CSS class to determine the presence and position of an arrow icon.
     * (`&#39;x-btn-arrow&#39;` or `&#39;x-btn-arrow-bottom&#39;` or `&#39;&#39;`)
     * @return {String} return.iconUrl The url for the button icon.
     * @return {String} return.iconCls The CSS class for the button icon.
     * @return {String} return.glyph The glyph to use as the button icon.
     * @return {String} return.glyphCls The CSS class to use for the glyph element.
     * @return {String} return.glyphFontFamily The CSS font-family to use for the glyph element.
     * @return {String} return.text The {@link #text} to display ion the Button.
     */
    getTemplateArgs: function() {
        var me = this,
            btnCls = me._btnCls,
            baseIconCls = me._baseIconCls,
            iconAlign = me.getIconAlign(),
            glyph = me.glyph,
            glyphFontFamily,
            text = me.text,
            hasIcon = me._hasIcon(),
            hasIconCls = me._hasIconCls;

        // Transform Glyph to the useful parts
        if (glyph) {
            glyphFontFamily = glyph.fontFamily;
            glyph = glyph.character;
        }

        return {
            split: me.isSplitButton,
            innerCls: me._innerCls,
            splitCls: me.getArrowVisible() ? me.getSplitCls() : &#39;&#39;,
            iconUrl: me.icon,
            iconCls: me.iconCls,
            glyph: glyph,
            glyphCls: glyph ? me._glyphCls : &#39;&#39;,
            glyphFontFamily: glyphFontFamily,
            text: text || &#39;&amp;#160;&#39;,
            closeText: me.closeText,
            textCls: text ? me._textCls : &#39;&#39;,
            noTextCls: text ? &#39;&#39; : me._noTextCls,
            hasIconCls: hasIcon ? hasIconCls : &#39;&#39;,
            btnWrapCls: me._btnWrapCls,
            btnWrapStyle: me.width ? &#39;table-layout:fixed;&#39; : &#39;&#39;,
            btnElStyle: me.height ? &#39;height:auto;&#39; : &#39;&#39;,
            btnCls: btnCls,
            baseIconCls: baseIconCls,
            iconBeforeText: iconAlign === &#39;left&#39; || iconAlign === &#39;top&#39;,
            iconAlignCls: hasIcon ? (hasIconCls + &#39;-&#39; + iconAlign) : &#39;&#39;,
            textAlignCls: btnCls + &#39;-&#39; + me.getTextAlign(),
            arrowElCls: me._arrowElCls,
            arrowElStyle: me.arrowVisible ? &#39;&#39; : &#39;display:none&#39;,
            tabIndex: me.tabIndex
        };
    },

<span id='Ext-button-Button-method-renderIcon'>    renderIcon: function(values) {
</span>        return this.lookupTpl(&#39;iconTpl&#39;).apply(values);
    },

<span id='Ext-button-Button-method-setHref'>    /**
</span>     * Sets the href of the embedded anchor element to the passed URL.
     *
     * Also appends any configured {@link #cfg-baseParams} and parameters set through {@link #setParams}.
     * @param {String} href The URL to set in the anchor element.
     *
     */
    setHref: function(href) {
        var me = this,
            hrefTarget = me.hrefTarget,
            dom;

        me.href = href;

        if (!me.configuredWithPreventDefault) {
            me.preventDefault = !href;
        }

        if (me.rendered) {
            dom = me.el.dom;
            // https://sencha.jira.com/browse/EXTJS-11964
            // Disabled links are clickable on iPad, and right clickable on desktop browsers.
            // The only way to completely disable navigation is removing the href
            if (!href || me.disabled) {
                dom.removeAttribute(&#39;href&#39;);
                dom.removeAttribute(&#39;hrefTarget&#39;);
            } else {
                dom.href = me.getHref();
                if (hrefTarget) {
                    dom.target = hrefTarget;
                }
            }
        }
    },

<span id='Ext-button-Button-method-getHref'>    /**
</span>     * @private
     * If there is a configured href for this Button, returns the href with parameters appended.
     * @return {String/Boolean} The href string with parameters appended.
     */
    getHref: function() {
        var me = this,
            href = me.href;

        return href ? Ext.urlAppend(href, Ext.Object.toQueryString(Ext.apply({}, me.params, me.baseParams))) : false;
    },

<span id='Ext-button-Button-method-setParams'>    /**
</span>     * Sets the href of the link dynamically according to the params passed, and any {@link #baseParams} configured.
     *
     *     var button = Ext.create(&#39;Ext.button.Button&#39;, {
     *         renderTo   : document.body,
     *         text       : &#39;Open&#39;,
     *         href       : &#39;http://www.sencha.com&#39;,
     *         baseParams : {
     *             foo : &#39;bar&#39;
     *         }
     *     });
     *
     *     button.setParams({
     *         company : &#39;Sencha&#39;
     *     });
     *
     * When clicked, this button will open a new window with the url http://www.sencha.com/?foo=bar&amp;company=Sencha because
     * the button was configured with the {@link #baseParams} to have `foo` = `&#39;bar&#39;`
     * and then used {@link #setParams} to set the `company` parameter to `&#39;Sencha&#39;`.
     *
     * **Only valid if the Button was originally configured with a {@link #href}**
     *
     * @param {Object} params Parameters to use in the href URL.
     */
    setParams: function(params) {
        var me = this,
            dom;

        me.params = params;

        // https://sencha.jira.com/browse/EXTJS-11964
        // Disabled links are clickable on iPad, and right clickable on desktop browsers.
        // The only way to completely disable navigation is removing the href
        if (me.rendered) {
            dom = me.el.dom;
            if (me.disabled) {
                dom.removeAttribute(&#39;href&#39;);
            } else {
                dom.href = me.getHref() || &#39;&#39;;
            }
        }
    },

<span id='Ext-button-Button-method-getSplitCls'>    getSplitCls: function() {
</span>        var me = this;
        return me.split ? (me.baseCls + &#39;-&#39; + me.arrowCls) + &#39; &#39; + (me.baseCls + &#39;-&#39; + me.arrowCls + &#39;-&#39; + me.arrowAlign) : &#39;&#39;;
    },

<span id='Ext-button-Button-method-setIcon'>    /**
</span>     * Sets the background image (inline style) of the button. This method also changes the value of the {@link #icon}
     * config internally.
     * @param {String} icon The path to an image to display in the button
     * @return {Ext.button.Button} this
     */
    setIcon: function(icon) {
        icon = icon || &#39;&#39;;
        var me = this,
            btnIconEl = me.btnIconEl,
            oldIcon = me.icon || &#39;&#39;;

        // If setIcon is called when we are configured with a glyph, clear the glyph
        if (me.glyph) {
            me.setGlyph(null);
        }
        me.icon = icon;
        if (icon !== oldIcon) {
            if (btnIconEl) {
                btnIconEl.removeCls(me.iconCls);
                btnIconEl.setStyle(&#39;background-image&#39;, icon ? &#39;url(&#39; + icon + &#39;)&#39;: &#39;&#39;);
                me._syncHasIconCls();
                if (me.didIconStateChange(oldIcon, icon)) {
                    me.updateLayout();
                }
            }
            me.fireEvent(&#39;iconchange&#39;, me, oldIcon, icon);
        }
        return me;
    },

<span id='Ext-button-Button-method-setIconCls'>    /**
</span>     * Sets the CSS class that provides a background image to use as the button&#39;s icon. This method also changes the
     * value of the {@link #iconCls} config internally.
     * @param {String} cls The CSS class providing the icon image
     * @return {Ext.button.Button} this
     */
    setIconCls: function(cls) {
        cls = cls || &#39;&#39;;
        var me = this,
            btnIconEl = me.btnIconEl,
            oldCls = me.iconCls || &#39;&#39;;

        // If setIcon is called when we are configured with a glyph, clear the glyph
        if (me.glyph) {
            me.setGlyph(null);
        }
        me.iconCls = cls;
        if (oldCls !== cls) {
            if (btnIconEl) {
                // In case it had been set to &#39;none&#39; by a glyph setting.
                btnIconEl.setStyle(&#39;background-image&#39;, &#39;&#39;);

                // Remove the previous iconCls from the button
                btnIconEl.removeCls(oldCls);
                btnIconEl.addCls(cls);
                me._syncHasIconCls();
                if (me.didIconStateChange(oldCls, cls)) {
                    me.updateLayout();
                }
            }
            me.fireEvent(&#39;iconchange&#39;, me, oldCls, cls);
        }
        return me;
    },

<span id='Ext-button-Button-method-applyGlyph'>    applyGlyph: function(glyph, oldGlyph) {
</span>        if (glyph) {
            if (!glyph.isGlyph) {
                glyph = new Ext.Glyph(glyph);
            }
            if (glyph.isEqual(oldGlyph)) {
                glyph = undefined;
            }
        }
        return glyph;
    },

<span id='Ext-button-Button-method-updateGlyph'>    updateGlyph: function(glyph, oldGlyph) {
</span>        var me = this,
            btnIconEl = me.btnIconEl,
            glyphCls = me._glyphCls;

        if (btnIconEl) {
            me.icon = null;
            btnIconEl.setStyle(&#39;background-image&#39;, &#39;&#39;);
            if (glyph) {
                btnIconEl.dom.innerHTML = glyph.character;
                btnIconEl.addCls(glyphCls);
                btnIconEl.setStyle(glyph.getStyle());
            } else {
                btnIconEl.dom.innerHTML = &#39;&#39;;
                btnIconEl.removeCls(glyphCls);
            }

            me._syncHasIconCls();
            if (me.didIconStateChange(oldGlyph, glyph)) {
                me.updateLayout();
            }
        }

        me.fireEvent(&#39;glyphchange&#39;, me, glyph &amp;&amp; glyph.glyphConfig, oldGlyph &amp;&amp; oldGlyph.glyphConfig);
        return me;
    },

<span id='Ext-button-Button-method-setTooltip'>    /**
</span>     * Sets the tooltip for this Button.
     *
     * @param {String/Object} tooltip This may be:
     *
     *   - **String** : A string to be used as innerHTML (html tags are accepted) to show in a tooltip
     *   - **Object** : A configuration object for {@link Ext.tip.QuickTipManager#register}.
     *
     * @return {Ext.button.Button} this
     */
    setTooltip: function(tooltip, initial) {
        var me = this;

        if (me.rendered) {
            if (!initial || !tooltip) {
                me.clearTip();
            }
            if (tooltip) {
                if (Ext.quickTipsActive &amp;&amp; Ext.isObject(tooltip)) {
                    Ext.tip.QuickTipManager.register(Ext.apply({
                        target: me.el.id
                    },
                    tooltip));
                    me.tooltip = tooltip;
                } else {
                    me.el.dom.setAttribute(me.getTipAttr(), tooltip);
                }
            }
        } else {
            me.tooltip = tooltip;
        }
        return me;
    },

<span id='Ext-button-Button-method-updateIconAlign'>    updateIconAlign: function(align, oldAlign) {
</span>        var me = this,
            btnEl, btnIconEl, hasIconCls;

        if (me.rendered) {
            btnEl = me.btnEl;
            btnIconEl = me.btnIconEl;
            hasIconCls = me._hasIconCls;

            if (oldAlign) {
                btnEl.removeCls(hasIconCls + &#39;-&#39; + oldAlign);
            }
            btnEl.addCls(hasIconCls + &#39;-&#39; + align);

            // move the iconWrap to the correct position in the dom - before the btnInnerEl
            // for top/left alignments, and after the btnInnerEl for right/bottom
            if (align === &#39;top&#39; || align === &#39;left&#39;) {
                btnEl.insertFirst(btnIconEl);
            } else {
                btnEl.appendChild(btnIconEl);
            }
            me.updateLayout();
        }
    },

<span id='Ext-button-Button-method-updateTextAlign'>    updateTextAlign: function(align, oldAlign) {
</span>        var me = this,
            btnEl = me.btnEl,
            btnCls = me._btnCls;

        if (me.rendered) {
            btnEl.removeCls(btnCls + &#39;-&#39; + oldAlign);
            btnEl.addCls(btnCls + &#39;-&#39; + align);
        }
    },

<span id='Ext-button-Button-method-getTipAttr'>    getTipAttr: function(){
</span>        return this.tooltipType === &#39;qtip&#39; ? &#39;data-qtip&#39; : &#39;title&#39;;
    },

<span id='Ext-button-Button-method-getRefItems'>    /**
</span>     * @private
     */
    getRefItems: function(deep){
        var menu = this.menu,
            items = [];

        if (menu) {
            if (deep) {
                items = menu.getRefItems(deep);
            }
            items.unshift(menu);
        }
        return items;
    },

<span id='Ext-button-Button-method-clearTip'>    /**
</span>     * @private
     */
    clearTip: function() {
        var me = this,
            el = me.el;

        if (Ext.quickTipsActive &amp;&amp; Ext.isObject(me.tooltip)) {
            Ext.tip.QuickTipManager.unregister(el);
        } else {
            el.dom.removeAttribute(me.getTipAttr());
        }
    },

<span id='Ext-button-Button-method-doDestroy'>    doDestroy: function() {
</span>        var me = this,
            menu = me.menu;

        if (me.rendered) {
            me.clearTip();
        }

        Ext.destroy(me.repeater);

        if (menu &amp;&amp; me.destroyMenu) {
            me.menu = Ext.destroy(menu);
        }

        Ext.button.Manager.unregister(me);

        me.callParent();
    },

<span id='Ext-button-Button-method-setHandler'>    /**
</span>     * Assigns this Button&#39;s click handler
     * @param {Function} handler The function to call when the button is clicked
     * @param {Object} [scope] The scope (`this` reference) in which the handler function is executed.
     * Defaults to this Button.
     * @return {Ext.button.Button} this
     */
    setHandler: function(handler, scope) {
        this.handler = handler;
        if (arguments.length &gt; 1) {
            this.scope = scope;
        }
        return this;
    },

<span id='Ext-button-Button-method-updateText'>    updateText: function(text, oldText) {
</span>        // Coerce to string. Maybe set to a numeric value.
        text = text == null ? &#39;&#39; : String(text);
        oldText = oldText || &#39;&#39;;

        var me = this,
            btnInnerEl = me.btnInnerEl,
            btnEl = me.btnEl;

        if (me.rendered) {
            btnInnerEl.setHtml(text || &#39;&amp;#160;&#39;);
            btnEl[text ? &#39;addCls&#39; : &#39;removeCls&#39;](me._textCls);
            btnEl[text ? &#39;removeCls&#39; : &#39;addCls&#39;](me._noTextCls);
            me.updateLayout();
        }
        me.fireEvent(&#39;textchange&#39;, me, oldText, text);
    },

<span id='Ext-button-Button-method-didIconStateChange'>    /**
</span>     * Checks if the icon/iconCls changed from being empty to having a value, or having a value to being empty.
     * @private
     * @param {String} old The old icon/iconCls
     * @param {String} current The current icon/iconCls
     * @return {Boolean} True if the icon state changed
     */
    didIconStateChange: function(old, current) {
        var currentEmpty = Ext.isEmpty(current);
        return Ext.isEmpty(old) ? !currentEmpty : currentEmpty;
    },

<span id='Ext-button-Button-method-click'>    /**
</span>     * Programmatically activate the button.
     *
     * @param {Ext.event.Event} [e] Optional event to process.
     */
    click: function(e) {
        return this.onClick(e);
    },

<span id='Ext-button-Button-method-setPressed'>    /**
</span>     * Sets the `pressed` state of this button.
     * @param {Boolean} [pressed=true] Pass `false` to clear the `pressed` state.
     * @return {Ext.button.Button} this
     */
    setPressed: function (pressed) {
        return this.toggle(pressed !== false);
    },

<span id='Ext-button-Button-method-toggle'>    /**
</span>     * If a state it passed, it becomes the pressed state otherwise the current state is toggled.
     * @param {Boolean} [state] Force a particular state
     * @param {Boolean} [suppressEvent=false] True to stop events being fired when calling this method.
     * @return {Ext.button.Button} this
     */
    toggle: function(state, suppressEvent) {
        var me = this,
            ariaDom = me.ariaEl.dom;

        if (!me.enableToggle) {
            return me;
        }

        state = state === undefined ? !me.pressed : !!state;

        // Allow toggle to be vetoed in case a toggle group needs to enforce a mimimum pressed state
        if (me.fireEvent(&#39;beforetoggle&#39;, me, state) !== false) {


            if (state !== me.pressed) {
                me[state ? &#39;addCls&#39;: &#39;removeCls&#39;](me._pressedCls);
                me.pressed = state;

                if (ariaDom) {
                    ariaDom.setAttribute(&#39;aria-pressed&#39;, state);
                }

                if (!suppressEvent) {
                    me.fireEvent(&#39;toggle&#39;, me, state);
                    Ext.callback(me.toggleHandler, me.scope, [me, state], 0, me);

                    if (me.publishState) {
                        me.publishState(&#39;pressed&#39;, state);
                    }
                }
            }
        }
        return me;
    },

<span id='Ext-button-Button-method-maybeShowMenu'>    maybeShowMenu: function(e) {
</span>        if (this.menu) {
            this.showMenu(e);
        }
    },

<span id='Ext-button-Button-method-showMenu'>    /**
</span>     * Shows this button&#39;s menu (if it has one)
     * @param clickEvent (private)
     */
    showMenu: function(clickEvent) {
        var me = this,
            menu = me.menu,
            isPointerEvent = !clickEvent || clickEvent.pointerType;

        if (menu &amp;&amp; me.rendered) {
            if (me.tooltip &amp;&amp; Ext.quickTipsActive &amp;&amp; me.getTipAttr() !== &#39;title&#39;) {
                Ext.tip.QuickTipManager.getQuickTip().cancelShow(me.el);
            }

            if (menu.isVisible()) {
                // Click/tap toggles the menu visibility.
                if (isPointerEvent) {
                    menu.hide();
                }
                else {
                    menu.focus();
                }
            }
            else if (!clickEvent || me.showEmptyMenu || menu.items.getCount() &gt; 0) {
                // Pointer-invoked menus do not auto focus, key invoked ones do.
                // Note that this behavior is inconsistent with WAI-ARIA specification
                // requirements, per which only Down Arrow key should activate the menu;
                // pressing Space or Enter key should open the menu but not focus it.
                // However no other accessible framework implements it that way;
                // both Dojo and YUI will activate the menu on either Space, Enter, or
                // Down Arrow keys. Furthermore, testing with JAWS screen reader
                // proved that this non-standard behavior is in fact expected since
                // JAWS will announce a menu button as follows: &lt;name&gt; button menu,
                // Press Space to activate the menu then navigate with arrow keys.
                // So without further ado we choose to keep the existing historical
                // Ext JS behavior which, by coincidence, happens to be congruent
                // with the industry standard. :)
                menu.autoFocus = !isPointerEvent;
                menu.showBy(me.el, me.menuAlign);
            }
        }

        return me;
    },

<span id='Ext-button-Button-method-hideMenu'>    /**
</span>     * Hides this button&#39;s menu (if it has one)
     */
    hideMenu: function() {
        if (this.hasVisibleMenu()) {
            this.menu.hide();
        }
        return this;
    },

<span id='Ext-button-Button-method-hasVisibleMenu'>    /**
</span>     * Returns true if the button has a menu and it is visible
     * @return {Boolean}
     */
    hasVisibleMenu: function() {
        var menu = this.menu;
        return menu &amp;&amp; menu.rendered &amp;&amp; menu.isVisible();
    },

<span id='Ext-button-Button-method-onRepeatClick'>    /**
</span>     * @private
     */
    onRepeatClick: function(repeat, e) {
        this.onClick(e);
    },

<span id='Ext-button-Button-method-onTouchStart'>    onTouchStart: function(e) {
</span>        this.doPreventDefault(e);
    },

<span id='Ext-button-Button-method-onEnterKey'>    /**
</span>     * @private
     */
    onEnterKey: function(e) {
        if (!this.href) {
            this.onClick(e);

            // Buttons always intercept Space and Enter keys
            e.stopEvent();

            return false;
        }
    },

<span id='Ext-button-Button-method-onClick'>    /**
</span>     * @private
     */
    onClick: function(e) {
        var me = this;

        // Event is optional if we&#39;re called from click()
        if (e) {
            me.doPreventDefault(e);
        }

        // Can be triggered by ENTER or SPACE keydown events which set the button property.
        // Only veto event handling if it&#39;s a mouse event with an alternative button.
        // Checking e.button for a truthy value (instead of != 0) also allows touch events
        // (tap) to continue, as they do not have a button property defined.
        if (e &amp;&amp; e.type !== &#39;keydown&#39; &amp;&amp; e.button) {
            return;
        }

        if (!me.disabled) {
            me.doToggle();
            me.maybeShowMenu(e);
            me.fireHandler(e);
        }
    },

<span id='Ext-button-Button-method-doToggle'>    doToggle: function() {
</span>        var me = this;
        if (me.allowDepress !== false || !me.pressed) {
            me.toggle();
        }
    },

<span id='Ext-button-Button-method-doPreventDefault'>    doPreventDefault: function(e) {
</span>        if (e &amp;&amp; (this.preventDefault || (this.disabled &amp;&amp; this.getHref()))) {
            e.preventDefault();
        }
    },

<span id='Ext-button-Button-method-fireHandler'>    fireHandler: function(e) {
</span>        var me = this;

        // Click may have destroyed the button
        if (me.fireEvent(&#39;click&#39;, me, e) !== false &amp;&amp; !me.destroyed) {
            Ext.callback(me.handler, me.scope, [me, e], 0, me);
        }
    },

<span id='Ext-button-Button-method-onMouseOver'>    /**
</span>     * @private
     * mouseover handler called when a mouseover event occurs anywhere within the encapsulating element.
     * The targets are interrogated to see what is being entered from where.
     * @param e
     */
    onMouseOver: function(e) {
        var me = this;
        if (!me.disabled &amp;&amp; !e.within(me.el, true, true)) {
            me.onMouseEnter(e);
        }
    },

<span id='Ext-button-Button-method-onMouseOut'>    /**
</span>     * @private
     * mouseout handler called when a mouseout event occurs anywhere within the encapsulating element -
     * or the mouse leaves the encapsulating element.
     * The targets are interrogated to see what is being exited to where.
     * @param e
     */
    onMouseOut: function(e) {
        var me = this;
        if (!e.within(me.el, true, true)) {
            if (me.overMenuTrigger) {
                me.onMenuTriggerOut(e);
            }
            me.onMouseLeave(e);
        }
    },

<span id='Ext-button-Button-method-onMouseMove'>    /**
</span>     * @private
     * mousemove handler called when the mouse moves anywhere within the encapsulating element.
     * The position is checked to determine if the mouse is entering or leaving the trigger area. Using
     * mousemove to check this is more resource intensive than we&#39;d like, but it is necessary because
     * the trigger area does not line up exactly with sub-elements so we don&#39;t always get mouseover/out
     * events when needed. In the future we should consider making the trigger a separate element that
     * is absolutely positioned and sized over the trigger area.
     */
    onMouseMove: function(e) {
        var me = this,
            over = me.overMenuTrigger;

        if (me.split) {
            if (me.isWithinTrigger(e)) {
                if (!over) {
                    me.onMenuTriggerOver(e);
                }
            } else if (over) {
                me.onMenuTriggerOut(e);
            }
        }
    },

<span id='Ext-button-Button-method-isWithinTrigger'>    /**
</span>     * @protected
     * Returns true if the passed event&#39;s x/y coordinates are within the trigger region
     * @param {Ext.event.Event} e
     */
    isWithinTrigger: function(e) {
        var me = this,
            el = me.el,
            overPosition, triggerRegion;

        overPosition = (me.arrowAlign === &#39;right&#39;) ?  e.getX() - me.getX() : e.getY() - el.getY();
        triggerRegion = me.getTriggerRegion();
        return overPosition &gt; triggerRegion.begin &amp;&amp; overPosition &lt; triggerRegion.end;
    },

<span id='Ext-button-Button-method-getTriggerRegion'>    /**
</span>     * @private
     * Returns an object containing `begin` and `end` properties that indicate the
     * left/right bounds of a right trigger or the top/bottom bounds of a bottom trigger.
     * @return {Object}
     */
    getTriggerRegion: function() {
        var me = this,
            region = me._triggerRegion,
            isRight = me.arrowAlign === &#39;right&#39;,
            getEnd = isRight ? &#39;getRight&#39; : &#39;getBottom&#39;,
            btnSize = isRight ? me.getWidth() : me.getHeight();

        region.begin = btnSize - (me.el[getEnd]() - me.btnEl[getEnd]());
        region.end = btnSize;
        return region;
    },

<span id='Ext-button-Button-method-onMouseEnter'>    /**
</span>     * @private
     * virtual mouseenter handler called when it is detected that the mouseout event
     * signified the mouse entering the encapsulating element.
     * @param e
     */
    onMouseEnter: function(e) {
        // overCls is handled by Component
        this.fireEvent(&#39;mouseover&#39;, this, e);
    },

<span id='Ext-button-Button-method-onMouseLeave'>    /**
</span>     * @private
     * virtual mouseleave handler called when it is detected that the mouseover event
     * signified the mouse entering the encapsulating element.
     * @param e
     */
    onMouseLeave: function(e) {
        // overCls is handled by Component
        this.fireEvent(&#39;mouseout&#39;, this, e);
    },

<span id='Ext-button-Button-method-onMenuTriggerOver'>    /**
</span>     * @private
     * virtual mouseenter handler called when it is detected that the mouseover event
     * signified the mouse entering the arrow area of the button - the `&lt;em&gt;`.
     * @param e
     */
    onMenuTriggerOver: function(e) {
        var me = this,
            arrowTip = me.arrowTooltip;

        me.overMenuTrigger = true;
        // We don&#39;t have a hoverable arrow element, so we only add the tip attribute if
        // we&#39;re over that part of the button
        if (me.split &amp;&amp; arrowTip) {
            me.btnWrap.dom.setAttribute(me.getTipAttr(), arrowTip);
        }

        me.fireEvent(&#39;menutriggerover&#39;, me, me.menu, e);
    },

<span id='Ext-button-Button-method-onMenuTriggerOut'>    /**
</span>     * @private
     * virtual mouseleave handler called when it is detected that the mouseout event
     * signified the mouse leaving the arrow area of the button - the `&lt;em&gt;`.
     * @param e
     */
    onMenuTriggerOut: function(e) {
        var me = this;

        delete me.overMenuTrigger;
        // See onMenuTriggerOver
        if (me.split &amp;&amp; me.arrowTooltip) {
            me.btnWrap.dom.setAttribute(me.getTipAttr(), &#39;&#39;);
        }

        me.fireEvent(&#39;menutriggerout&#39;, me, me.menu, e);
    },

<span id='Ext-button-Button-method-onEnable'>    onEnable: function() {
</span>        var me = this,
            href = me.href,
            hrefTarget = me.hrefTarget,
            dom = me.el.dom;

        me.callParent();

        me.removeCls(me._disabledCls);
        dom.setAttribute(&#39;tabIndex&#39;, me.tabIndex);

        // https://sencha.jira.com/browse/EXTJS-11964
        // Disabled links are clickable on iPad, and right clickable on desktop browsers.
        // The only way to completely disable navigation is removing the href
        if (href) {
            dom.href = href;
        }
        if (hrefTarget) {
            dom.target = hrefTarget;
        }
    },

<span id='Ext-button-Button-method-onDisable'>    onDisable: function() {
</span>        var me = this,
            dom = me.el.dom;

        me.callParent();

        me.addCls(me._disabledCls);
        me.removeCls(me.overCls);

        dom.removeAttribute(&#39;tabIndex&#39;);

        // https://sencha.jira.com/browse/EXTJS-11964
        // Disabled links are clickable on iPad, and right clickable on desktop browsers.
        // The only way to completely disable navigation is clearing the href
        if (me.href) {
            dom.removeAttribute(&#39;href&#39;);
        }
        if (me.hrefTarget) {
            dom.removeAttribute(&#39;target&#39;);
        }
    },

<span id='Ext-button-Button-method-setScale'>    /**
</span>     * Method to change the scale of the button. See {@link #scale} for allowed configurations.
     * @param {String} scale The scale to change to.
     */
    setScale: function(scale) {
        var me = this,
            ui = me.ui.replace(&#39;-&#39; + me.scale, &#39;&#39;);

        //check if it is an allowed scale
        if (!Ext.Array.contains(me.allowedScales, scale)) {
            throw(&#39;#setScale: scale must be an allowed scale (&#39; + me.allowedScales.join(&#39;, &#39;) + &#39;)&#39;);
        }

        me.scale = scale;
        me.setUI(ui);
    },

<span id='Ext-button-Button-method-setUI'>    setUI: function(ui) {
</span>        var me = this;

        //we need to append the scale to the UI, if not already done
        if (me.scale &amp;&amp; !ui.match(me.scale)) {
            ui = ui + &#39;-&#39; + me.scale;
        }

        me.callParent([ui]);
    },

<span id='Ext-button-Button-method-onMouseDown'>    /**
</span>     * @private
     */
    onMouseDown: function(e) {
        var me = this;

        if (Ext.isIE || e.pointerType === &#39;touch&#39;) {
            // In IE the use of unselectable on the button&#39;s elements causes the element
            // to not receive focus, even when it is directly clicked.
            // On Touch devices, we need to explicitly focus on touchstart.
            Ext.defer(function() {
                var focusEl = me.getFocusEl();
                // Deferred to give other mousedown handlers the chance to preventDefault
                if (focusEl &amp;&amp; !e.defaultPrevented) {
                    focusEl.focus();
                }
            }, 1);
        }

        if (!me.disabled &amp;&amp; e.button === 0) {
            Ext.button.Manager.onButtonMousedown(me, e);
            me.addCls(me._pressedCls);
        }
    },

<span id='Ext-button-Button-method-onMouseUp'>    /**
</span>     * @private
     */
    onMouseUp: function(e) {
        var me = this;

        // If the external mouseup listener of the ButtonManager fires after the button has been destroyed, ignore.
        if (!me.destroyed &amp;&amp; e.button === 0) {
            if (!me.pressed) {
                me.removeCls(me._pressedCls);
            }
        }
    },

<span id='Ext-button-Button-method-onMenuShow'>    /**
</span>     * @private
     */
    onMenuShow: function() {
        var me = this;
        me.addCls(me._menuActiveCls);
        me.fireEvent(&#39;menushow&#39;, me, me.menu);
    },

<span id='Ext-button-Button-method-onMenuHide'>    /**
</span>     * @private
     */
    onMenuHide: function(e) {
        var me = this;

        me.removeCls(me._menuActiveCls);
        me.fireEvent(&#39;menuhide&#39;, me, me.menu);
    },

<span id='Ext-button-Button-method-onDownKey'>    /**
</span>     * @private
     */
    onDownKey: function(e) {
        var me = this;

        if (me.menu &amp;&amp; !me.disabled) {
            me.showMenu(e);
            e.stopEvent();
            return false;
        }
    },

<span id='Ext-button-Button-method-updateArrowVisible'>    updateArrowVisible: function(visible) {
</span>        var me = this;

        if (me.rendered) {
            if (visible) {
                if (me.menu || me.isSplitButton) {
                    me.split = true;
                    me._addSplitCls();
                }
            } else {
                me._removeSplitCls();
                me.split = false;
            }
        }

        return visible;
    },

<span id='Ext-button-Button-property-privates'>    privates: {
</span>        elClsMap: {
            &#39;btnWrap&#39;: &#39;_btnWrapCls&#39;,
            &#39;btnEl&#39;: &#39;_btnCls&#39;,
            &#39;btnIconEl&#39;: &#39;_baseIconCls&#39;,
            &#39;btnInnerEl&#39;: &#39;_innerCls&#39;
        },

        addUIToElement: function() {
            this.callParent();
            this.updateChildElsUICls(true);
        },

        addOverCls: function() {
            if (!this.disabled) {
                this.addCls(this.overCls);
            }
        },

        _addSplitCls: function() {
            var me = this;

            me.btnWrap.addCls(me.getSplitCls());
        },

<span id='Ext-button-Button-method-getTdCls'>        /**
</span>         * @private
         * Needed for when widget is rendered into a grid cell. The class to add to the cell element.
         * Override needed to add scale to the mix which is part of the ui name in the
         * mixin and the CSS rule.
         */
        getTdCls: function() {
            return Ext.baseCSSPrefix + &#39;button-&#39; + this.ui + &#39;-&#39; + this.scale + &#39;-cell&#39;;
        },

<span id='Ext-button-Button-method-getValue'>        /**
</span>         * @private
         * @return {Number/String} The button value, used for segmented button API compatibility
         * with modern.
         */
        getValue: function() {
            return this.value;
        },

        removeUIFromElement: function() {
            this.callParent();
            this.updateChildElsUICls(false);
        },

        removeOverCls: function() {
            this.removeCls(this.overCls);
        },

        _removeSplitCls: function() {
            var me = this;

            me.btnWrap.removeCls(me.getSplitCls());
        },

        _syncHasIconCls: function() {
            var me = this,
                btnEl = me.btnEl,
                hasIconCls = me._hasIconCls;

            if (btnEl) {
                btnEl[me._hasIcon() ? &#39;addCls&#39; : &#39;removeCls&#39;]([
                    hasIconCls,
                    hasIconCls + &#39;-&#39; + me.iconAlign
                ]);
            }
        },

<span id='Ext-button-Button-method-_hasIcon'>        /**
</span>         * Returns true if this button has an icon (either icon, iconCls, or glyph)
         * @return {Boolean}
         * @private
         */
        _hasIcon: function() {
            return !!(this.icon || this.iconCls || this.glyph);
        },

        updateChildElsUICls: function(add) {
            var me = this,
                ui = me.ui,
                state = add ? &#39;addCls&#39; : &#39;removeCls&#39;,
                elClsMap = me.elClsMap,
                key, el, mapCls, cls;

            for(key in elClsMap) {
                el = me[key];
                mapCls = elClsMap[key];
                cls = me[mapCls];
                if(el &amp;&amp; cls) {
                    el[state](cls + &#39;-&#39; + ui);
                }
            }
        },

        wrapPrimaryEl: function(dom) {
            this.el = new Ext.dom.ButtonElement(dom);
            this.callParent([dom]);
        }
    }
});
</pre>
</body>
</html>
