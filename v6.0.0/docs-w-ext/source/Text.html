<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-form-field-Text'>/**
</span> * A basic text field.  Can be used as a direct replacement for traditional text inputs,
 * or as the base class for more sophisticated input controls (like {@link Ext.form.field.TextArea}
 * and {@link Ext.form.field.ComboBox}). Has support for empty-field placeholder values (see {@link #emptyText}).
 *
 * # Validation
 *
 * The Text field has a useful set of validations built in:
 *
 * - {@link #allowBlank} for making the field required
 * - {@link #minLength} for requiring a minimum value length
 * - {@link #maxLength} for setting a maximum value length (with {@link #enforceMaxLength} to add it
 *   as the `maxlength` attribute on the input element)
 * - {@link #regex} to specify a custom regular expression for validation
 *
 * In addition, custom validations may be added:
 *
 * - {@link #vtype} specifies a virtual type implementation from {@link Ext.form.field.VTypes} which can contain
 *   custom validation logic
 * - {@link #validator} allows a custom arbitrary function to be called during validation
 *
 * The details around how and when each of these validation options get used are described in the
 * documentation for {@link #getErrors}.
 *
 * By default, the field value is checked for validity immediately while the user is typing in the
 * field. This can be controlled with the {@link #validateOnChange}, {@link #checkChangeEvents}, and
 * {@link #checkChangeBuffer} configurations. Also see the details on Form Validation in the
 * {@link Ext.form.Panel} class documentation.
 *
 * # Masking and Character Stripping
 *
 * Text fields can be configured with custom regular expressions to be applied to entered values before
 * validation: see {@link #maskRe} and {@link #stripCharsRe} for details.
 *
 * # Example usage
 *
 *     @example
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         title: &#39;Contact Info&#39;,
 *         width: 300,
 *         bodyPadding: 10,
 *         renderTo: Ext.getBody(),
 *         items: [{
 *             xtype: &#39;textfield&#39;,
 *             name: &#39;name&#39;,
 *             fieldLabel: &#39;Name&#39;,
 *             allowBlank: false  // requires a non-empty value
 *         }, {
 *             xtype: &#39;textfield&#39;,
 *             name: &#39;email&#39;,
 *             fieldLabel: &#39;Email Address&#39;,
 *             vtype: &#39;email&#39;  // requires value to be a valid email address format
 *         }]
 *     });
 *
 * # Custom Subclasses
 *
 * This class can be extended to provide additional functionality. The example below demonstrates creating
 * a custom search field that uses the HTML5 search input type.
 *
 *     @example
 *     // A simple subclass of Base that creates a HTML5 search field. Redirects to the
 *     // searchUrl when the Enter key is pressed.
 *     Ext.define(&#39;Ext.form.SearchField&#39;, {
 *         extend: &#39;Ext.form.field.Text&#39;,
 *         alias: &#39;widget.searchfield&#39;,
 *     
 *         inputType: &#39;search&#39;,
 *     
 *         // Config defining the search URL
 *         searchUrl: &#39;http://www.google.com/search?q={0}&#39;,
 *     
 *         // Add specialkey listener
 *         initComponent: function() {
 *             this.callParent();
 *             this.on(&#39;specialkey&#39;, this.checkEnterKey, this);
 *         },
 *     
 *         // Handle enter key presses, execute the search if the field has a value
 *         checkEnterKey: function(field, e) {
 *             var value = this.getValue();
 *             if (e.getKey() === e.ENTER &amp;&amp; !Ext.isEmpty(value)) {
 *                 location.href = Ext.String.format(this.searchUrl, value);
 *             }
 *         }
 *     });
 *     
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         title: &#39;Base Example&#39;,
 *         bodyPadding: 5,
 *         width: 250,
 *     
 *         // Fields will be arranged vertically, stretched to full width
 *         layout: &#39;anchor&#39;,
 *         defaults: {
 *             anchor: &#39;100%&#39;
 *         },
 *         items: [{
 *             xtype: &#39;searchfield&#39;,
 *             fieldLabel: &#39;Search&#39;,
 *             name: &#39;query&#39;
 *         }],
 *         renderTo: Ext.getBody()
 *     });
 */
Ext.define(&#39;Ext.form.field.Text&#39;, {
    extend:&#39;Ext.form.field.Base&#39;,
    alias: &#39;widget.textfield&#39;,
    requires: [
        &#39;Ext.form.field.VTypes&#39;,
        &#39;Ext.form.trigger.Trigger&#39;,
        &#39;Ext.util.TextMetrics&#39;
    ],
    alternateClassName: [&#39;Ext.form.TextField&#39;, &#39;Ext.form.Text&#39;],

    config: {
<span id='Ext-form-field-Text-cfg-hideTrigger'>        /**
</span>         * @cfg {Boolean} hideTrigger
         * `true` to hide all triggers
         */
        hideTrigger: false,

        // @cmd-auto-dependency {aliasPrefix: &quot;trigger.&quot;, isKeyedObject: true}
<span id='Ext-form-field-Text-cfg-triggers'>        /**
</span>         * @cfg {Object} triggers
         * {@link Ext.form.trigger.Trigger Triggers} to use in this field.  The keys in
         * this object are unique identifiers for the triggers. The values in this object
         * are {@link Ext.form.trigger.Trigger Trigger} configuration objects.
         *
         *     Ext.create(&#39;Ext.form.field.Text&#39;, {
         *         renderTo: document.body,
         *         fieldLabel: &#39;My Custom Field&#39;,
         *         triggers: {
         *             foo: {
         *                 cls: &#39;my-foo-trigger&#39;,
         *                 handler: function() {
         *                     console.log(&#39;foo trigger clicked&#39;);
         *                 }
         *             },
         *             bar: {
         *                 cls: &#39;my-bar-trigger&#39;,
         *                 handler: function() {
         *                     console.log(&#39;bar trigger clicked&#39;);
         *                 }
         *             }
         *         }
         *     });
         * 
         * The weight value may be a negative value in order to position custom triggers 
         * ahead of default triggers like that of ComboBox.
         * 
         *     Ext.create(&#39;Ext.form.field.ComboBox&#39;, {
         *         renderTo: Ext.getBody(),
         *         fieldLabel: &#39;My Custom Field&#39;,
         *         triggers: {
         *             foo: {
         *                 cls: &#39;my-foo-trigger&#39;,
         *                 weight: -2, // negative to place before default triggers
         *                 handler: function() {
         *                     console.log(&#39;foo trigger clicked&#39;);
         *                 }
         *             },
         *             bar: {
         *                 cls: &#39;my-bar-trigger&#39;,
         *                 weight: -1, 
         *                 handler: function() {
         *                     console.log(&#39;bar trigger clicked&#39;);
         *                 }
         *             }
         *         }
         *     });
         */
        triggers: undefined
    },
    
<span id='Ext-form-field-Text-property-renderConfig'>    renderConfig: {
</span><span id='Ext-form-field-Text-cfg-editable'>        /**
</span>         * @cfg {Boolean} editable
         * false to prevent the user from typing text directly into the field; the field can
         * only have its value set programmatically or via an action invoked by a trigger.
         */
        editable: true
    },

<span id='Ext-form-field-Text-cfg-vtypeText'>    /**
</span>     * @cfg {String} vtypeText
     * A custom error message to display in place of the default message provided for the **`{@link #vtype}`** currently
     * set for this field. **Note**: only applies if **`{@link #vtype}`** is set, else ignored.
     */

<span id='Ext-form-field-Text-cfg-stripCharsRe'>    /**
</span>     * @cfg {RegExp} stripCharsRe
     * A JavaScript RegExp object used to strip unwanted content from the value
     * during input. If `stripCharsRe` is specified,
     * every *character sequence* matching `stripCharsRe` will be removed.
     */

<span id='Ext-form-field-Text-cfg-size'>    /**
</span>     * @cfg {Number} size
     * An initial value for the &#39;size&#39; attribute on the text input element. This is only
     * used if the field has no configured {@link #width} and is not given a width by its
     * container&#39;s layout. Defaults to 20.
     * @deprecated use {@link #width} instead.
     */

<span id='Ext-form-field-Text-cfg-grow'>    /**
</span>     * @cfg {Boolean} [grow=false]
     * true if this field should automatically grow and shrink to its content
     */

<span id='Ext-form-field-Text-cfg-growMin'>    /**
</span>     * @cfg {Number} growMin
     * The minimum width to allow when `{@link #grow} = true`
     */
    growMin : 30,

<span id='Ext-form-field-Text-cfg-growMax'>    /**
</span>     * @cfg {Number} growMax
     * The maximum width to allow when `{@link #grow} = true`
     */
    growMax : 800,

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-growAppend'>    /**
</span>     * @cfg {String} growAppend
     * A string that will be appended to the field&#39;s current value for the purposes of calculating the target field
     * size. Only used when the {@link #grow} config is true. Defaults to a single capital &quot;W&quot; (the widest character in
     * common fonts) to leave enough space for the next typed character and avoid the field value shifting before the
     * width is adjusted.
     */
    growAppend: &#39;W&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-field-Text-cfg-vtype'>    /**
</span>     * @cfg {String} vtype
     * A validation type name as defined in {@link Ext.form.field.VTypes}
     */

<span id='Ext-form-field-Text-cfg-maskRe'>    /**
</span>     * @cfg {RegExp} maskRe An input mask regular expression that will be used to filter keystrokes (character being
     * typed) that do not match.
     * Note: It does not filter characters already in the input.
     */

<span id='Ext-form-field-Text-cfg-disableKeyFilter'>    /**
</span>     * @cfg {Boolean} [disableKeyFilter=false]
     * Specify true to disable input keystroke filtering
     */

<span id='Ext-form-field-Text-cfg-allowBlank'>    /**
</span>     * @cfg {Boolean} [allowBlank=true]
     * Specify false to validate that the value&#39;s length must be &gt; 0. If `true`, then a blank value is **always** taken to be valid regardless of any {@link #vtype}
     * validation that may be applied.
     *
     * If {@link #vtype} validation must still be applied to blank values, configure {@link #validateBlank} as `true`;
     */
    allowBlank : true,

<span id='Ext-form-field-Text-cfg-validateBlank'>    /**
</span>     * @cfg {Boolean} [validateBlank=false]
     * Specify as `true` to modify the behaviour of {@link #allowBlank} so that blank values are not passed as valid, but are subject to any configure {@link #vtype} validation.
     */
    validateBlank: false,

<span id='Ext-form-field-Text-cfg-allowOnlyWhitespace'>    /**
</span>     * @cfg {Boolean} allowOnlyWhitespace
     * Specify false to automatically trim the value before validating
     * the whether the value is blank. Setting this to false automatically
     * sets {@link #allowBlank} to false.
     */
    allowOnlyWhitespace: true,

<span id='Ext-form-field-Text-cfg-minLength'>    /**
</span>     * @cfg {Number} minLength
     * Minimum input field length required
     */
    minLength : 0,

<span id='Ext-form-field-Text-cfg-maxLength'>    /**
</span>     * @cfg {Number} maxLength
     * Maximum input field length allowed by validation. This behavior is intended to
     * provide instant feedback to the user by improving usability to allow pasting and editing or overtyping and back
     * tracking. To restrict the maximum number of characters that can be entered into the field use the
     * **{@link Ext.form.field.Text#enforceMaxLength enforceMaxLength}** option.
     *
     * Defaults to Number.MAX_VALUE.
     */
    maxLength : Number.MAX_VALUE,

<span id='Ext-form-field-Text-cfg-enforceMaxLength'>    /**
</span>     * @cfg {Boolean} enforceMaxLength
     * True to set the maxLength property on the underlying input field. Defaults to false
     */

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-minLengthText'>    /**
</span>     * @cfg {String} minLengthText
     * Error text to display if the **{@link #minLength minimum length}** validation fails.
     */
    minLengthText : &#39;The minimum length for this field is {0}&#39;,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-maxLengthText'>    /**
</span>     * @cfg {String} maxLengthText
     * Error text to display if the **{@link #maxLength maximum length}** validation fails
     */
    maxLengthText : &#39;The maximum length for this field is {0}&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-field-Text-cfg-selectOnFocus'>    /**
</span>     * @cfg {Boolean} [selectOnFocus=false]
     * `true` to automatically select any existing field text when the field receives input
     * focus. Only applies when {@link #editable editable} = true
     */

    //&lt;locale&gt;
<span id='Ext-form-field-Text-cfg-blankText'>    /**
</span>     * @cfg {String} blankText
     * The error text to display if the **{@link #allowBlank}** validation fails
     */
    blankText : &#39;This field is required&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-field-Text-cfg-validator'>    /**
</span>     * @cfg {Function} validator
     * A custom validation function to be called during field validation ({@link #getErrors}).
     * If specified, this function will be called first, allowing the developer to override the default validation
     * process.
     * 
     *     Ext.create(&#39;Ext.form.field.Text&#39;, {
     *         renderTo: document.body,
     *         name: &#39;phone&#39;,
     *         fieldLabel: &#39;Phone Number&#39;,
     *         validator: function (val) {
     *             // remove non-numeric characters
     *             var tn = val.replace(/[^0-9]/g,&#39;&#39;),
     *                 errMsg = &quot;Must be a 10 digit telephone number&quot;;
     *             // if the numeric value is not 10 digits return an error message
     *             return (tn.length === 10) ? true : errMsg;
     *         }
     *     });
     *
     * @param {Object} value The current field value
     * @return {Boolean/String} response
     *
     *  - True if the value is valid
     *  - An error message if the value is invalid
     */

<span id='Ext-form-field-Text-cfg-regex'>    /**
</span>     * @cfg {RegExp} regex
     * A JavaScript RegExp object to be tested against the field value during validation.
     * If the test fails, the field will be marked invalid using
     * either **{@link #regexText}** or **{@link #invalidText}**.
     */

<span id='Ext-form-field-Text-cfg-regexText'>    /**
</span>     * @cfg {String} regexText
     * The error text to display if **{@link #regex}** is used and the test fails during validation
     */
    regexText : &#39;&#39;,

<span id='Ext-form-field-Text-cfg-emptyText'>    /**
</span>     * @cfg {String} emptyText
     * The default text to place into an empty field.
     *
     * Note that normally this value will be submitted to the server if this field is enabled; to prevent this you can
     * set the {@link Ext.form.action.Action#submitEmptyText submitEmptyText} option of {@link Ext.form.Basic#submit} to
     * false.
     *
     * Also note that if you use {@link #inputType inputType}:&#39;file&#39;, {@link #emptyText} is not supported and should be
     * avoided.
     *
     * Note that for browsers that support it, setting this property will use the HTML 5 placeholder attribute, and for
     * older browsers that don&#39;t support the HTML 5 placeholder attribute the value will be placed directly into the input
     * element itself as the raw value. This means that older browsers will obfuscate the {@link #emptyText} value for
     * password input fields.
     */
    emptyText : &#39;&#39;,

<span id='Ext-form-field-Text-cfg-emptyCls'>    /**
</span>     * @cfg {String} [emptyCls=&#39;x-form-empty-field&#39;]
     * The CSS class to apply to an empty field to style the **{@link #emptyText}**.
     * This class is automatically added and removed as needed depending on the current field value.
     */
    emptyCls : Ext.baseCSSPrefix + &#39;form-empty-field&#39;,

<span id='Ext-form-field-Text-property-placeholderCoverCls'>    /**
</span>     * @private
     * The default CSS class for the placeholder label cover need when the browser
     * does not support a Placeholder.
     */
     placeholderCoverCls: Ext.baseCSSPrefix + &#39;placeholder-label&#39;,

<span id='Ext-form-field-Text-cfg-requiredCls'>    /**
</span>     * @cfg {String} [requiredCls=&#39;x-form-required-field&#39;]
     * The CSS class to apply to a required field, i.e. a field where **{@link #allowBlank}** is false.
     */
    requiredCls : Ext.baseCSSPrefix + &#39;form-required-field&#39;,

<span id='Ext-form-field-Text-cfg-enableKeyEvents'>    /**
</span>     * @cfg {Boolean} [enableKeyEvents=false]
     * true to enable the proxying of key events for the HTML input field
     */

    ariaRole: &#39;textbox&#39;,

<span id='Ext-form-field-Text-cfg-repeatTriggerClick'>    /**
</span>     * @cfg {Boolean} repeatTriggerClick
     * `true` to attach a {@link Ext.util.ClickRepeater click repeater} to the trigger(s).
     * Click repeating behavior can also be configured on the individual {@link #triggers
     * trigger instances using the trigger&#39;s {@link {Ext.form.trigger.Trigger#repeatClick
     * repeatClick} config.
     */
    repeatTriggerClick: false,

<span id='Ext-form-field-Text-cfg-readOnly'>    /**
</span>     * @cfg {Boolean} readOnly
     * `true` to prevent the user from changing the field, and hide all triggers.
     */

<span id='Ext-form-field-Text-cfg-stateEvents'>    /**
</span>     * @cfg stateEvents
     * @inheritdoc Ext.state.Stateful#cfg-stateEvents
     * @localdoc By default the following stateEvents are added:
     * 
     *  - {@link #event-resize} - _(added by Ext.Component)_
     *  - {@link #event-change}
     */

<span id='Ext-form-field-Text-cfg-triggerWrapCls'>    /**
</span>     * @cfg {String}
     * The CSS class that is added to the div wrapping the input element and trigger button(s).
     */
    triggerWrapCls: Ext.baseCSSPrefix + &#39;form-trigger-wrap&#39;,

<span id='Ext-form-field-Text-property-triggerWrapFocusCls'>    triggerWrapFocusCls: Ext.baseCSSPrefix + &#39;form-trigger-wrap-focus&#39;,
</span><span id='Ext-form-field-Text-property-triggerWrapInvalidCls'>    triggerWrapInvalidCls: Ext.baseCSSPrefix + &#39;form-trigger-wrap-invalid&#39;,
</span>
<span id='Ext-form-field-Text-cfg-fieldBodyCls'>    fieldBodyCls: Ext.baseCSSPrefix + &#39;form-text-field-body&#39;,
</span>
<span id='Ext-form-field-Text-cfg-inputWrapCls'>    /**
</span>     * @cfg {String}
     * The CSS class that is added to the element wrapping the input element
     */
    inputWrapCls: Ext.baseCSSPrefix + &#39;form-text-wrap&#39;,

<span id='Ext-form-field-Text-property-inputWrapFocusCls'>    inputWrapFocusCls: Ext.baseCSSPrefix + &#39;form-text-wrap-focus&#39;,
</span><span id='Ext-form-field-Text-property-inputWrapInvalidCls'>    inputWrapInvalidCls: Ext.baseCSSPrefix + &#39;form-text-wrap-invalid&#39;,
</span><span id='Ext-form-field-Text-property-growCls'>    growCls: Ext.baseCSSPrefix + &#39;form-text-grow&#39;,
</span>
<span id='Ext-form-field-Text-property-emptyClsElements'>    /* 
</span>     * @private
     * This property will hold all elements that require emtpyCls to be applied to them
     */
    emptyClsElements: null,
    
<span id='Ext-form-field-Text-property-needArrowKeys'>    needArrowKeys: true,
</span>
<span id='Ext-form-field-Text-property-squashMouseUp'>    // Listener block to preventDefault on the mouseup event..
</span>    // Observable rejects Ext.emptyFn as a no-op and the listener does not get added so the default does not get prevented.
    // We do not want touchend events translated into mouseup, we only want to prevent default on real mouseup events.
    squashMouseUp: {
        mouseup: function(e) {
            if (this.selectOnFocus) {
                this.inputEl.dom.select();
            }
        },
        translate: false,
        single: true,
        preventDefault: true
    },

<span id='Ext-form-field-Text-cfg-childEls'>    childEls: [
</span><span id='Ext-form-field-Text-property-triggerWrap'>        /**
</span>         * @property {Ext.dom.Element} triggerWrap
         * A reference to the element which encapsulates the input field and all
         * trigger button(s). Only set after the field has been rendered.
         */
        &#39;triggerWrap&#39;,

<span id='Ext-form-field-Text-property-inputWrap'>        /**
</span>         * @property {Ext.dom.Element} inputWrap
         * A reference to the element that wraps the input element. Only set after the
         * field has been rendered.
         */
        &#39;inputWrap&#39;,

        &#39;placeholderLabel&#39;
    ],

<span id='Ext-form-field-Text-property-preSubTpl'>    preSubTpl: [
</span>        &#39;&lt;div id=&quot;{cmpId}-triggerWrap&quot; data-ref=&quot;triggerWrap&quot;&#39;,
                &#39;&lt;tpl if=&quot;ariaEl == \&#39;triggerWrap\&#39;&quot;&gt;&#39;,
                    &#39;&lt;tpl foreach=&quot;ariaElAttributes&quot;&gt; {$}=&quot;{.}&quot;&lt;/tpl&gt;&#39;,
                &#39;&lt;tpl else&gt;&#39;,
                    &#39; role=&quot;presentation&quot;&#39;,
                &#39;&lt;/tpl&gt;&#39;,
                &#39; class=&quot;{triggerWrapCls} {triggerWrapCls}-{ui}&quot;&gt;&#39;,
            &#39;&lt;div id={cmpId}-inputWrap data-ref=&quot;inputWrap&quot;&#39;,
                &#39; role=&quot;presentation&quot; class=&quot;{inputWrapCls} {inputWrapCls}-{ui}&quot;&gt;&#39;
    ],

<span id='Ext-form-field-Text-property-postSubTpl'>    postSubTpl: [
</span>            &#39;&lt;tpl if=&quot;!Ext.supports.Placeholder&quot;&gt;&#39;,
            &#39;&lt;label id=&quot;{cmpId}-placeholderLabel&quot; data-ref=&quot;placeholderLabel&quot; for=&quot;{id}&quot; class=&quot;{placeholderCoverCls} {placeholderCoverCls}-{ui}&quot;&gt;{placeholder}&lt;/label&gt;&#39;,
            &#39;&lt;/tpl&gt;&#39;,
            &#39;&lt;/div&gt;&#39;, // end inputWrap
            &#39;&lt;tpl for=&quot;triggers&quot;&gt;{[values.renderTrigger(parent)]}&lt;/tpl&gt;&#39;,
        &#39;&lt;/div&gt;&#39; // end triggerWrap
    ],

<span id='Ext-form-field-Text-event-autosize'>    /**
</span>     * @event autosize
     * Fires when the **{@link #autoSize}** function is triggered and the field is resized according to the
     * {@link #grow}/{@link #growMin}/{@link #growMax} configs as a result. This event provides a hook for the
     * developer to apply additional logic at runtime to resize the field if needed.
     * @param {Ext.form.field.Text} this This text field
     * @param {Number} width The new field width
     */

<span id='Ext-form-field-Text-event-keydown'>    /**
</span>     * @event keydown
     * Keydown input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
     * @param {Ext.form.field.Text} this This text field
     * @param {Ext.event.Event} e
     */

<span id='Ext-form-field-Text-event-keyup'>    /**
</span>     * @event keyup
     * Keyup input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
     * @param {Ext.form.field.Text} this This text field
     * @param {Ext.event.Event} e
     */

<span id='Ext-form-field-Text-event-keypress'>    /**
</span>     * @event keypress
     * Keypress input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
     * @param {Ext.form.field.Text} this This text field
     * @param {Ext.event.Event} e
     */

    initComponent: function () {
        var me = this,
            emptyCls = me.emptyCls;

        if (me.allowOnlyWhitespace === false) {
            me.allowBlank = false;
        }

        //&lt;debug&gt;
        if (me.size) {
            Ext.log.warn(&#39;Ext.form.field.Text &quot;size&quot; config was deprecated in Ext 5.0. Please specify a &quot;width&quot; or use a layout instead.&#39;);
        }
        //&lt;/debug&gt;
        // In Ext JS 4.x the layout system used the following magic formula for converting
        // the &quot;size&quot; config into a pixel value.
        if (me.size) {
            me.defaultBodyWidth = me.size * 6.5 + 20;
        }

        if (!me.onTrigger1Click) {
            // for compat with 4.x TriggerField
            me.onTrigger1Click = me.onTriggerClick;
        }

        me.callParent();

        if (me.readOnly) {
            me.setReadOnly(me.readOnly);
        }
        me.fieldFocusCls = me.baseCls + &#39;-focus&#39;;
        me.emptyUICls = emptyCls + &#39; &#39; + emptyCls + &#39;-&#39; + me.ui;
        me.addStateEvents(&#39;change&#39;);
    },

<span id='Ext-form-field-Text-method-initEvents'>    initEvents: function(){
</span>        var me = this,
            el = me.inputEl;

        me.callParent();

        // Workaround for https://code.google.com/p/chromium/issues/detail?id=4505
        // On mousedown, add a single: true mouseup listener which prevents default.
        // That will prevent deselection of the text that was selected in the onFocus method.
        if (me.selectOnFocus || me.emptyText) {
            me.mon(el, &#39;mousedown&#39;, me.onMouseDown, me);
        }
        if (me.maskRe || (me.vtype &amp;&amp; me.disableKeyFilter !== true &amp;&amp; (me.maskRe = Ext.form.field.VTypes[me.vtype+&#39;Mask&#39;]))){
            me.mon(el, &#39;keypress&#39;, me.filterKeys, me);
        }

        if (me.enableKeyEvents) {
            me.mon(el, {
                scope: me,
                keyup: me.onKeyUp,
                keydown: me.onKeyDown,
                keypress: me.onKeyPress
            });
        }
    },

<span id='Ext-form-field-Text-method-isEqual'>    /**
</span>     * @private
     * Treat undefined and null values as equal to an empty string value.
     */
    isEqual: function(value1, value2) {
        return this.isEqualAsString(value1, value2);
    },

<span id='Ext-form-field-Text-method-onChange'>    /**
</span>     * @private
     * If grow=true, invoke the autoSize method when the field&#39;s value is changed.
     */
    onChange: function(newVal, oldVal) {
        this.callParent([newVal, oldVal]);
        this.autoSize();
    },

<span id='Ext-form-field-Text-method-getSubTplData'>    getSubTplData: function(fieldData) {
</span>        var me = this,
            value = me.getRawValue(),
            isEmpty = me.emptyText &amp;&amp; value.length &lt; 1,
            maxLength = me.maxLength,
            placeholder, data, inputElAttr;

        // We can&#39;t just dump the value here, since MAX_VALUE ends up
        // being something like 1.xxxxe+300, which gets interpreted as 1
        // in the markup
        if (me.enforceMaxLength) {
            if (maxLength === Number.MAX_VALUE) {
                maxLength = undefined;
            }
        } else {
            maxLength = undefined;
        }

        if (me.emptyText) {
            placeholder = me.emptyText;
        }

        data = Ext.apply(me.callParent([fieldData]), {
            triggerWrapCls: me.triggerWrapCls,
            inputWrapCls: me.inputWrapCls,
            placeholderCoverCls: me.placeholderCoverCls,
            triggers: me.orderedTriggers,
            maxLength: maxLength,
            readOnly: !me.editable || me.readOnly,
            placeholder: placeholder,
            value: value,
            fieldCls: me.fieldCls + (me.allowBlank ? &#39;&#39; :  &#39; &#39; + me.requiredCls) + (isEmpty ? &#39; &#39; + me.emptyUICls : &#39;&#39;)
        });
        
        inputElAttr = data.inputElAriaAttributes;
        
        if (inputElAttr) {
            inputElAttr[&#39;aria-required&#39;] = !me.allowBlank;
        }
        
        return data;
    },

<span id='Ext-form-field-Text-method-onRender'>    onRender: function() {
</span>        var me = this,
            triggers = me.getTriggers(),
            elements = [],
            id;

        if (Ext.supports.FixedTableWidthBug) {
            // Workaround for https://bugs.webkit.org/show_bug.cgi?id=130239 and
            // https://code.google.com/p/chromium/issues/detail?id=377190
            // See styleHooks for more details
            me.el._needsTableWidthFix = true;
        }

        me.callParent();

        if (triggers) {
            this.invokeTriggers(&#39;onFieldRender&#39;);

<span id='Ext-form-field-Text-property-triggerEl'>            /**
</span>             * @property {Ext.CompositeElement} triggerEl
             * @deprecated 5.0
             * A composite of all the trigger button elements. Only set after the field has
             * been rendered.
             */
            for(id in triggers) {
                elements.push(triggers[id].el);
            }
            // for 4.x compat, also set triggerCell
            me.triggerEl = me.triggerCell = new Ext.CompositeElement(elements, true);
        }

<span id='Ext-form-field-Text-property-inputCell'>        /**
</span>         * @property {Ext.dom.Element} inputCell
         * A reference to the element that wraps the input element. Only set after the
         * field has been rendered.
         * @deprecated 5.0 use {@link #inputWrap} instead
         */
        me.inputCell = me.inputWrap;
    },

<span id='Ext-form-field-Text-method-afterRender'>    afterRender: function() {
</span>        var me = this;

        me.autoSize();
        me.callParent();
        me.invokeTriggers(&#39;afterFieldRender&#39;);
        me.emptyClsElements = [me.inputEl];
    },

<span id='Ext-form-field-Text-method-onMouseDown'>    onMouseDown: function(){
</span>        if (!this.hasFocus) {
            // On the next mouseup, prevent default.
            // 99% of the time, it will be the mouseup of the click into the field, and 
            // We will be preventing deselection of selected text: https://code.google.com/p/chromium/issues/detail?id=4505
            // Listener is on the doc in case the pointer moves out before user lets go.
            this.squashMouseUp.scope = this;
            Ext.getDoc().on(this.squashMouseUp);
        }
    },

<span id='Ext-form-field-Text-method-applyTriggers'>    applyTriggers: function(triggers) {
</span>        var me = this,
            hideAllTriggers = me.getHideTrigger(),
            readOnly = me.readOnly,
            orderedTriggers = me.orderedTriggers = [],
            repeatTriggerClick = me.repeatTriggerClick,
            id, triggerCfg, trigger, triggerCls, i;

        //&lt;debug&gt;
        if (me.rendered) {
            Ext.raise(&quot;Cannot set triggers after field has already been rendered.&quot;);
        }

        // don&#39;t warn if we have both triggerCls and triggers, because picker field
        // uses triggerCls to style the &quot;picker&quot; trigger.
        if ((me.triggerCls &amp;&amp; !triggers) || me.trigger1Cls) {
            Ext.log.warn(&quot;Ext.form.field.Text: &#39;triggerCls&#39; and &#39;trigger&lt;n&gt;Cls&#39;&quot; +
                &quot; are deprecated.  Use &#39;triggers&#39; instead.&quot;);
        }
        //&lt;/debug&gt;

        if (!triggers) {
            // For compatibility with 4.x, transform the trigger&lt;n&gt;Cls configs into the
            // new &quot;triggers&quot; config.
            triggers = {};

            if (me.triggerCls &amp;&amp; !me.trigger1Cls) {
                me.trigger1Cls = me.triggerCls;
            }

            // Assignment in conditional test is deliberate here
            for (i = 1; (triggerCls = me[&#39;trigger&#39; + i + &#39;Cls&#39;]); i++) { // jshint ignore:line
                triggers[&#39;trigger&#39; + i] = {
                    cls: triggerCls,
                    extraCls: Ext.baseCSSPrefix + &#39;trigger-index-&#39; + i,
                    handler: &#39;onTrigger&#39; + i + &#39;Click&#39;,
                    compat4Mode: true,
                    scope: me
                };
            }
        }

        for(id in triggers) {
            if (triggers.hasOwnProperty(id)) {
                triggerCfg = triggers[id];
                triggerCfg.field = me;
                triggerCfg.id = id;

                /*
                 * An explicitly-configured &#39;triggerConfig.hideOnReadOnly : false&#39; allows {@link #hideTrigger} analysis
                 */
                if ((readOnly &amp;&amp; triggerCfg.hideOnReadOnly !== false) || (hideAllTriggers &amp;&amp; triggerCfg.hidden !== false)) {
                    triggerCfg.hidden = true;
                }
                if (repeatTriggerClick &amp;&amp; (triggerCfg.repeatClick !== false)) {
                    triggerCfg.repeatClick = true;
                }

                trigger = triggers[id] = Ext.form.trigger.Trigger.create(triggerCfg);
                orderedTriggers.push(trigger);
            }
        }

        Ext.Array.sort(orderedTriggers, Ext.form.trigger.Trigger.weightComparator);

        return triggers;
    },

<span id='Ext-form-field-Text-method-invokeTriggers'>    /**
</span>     * Invokes a method on all triggers.
     * @param {String} methodName
     * @private
     */
    invokeTriggers: function(methodName, args) {
        var me = this,
            triggers = me.getTriggers(),
            id, trigger;

        if (triggers) {
            for (id in triggers) {
                if (triggers.hasOwnProperty(id)) {
                    trigger = triggers[id];
                    // IE8 needs &quot;|| []&quot; if args is undefined
                    trigger[methodName].apply(trigger, args || []);
                }
            }
        }
    },

<span id='Ext-form-field-Text-method-getTrigger'>    /**
</span>     * Returns the trigger with the given id
     * @param {String} id
     * @return {Ext.form.trigger.Trigger}
     */
    getTrigger: function(id) {
        return this.getTriggers()[id];
    },

<span id='Ext-form-field-Text-method-updateHideTrigger'>    updateHideTrigger: function(hideTrigger) {
</span>        this.invokeTriggers(hideTrigger ? &#39;hide&#39; : &#39;show&#39;);
    },

<span id='Ext-form-field-Text-method-updateEditable'>    updateEditable: function(editable, oldEditable) {
</span>        this.setReadOnlyAttr(!editable || this.readOnly);
    },

<span id='Ext-form-field-Text-method-setReadOnly'>    /**
</span>     * Sets the read-only state of this field.
     * @param {Boolean} readOnly True to prevent the user changing the field and explicitly
     * hide the trigger(s). Setting this to true will supersede settings editable and
     * hideTrigger. Setting this to false will defer back to {@link #editable editable} and {@link #hideTrigger hideTrigger}.
     */
    setReadOnly: function(readOnly) {
        var me = this,
            triggers = me.getTriggers(),
            hideTriggers = me.getHideTrigger(),
            trigger,
            id;

        readOnly = !!readOnly;

        me.callParent([readOnly]);
        if (me.rendered) {
            me.setReadOnlyAttr(readOnly || !me.editable);
        }

        if (triggers) {
            for (id in triggers) {
                trigger = triggers[id];
                /*
                 * Controlled trigger visibility state is only managed fully when &#39;hideOnReadOnly&#39; is falsy.
                 * Truth table:
                 *   - If the trigger is configured/defaulted as &#39;hideOnReadOnly : true&#39;, it&#39;s readOnly-visibility
                 *     is determined solely by readOnly state of the Field.
                 *   - If &#39;hideOnReadOnly : false/undefined&#39;, the Fields.{link #hideTrigger hideTrigger} is honored.
                 */
                if (trigger.hideOnReadOnly === true || (trigger.hideOnReadOnly !== false &amp;&amp; !hideTriggers)) {
                    trigger.setVisible(!readOnly);
                }
            }
        }
    },

<span id='Ext-form-field-Text-method-setReadOnlyAttr'>    /**
</span>     * @private
     * Sets the readonly attribute of the input element
     */
    setReadOnlyAttr: function(readOnly) {
        var me = this,
            readOnlyName = &#39;readonly&#39;,
            inputEl = me.inputEl.dom;

        if (readOnly) {
            inputEl.setAttribute(readOnlyName, readOnlyName);
        } else {
            inputEl.removeAttribute(readOnlyName);
        }
        
        if (!me.ariaStaticRoles[me.ariaRole]) {
            me.inputEl.dom.setAttribute(&#39;aria-readonly&#39;, !!readOnly);
        }
    },

<span id='Ext-form-field-Text-method-processRawValue'>    /**
</span>     * Performs any necessary manipulation of a raw String value to prepare it for conversion and/or
     * {@link #validate validation}. For text fields this applies the configured {@link #stripCharsRe}
     * to the raw value.
     * @param {String} value The unprocessed string value
     * @return {String} The processed string value
     */
    processRawValue: function(value) {
        var me = this,
            stripRe = me.stripCharsRe,
            mod, newValue;

        if (stripRe) {
            // This will force all instances that match stripRe to be removed
            // in case the user tries to add it with copy and paste EXTJS-18621
            if (!stripRe.global) {
                mod = &#39;g&#39;;
                mod += (stripRe.ignoreCase) ? &#39;i&#39; : &#39;&#39;;
                mod += (stripRe.multiline) ? &#39;m&#39; : &#39;&#39;;
                stripRe = new RegExp(stripRe.source, mod);
            }

            newValue = value.replace(stripRe, &#39;&#39;);
            if (newValue !== value) {
                me.setRawValue(newValue);
                // Some components change lastValue as you type, so we need to verify
                // if this is the case here and replace the value of lastValue
                if (me.lastValue === value) {
                    me.lastValue = newValue;
                }
                value = newValue;
            }
        }
        return value;
    },

<span id='Ext-form-field-Text-method-onDisable'>    onDisable: function(){
</span>        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = &#39;on&#39;;
        }
    },

<span id='Ext-form-field-Text-method-onEnable'>    onEnable: function(){
</span>        this.callParent();
        if (Ext.isIE) {
            this.inputEl.dom.unselectable = &#39;&#39;;
        }
    },

<span id='Ext-form-field-Text-method-onKeyDown'>    onKeyDown: function(e) {
</span>        this.fireEvent(&#39;keydown&#39;, this, e);
    },

<span id='Ext-form-field-Text-method-onKeyUp'>    onKeyUp: function(e) {
</span>        this.fireEvent(&#39;keyup&#39;, this, e);
    },

<span id='Ext-form-field-Text-method-onKeyPress'>    onKeyPress: function(e) {
</span>        this.fireEvent(&#39;keypress&#39;, this, e);
    },

<span id='Ext-form-field-Text-method-getEmptyText'>    /**
</span>     * Returns the value of this field&#39;s {@link #cfg-emptyText}
     * @return {String} The value of this field&#39;s emptyText
     */
    getEmptyText: function() {
        return this.emptyText;
    },
    
<span id='Ext-form-field-Text-method-setEmptyText'>    /**
</span>     * Sets the default text to place into an empty field
     * @param {String} value The {@link #cfg-emptyText} value for this field
     * @return {Ext.form.field.Text} this
     */
    setEmptyText: function(value) {
        var me = this,
            inputEl = me.inputEl;

        value = value || &#39;&#39;;

        me.emptyText = value;

        if (me.rendered) {
            if (Ext.supports.Placeholder &amp;&amp; !me.simulatePlaceholder) {
                if (value) {
                    inputEl.dom.setAttribute(&#39;placeholder&#39;, value);
                } else  {
                    inputEl.dom.removeAttribute(&#39;placeholder&#39;);
                }
            } else {
                me.placeholderLabel.setHtml(value);
            }
            me.refreshEmptyText();
        }

        return this;
    },

<span id='Ext-form-field-Text-method-afterFirstLayout'>    afterFirstLayout: function() {
</span>        this.callParent();
        if (Ext.isIE &amp;&amp; this.disabled) {
            var el = this.inputEl;
            if (el) {
                el.dom.unselectable = &#39;on&#39;;
            }
        }
    },

<span id='Ext-form-field-Text-method-toggleInvalidCls'>    /**
</span>     * @private
     */
    toggleInvalidCls: function(hasError) {
        var method = hasError ? &#39;addCls&#39; : &#39;removeCls&#39;;

        this.callParent([hasError]);

        this.triggerWrap[method](this.triggerWrapInvalidCls);
        this.inputWrap[method](this.inputWrapInvalidCls);
    },

<span id='Ext-form-field-Text-method-onFieldMutation'>    onFieldMutation: function(e) {
</span>        this.refreshEmptyText();
        this.callParent([e]);
    },

<span id='Ext-form-field-Text-method-refreshEmptyText'>    refreshEmptyText: function() {
</span>        var me = this,
            inputEl = me.inputEl,
            emptyClsElements = me.emptyClsElements,
            value, isEmpty, i;

        if (inputEl) {
            value = me.getValue();
            isEmpty = !(inputEl.dom.value || (Ext.isArray(value) &amp;&amp; value.length));
            
            if (me.placeholderLabel) {
                me.placeholderLabel.setDisplayed(isEmpty);
            }

            for (i=0; i &lt; emptyClsElements.length; i++) {
                emptyClsElements[i].toggleCls(me.emptyUICls, isEmpty);
            }
        }

    },

<span id='Ext-form-field-Text-method-setValue'>    setValue: function(value) {
</span>        value = this.callParent([value]);

        this.refreshEmptyText();

        return value;
    },

<span id='Ext-form-field-Text-method-onFocus'>    onFocus: function(e) {
</span>        var me = this,
            len;

        me.callParent([e]);
        
        // This handler may be called when the focus has already shifted to another element;
        // calling inputEl.select() will forcibly focus again it which in turn might set up
        // a nasty circular race condition if focusEl !== inputEl.
        Ext.asap(function() {
            // This ensures the carret will be at the end of the input element
            // while tabbing between editors.
            if (!me.destroyed &amp;&amp; document.activeElement === me.inputEl.dom) {
                len = me.inputEl.dom.value.length;
                me.selectText(me.selectOnFocus ? 0 : len, len);
            }
        });

        if (me.emptyText) {
            me.autoSize();
        }

        me.addCls(me.fieldFocusCls);
        me.triggerWrap.addCls(me.triggerWrapFocusCls);
        me.inputWrap.addCls(me.inputWrapFocusCls);
        me.invokeTriggers(&#39;onFieldFocus&#39;, [e]);
    },

<span id='Ext-form-field-Text-method-onBlur'>    /**
</span>     * @private
     */
    onBlur: function(e) {
        var me = this;

        me.callParent([e]);

        me.removeCls(me.fieldFocusCls);
        me.triggerWrap.removeCls(me.triggerWrapFocusCls);
        me.inputWrap.removeCls(me.inputWrapFocusCls);
        me.invokeTriggers(&#39;onFieldBlur&#39;, [e]);
    },

<span id='Ext-form-field-Text-method-filterKeys'>    /**
</span>     * @private
     */
    filterKeys : function(e){
        /*
         * Current only FF will fire keypress events for special keys.
         * 
         * On European keyboards, the right alt key, Alt Gr, is used to type certain special characters.
         * JS detects a keypress of this as ctrlKey &amp; altKey. As such, we check that alt isn&#39;t pressed
         * so we can still process these special characters.
         */
        if ((e.ctrlKey &amp;&amp; !e.altKey) || e.isSpecialKey()) {
            return;
        }
        var charCode = String.fromCharCode(e.getCharCode());
        if (!this.maskRe.test(charCode)) {
            e.stopEvent();
        }
    },

<span id='Ext-form-field-Text-method-getState'>    getState: function() {
</span>        return this.addPropertyToState(this.callParent(), &#39;value&#39;);
    },

<span id='Ext-form-field-Text-method-applyState'>    applyState: function(state) {
</span>        this.callParent([state]);
        if (state.hasOwnProperty(&#39;value&#39;)) {
            this.setValue(state.value);
        }
    },

<span id='Ext-form-field-Text-method-getErrors'>    /**
</span>     * Validates a value according to the field&#39;s validation rules and returns an array of errors
     * for any failing validations. Validation rules are processed in the following order:
     *
     * 1. **Field specific validator**
     *
     *     A validator offers a way to customize and reuse a validation specification.
     *     If a field is configured with a `{@link #validator}`
     *     function, it will be passed the current field value.  The `{@link #validator}`
     *     function is expected to return either:
     *
     *     - Boolean `true`  if the value is valid (validation continues).
     *     - a String to represent the invalid message if invalid (validation halts).
     *
     * 2. **Basic Validation**
     *
     *     If the `{@link #validator}` has not halted validation,
     *     basic validation proceeds as follows:
     *
     *     - `{@link #allowBlank}` : (Invalid message = `{@link #blankText}`)
     *
     *         Depending on the configuration of `{@link #allowBlank}`, a
     *         blank field will cause validation to halt at this step and return
     *         Boolean true or false accordingly.
     *
     *     - `{@link #minLength}` : (Invalid message = `{@link #minLengthText}`)
     *
     *         If the passed value does not satisfy the `{@link #minLength}`
     *         specified, validation halts.
     *
     *     -  `{@link #maxLength}` : (Invalid message = `{@link #maxLengthText}`)
     *
     *         If the passed value does not satisfy the `{@link #maxLength}`
     *         specified, validation halts.
     *
     * 3. **Preconfigured Validation Types (VTypes)**
     *
     *     If none of the prior validation steps halts validation, a field
     *     configured with a `{@link #vtype}` will utilize the
     *     corresponding {@link Ext.form.field.VTypes VTypes} validation function.
     *     If invalid, either the field&#39;s `{@link #vtypeText}` or
     *     the VTypes vtype Text property will be used for the invalid message.
     *     Keystrokes on the field will be filtered according to the VTypes
     *     vtype Mask property.
     *
     * 4. **Field specific regex test**
     *
     *     If none of the prior validation steps halts validation, a field&#39;s
     *     configured `{@link #regex}` test will be processed.
     *     The invalid message for this test is configured with `{@link #regexText}`
     *
     * @param {Object} value The value to validate. The processed raw value will be used if nothing is passed.
     * @return {String[]} Array of any validation errors
     */
    getErrors: function(value) {
        value = arguments.length ? (value == null ? &#39;&#39; : value) : this.processRawValue(this.getRawValue());

        var me = this,
            errors = me.callParent([value]),
            validator = me.validator,
            vtype = me.vtype,
            vtypes = Ext.form.field.VTypes,
            regex = me.regex,
            format = Ext.String.format,
            msg, trimmed, isBlank;

        if (Ext.isFunction(validator)) {
            msg = validator.call(me, value);
            if (msg !== true) {
                errors.push(msg);
            }
        }

        trimmed = me.allowOnlyWhitespace ? value : Ext.String.trim(value);

        if (trimmed.length &lt; 1) {
            if (!me.allowBlank) {
                errors.push(me.blankText);
            }
            // If we are not configured to validate blank values, there cannot be any additional errors
            if (!me.validateBlank) {
                return errors;
            }
            isBlank = true;
        }

        // If a blank value has been allowed through, then exempt it from the minLength check.
        // It must be allowed to hit the vtype validation.
        if (!isBlank &amp;&amp; value.length &lt; me.minLength) {
            errors.push(format(me.minLengthText, me.minLength));
        }

        if (value.length &gt; me.maxLength) {
            errors.push(format(me.maxLengthText, me.maxLength));
        }

        if (vtype) {
            if (!vtypes[vtype](value, me)) {
                errors.push(me.vtypeText || vtypes[vtype +&#39;Text&#39;]);
            }
        }

        if (regex &amp;&amp; !regex.test(value)) {
            errors.push(me.regexText || me.invalidText);
        }

        return errors;
    },

<span id='Ext-form-field-Text-method-selectText'>    /**
</span>     * Selects text in this field
     * @param {Number} [start=0] The index where the selection should start
     * @param {Number} [end] The index where the selection should end (defaults to the text length)
     */
    selectText: function (start, end) {
        var me = this,
            el = me.inputEl.dom,
            v = el.value,
            len = v.length,
            range;

        if (len &gt; 0) {
            start = start === undefined ? 0 : Math.min(start, len);
            end = end === undefined ? len : Math.min(end, len);

            if (el.setSelectionRange) {
                el.setSelectionRange(start, end);
            } else if (el.createTextRange) {
                range = el.createTextRange();
                range.moveStart(&#39;character&#39;, start);
                range.moveEnd(&#39;character&#39;, end - len);
                range.select();
            }
        }

        // TODO: Reinvestigate FF and Opera.
    },

<span id='Ext-form-field-Text-method-getGrowWidth'>    // Template method, override in Combobox.
</span>    getGrowWidth: function () {
        return this.inputEl.dom.value;
    },

<span id='Ext-form-field-Text-method-autoSize'>    /**
</span>     * Automatically grows the field to accommodate the width of the text up to the maximum
     * field width allowed. This only takes effect if {@link #grow} = true, and fires the
     * {@link #autosize} event if the width changes.
     */
    autoSize: function() {
        var me = this,
            triggers, triggerId, triggerWidth, inputEl, width, value;

        if (me.grow &amp;&amp; me.rendered &amp;&amp; me.getSizeModel().width.auto) {
            inputEl = me.inputEl;
            triggers = me.getTriggers();
            triggerWidth = 0;

            value = Ext.util.Format.htmlEncode(
                me.getGrowWidth() || (me.hasFocus ? &#39;&#39; : me.emptyText) || &#39;&#39;
            );
            value += me.growAppend;

            for (triggerId in triggers) {
                triggerWidth += triggers[triggerId].el.getWidth();
            }

            width = inputEl.getTextWidth(value) +  triggerWidth +
                // The element that has the border depends on theme - inputWrap (classic)
                // or triggerWrap (neptune)
                me.inputWrap.getBorderWidth(&#39;lr&#39;) + me.triggerWrap.getBorderWidth(&#39;lr&#39;);

            width = Math.min(Math.max(width, me.growMin), me.growMax);

            me.bodyEl.setWidth(width);

            me.updateLayout();

            me.fireEvent(&#39;autosize&#39;, me, width);
        }
    },

<span id='Ext-form-field-Text-method-doDestroy'>    doDestroy: function() {
</span>        var me = this;

        me.invokeTriggers(&#39;destroy&#39;);
        Ext.destroy(me.triggerRepeater);

        me.callParent();
    },

<span id='Ext-form-field-Text-method-onTriggerClick'>    onTriggerClick: Ext.emptyFn,
</span>
<span id='Ext-form-field-Text-property-privates'>    privates: {
</span><span id='Ext-form-field-Text-method-getTdType'>        /**
</span>         * @private
         */
        getTdType: function () {
            return &#39;textfield&#39;;
        }
    },

<span id='Ext-form-field-Text-property-deprecated'>    deprecated: {
</span>        5: {
            methods: {
<span id='Ext-form-field-Text-method-getTriggerWidth'>                /**
</span>                 * Get the total width of the trigger button area.
                 * @return {Number} The total trigger width
                 * @deprecated 5.0
                 */
                getTriggerWidth: function() {
                    var triggers = this.getTriggers(),
                        width = 0,
                        id;
                    if (triggers &amp;&amp; this.rendered) {
                        for (id in triggers) {
                            if (triggers.hasOwnProperty(id)) {
                                width += triggers[id].el.getWidth();
                            }
                        }
                    }

                    return width;
                }
            }
        }
    }

});
</pre>
</body>
</html>
