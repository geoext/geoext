<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-mixin-Pluggable'>/**
</span> * This mixin provides support for a `plugins` config and related API&#39;s.
 *
 * If this mixin is used for non-Components, the statements regarding the host being a
 * Component can be translated accordingly. The only requirement on the user of this class
 * is that the plugins actually used be appropriate for their host.
 *
 * While `Ext.Component` in the Classic Toolkit supports `plugins`, it does not use this
 * class to provide that support. This is due to backwards compatibility in regard to
 * timing changes this implementation would present.
 *
 * **Important:** To ensure plugins are destroyed, call `setPlugins(null)`.
 * @protected
 * @since 6.2.0
 */
Ext.define(&#39;Ext.mixin.Pluggable&#39;, function (Pluggable) {
    var EMPTY = [];

return {
    config: {
<span id='Ext-mixin-Pluggable-cfg-plugins'>        /**
</span>         * @cfg {Object/String/Object[]/String[]} plugins
         * An object or array of objects that will provide custom functionality for this
         * component. If a string is provided or a string is one of the elements of the
         * array, that string is treated as the `type` alias. For example, &quot;listpaging&quot;
         * is the type alias for `Ext.plugin.ListPaging`. The full alias includes the
         * &quot;plugin.&quot; prefix (i.e., &#39;plugin.listpaging&#39;).
         *
         * Plugins should derive from `Ext.plugin.Abstract` but this is not required. The
         * only requirement for a valid plugin is that it contain an `init()` method that
         * accepts a reference to the owning component.
         *
         * When a component is created, if any plugins are available, the component will
         * call the `{@link Ext.plugin.Abstract#method-init init}` method on each plugin,
         * passing a reference to itself. Each plugin can then call methods or respond to
         * events on the component as needed to provide its functionality.
         *
         * ## Example code
         *
         * A plugin by alias:
         *
         *      var list = Ext.create({
         *          xtype: &#39;list&#39;,
         *          itemTpl: &#39;&lt;div class=&quot;item&quot;&gt;{title}&lt;/div&gt;&#39;,
         *          store: &#39;Items&#39;,
         *
         *          plugins: &#39;listpaging&#39;
         *      });
         *
         * Multiple plugins by alias:
         *
         *      var list = Ext.create({
         *          xtype: &#39;list&#39;,
         *          itemTpl: &#39;&lt;div class=&quot;item&quot;&gt;{title}&lt;/div&gt;&#39;,
         *          store: &#39;Items&#39;,
         *
         *          plugins: [&#39;listpaging&#39;, &#39;pullrefresh&#39;]
         *      });
         *
         * Single plugin by class name with config options:
         *
         *      var list = Ext.create({
         *          xtype: &#39;list&#39;,
         *          itemTpl: &#39;&lt;div class=&quot;item&quot;&gt;{title}&lt;/div&gt;&#39;,
         *          store: &#39;Items&#39;,
         *
         *          plugins: {
         *              type: &#39;listpaging&#39;,
         *              autoPaging: true
         *          }
         *      });
         *
         * Multiple plugins by type and class name with config options:
         *
         *      var list = Ext.create({
         *          xtype: &#39;list&#39;,
         *          itemTpl: &#39;&lt;div class=&quot;item&quot;&gt;{title}&lt;/div&gt;&#39;,
         *          store: &#39;Items&#39;,
         *
         *          plugins: [{
         *              xclass: &#39;Ext.plugin.PullRefresh&#39;,
         *              pullRefreshText: &#39;Pull to refresh...&#39;
         *          }, {
         *              type: &#39;listpaging&#39;,
         *              autoPaging: true
         *          }]
         *      });
         *
         */
        plugins: null
    },

<span id='Ext-mixin-Pluggable-method-addPlugin'>    /**
</span>     * Adds a plugin. For example:
     *
     *      list.addPlugin(&#39;pullrefresh&#39;);
     *
     * Or:
     *
     *      list.addPlugin({
     *          type: &#39;pullrefresh&#39;,
     *          pullRefreshText: &#39;Pull to refresh...&#39;
     *      });
     *
     * @param {Object/String/Ext.plugin.Abstract} plugin The plugin or config object or
     * alias to add.
     * @since 6.2.0
     */
    addPlugin: function (plugin) {
        var me = this,
            plugins = me.getPlugins();

        if (plugins) {
            plugin = me.createPlugin(plugin);
            plugin.init(me);
            plugins.push(plugin);
        } else {
            me.setPlugins(plugin);
        }

        return plugin;
    },

<span id='Ext-mixin-Pluggable-method-destroyPlugin'>    /**
</span>     * Removes and destroys a plugin.
     *
     * **Note:** Not all plugins are designed to be removable. Consult the documentation
     * for the specific plugin in question to be sure.
     * @param {String/Ext.plugin.Abstract} plugin The plugin or its `id` to remove.
     * @return {Ext.plugin.Abstract} plugin instance or `null` if not found.
     * @since 6.2.0
     */
    destroyPlugin: function (plugin) {
        return this.removePlugin(plugin, true);
    },

<span id='Ext-mixin-Pluggable-method-findPlugin'>    /**
</span>     * Retrieves plugin by its `type` alias. For example:
     *
     *      var list = Ext.create({
     *          xtype: &#39;list&#39;,
     *          itemTpl: &#39;&lt;div class=&quot;item&quot;&gt;{title}&lt;/div&gt;&#39;,
     *          store: &#39;Items&#39;,
     *
     *          plugins: [&#39;listpaging&#39;, &#39;pullrefresh&#39;]
     *      });
     *
     *      list.findPlugin(&#39;pullrefresh&#39;).setPullRefreshText(&#39;Pull to refresh...&#39;);
     *
     * **Note:** See also {@link #getPlugin}.
     *
     * @param {String} type The Plugin&#39;s `type` as specified by the class&#39;s
     * {@link Ext.Class#cfg-alias alias} configuration.
     * @return {Ext.plugin.Abstract} plugin instance or `null` if not found.
     * @since 6.2.0
     */
    findPlugin: function (type) {
        var plugins = this.getPlugins(),
            n = plugins &amp;&amp; plugins.length,
            i, plugin, ret;

        for (i = 0; i &lt; n &amp;&amp; !ret; i++) {
            plugin = plugins[i];

            // Classic used ptype forever, so support it too but Core/Modern just use
            // type.
            if (plugin.type === type || plugin.ptype === type) {
                ret = plugin;
            }
        }

        return ret || null;
    },

<span id='Ext-mixin-Pluggable-method-getPlugin'>    /**
</span>     * Retrieves a plugin by its `id`.
     *
     *      var list = Ext.create({
     *          xtype: &#39;list&#39;,
     *          itemTpl: &#39;&lt;div class=&quot;item&quot;&gt;{title}&lt;/div&gt;&#39;,
     *          store: &#39;Items&#39;,
     *
     *          plugins: {
     *              xclass: &#39;Ext.plugin.PullRefresh&#39;,
     *              id: &#39;foo&#39;
     *          }
     *      });
     *
     *      list.getPlugin(&#39;foo&#39;).setPullRefreshText(&#39;Pull to refresh...&#39;);
     *
     * **Note:** See also {@link #findPlugin}.
     *
     * @param {String} id The `id` of the plugin.
     * @return {Ext.plugin.Abstract} plugin instance or `null` if not found.
     * @since 6.2.0
     */
    getPlugin: function (id) {
        var plugins = this.getPlugins(),
            n = plugins &amp;&amp; plugins.length,
            i, plugin, ret;

        for (i = 0; i &lt; n &amp;&amp; !ret; i++) {
            plugin = plugins[i];

            // Classic used pluginId, so support it too but Core/Modern just use id.
            if (plugin.id === id || plugin.pluginId === id) {
                ret = plugin;
            }
        }

        return ret || null;
    },

<span id='Ext-mixin-Pluggable-method-removePlugin'>    /**
</span>     * Removes and (optionally) destroys a plugin.
     *
     * **Note:** Not all plugins are designed to be removable. Consult the documentation
     * for the specific plugin in question to be sure.
     * @param {String/Ext.plugin.Abstract} plugin The plugin or its `id` to remove.
     * @param {Boolean} [destroy] Pass `true` to not call `destroy()` on the plugin.
     * @return {Ext.plugin.Abstract} plugin instance or `null` if not found.
     * @since 6.2.0
     */
    removePlugin: function (plugin, destroy) {
        var plugins = this.getPlugins(),
            i = plugins &amp;&amp; plugins.length || 0,
            p;

        while (i-- &gt; 0) {
            p = plugins[i];

            if (p === plugin || p.id === plugin) {
                plugins.splice(i, 1);

                if (destroy) {
                    if (p.destroy) {
                        p.destroy();
                    }
                } else if (p.detachCmp) {
                    p.detachCmp();
                    if (p.setCmp) {
                        p.setCmp(null);
                    }
                }

                break;
            }

            p = null;
        }

        return p;
    },

    privates: {
        statics: {
            idSeed: 0
        },

<span id='Ext-mixin-Pluggable-method-activatePlugin'>        /**
</span>         * Creates a particular plugin type if defined in the `plugins` configuration.
         * @param {String} type The `type` of the plugin.
         * @return {Ext.plugin.Abstract} The plugin that was created.
         * @private
         * @since 6.2.0
         */
        activatePlugin: function (type) {
            var me = this,
                config = me.initialConfig,
                plugins = config &amp;&amp; config.plugins,
                ret = null,
                i, p;
            
            if (plugins) {
                plugins = EMPTY.concat(plugins); // we need an array we can modify
    
                for (i = plugins.length; i-- &gt; 0; ) {
                    p = plugins[i];

                    if (p === type || p.type === type) {
                        me.initialConfig = config = Ext.apply({}, config);
                        config.plugins = plugins; // switch over to our copy
    
                        // Put the instance in the plugins array so it will be included in
                        // the applyPlugins loop for normal processing of plugins.
                        plugins[i] = ret = me.createPlugin(p);
                        break;
                    }
                }
            }
            
            return ret;
        },

<span id='Ext-mixin-Pluggable-method-applyPlugins'>        /**
</span>         * Applier for the `plugins` config property.
         * @param {String[]/Object[]/Ext.plugin.Abstract[]} plugins The new plugins to use.
         * @param {Ext.plugin.Abstract[]} oldPlugins The existing plugins in use.
         * @private
         */
        applyPlugins: function (plugins, oldPlugins) {
            var me = this,
                oldCount = oldPlugins &amp;&amp; oldPlugins.length || 0,
                count, i, plugin;
    
            // Ensure we have an array if we got a single thing or a copy of the array
            // if we got an array.
            plugins = plugins ? EMPTY.concat(plugins) : null;
            count = plugins &amp;&amp; plugins.length || 0;

            // We need to destroy() old plugins that aren&#39;t being brought forward in
            // the new array...
            //
            for (i = 0; i &lt; oldCount; ++i) {
                oldPlugins[i].$dead = true; // so paint the old ones
            }

            // Pass #1 (For historical reasons): Create all of the plugins. Prior versions
            // did this pass first then called init() so we preserve the timings and do
            // the same.
            //
            for (i = 0; i &lt; count; ++i) {
                plugins[i] = me.createPlugin(plugins[i]); // ensure we have an instance
            }

            // Pass #2: Initialize the plugins that have not been and clear $dead for
            // any returning for the next round.
            //
            for (i = 0; i &lt; count; ++i) {
                plugin = plugins[i];

                if (plugin.$dead) { // if (it was in oldPlugins)
                    delete plugin.$dead;  // unpaint it (it&#39;s a keeper)
                } else {
                    plugin.init(me);  // this one is new to the party
                }
            }

            // Now we can teardown any plugins that aren&#39;t coming back.
            //
            for (i = 0; i &lt; oldCount; ++i) {
                if ((plugin = oldPlugins[i]).$dead) {
                    delete plugin.$dead;
                    Ext.destroy(plugin);
                }
            }

            return plugins;
        },
    
<span id='Ext-mixin-Pluggable-method-createPlugin'>        /**
</span>         * Converts the provided type or config object into a plugin instance.
         * @param {String/Object/Ext.plugin.Abstract} config The plugin type, config
         * object or instance.
         * @return {Ext.plugin.Abstract}
         * @private
         */
        createPlugin: function (config) {
            if (typeof config === &#39;string&#39;) {
                config = {
                    type: config
                };
            }
    
            var ret = config;
    
            if (!config.isInstance) {
                // The owner may be needed by plugin&#39;s initConfig so provide it:
                config.cmp = this;
    
                ret = Ext.factory(config, null, null, &#39;plugin&#39;);
    
                // Cleanup the user&#39;s config object:
                delete config.cmp;
            }

            if (!ret.id) {
                ret.id = ++Pluggable.idSeed;
            }
    
            if (ret.setCmp) {
                ret.setCmp(this);
            }
    
            return ret;
        }
    }
}});
</pre>
</body>
</html>
