<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-form-Basic'>/**
</span> * Provides input field management, validation, submission, and form loading services for the collection
 * of {@link Ext.form.field.Field Field} instances within a {@link Ext.container.Container}. It is recommended
 * that you use a {@link Ext.form.Panel} as the form container, as that has logic to automatically
 * hook up an instance of {@link Ext.form.Basic} (plus other conveniences related to field configuration.)
 *
 * ## Form Actions
 *
 * The Basic class delegates the handling of form loads and submits to instances of {@link Ext.form.action.Action}.
 * See the various Action implementations for specific details of each one&#39;s functionality, as well as the
 * documentation for {@link #doAction} which details the configuration options that can be specified in
 * each action call.
 *
 * The default submit Action is {@link Ext.form.action.Submit}, which uses an Ajax request to submit the
 * form&#39;s values to a configured URL. To enable normal browser submission of an Ext form, use the
 * {@link #standardSubmit} config option.
 *
 * ## File uploads
 *
 * File uploads are not performed using normal &#39;Ajax&#39; techniques; see the description for
 * {@link #hasUpload} for details. If you&#39;re using file uploads you should read the method description.
 *
 * ## Example usage:
 *
 *     @example
 *     Ext.create(&#39;Ext.form.Panel&#39;, {
 *         title: &#39;Basic Form&#39;,
 *         renderTo: Ext.getBody(),
 *         bodyPadding: 5,
 *         width: 350,
 *
 *         // Any configuration items here will be automatically passed along to
 *         // the Ext.form.Basic instance when it gets created.
 *
 *         // The form will submit an AJAX request to this URL when submitted
 *         url: &#39;save-form.php&#39;,
 *
 *         items: [{
 *             xtype: &#39;textfield&#39;,
 *             fieldLabel: &#39;Field&#39;,
 *             name: &#39;theField&#39;
 *         }],
 *
 *         buttons: [{
 *             text: &#39;Submit&#39;,
 *             handler: function() {
 *                 // The getForm() method returns the Ext.form.Basic instance:
 *                 var form = this.up(&#39;form&#39;).getForm();
 *                 if (form.isValid()) {
 *                     // Submit the Ajax request and handle the response
 *                     form.submit({
 *                         success: function(form, action) {
 *                            Ext.Msg.alert(&#39;Success&#39;, action.result.message);
 *                         },
 *                         failure: function(form, action) {
 *                             Ext.Msg.alert(&#39;Failed&#39;, action.result ? action.result.message : &#39;No response&#39;);
 *                         }
 *                     });
 *                 }
 *             }
 *         }]
 *     });
 */
Ext.define(&#39;Ext.form.Basic&#39;, {
    extend: &#39;Ext.util.Observable&#39;,
    alternateClassName: &#39;Ext.form.BasicForm&#39;,

    requires: [
        &#39;Ext.util.MixedCollection&#39;,
        &#39;Ext.form.action.Load&#39;,
        &#39;Ext.form.action.Submit&#39;,
        &#39;Ext.form.action.StandardSubmit&#39;,
        &#39;Ext.window.MessageBox&#39;,
        &#39;Ext.data.ErrorCollection&#39;,
        &#39;Ext.util.DelayedTask&#39;
    ],

<span id='Ext-form-Basic-property-taskDelay'>    // Not a public API config, this is useful when we&#39;re unit testing so we can
</span>    // turn off the delayed tasks so they fire immediately.
    taskDelay: 10,

<span id='Ext-form-Basic-event-beforeaction'>    /**
</span>     * @event beforeaction
     * Fires before any action is performed. Return false to cancel the action.
     * @param {Ext.form.Basic} this
     * @param {Ext.form.action.Action} action The {@link Ext.form.action.Action} to be performed
     */

<span id='Ext-form-Basic-event-actionfailed'>    /**
</span>     * @event actionfailed
     * Fires when an action fails.
     * @param {Ext.form.Basic} this
     * @param {Ext.form.action.Action} action The {@link Ext.form.action.Action} that failed
     */

<span id='Ext-form-Basic-event-actioncomplete'>    /**
</span>     * @event actioncomplete
     * Fires when an action is completed.
     * @param {Ext.form.Basic} this
     * @param {Ext.form.action.Action} action The {@link Ext.form.action.Action} that completed
     */

<span id='Ext-form-Basic-event-validitychange'>    /**
</span>     * @event validitychange
     * Fires when the validity of the entire form changes.
     * @param {Ext.form.Basic} this
     * @param {Boolean} valid `true` if the form is now valid, `false` if it is now invalid.
     */

<span id='Ext-form-Basic-event-dirtychange'>    /**
</span>     * @event dirtychange
     * Fires when the dirty state of the entire form changes.
     * @param {Ext.form.Basic} this
     * @param {Boolean} dirty `true` if the form is now dirty, `false` if it is no longer dirty.
     */
    
<span id='Ext-form-Basic-event-errorchange'>    /**
</span>     * @event errorchange
     * Fires when the error of one (or more) of the fields in the form changes.
     * @param {Ext.form.Basic} this
     *
     * @private
     */

<span id='Ext-form-Basic-method-constructor'>    /**
</span>     * Creates new form.
     * @param {Ext.container.Container} owner The component that is the container for the form, usually a {@link Ext.form.Panel}
     * @param {Object} config Configuration options. These are normally specified in the config to the
     * {@link Ext.form.Panel} constructor, which passes them along to the BasicForm automatically.
     */
    constructor: function(owner, config) {
        var me = this,
            reader;

<span id='Ext-form-Basic-property-owner'>        /**
</span>         * @property {Ext.container.Container} owner
         * The container component to which this BasicForm is attached.
         */
        me.owner = owner;
        
        me.fieldMonitors = {
            validitychange: me.checkValidityDelay,
            enable: me.checkValidityDelay,
            disable: me.checkValidityDelay,
            dirtychange: me.checkDirtyDelay,
            errorchange: me.checkErrorDelay,
            scope: me
        };

        me.checkValidityTask = new Ext.util.DelayedTask(me.checkValidity, me);
        me.checkDirtyTask = new Ext.util.DelayedTask(me.checkDirty, me);
        me.checkErrorTask = new Ext.util.DelayedTask(me.checkError, me);
        
        // We use the monitor here as opposed to event bubbling. The problem with bubbling is it doesn&#39;t
        // let us react to items being added/remove at different places in the hierarchy which may have an
        // impact on the dirty/valid state.
        me.monitor = new Ext.container.Monitor({
            selector: &#39;[isFormField]:not([excludeForm])&#39;,
            scope: me,
            addHandler: me.onFieldAdd,
            removeHandler: me.onFieldRemove,
            invalidateHandler: me.onMonitorInvalidate
        });
        me.monitor.bind(owner);

        Ext.apply(me, config);

        // Normalize the paramOrder to an Array
        if (Ext.isString(me.paramOrder)) {
            me.paramOrder = me.paramOrder.split(/[\s,|]/);
        }
        
        reader = me.reader;
        if (reader &amp;&amp; !reader.isReader) {
            if (typeof reader === &#39;string&#39;) {
                reader = {
                    type: reader
                };
            }
            me.reader = Ext.createByAlias(&#39;reader.&#39; + reader.type, reader);
        }
        
        reader = me.errorReader;
        if (reader &amp;&amp; !reader.isReader) {
            if (typeof reader === &#39;string&#39;) {
                reader = {
                    type: reader
                };
            }
            me.errorReader = Ext.createByAlias(&#39;reader.&#39; + reader.type, reader);
        }

        me.callParent();
    },

<span id='Ext-form-Basic-method-initialize'>    /**
</span>     * Do any post layout initialization
     * @private
     */
    initialize : function() {
        this.initialized = true;
        this.onValidityChange(!this.hasInvalidField());
    },


<span id='Ext-form-Basic-cfg-method'>    /**
</span>     * @cfg {String} method
     * The request method to use (GET or POST) for form actions if one isn&#39;t supplied in the action options.
     */

<span id='Ext-form-Basic-cfg-reader'>    /**
</span>     * @cfg {Object/Ext.data.reader.Reader} reader
     * An Ext.data.reader.Reader (e.g. {@link Ext.data.reader.Xml}) instance or
     * configuration to be used to read data when executing &#39;load&#39; actions. This 
     * is optional as there is built-in support for processing JSON responses.
     */

<span id='Ext-form-Basic-cfg-errorReader'>    /**
</span>     * @cfg {Object/Ext.data.reader.Reader} errorReader
     * An Ext.data.reader.Reader (e.g. {@link Ext.data.reader.Xml}) instance or
     * configuration to be used to read field error messages returned from &#39;submit&#39; actions. 
     * This is optional as there is built-in support for processing JSON responses.
     *
     * The Records which provide messages for the invalid Fields must use the
     * Field name (or id) as the Record ID, and must contain a field called &#39;msg&#39;
     * which contains the error message.
     *
     * The errorReader does not have to be a full-blown implementation of a
     * Reader. It simply needs to implement a `read(xhr)` function
     * which returns an Array of Records in an object with the following
     * structure:
     *
     *     {
     *         records: recordArray
     *     }
     */

<span id='Ext-form-Basic-cfg-url'>    /**
</span>     * @cfg {String} url
     * The URL to use for form actions if one isn&#39;t supplied in the
     * {@link Ext.form.Basic#doAction doAction} options.
     */

<span id='Ext-form-Basic-cfg-baseParams'>    /**
</span>     * @cfg {Object} baseParams
     * Parameters to pass with all requests. e.g. baseParams: `{id: &#39;123&#39;, foo: &#39;bar&#39;}`.
     *
     * Parameters are encoded as standard HTTP parameters using {@link Ext.Object#toQueryString}.
     */

<span id='Ext-form-Basic-cfg-timeout'>    /**
</span>     * @cfg {Number} timeout
     * Timeout for form actions in seconds.
     */
    timeout: 30,

<span id='Ext-form-Basic-cfg-api'>    /**
</span>     * @cfg {Object} api
     * If specified, load and submit actions will be handled with {@link Ext.form.action.DirectLoad DirectLoad}
     * and {@link Ext.form.action.DirectSubmit DirectSubmit}.  Methods which have been imported by
     * {@link Ext.direct.Manager} can be specified here to load and submit forms. API methods may also be
     * specified as strings. See {@link Ext.data.proxy.Direct#directFn}.  Such as the following:
     *
     *     api: {
     *         load: App.ss.MyProfile.load,
     *         submit: App.ss.MyProfile.submit
     *     }
     *
     * Load actions can use {@link #paramOrder} or {@link #paramsAsHash} to customize how the load method
     * is invoked.  Submit actions will always use a standard form submit. The `formHandler` configuration
     * (see Ext.direct.RemotingProvider#action) must be set on the associated server-side method which has
     * been imported by {@link Ext.direct.Manager}.
     */

<span id='Ext-form-Basic-cfg-paramOrder'>    /**
</span>     * @cfg {String/String[]} paramOrder
     * A list of params to be executed server side. Only used for the {@link #api} `load`
     * configuration.
     *
     * Specify the params in the order in which they must be executed on the
     * server-side as either (1) an Array of String values, or (2) a String of params
     * delimited by either whitespace, comma, or pipe. For example,
     * any of the following would be acceptable:
     *
     *     paramOrder: [&#39;param1&#39;,&#39;param2&#39;,&#39;param3&#39;]
     *     paramOrder: &#39;param1 param2 param3&#39;
     *     paramOrder: &#39;param1,param2,param3&#39;
     *     paramOrder: &#39;param1|param2|param&#39;
     */

<span id='Ext-form-Basic-cfg-paramsAsHash'>    /**
</span>     * @cfg {Boolean} paramsAsHash
     * Only used for the {@link #api} `load` configuration. If true, parameters will be sent as a
     * single hash collection of named arguments. Providing a {@link #paramOrder} nullifies this
     * configuration.
     */
    paramsAsHash: false,
    
<span id='Ext-form-Basic-cfg-metadata'>    /**
</span>     * @cfg {Object/Array} [metadata]
     * Optional metadata to pass with the actions when Ext Direct {@link #api} is used.
     * See {@link Ext.direct.Manager} for more information.
     */

    //&lt;locale&gt;
<span id='Ext-form-Basic-cfg-waitTitle'>    /**
</span>     * @cfg {String} waitTitle
     * The default title to show for the waiting message box
     */
    waitTitle: &#39;Please Wait...&#39;,
    //&lt;/locale&gt;

<span id='Ext-form-Basic-cfg-trackResetOnLoad'>    /**
</span>     * @cfg {Boolean} trackResetOnLoad
     * If set to true, {@link #method-reset}() resets to the last loaded or
     * {@link Ext.form.Basic#setValues}() data instead of when the form was first
     * created.
     */
    trackResetOnLoad: false,

<span id='Ext-form-Basic-cfg-standardSubmit'>    /**
</span>     * @cfg {Boolean} standardSubmit
     * If set to true, a standard HTML form submit is used instead of a XHR (Ajax) style form submission.
     * All of the field values, plus any additional params configured via {@link #baseParams}
     * and/or the `options` to {@link #submit}, will be included in the values submitted in the form.
     */

<span id='Ext-form-Basic-cfg-jsonSubmit'>    /**
</span>     * @cfg {Boolean} jsonSubmit
     * If set to true, the field values are sent as JSON in the request body.
     * All of the field values, plus any additional params configured via {@link #baseParams}
     * and/or the `options` to {@link #submit}, will be included in the values POSTed in the body of the request.
     */

<span id='Ext-form-Basic-cfg-waitMsgTarget'>    /**
</span>     * @cfg {String/HTMLElement/Ext.dom.Element} waitMsgTarget
     * By default wait messages are displayed with Ext.MessageBox.wait. You can target a specific
     * element by passing it or its id or mask the form itself by passing in true.
     */

<span id='Ext-form-Basic-property-wasDirty'>    /**
</span>     * @private
     */
    wasDirty: false,

<span id='Ext-form-Basic-method-destroy'>    /**
</span>     * Destroys this object.
     */
    destroy: function() {
        var me = this,
            mon = me.monitor;
        
        if (mon) {
            mon.unbind();
            me.monitor = null;
        }
        me.clearListeners();
        me.checkValidityTask.cancel();
        me.checkDirtyTask.cancel();
        me.checkErrorTask.cancel();

        me.checkValidityTask = me.checkDirtyTask = me.checkErrorTask = null;
        me.callParent();
    },
    
<span id='Ext-form-Basic-method-onFieldAdd'>    onFieldAdd: function(field){
</span>        field.on(this.fieldMonitors);
        this.onMonitorInvalidate();
    },
    
<span id='Ext-form-Basic-method-onFieldRemove'>    onFieldRemove: function(field){
</span>        field.un(this.fieldMonitors);
        this.onMonitorInvalidate();
    },
    
<span id='Ext-form-Basic-method-onMonitorInvalidate'>    onMonitorInvalidate: function() {
</span>        if (this.initialized) {
            this.checkValidityDelay();
        }
    },
    
<span id='Ext-form-Basic-method-getFields'>    /**
</span>     * Return all the {@link Ext.form.field.Field} components in the owner container.
     * @return {Ext.util.MixedCollection} Collection of the Field objects
     */
    getFields: function() {
        return this.monitor.getItems();
    },

<span id='Ext-form-Basic-method-getBoundItems'>    /**
</span>     * @private
     * Finds and returns the set of all items bound to fields inside this form
     * @return {Ext.util.MixedCollection} The set of all bound form field items
     */
    getBoundItems: function() {
        var boundItems = this._boundItems;
        
        if (!boundItems || boundItems.getCount() === 0) {
            boundItems = this._boundItems = new Ext.util.MixedCollection();
            boundItems.addAll(this.owner.query(&#39;[formBind]&#39;));
        }
        
        return boundItems;
    },

<span id='Ext-form-Basic-method-hasInvalidField'>    /**
</span>     * Returns true if the form contains any invalid fields. No fields will be marked as invalid
     * as a result of calling this; to trigger marking of fields use {@link #isValid} instead.
     */
    hasInvalidField: function() {
        return !!this.getFields().findBy(function(field) {
            var preventMark = field.preventMark,
                isValid;
            field.preventMark = true;
            isValid = field.isValid();
            field.preventMark = preventMark;
            return !isValid;
        });
    },

<span id='Ext-form-Basic-method-isValid'>    /**
</span>     * Returns true if client-side validation on the form is successful. Any invalid fields will be
     * marked as invalid. If you only want to determine overall form validity without marking anything,
     * use {@link #hasInvalidField} instead.
     * @return {Boolean}
     */
    isValid: function() {
        var me = this,
            invalid;
        Ext.suspendLayouts();
        invalid = me.getFields().filterBy(function(field) {
            return !field.validate();
        });
        Ext.resumeLayouts(true);
        return invalid.length &lt; 1;
    },

<span id='Ext-form-Basic-method-checkValidity'>    /**
</span>     * Check whether the validity of the entire form has changed since it was last checked, and
     * if so fire the {@link #validitychange validitychange} event. This is automatically invoked
     * when an individual field&#39;s validity changes.
     */
    checkValidity: function() {
        var me = this,
            valid;
        
        if (me.destroyed) {
            return;
        }
            
        valid = !me.hasInvalidField();
        if (valid !== me.wasValid) {
            me.onValidityChange(valid);
            me.fireEvent(&#39;validitychange&#39;, me, valid);
            me.wasValid = valid;
        }
    },
    
<span id='Ext-form-Basic-method-checkValidityDelay'>    checkValidityDelay: function(){
</span>        var timer = this.taskDelay;
        if (timer) {
            this.checkValidityTask.delay(timer);
        } else {
            this.checkValidity();
        }
    },

<span id='Ext-form-Basic-method-checkError'>    checkError: function() {
</span>        // Currently this event is private, we don&#39;t really care
        // about the summation of the change, rather that something has
        // changed so we may need to recalculate. In the future if this
        // is made public, we would need to track the error on a per-field basis.
        this.fireEvent(&#39;errorchange&#39;, this);
    },

<span id='Ext-form-Basic-method-checkErrorDelay'>    checkErrorDelay: function() {
</span>        var timer = this.taskDelay;
        if (timer) {
            this.checkErrorTask.delay(timer);
        } else {
            this.checkError();
        }
    },

<span id='Ext-form-Basic-method-onValidityChange'>    /**
</span>     * @private
     * Handle changes in the form&#39;s validity. If there are any sub components with
     * `formBind=true` then they are enabled/disabled based on the new validity.
     * @param {Boolean} valid
     */
    onValidityChange: function(valid) {
        var boundItems = this.getBoundItems(),
            items, i, iLen, cmp;

        if (boundItems) {
            items = boundItems.items;
            iLen  = items.length;

            for (i = 0; i &lt; iLen; i++) {
                cmp = items[i];

                if (cmp.disabled === valid) {
                    cmp.setDisabled(!valid);
                }
            }
        }
    },

<span id='Ext-form-Basic-method-isDirty'>    /**
</span>     * Returns `true` if any fields in this form have changed from their original values.
     *
     * Note that if this BasicForm was configured with {@link Ext.form.Basic#trackResetOnLoad
     * trackResetOnLoad} then the Fields&#39; *original values* are updated when the values are
     * loaded by {@link Ext.form.Basic#setValues setValues} or {@link #loadRecord}. This means
     * that:
     * 
     * - {@link #trackResetOnLoad}: `false` -&gt; Will return `true` after calling this method.
     * - {@link #trackResetOnLoad}: `true` -&gt; Will return `false` after calling this method.
     *
     * @return {Boolean}
     */
    isDirty: function() {
        return !!this.getFields().findBy(function(f) {
            return f.isDirty();
        });
    },
    
<span id='Ext-form-Basic-method-checkDirtyDelay'>    checkDirtyDelay: function(){
</span>        var timer = this.taskDelay;
        if (timer) {
            this.checkDirtyTask.delay(timer);
        } else {
            this.checkDirty();
        }
    },

<span id='Ext-form-Basic-method-checkDirty'>    /**
</span>     * Check whether the dirty state of the entire form has changed since it was last checked, and
     * if so fire the {@link #dirtychange dirtychange} event. This is automatically invoked
     * when an individual field&#39;s `dirty` state changes.
     */
    checkDirty: function() {
        var me = this,
            dirty;
            
        if (me.destroyed) {
            return;
        }
            
        dirty = this.isDirty();
        if (dirty !== this.wasDirty) {
            this.fireEvent(&#39;dirtychange&#39;, this, dirty);
            this.wasDirty = dirty;
        }
    },

<span id='Ext-form-Basic-method-hasUpload'>    /**
</span>     * Returns `true` if the form contains a file upload field. This is used to determine the method for submitting the
     * form: File uploads are not performed using normal &#39;Ajax&#39; techniques, that is they are **not** performed using
     * XMLHttpRequests. Instead a hidden `&lt;form&gt;` element containing all the fields is created temporarily and submitted
     * with its [target][1] set to refer to a dynamically generated, hidden `&lt;iframe&gt;` which is inserted into the document
     * but removed after the return data has been gathered.
     *
     * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON
     * to send the return object, then the [Content-Type][2] header should be set to &quot;text/plain&quot; in order to tell the
     * browser to insert the text unchanged into a &#39;&amp;lt;pre&gt;&#39; element in the document body from which it can be retrieved.
     *
     * If the [Content-Type][2] header is sent as the default, &quot;text/html&quot;, then characters which are significant to an HTML
     * parser must be sent as HTML entities, so encode `&quot;&lt;&quot;` as `&quot;&amp;lt;&quot;`, `&quot;&amp;&quot;` as `&quot;&amp;amp;&quot;` etc.
     *
     * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
     * responseText property in order to conform to the requirements of event handlers and callbacks.
     *
     * Be aware that file upload packets are sent with the content type [multipart/form][3] and some server technologies
     * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from
     * the packet content.
     *
     * [1]: http://www.w3.org/TR/REC-html40/present/frames.html#adef-target
     * [2]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17
     * [3]: http://www.faqs.org/rfcs/rfc2388.html
     *
     * @return {Boolean}
     */
    hasUpload: function() {
        return !!this.getFields().findBy(function(f) {
            return f.isFileUpload();
        });
    },

<span id='Ext-form-Basic-method-doAction'>    /**
</span>     * Performs a predefined action (an implementation of {@link Ext.form.action.Action}) to perform application-
     * specific processing.
     *
     * @param {String/Ext.form.action.Action} action The name of the predefined action type, or instance of {@link
     * Ext.form.action.Action} to perform.
     *
     * @param {Object} [options] The options to pass to the {@link Ext.form.action.Action} that will get created,
     * if the action argument is a String.
     *
     * All of the config options listed below are supported by both the {@link Ext.form.action.Submit submit} and
     * {@link Ext.form.action.Load load} actions unless otherwise noted (custom actions could also accept other
     * config options):
     *
     * @param {String} options.url
     * The url for the action (defaults to the form&#39;s {@link #url}.)
     *
     * @param {String} options.method
     * The form method to use (defaults to the form&#39;s method, or POST if not defined)
     *
     * @param {String/Object} options.params
     * The params to pass (defaults to the form&#39;s baseParams, or none if not defined)
     *
     * Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode Ext.Object.toQueryString}.
     *
     * @param {Object} options.headers
     * Request headers to set for the action.
     *
     * @param {Function} options.success
     * The callback that will be invoked after a successful response (see top of {@link Ext.form.action.Submit submit}
     * and {@link Ext.form.action.Load load} for a description of what constitutes a successful response).
     * @param {Ext.form.Basic} options.success.form The form that requested the action.
     * @param {Ext.form.action.Action} options.success.action The Action object which performed the operation.
     * The action object contains these properties of interest:
     *
     *  - {@link Ext.form.action.Action#response response}
     *  - {@link Ext.form.action.Action#result result} - interrogate for custom post-processing
     *  - {@link Ext.form.action.Action#type type}
     *
     * @param {Function} options.failure
     * The callback that will be invoked after a failed transaction attempt.
     * @param {Ext.form.Basic} options.failure.form The form that requested the action.
     * @param {Ext.form.action.Action} options.failure.action The Action object which performed the operation.
     * The action object contains these properties of interest:
     *
     * - {@link Ext.form.action.Action#failureType failureType}
     * - {@link Ext.form.action.Action#response response}
     * - {@link Ext.form.action.Action#result result} - interrogate for custom post-processing
     * - {@link Ext.form.action.Action#type type}
     *
     * @param {Object} options.scope
     * The scope in which to call the callback functions (The this reference for the callback functions).
     *
     * @param {Boolean} options.clientValidation
     * Submit Action only. Determines whether a Form&#39;s fields are validated in a final call to {@link
     * Ext.form.Basic#isValid isValid} prior to submission. Set to false to prevent this. If undefined, pre-submission
     * field validation is performed.
     *
     * @return {Ext.form.Basic} this
     */
    doAction: function(action, options) {
        if (Ext.isString(action)) {
            action = Ext.ClassManager.instantiateByAlias(&#39;formaction.&#39; + action, Ext.apply({}, options, {form: this}));
        }
        if (this.fireEvent(&#39;beforeaction&#39;, this, action) !== false) {
            this.beforeAction(action);
            Ext.defer(action.run, 100, action);
        }
        return this;
    },

<span id='Ext-form-Basic-method-submit'>    /**
</span>     * Shortcut to {@link #doAction do} a {@link Ext.form.action.Submit submit action}. This will use the
     * {@link Ext.form.action.Submit AJAX submit action} by default. If the {@link #standardSubmit} config
     * is enabled it will use a standard form element to submit, or if the {@link #api} config is present
     * it will use the {@link Ext.form.action.DirectLoad Ext.direct.Direct submit action}.
     *
     * The following code:
     *
     *     myFormPanel.getForm().submit({
     *         clientValidation: true,
     *         url: &#39;updateConsignment.php&#39;,
     *         params: {
     *             newStatus: &#39;delivered&#39;
     *         },
     *         success: function(form, action) {
     *            Ext.Msg.alert(&#39;Success&#39;, action.result.msg);
     *         },
     *         failure: function(form, action) {
     *             switch (action.failureType) {
     *                 case Ext.form.action.Action.CLIENT_INVALID:
     *                     Ext.Msg.alert(&#39;Failure&#39;, &#39;Form fields may not be submitted with invalid values&#39;);
     *                     break;
     *                 case Ext.form.action.Action.CONNECT_FAILURE:
     *                     Ext.Msg.alert(&#39;Failure&#39;, &#39;Ajax communication failed&#39;);
     *                     break;
     *                 case Ext.form.action.Action.SERVER_INVALID:
     *                    Ext.Msg.alert(&#39;Failure&#39;, action.result.msg);
     *            }
     *         }
     *     });
     *
     * would process the following server response for a successful submission:
     *
     *     {
     *         &quot;success&quot;:true, // note this is Boolean, not string
     *         &quot;msg&quot;:&quot;Consignment updated&quot;
     *     }
     *
     * and the following server response for a failed submission:
     *
     *     {
     *         &quot;success&quot;:false, // note this is Boolean, not string
     *         &quot;msg&quot;:&quot;You do not have permission to perform this operation&quot;
     *     }
     *
     * @param {Object} options The options to pass to the action (see {@link #doAction} for details).
     * @return {Ext.form.Basic} this
     */
    submit: function(options) {
        options = options || {};
        var me = this,
            action;
            
        if (options.standardSubmit || me.standardSubmit) {
            action = &#39;standardsubmit&#39;;
        } else {
            action = me.api ? &#39;directsubmit&#39; : &#39;submit&#39;;
        }
            
        return me.doAction(action, options);
    },

<span id='Ext-form-Basic-method-load'>    /**
</span>     * Shortcut to {@link #doAction do} a {@link Ext.form.action.Load load action}.
     * @param {Object} options The options to pass to the action (see {@link #doAction} for details)
     * @return {Ext.form.Basic} this
     */
    load: function(options) {
        return this.doAction(this.api ? &#39;directload&#39; : &#39;load&#39;, options);
    },

<span id='Ext-form-Basic-method-updateRecord'>    /**
</span>     * Persists the values in this form into the passed {@link Ext.data.Model} object in a beginEdit/endEdit block.
     * If the record is not specified, it will attempt to update (if it exists) the record provided to loadRecord.
     * @param {Ext.data.Model} [record] The record to edit
     * @return {Ext.form.Basic} this
     */
    updateRecord: function(record) {
        record = record || this._record;
        if (!record) {
            //&lt;debug&gt;
            Ext.raise(&quot;A record is required.&quot;);
            //&lt;/debug&gt;
            return this;
        }
        
        var fields = record.self.fields,
            values = this.getFieldValues(),
            obj = {},
            i = 0,
            len = fields.length,
            name;

        for (; i &lt; len; ++i) {
            name  = fields[i].name;

            if (values.hasOwnProperty(name)) {
                obj[name] = values[name];
            }
        }

        record.beginEdit();
        record.set(obj);
        record.endEdit();

        return this;
    },

<span id='Ext-form-Basic-method-loadRecord'>    /**
</span>     * Loads an {@link Ext.data.Model} into this form by calling {@link #setValues} with the
     * {@link Ext.data.Model#getData record data}. The fields in the model are mapped to 
     * fields in the form by matching either the {@link Ext.form.field.Base#name} or {@link Ext.Component#itemId}.  
     * See also {@link #trackResetOnLoad}. 
     * @param {Ext.data.Model} record The record to load
     * @return {Ext.form.Basic} this
     */
    loadRecord: function(record) {
        this._record = record;
        return this.setValues(record.getData());
    },

<span id='Ext-form-Basic-method-getRecord'>    /**
</span>     * Returns the last Ext.data.Model instance that was loaded via {@link #loadRecord}
     * @return {Ext.data.Model} The record
     */
    getRecord: function() {
        return this._record;
    },

<span id='Ext-form-Basic-method-beforeAction'>    /**
</span>     * @private
     * Called before an action is performed via {@link #doAction}.
     * @param {Ext.form.action.Action} action The Action instance that was invoked
     */
    beforeAction: function(action) {
        var me = this,
            waitMsg = action.waitMsg,
            maskCls = Ext.baseCSSPrefix + &#39;mask-loading&#39;,
            fields  = me.getFields().items,
            f,
            fLen    = fields.length,
            field, waitMsgTarget;

        // Call HtmlEditor&#39;s syncValue before actions
        for (f = 0; f &lt; fLen; f++) {
            field = fields[f];

            if (field.isFormField &amp;&amp; field.syncValue) {
                field.syncValue();
            }
        }

        if (waitMsg) {
            waitMsgTarget = me.waitMsgTarget;
            if (waitMsgTarget === true) {
                me.owner.el.mask(waitMsg, maskCls);
            } else if (waitMsgTarget) {
                waitMsgTarget = me.waitMsgTarget = Ext.get(waitMsgTarget);
                waitMsgTarget.mask(waitMsg, maskCls);
            } else {
                me.floatingAncestor = me.owner.up(&#39;[floating]&#39;);

                // https://sencha.jira.com/browse/EXTJSIV-6397
                // When the &quot;wait&quot; MessageBox is hidden, the ZIndexManager activates the previous
                // topmost floating item which would be any Window housing this form.
                // That kicks off a delayed focus call on that Window.
                // So if any form post submit processing displayed a MessageBox, that gets
                // stomped on.
                // The solution is to not move focus at all during this process.
                if (me.floatingAncestor) {
                    me.savePreventFocusOnActivate = me.floatingAncestor.preventFocusOnActivate;
                    me.floatingAncestor.preventFocusOnActivate = true;
                }
                Ext.MessageBox.wait(waitMsg, action.waitTitle || me.waitTitle);
            }
        }
    },

<span id='Ext-form-Basic-method-afterAction'>    /**
</span>     * @private
     * Called after an action is performed via {@link #doAction}.
     * @param {Ext.form.action.Action} action The Action instance that was invoked
     * @param {Boolean} success True if the action completed successfully, false, otherwise.
     */
    afterAction: function(action, success) {
        var me = this;
        if (action.waitMsg) {
            var messageBox = Ext.MessageBox,
                waitMsgTarget = me.waitMsgTarget;
            if (waitMsgTarget === true) {
                me.owner.el.unmask();
            } else if (waitMsgTarget) {
                waitMsgTarget.unmask();
            } else {
                messageBox.hide();
            }
        }
        // Restore setting of any floating ancestor which was manipulated in beforeAction
        if (me.floatingAncestor) {
            me.floatingAncestor.preventFocusOnActivate = me.savePreventFocusOnActivate;
        }
        if (success) {
            if (action.reset) {
                me.reset();
            }
            Ext.callback(action.success, action.scope || action, [me, action]);
            me.fireEvent(&#39;actioncomplete&#39;, me, action);
        } else {
            Ext.callback(action.failure, action.scope || action, [me, action]);
            me.fireEvent(&#39;actionfailed&#39;, me, action);
        }
    },


<span id='Ext-form-Basic-method-findField'>    /**
</span>     * Find a specific {@link Ext.form.field.Field} in this form by id or name.
     * @param {String} id The value to search for (specify either a {@link Ext.Component#id id} or
     * {@link Ext.form.field.Field#getName name or hiddenName}).
     * @return {Ext.form.field.Field} The first matching field, or `null` if none was found.
     */
    findField: function (id) {
        return this.getFields().findBy(function (f) {
            return f.id === id || f.name === id || f.dataIndex === id;
        });
    },


<span id='Ext-form-Basic-method-markInvalid'>    /**
</span>     * This method allows you to mark one or more fields in a form as invalid along with 
     * one or more invalid messages per field.
     * 
     *     var formPanel = Ext.create(&#39;Ext.form.Panel&#39;, {
     *         title: &#39;Contact Info&#39;,
     *         width: 300,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: &#39;textfield&#39;,
     *             name: &#39;name&#39;,
     *             id: &#39;nameId&#39;,
     *             fieldLabel: &#39;Name&#39;
     *         }, {
     *             xtype: &#39;textfield&#39;,
     *             name: &#39;email&#39;,
     *             id: &#39;emailId&#39;,
     *             fieldLabel: &#39;Email Address&#39;
     *         }],
     *         bbar: [{
     *             text: &#39;Mark both fields invalid&#39;,
     *             handler: function() {
     *                 formPanel.getForm().markInvalid([{
     *                     field: &#39;name&#39;,
     *                     message: &#39;Name invalid message&#39;
     *                 }, {
     *                     field: &#39;email&#39;,
     *                     message: [&#39;First invalid message&#39;, &#39;Second message&#39;]
     *                 }]);
     *             }
     *         }]
     *     });
     * 
     * **Note**: this method does not cause the Field&#39;s 
     * {@link Ext.form.field.Field#validate} or {@link Ext.form.field.Base#isValid} 
     * methods to return `false` if the value does _pass_ validation.  So simply marking 
     * a Field as invalid will not prevent submission of forms submitted with the 
     * {@link Ext.form.action.Submit#clientValidation} option set.
     * 
     * For additional information on how the fields are marked invalid see field&#39;s 
     * {@link Ext.form.field.Base#markInvalid markInvalid} method.
     * 
     * @param {Object/Object[]} errors
     * The errors param may be in one of two forms: Object[] or Object
     * 
     * - **Array:** An array of Objects with the following keys:
     *     - _field_ ({@link String}): The {@link Ext.form.field.Base#name name} or 
     * {@link Ext.form.field.Base#id id} of the form field to receive the error message
     *     - _message_ ({@link String}/{@link String}[]): The error message or an array 
     * of messages
     * 
     * Example Array syntax:
     * 
     *     form.markInvalid([{
     *         field: &#39;email&#39;, // the field name
     *         message: &#39;Error message&#39;
     *     }]);
     * 
     * - **Object:** An Object hash with key/value pairs where the key is the field name 
     * or field ID and the value is the message or array of messages to display.
     * 
     * Example Object syntax:
     * 
     *     form.markInvalid({
     *         name: &#39;Err. message&#39;,
     *         emailId: [&#39;Error1&#39;, &#39;Error 2&#39;]
     *     });
     * 
     * @return {Ext.form.Basic} basicForm The Ext.form.Basic instance
     */
    markInvalid: function(errors) {
        var me = this,
            e, eLen, error, value,
            key;

        function mark(fieldId, msg) {
            var field = me.findField(fieldId);
            if (field) {
                field.markInvalid(msg);
            }
        }

        if (Ext.isArray(errors)) {
            eLen = errors.length;

            for (e = 0; e &lt; eLen; e++) {
                error = errors[e];
                mark(error.id || error.field, error.msg || error.message);
            }
        } else if (errors instanceof Ext.data.ErrorCollection) {
            eLen  = errors.items.length;
            for (e = 0; e &lt; eLen; e++) {
                error = errors.items[e];

                mark(error.field, error.message);
            }
        } else {
            for (key in errors) {
                if (errors.hasOwnProperty(key)) {
                    value = errors[key];
                    mark(key, value, errors);
                }
            }
        }
        return this;
    },

<span id='Ext-form-Basic-method-setValues'>    /**
</span>     * Set values for fields in this form in bulk.
     *
     * @param {Object/Object[]} values Either an array in the form:
     *
     *     [{id:&#39;clientName&#39;, value:&#39;Fred. Olsen Lines&#39;},
     *      {id:&#39;portOfLoading&#39;, value:&#39;FXT&#39;},
     *      {id:&#39;portOfDischarge&#39;, value:&#39;OSL&#39;} ]
     *
     * or an object hash of the form:
     *
     *     {
     *         clientName: &#39;Fred. Olsen Lines&#39;,
     *         portOfLoading: &#39;FXT&#39;,
     *         portOfDischarge: &#39;OSL&#39;
     *     }
     *
     * @return {Ext.form.Basic} this
     */
    setValues: function(values) {
        var me = this,
            v, vLen, val;

        function setVal(fieldId, val) {
            var field = me.findField(fieldId);
            if (field) {
                field.setValue(val);
                if (me.trackResetOnLoad) {
                    field.resetOriginalValue();
                }
            }
        }

        // Suspend here because setting the value on a field could trigger
        // a layout, for example if an error gets set, or it&#39;s a display field
        Ext.suspendLayouts();
        if (Ext.isArray(values)) {
            // array of objects
            vLen = values.length;

            for (v = 0; v &lt; vLen; v++) {
                val = values[v];

                setVal(val.id, val.value);
            }
        } else {
            // object hash
            Ext.iterate(values, setVal);
        }
        Ext.resumeLayouts(true);
        return this;
    },

<span id='Ext-form-Basic-method-getValues'>    /**
</span>     * Retrieves the fields in the form as a set of key/value pairs, using their
     * {@link Ext.form.field.Field#getSubmitData getSubmitData()} method to collect the values.
     * If multiple fields return values under the same name those values will be combined into an Array.
     * This is similar to {@link Ext.form.Basic#getFieldValues getFieldValues} except that this method
     * collects only String values for submission, while getFieldValues collects type-specific data
     * values (e.g. Date objects for date fields.)
     *
     * @param {Boolean} [asString=false] If true, will return the key/value collection as a single
     * URL-encoded param string.
     * @param {Boolean} [dirtyOnly=false] If true, only fields that are dirty will be included in the result.
     * @param {Boolean} [includeEmptyText=false] If true, the configured emptyText of empty fields will be used.
     * @param {Boolean} [useDataValues=false] If true, the {@link Ext.form.field.Field#getModelData getModelData}
     * method is used to retrieve values from fields, otherwise the {@link Ext.form.field.Field#getSubmitData getSubmitData}
     * method is used.
     * @return {String/Object}
     */
    getValues: function(asString, dirtyOnly, includeEmptyText, useDataValues, isSubmitting) {
        var values  = {},
            fields  = this.getFields().items,
            fLen    = fields.length,
            isArray = Ext.isArray,
            field, data, val, bucket, name, f;

        for (f = 0; f &lt; fLen; f++) {
            field = fields[f];
            if (!dirtyOnly || field.isDirty()) {
                data = field[useDataValues ? &#39;getModelData&#39; : &#39;getSubmitData&#39;](includeEmptyText, isSubmitting);

                if (Ext.isObject(data)) {
                    for (name in data) {
                        if (data.hasOwnProperty(name)) {
                            val = data[name];

                            if (includeEmptyText &amp;&amp; val === &#39;&#39;) {
                                val = field.emptyText || &#39;&#39;;
                            }

                            if (!field.isRadio) {
                                // skipping checkbox null values since they have no contextual value
                                if(field.isCheckbox &amp;&amp; val===null) {
                                    continue;
                                }
                                if (values.hasOwnProperty(name)) {
                                    bucket = values[name];

                                    if (!isArray(bucket)) {
                                        bucket = values[name] = [bucket];
                                    }

                                    if (isArray(val)) {
                                        values[name] = bucket.concat(val);
                                    } else {
                                        bucket.push(val);
                                    }
                                } else {
                                    values[name] = val;
                                }
                            } else {
                                values[name] = values[name] || val;
                            }
                        }
                    }
                }
            }
        }

        if (asString) {
            values = Ext.Object.toQueryString(values);
        }
        return values;
    },

<span id='Ext-form-Basic-method-getFieldValues'>    /**
</span>     * Retrieves the fields in the form as a set of key/value pairs, using their
     * {@link Ext.form.field.Field#getModelData getModelData()} method to collect the values.
     * If multiple fields return values under the same name those values will be combined into an Array.
     * This is similar to {@link #getValues} except that this method collects type-specific data values
     * (e.g. Date objects for date fields) while getValues returns only String values for submission.
     *
     * @param {Boolean} [dirtyOnly=false] If true, only fields that are dirty will be included in the result.
     * @return {Object}
     */
    getFieldValues: function(dirtyOnly) {
        return this.getValues(false, dirtyOnly, false, true);
    },

<span id='Ext-form-Basic-method-clearInvalid'>    /**
</span>     * Clears all invalid field messages in this form.
     * @return {Ext.form.Basic} this
     */
    clearInvalid: function() {
        Ext.suspendLayouts();

        var me     = this,
            fields = me.getFields().items,
            f,
            fLen   = fields.length;

        for (f = 0; f &lt; fLen; f++) {
            fields[f].clearInvalid();
        }

        Ext.resumeLayouts(true);
        return me;
    },

<span id='Ext-form-Basic-method-reset'>    /**
</span>     * Resets all fields in this form. By default, any record bound by {@link #loadRecord}
     * will be retained.
     * @param {Boolean} [resetRecord=false] True to unbind any record set
     * by {@link #loadRecord}
     * @return {Ext.form.Basic} this
     */
    reset: function(resetRecord) {
        Ext.suspendLayouts();

        var me     = this,
            fields = me.getFields().items,
            f,
            fLen   = fields.length;

        for (f = 0; f &lt; fLen; f++) {
            fields[f].reset();
        }

        Ext.resumeLayouts(true);
        
        if (resetRecord === true) {
            delete me._record;
        }
        return me;
    },

<span id='Ext-form-Basic-method-applyToFields'>    /**
</span>     * Calls {@link Ext#apply Ext.apply} for all fields in this form with the passed object.
     * @param {Object} obj The object to be applied
     * @return {Ext.form.Basic} this
     */
    applyToFields: function(obj) {
        var fields = this.getFields().items,
            f,
            fLen   = fields.length;

        for (f = 0; f &lt; fLen; f++) {
            Ext.apply(fields[f], obj);
        }

        return this;
    },

<span id='Ext-form-Basic-method-applyIfToFields'>    /**
</span>     * Calls {@link Ext#applyIf Ext.applyIf} for all field in this form with the passed object.
     * @param {Object} obj The object to be applied
     * @return {Ext.form.Basic} this
     */
    applyIfToFields: function(obj) {
        var fields = this.getFields().items,
            f,
            fLen   = fields.length;

        for (f = 0; f &lt; fLen; f++) {
            Ext.applyIf(fields[f], obj);
        }

        return this;
    }
});
</pre>
</body>
</html>
