<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-toolbar-Breadcrumb'>/**
</span> * A toolbar that displays hierarchical data from a {@link Ext.data.TreeStore TreeStore}
 * as a trail of breadcrumb buttons.  Each button represents a node in the store.  A click
 * on a button will &quot;select&quot; that node in the tree.  Non-leaf nodes will display their
 * child nodes on a dropdown menu of the corresponding button in the breadcrumb trail,
 * and a click on an item in the menu will trigger selection of the corresponding child
 * node.
 *
 * The selection can be set programmatically  using {@link #setSelection}, or retrieved
 * using {@link #getSelection}.
 */
Ext.define(&#39;Ext.toolbar.Breadcrumb&#39;, {
    extend: &#39;Ext.Container&#39;,
    xtype: &#39;breadcrumb&#39;,
    requires: [
        &#39;Ext.data.TreeStore&#39;,
        &#39;Ext.button.Split&#39;
    ],
    
    mixins: [
        &#39;Ext.util.FocusableContainer&#39;
    ],

<span id='Ext-toolbar-Breadcrumb-property-isBreadcrumb'>    isBreadcrumb: true,
</span><span id='Ext-toolbar-Breadcrumb-cfg-baseCls'>    baseCls: Ext.baseCSSPrefix + &#39;breadcrumb&#39;,
</span>
<span id='Ext-toolbar-Breadcrumb-cfg-layout'>    layout: {
</span>        type: &#39;hbox&#39;,
        align: &#39;middle&#39;
    },

    config: {
<span id='Ext-toolbar-Breadcrumb-cfg-buttonUI'>        /**
</span>         * @cfg {String} [buttonUI=&#39;plain-toolbar&#39;]
         * Button UI to use for breadcrumb items.  Use {@link #extjs-breadcrumb-ui} to
         * add special styling to the breadcrumb arrows
         */
        buttonUI: &#39;plain-toolbar&#39;,

<span id='Ext-toolbar-Breadcrumb-cfg-displayField'>        /**
</span>         * @cfg {String}
         * The name of the field in the data model to display in the navigation items of
         * this breadcrumb toolbar
         */
        displayField: &#39;text&#39;,

<span id='Ext-toolbar-Breadcrumb-cfg-overflowHandler'>        /**
</span>         * @cfg {String} [overflowHandler=null]
         * The overflowHandler for this Breadcrumb:
         *
         * - `null` - hidden overflow
         * - `&#39;scroller&#39;` to render left/right scroller buttons on either side of the breadcrumb
         * - `&#39;menu&#39;` to render the overflowing buttons as items of an overflow menu.
         */
        overflowHandler: null,

<span id='Ext-toolbar-Breadcrumb-cfg-showIcons'>        /**
</span>         * @cfg {Boolean} [showIcons=null]
         *
         * Controls whether or not icons of tree nodes are displayed in the breadcrumb
         * buttons.  There are 3 possible values for this config:
         *
         * 1. unspecified (`null`) - the default value. In this mode only icons that are
         * specified in the tree data using ({@link Ext.data.NodeInterface#icon icon}
         * or {@link Ext.data.NodeInterface#iconCls iconCls} will be displayed, but the
         * default &quot;folder&quot; and &quot;leaf&quot; icons will not be displayed.
         *
         * 2. `true` - Icons specified in the tree data will be displayed, and the default
         * &quot;folder&quot; and &quot;leaf&quot; icons will be displayed for nodes that do not specify
         * an `icon` or `iconCls`.
         *
         * 3. `false` - No icons will be displayed in the breadcrumb buttons, only text.
         */
        showIcons: null,

<span id='Ext-toolbar-Breadcrumb-cfg-showMenuIcons'>        /**
</span>         * @cfg {Boolean} [showMenuIcons=null]
         *
         * Controls whether or not icons of tree nodes are displayed in the breadcrumb
         * menu items. There are 3 possible values for this config:
         *
         * 1. unspecified (`null`) - the default value. In this mode only icons that are
         * specified in the tree data using ({@link Ext.data.NodeInterface#icon icon}
         * or {@link Ext.data.NodeInterface#iconCls iconCls} will be displayed, but the
         * default &quot;folder&quot; and &quot;leaf&quot; icons will not be displayed.
         *
         * 2. `true` - Icons specified in the tree data will be displayed, and the default
         * &quot;folder&quot; and &quot;leaf&quot; icons will be displayed for nodes that do not specify
         * an `icon` or `iconCls`.
         *
         * 3. `false` - No icons will be displayed on the breadcrumb menu items, only text.
         */
        showMenuIcons: null,

<span id='Ext-toolbar-Breadcrumb-cfg-store'>        /**
</span>         * @cfg {Ext.data.TreeStore} store
         * The TreeStore that this breadcrumb toolbar should use as its data source
         */
        store: null,

<span id='Ext-toolbar-Breadcrumb-cfg-useSplitButtons'>        /**
</span>         * @cfg {Boolean} [useSplitButtons=true]
         * `false` to use regular {@link Ext.button.Button Button}s instead of {@link
         * Ext.button.Split Split Buttons}.  When `true`, a click on the body of a button
         * will navigate to the specified node, and a click on the arrow will show a menu
         * containing the the child nodes.  When `false`, the only mode of navigation is
         * the menu, since a click anywhere on the button will show the menu.
         */
        useSplitButtons: true
    },

<span id='Ext-toolbar-Breadcrumb-property-renderConfig'>    renderConfig: {
</span><span id='Ext-toolbar-Breadcrumb-cfg-selection'>        /**
</span>         * @cfg {Ext.data.TreeModel/String} selection
         * The selected node, or `&quot;root&quot;` to select the root node
         * @accessor
         */
        selection: &#39;root&#39;
    },

<span id='Ext-toolbar-Breadcrumb-cfg-publishes'>    publishes: [&#39;selection&#39;],
</span><span id='Ext-toolbar-Breadcrumb-cfg-twoWayBindable'>    twoWayBindable: [&#39;selection&#39;],
</span>
<span id='Ext-toolbar-Breadcrumb-property-_breadcrumbCls'>    _breadcrumbCls: Ext.baseCSSPrefix + &#39;breadcrumb&#39;,
</span><span id='Ext-toolbar-Breadcrumb-property-_btnCls'>    _btnCls: Ext.baseCSSPrefix + &#39;breadcrumb-btn&#39;,
</span><span id='Ext-toolbar-Breadcrumb-property-_folderIconCls'>    _folderIconCls: Ext.baseCSSPrefix + &#39;breadcrumb-icon-folder&#39;,
</span><span id='Ext-toolbar-Breadcrumb-property-_leafIconCls'>    _leafIconCls: Ext.baseCSSPrefix + &#39;breadcrumb-icon-leaf&#39;,
</span>
<span id='Ext-toolbar-Breadcrumb-method-initComponent'>    initComponent: function() {
</span>        var me = this,
            layout = me.layout,
            overflowHandler = me.getOverflowHandler();

        if (typeof layout === &#39;string&#39;) {
            layout = {
                type: layout
            };
        }

        if (overflowHandler) {
            layout.overflowHandler = overflowHandler;
        }

        me.layout = layout;

        // set defaultButtonUI for possible menu overflow handler.
        me.defaultButtonUI = me.getButtonUI();

<span id='Ext-toolbar-Breadcrumb-property-buttons'>        /**
</span>         * Internal cache of buttons that are re-purposed as the items of this container
         * as navigation occurs.
         * @property {Ext.button.Split[]} buttons
         * @private
         */
        me._buttons = [];

        me.addCls([me._breadcrumbCls, me._breadcrumbCls + &#39;-&#39; + me.ui]);

        me.callParent();
    },

<span id='Ext-toolbar-Breadcrumb-method-doDestroy'>    doDestroy: function() {
</span>        Ext.destroy(this._buttons);
        this.setStore(null);
        
        this.callParent();
    },

<span id='Ext-toolbar-Breadcrumb-method-onRemove'>    onRemove: function(component, destroying) {
</span>        this.callParent([component, destroying]);
        delete component._breadcrumbNodeId;
    },

<span id='Ext-toolbar-Breadcrumb-method-afterComponentLayout'>    afterComponentLayout: function() {
</span>        var me = this,
            overflowHandler = me.layout.overflowHandler;

        me.callParent(arguments);

        if (overflowHandler &amp;&amp; me.tooNarrow &amp;&amp; overflowHandler.scrollToItem) {
            overflowHandler.scrollToItem(me.getSelection().get(&#39;depth&#39;));
        }
    },

<span id='Ext-toolbar-Breadcrumb-method-getSelection'>    /**
</span>     * @method getSelection
     * Returns the currently selected {@link Ext.data.TreeModel node}.
     * @return {Ext.data.TreeModel} node The selected node (or null if there is no
     * selection).
     */

<span id='Ext-toolbar-Breadcrumb-method-setSelection'>    /**
</span>     * @method setSelection
     * Selects the passed {@link Ext.data.TreeModel node} in the breadcrumb component.
     * @param {Ext.data.TreeModel} node The node in the breadcrumb {@link #store} to
     * select as the active node.
     * @return {Ext.toolbar.Breadcrumb} this The breadcrumb component
     */

    applySelection: function(node) {
        var store = this.getStore();
        if (store) {
            node = (node === &#39;root&#39;) ? this.getStore().getRoot() : node;
        } else {
            node = null;
        }
        return node;
    },

<span id='Ext-toolbar-Breadcrumb-method-updateSelection'>    updateSelection: function(node, prevNode) {
</span>        var me = this,
            buttons = me._buttons,
            items = [],
            itemCount = Ext.ComponentQuery.query(&#39;[isCrumb]&#39;, me.getRefItems()).length,
            needsSync = me._needsSync,
            displayField = me.getDisplayField(),
            showIcons, glyph, iconCls, icon, newItemCount, currentNode, text, button, id, depth, i;

        Ext.suspendLayouts();

        if (node) {
            currentNode = node;
            depth = node.get(&#39;depth&#39;);
            newItemCount = depth + 1;
            i = depth;

            while (currentNode) {
                id = currentNode.getId();

                button = buttons[i];

                if (!needsSync &amp;&amp; button &amp;&amp; button._breadcrumbNodeId === id) {
                    // reached a level in the hierarchy where we are already in sync.
                    break;
                }

                text = currentNode.get(displayField);

                if (button) {
                    // If we already have a button for this depth in the button cache reuse it
                    button.setText(text);
                } else {
                    // no button in the cache - make one and add it to the cache
                    button = buttons[i] = Ext.create({
                        isCrumb: true,
                        xtype: me.getUseSplitButtons() ? &#39;splitbutton&#39; : &#39;button&#39;,
                        ui: me.getButtonUI(),
                        cls: me._btnCls + &#39; &#39; + me._btnCls + &#39;-&#39; + me.ui,
                        text: text,
                        showEmptyMenu: true,
                        // begin with an empty menu - items are populated on beforeshow
                        menu: {
                            listeners: {
                                click: &#39;_onMenuClick&#39;,
                                beforeshow: &#39;_onMenuBeforeShow&#39;,
                                scope: this
                            }
                        },
                        handler: &#39;_onButtonClick&#39;,
                        scope: me
                    });
                }

                showIcons = this.getShowIcons();

                if (showIcons !== false) {
                    glyph = currentNode.get(&#39;glyph&#39;);
                    icon = currentNode.get(&#39;icon&#39;);
                    iconCls = currentNode.get(&#39;iconCls&#39;);

                    if (glyph) {
                        button.setGlyph(glyph);
                        button.setIcon(null);
                        button.setIconCls(iconCls); // may need css to get glyph
                    } else if (icon) {
                        button.setGlyph(null);
                        button.setIconCls(null);
                        button.setIcon(icon);
                    } else if (iconCls) {
                        button.setGlyph(null);
                        button.setIcon(null);
                        button.setIconCls(iconCls);
                    } else if (showIcons) {
                        // only show default icons if showIcons === true
                        button.setGlyph(null);
                        button.setIcon(null);
                        button.setIconCls(
                            (currentNode.isLeaf() ? me._leafIconCls : me._folderIconCls) + &#39;-&#39; + me.ui
                        );
                    } else {
                        // if showIcons is null do not show default icons
                        button.setGlyph(null);
                        button.setIcon(null);
                        button.setIconCls(null);
                    }
                }

                button.setArrowVisible(currentNode.hasChildNodes());
                button._breadcrumbNodeId = currentNode.getId();

                currentNode = currentNode.parentNode;
                i--;
            }

            if (newItemCount &gt; itemCount) {
                // new selection has more buttons than existing selection, add the new buttons
                items = buttons.slice(itemCount, depth + 1);
                me.add(items);
            } else {
                // new selection has fewer buttons, remove the extra ones from the items, but
                // do not destroy them, as they are returned to the cache and recycled.
                for (i = itemCount - 1; i &gt;= newItemCount; i--) {
                    me.remove(buttons[i], false);
                }
            }

        } else {
            // null selection
            for (i = 0; i &lt; buttons.length; i++) {
                me.remove(buttons[i], false);
            }
        }

        Ext.resumeLayouts(true);

<span id='Ext-toolbar-Breadcrumb-event-selectionchange'>        /**
</span>         * @event selectionchange
         * Fires when the selected node changes. At render time, this event will fire
         * indicating that the configured {@link #selection} has been selected.
         * @param {Ext.toolbar.Breadcrumb} this
         * @param {Ext.data.TreeModel} node The selected node.
         * @param {Ext.data.TreeModel} prevNode The previously selected node.
         */
        me.fireEvent(&#39;selectionchange&#39;, me, node, prevNode);
        
        if (me._shouldFireChangeEvent) {
<span id='Ext-toolbar-Breadcrumb-event-change'>            /**
</span>             * @event change
             * Fires when the user changes the selected record. In contrast to the {@link #selectionchange} event, this does
             * *not* fire at render time, only in response to user activity.
             * @param {Ext.toolbar.Breadcrumb} this
             * @param {Ext.data.TreeModel} node The selected node.
             * @param {Ext.data.TreeModel} prevNode The previously selected node.
             */
            me.fireEvent(&#39;change&#39;, me, node, prevNode);
        }
        me._shouldFireChangeEvent = true;

        me._needsSync = false;
    },

<span id='Ext-toolbar-Breadcrumb-method-applyUseSplitButtons'>    applyUseSplitButtons: function(useSplitButtons, oldUseSplitButtons) {
</span>        if (this.rendered &amp;&amp; useSplitButtons !== oldUseSplitButtons) {
            Ext.raise(&quot;Cannot reconfigure &#39;useSplitButtons&#39; config of Ext.toolbar.Breadcrumb after initial render&quot;);
        }
        return useSplitButtons;
    },

<span id='Ext-toolbar-Breadcrumb-method-applyStore'>    applyStore: function(store) {
</span>        if (store) {
            store = Ext.data.StoreManager.lookup(store);
        }
        return store;
    },

<span id='Ext-toolbar-Breadcrumb-method-updateStore'>    updateStore: function(store, oldStore) {
</span>        this._needsSync = true;

        if (store &amp;&amp; !this.isConfiguring) {
            this.setSelection(store.getRoot());
        }
    },

<span id='Ext-toolbar-Breadcrumb-method-updateOverflowHandler'>    //&lt;debug&gt;
</span>    updateOverflowHandler: function(overflowHandler) {
        if (overflowHandler === &#39;menu&#39;) {
            Ext.raise(&quot;Using Menu overflow with breadcrumb is not currently supported.&quot;);
        }
    },
<span id='Ext-toolbar-Breadcrumb-property-privates'>    //&lt;/debug&gt;
</span>
    privates: {
<span id='Ext-toolbar-Breadcrumb-method-_onButtonClick'>        /**
</span>         * Handles a click on a breadcrumb button
         * @private
         * @param {Ext.button.Split} button
         * @param {Ext.event.Event} e
         */
        _onButtonClick: function(button, e) {
            if (this.getUseSplitButtons()) {
                this.setSelection(this.getStore().getNodeById(button._breadcrumbNodeId));
            }
        },

<span id='Ext-toolbar-Breadcrumb-method-_onMenuClick'>        /**
</span>         * Handles a click on a button menu
         * @private
         * @param {Ext.menu.Menu} menu
         * @param {Ext.menu.Item} item
         * @param {Ext.event.Event} e
         */
        _onMenuClick: function(menu, item, e) {
            if (item) {
                // Find the TreeStore node corresponding to the menu item
                item = this.getStore().getNodeById(item._breadcrumbNodeId);

                this.setSelection(item);

                // Find the button that has just been shown and focus it.
                item = this._buttons[item.getDepth()];
                if (item) {
                    item.focus();
                }
            }
        },

<span id='Ext-toolbar-Breadcrumb-method-_onMenuBeforeShow'>        /**
</span>         * Handles the `beforeshow` event of a button menu
         * @private
         * @param {Ext.menu.Menu} menu
         */
        _onMenuBeforeShow: function(menu) {
            var me = this,
                node = me.getStore().getNodeById(menu.ownerCmp._breadcrumbNodeId),
                displayField = me.getDisplayField(),
                showMenuIcons = me.getShowMenuIcons(),
                childNodes, child, glyph, items, i, icon, iconCls, ln, item;

            if (node.hasChildNodes()) {
                childNodes = node.childNodes;
                items = [];

                for (i = 0, ln = childNodes.length; i &lt; ln; i++) {
                    child = childNodes[i];
                    item = {
                        text: child.get(displayField),
                        _breadcrumbNodeId: child.getId()
                    };

                    if (showMenuIcons !== false) {
                        glyph = child.get(&#39;glyph&#39;);
                        icon = child.get(&#39;icon&#39;);
                        iconCls = child.get(&#39;iconCls&#39;);

                        if (glyph) {
                            item.glyph = glyph;
                            item.iconCls = iconCls;  // may need css to get glyph
                        } else if (icon) {
                            item.icon = icon;
                        } else if (iconCls) {
                            item.iconCls = iconCls;
                        } else if (showMenuIcons) {
                            // only show default icons if showIcons === true
                            item.iconCls =
                                (child.isLeaf() ? me._leafIconCls : me._folderIconCls) +
                                &#39;-&#39; + me.ui;
                        }
                    }

                    items.push(item);
                }

                menu.removeAll();
                menu.add(items);
            } else {
                // prevent menu from being shown for nodes with no children
                return false;
            }
        }
    }
});
</pre>
</body>
</html>
