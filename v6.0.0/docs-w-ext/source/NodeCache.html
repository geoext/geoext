<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-view-NodeCache'>/**
</span> * @private
 * A cache of View elements keyed using the index of the associated record in the store.
 * 
 * This implements the methods of {Ext.dom.CompositeElement} which are used by {@link Ext.view.AbstractView}
 * to provide a map of record nodes and methods to manipulate the nodes.
 * @class Ext.view.NodeCache
 */
Ext.define(&#39;Ext.view.NodeCache&#39;, {
    requires: [
        &#39;Ext.dom.CompositeElementLite&#39;
    ],
    statics: {
<span id='Ext-view-NodeCache-static-property-range'>        range: document.createRange &amp;&amp; document.createRange()
</span>    },

<span id='Ext-view-NodeCache-method-constructor'>    constructor: function(view) {
</span>        this.view = view;
        this.clear();
        this.el = new Ext.dom.Fly();
    },
    
<span id='Ext-view-NodeCache-method-destroy'>    destroy: function() {
</span>        var me = this;
        
        if (!me.destroyed) {
            me.el.destroy();
            me.el = me.view = null;
            me.destroyed = true;
        }
        
        me.callParent();
    },

<span id='Ext-view-NodeCache-method-clear'>    /**
</span>    * Removes all elements from this NodeCache.
    * @param {Boolean} [removeDom] True to also remove the elements from the document.
    */
    clear: function(removeDom) {
        var me = this,
            elements = me.elements,
            range = me.statics().range,
            key;

        if (me.count &amp;&amp; removeDom) {
            // Some browsers throw error if Range used on detached DOM
            if (range &amp;&amp; Ext.getBody().contains(elements[0])) {
                range.setStartBefore(elements[me.startIndex]);
                range.setEndAfter(elements[me.endIndex]);
                range.deleteContents();
             } else {
                for (key in elements) {
                    Ext.removeNode(elements[key]);
                }
            }
        }
        me.elements = {};
        me.count = me.startIndex = 0;
        me.endIndex = -1;
    },

<span id='Ext-view-NodeCache-method-fill'>    /**
</span>    * Clears this NodeCache and adds the elements passed.
    * @param {HTMLElement[]} els An array of DOM elements from which to fill this NodeCache.
    * @return {Ext.view.NodeCache} this
    */
    fill: function(newElements, startIndex, fixedNodes) {
        fixedNodes = fixedNodes || 0;
        var me = this,
            elements = me.elements = {},
            i,
            len = newElements.length - fixedNodes;

        if (!startIndex) {
            startIndex = 0;
        }
        for (i = 0; i &lt; len; i++) {
            elements[startIndex + i] = newElements[i + fixedNodes];
        }
        me.startIndex = startIndex;
        me.endIndex = startIndex + len - 1;
        me.count = len;
        return this;
    },

<span id='Ext-view-NodeCache-method-insert'>    insert: function(insertPoint, nodes) {
</span>        var me = this,
            elements = me.elements,
            i,
            nodeCount = nodes.length;

        // If not inserting into empty cache, validate, and possibly shuffle.
        if (me.count) {
            //&lt;debug&gt;
            if (insertPoint &gt; me.endIndex + 1 || insertPoint + nodes.length &lt; me.startIndex) {
                Ext.raise(&#39;Discontiguous range would result from inserting &#39; + nodes.length + &#39; nodes at &#39; + insertPoint);
            }
            //&lt;/debug&gt;

            // Move following nodes forwards by &lt;nodeCount&gt; positions
            if (insertPoint &lt; me.count) {
                for (i = me.endIndex + nodeCount; i &gt;= insertPoint + nodeCount; i--) {
                    elements[i] = elements[i - nodeCount];
                    elements[i].setAttribute(&#39;data-recordIndex&#39;, i);
                }
            }
            me.endIndex = me.endIndex + nodeCount;
        }
        // Empty cache. set up counters
        else {
            me.startIndex = insertPoint;
            me.endIndex = insertPoint + nodeCount - 1;
        }

        // Insert new nodes into place
        for (i = 0; i &lt; nodeCount; i++, insertPoint++) {
            elements[insertPoint] = nodes[i];
            elements[insertPoint].setAttribute(&#39;data-recordIndex&#39;, insertPoint);
        }
        me.count += nodeCount;
    },

<span id='Ext-view-NodeCache-method-invoke'>    invoke: function(fn, args) {
</span>        var me = this,
            element,
            i;

        fn = Ext.dom.Element.prototype[fn];
        for (i = me.startIndex; i &lt;= me.endIndex; i++) {
            element = me.item(i);
            if (element) {
                fn.apply(element, args);
            }
        }
        return me;
    },

<span id='Ext-view-NodeCache-method-item'>    item: function(index, asDom) {
</span>        var el = this.elements[index],
            result = null;

        if (el) {
            result = asDom ? this.elements[index] : this.el.attach(this.elements[index]);
        }
        return result;
    },

<span id='Ext-view-NodeCache-method-first'>    first: function(asDom) {
</span>        return this.item(this.startIndex, asDom);
    },

<span id='Ext-view-NodeCache-method-last'>    last: function(asDom) {
</span>        return this.item(this.endIndex, asDom);
    },

<span id='Ext-view-NodeCache-method-moveBlock'>    /**
</span>     * @private
     * Used by buffered renderer when adding or removing record ranges which are above the
     * rendered block. The element block must be shuffled up or down the index range,
     * and the data-recordIndex connector attribute must be updated.
     *
     */
    moveBlock: function(increment) {
        var me = this,
            elements = me.elements,
            node,
            end,
            step,
            i;

        // No movement; return
        if (!increment) {
            return;
        }
        if (increment &lt; 0) {
            i = me.startIndex - 1;
            end = me.endIndex;
            step = 1;
        } else {
            i = me.endIndex + 1;
            end = me.startIndex;
            step = -1;
        }
        me.startIndex += increment;
        me.endIndex += increment;

        do {
            i += step;
            node = elements[i + increment] = elements[i];
            node.setAttribute(&#39;data-recordIndex&#39;, i + increment);

            // &quot;from&quot; element is outside of the new range, then delete it.
            if (i &lt; me.startIndex || i &gt; me.endIndex) {
                delete elements[i];
            }
        } while (i !== end);

        delete elements[i];
    },

<span id='Ext-view-NodeCache-method-getCount'>    getCount : function() {
</span>        return this.count;
    },

<span id='Ext-view-NodeCache-method-slice'>    slice: function(start, end) {
</span>        var elements = this.elements,
            result = [],
            i;

        if (!end) {
            end = this.endIndex;
        } else {
            end = Math.min(this.endIndex, end - 1);
        }
        for (i = start||this.startIndex; i &lt;= end; i++) {
            result.push(elements[i]);
        }
        return result;
    },

<span id='Ext-view-NodeCache-method-replaceElement'>    /**
</span>    * Replaces the specified element with the passed element.
    * @param {String/HTMLElement/Ext.dom.Element/Number} el The id of an element, the Element itself, the index of the
    * element in this composite to replace.
    * @param {String/Ext.dom.Element} replacement The id of an element or the Element itself.
    * @param {Boolean} [domReplace] True to remove and replace the element in the document too.
    */
    replaceElement: function(el, replacement, domReplace) {
        var elements = this.elements,
            index = (typeof el === &#39;number&#39;) ? el : this.indexOf(el);

        if (index &gt; -1) {
            replacement = Ext.getDom(replacement);
            if (domReplace) {
                el = elements[index];
                el.parentNode.insertBefore(replacement, el);
                Ext.removeNode(el);
                replacement.setAttribute(&#39;data-recordIndex&#39;, index);
            }
            this.elements[index] = replacement;
        }
        return this;
    },

<span id='Ext-view-NodeCache-method-indexOf'>    /**
</span>    * Find the index of the passed element within the composite collection.
    * @param {String/HTMLElement/Ext.dom.Element/Number} el The id of an element, or an Ext.dom.Element, or an HTMLElement
    * to find within the composite collection.
    * @return {Number} The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
    */
    indexOf: function(el) {
        var elements = this.elements,
            index;

        el = Ext.getDom(el);
        for (index = this.startIndex; index &lt;= this.endIndex; index++) {
            if (elements[index] === el) {
                return index;
            }
        }
        return -1;
    },

<span id='Ext-view-NodeCache-method-clip'>    clip: function(removeEnd, removeCount) {
</span>        var me = this,
            elements = me.elements,
            removed = [],
            start, end, el, i;

        // Clipping from start
        if (removeEnd === 1) {
            start = me.startIndex;
            me.startIndex += removeCount;
        }
        // Clipping from end
        else {
            me.endIndex -= removeCount;
            start = me.endIndex + 1;
        }
        for (i = start, end = start + removeCount - 1; i &lt;= end; i++) {
            el = elements[i];

            removed.push(el);
            Ext.removeNode(el);
            delete elements[i];
        }
        me.count -= removeCount;
        me.view.fireItemMutationEvent(&#39;itemremove&#39;, me.view.dataSource.getRange(start, end), start, removed, me.view);
    },

<span id='Ext-view-NodeCache-method-removeRange'>    removeRange: function(start, end, removeDom) {
</span>        var me = this,
            elements = me.elements,
            removed = [],
            el, i, removeCount, fromPos;

        if (end == null) {
            end = me.endIndex + 1;
        } else {
            end = Math.min(me.endIndex + 1, end + 1);
        }
        if (start == null) {
            start = me.startIndex;
        }
        removeCount = end - start;
        for (i = start, fromPos = end; i &lt;= me.endIndex; i++, fromPos++) {
            el = elements[i];

            // Within removal range and we are removing from DOM
            if (i &lt; end) {
                removed.push(el);
                if (removeDom) {
                    Ext.removeNode(el);
                }
            }
            // If the from position is occupied, shuffle that entry back into reference &quot;i&quot;
            if (fromPos &lt;= me.endIndex) {
                el = elements[i] = elements[fromPos];
                el.setAttribute(&#39;data-recordIndex&#39;, i);
            }
            // The from position has walked off the end, so delete reference &quot;i&quot;
            else {
                delete elements[i];
            }
        }
        me.count -= removeCount;
        me.endIndex -= removeCount;
        return removed;
    },

<span id='Ext-view-NodeCache-method-removeElement'>    /**
</span>    * Removes the specified element(s).
    * @param {String/HTMLElement/Ext.dom.Element/Number} el The id of an element, the Element itself, the index of the
    * element in this composite or an array of any of those.
    * @param {Boolean} [removeDom] True to also remove the element from the document
    */
    removeElement: function(keys, removeDom) {
        var me = this,
            inKeys,
            key,
            elements = me.elements,
            el,
            deleteCount,
            keyIndex = 0, index,
            fromIndex;

        // Sort the keys into ascending order so that we can iterate through the elements
        // collection, and delete items encountered in the keys array as we encounter them.
        if (Ext.isArray(keys)) {
            inKeys = keys;
            keys = [];
            deleteCount = inKeys.length;
            for (keyIndex = 0; keyIndex &lt; deleteCount; keyIndex++) {
                key = inKeys[keyIndex];
                if (typeof key !== &#39;number&#39;) {
                    key = me.indexOf(key);
                }
                // Could be asked to remove data above the start, or below the end of rendered zone in a buffer rendered view
                // So only collect keys which are within our range
                if (key &gt;= me.startIndex &amp;&amp; key &lt;= me.endIndex) {
                    keys[keys.length] = key;
                }
            }
            Ext.Array.sort(keys);
            deleteCount = keys.length;
        } else {
            // Could be asked to remove data above the start, or below the end of rendered zone in a buffer rendered view
            if (keys &lt; me.startIndex || keys &gt; me.endIndex) {
                return;
            }
            deleteCount = 1;
            keys = [keys];
        }

        // Iterate through elements starting at the element referenced by the first deletion key.
        // We also start off and index zero in the keys to delete array.
        for (index = fromIndex = keys[0], keyIndex = 0; index &lt;= me.endIndex; index++, fromIndex++) {

            // If the current index matches the next key in the delete keys array, this 
            // entry is being deleted, so increment the fromIndex to skip it.
            // Advance to next entry in keys array.
            if (keyIndex &lt; deleteCount &amp;&amp; index === keys[keyIndex]) {
                fromIndex++;
                keyIndex++;
                if (removeDom) {
                    Ext.removeNode(elements[index]);
                }
            }

            // Shuffle entries forward of the delete range back into contiguity.
            if (fromIndex &lt;= me.endIndex &amp;&amp; fromIndex &gt;= me.startIndex) {
                el = elements[index] = elements[fromIndex];
                el.setAttribute(&#39;data-recordIndex&#39;, index);
            } else {
                delete elements[index];
            }
        }
        me.endIndex -= deleteCount;
        me.count -= deleteCount;
    },

<span id='Ext-view-NodeCache-method-scroll'>    /**
</span>     * Appends/prepends records depending on direction flag
     * @param {Ext.data.Model[]} newRecords Items to append/prepend
     * @param {Number} direction `-1&#39; = scroll up, `0` = scroll down.
     * @param {Number} removeCount The number of records to remove from the end. if scrolling
     * down, rows are removed from the top and the new rows are added at the bottom.
     * @return {HTMLElement[]} The view item nodes added either at the top or the bottom of the view.
     */
    scroll: function(newRecords, direction, removeCount) {
        var me = this,
            view = me.view,
            vm = view.lookupViewModel(),
            store = view.store,
            elements = me.elements,
            recCount = newRecords.length,
            nodeContainer = view.getNodeContainer(),
            range = me.statics().range,
            i, el, removeEnd, children, result,
            removeStart, removedRecords, removedItems;

        if (!(newRecords.length || removeCount)) {
            return;
        }

        // Scrolling up (content moved down - new content needed at top, remove from bottom)
        if (direction === -1) {
            if (removeCount) {
                removedRecords = [];
                removedItems = [];
                removeStart = (me.endIndex - removeCount) + 1;
                if (range) {
                    range.setStartBefore(elements[removeStart]);
                    range.setEndAfter(elements[me.endIndex]);
                    range.deleteContents();
                    for (i = removeStart; i &lt;= me.endIndex; i++) {
                        el = elements[i];
                        delete elements[i];
                        removedRecords.push(store.getByInternalId(el.getAttribute(&#39;data-recordId&#39;)));
                        removedItems.push(el);
                    }
                } else {
                    for (i = removeStart; i &lt;= me.endIndex; i++) {
                        el = elements[i];
                        delete elements[i];
                        Ext.removeNode(el);
                        removedRecords.push(store.getByInternalId(el.getAttribute(&#39;data-recordId&#39;)));
                        removedItems.push(el);
                    }
                }
                view.fireItemMutationEvent(&#39;itemremove&#39;, removedRecords, removeStart, removedItems, view);
                me.endIndex -= removeCount;
            }

            // Only do rendering if there are rows to render.
            // This could have been a remove only operation due to a view resize event.
            if (newRecords.length) {

                // grab all nodes rendered, not just the data rows
                result = view.bufferRender(newRecords, me.startIndex -= recCount);
                children = result.children;
                for (i = 0; i &lt; recCount; i++) {
                    elements[me.startIndex + i] = children[i];
                }
                nodeContainer.insertBefore(result.fragment, nodeContainer.firstChild);

                // pass the new DOM to any interested parties
                view.fireItemMutationEvent(&#39;itemadd&#39;, newRecords, me.startIndex, children, view);
            }
        }

        // Scrolling down (content moved up - new content needed at bottom, remove from top)
        else {
            if (removeCount) {
                removedRecords = [];
                removedItems = [];
                removeEnd = me.startIndex + removeCount;
                if (range) {
                    range.setStartBefore(elements[me.startIndex]);
                    range.setEndAfter(elements[removeEnd - 1]);
                    range.deleteContents();
                    for (i = me.startIndex; i &lt; removeEnd; i++) {
                        el = elements[i];
                        delete elements[i];
                        removedRecords.push(store.getByInternalId(el.getAttribute(&#39;data-recordId&#39;)));
                        removedItems.push(el);
                    }
                } else {
                    for (i = me.startIndex; i &lt; removeEnd; i++) {
                        el = elements[i];
                        delete elements[i];
                        Ext.removeNode(el);
                        removedRecords.push(store.getByInternalId(el.getAttribute(&#39;data-recordId&#39;)));
                        removedItems.push(el);
                    }
                }
                view.fireItemMutationEvent(&#39;itemremove&#39;, removedRecords, me.startIndex, removedItems, view);
                me.startIndex = removeEnd;
            }

            // grab all nodes rendered, not just the data rows
            result = view.bufferRender(newRecords, me.endIndex + 1);
            children = result.children;

            for (i = 0; i &lt; recCount; i++) {
                elements[me.endIndex += 1] = children[i];
            }
            nodeContainer.appendChild(result.fragment);

            // pass the new DOM to any interested parties
            view.fireItemMutationEvent(&#39;itemadd&#39;, newRecords, me.endIndex + 1, children, view);
        }
        // Keep count consistent.
        me.count = me.endIndex - me.startIndex + 1;

        // The content height MUST be measurable by the caller (the buffered renderer), so data must be flushed to it immediately.
        if (vm) {
            vm.notify();
        }
 
        return children;
    },

<span id='Ext-view-NodeCache-method-sumHeights'>    sumHeights: function() {
</span>        var result = 0,
            elements = this.elements,
            i;

        for (i = this.startIndex; i &lt;= this.endIndex; i++) {
            result += elements[i].offsetHeight;
        }
        return result;
    }
}, function() {
    Ext.dom.CompositeElementLite.importElementMethods.call(this);
});
</pre>
</body>
</html>
