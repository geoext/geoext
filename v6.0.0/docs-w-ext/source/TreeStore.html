<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-TreeStore'>/**
</span> * The TreeStore is a store implementation that owns the {@link #cfg-root root node} of
 * a tree, and provides methods to load either local or remote data as child nodes of the root
 * and any descendant non-leaf node.
 *
 * The TreeStore must be used as the store of a {@link Ext.tree.Panel tree panel}.
 *
 * This class also relays many node events from the underlying node structure.
 *
 * # Using Models
 *
 * If no Model is specified, an implicit model will be created that extends {@link Ext.data.TreeModel}.
 * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
 * in the {@link Ext.data.NodeInterface} documentation.
 *
 * # Reading Nested Data
 *
 * For the tree to read nested data, the {@link Ext.data.reader.Reader} must be configured with a root property,
 * so the reader can find nested data for each node (if a root is not specified, it will default to
 * &#39;children&#39;). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., &#39;children&#39;.
 * If a root is specified in the config make sure that any nested nodes with children have the same name.
 * 
 * **Note:** Setting {@link #defaultRootProperty} accomplishes the same thing.
 * 
 * #rootProperty as a Function
 * You can pass a function as the data reader&#39;s rootProperty when the tree&#39;s dataset has 
 * mixed root properties. Child nodes can then be programmatically determined at read time.  
 * 
 * For example, the child nodes may be passed via the &#39;children&#39; property 
 * name, though you may have a top-level root property of &#39;items&#39;.  
 * 
 * See {@link Ext.data.reader.Reader#rootProperty rootProperty} for more information.
 *
 * #Filtering#
 * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
 * pass the filter, then it, and all its descendants are filtered *out* of the store.
 *
 * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
 * the `TreeStore` with &#39;{@link #cfg-filterer filterer: &#39;bottomup&#39;}`
 *
 * You may also programatically filter individual tree nodes by setting their `&#39;visible&#39;` field.
 *
 * Setting this to `false` filters the node out so that it will not appear in the UI. Setting it to `true`
 * filters the node in.
 *
 * Note that if performing several filter operations, it is best to {@link #method-suspendEvents}
 * on the store first, and when all nodes have been modified, {@link #method-resumeEvents} and fire the
 * {@link #event-refresh} event on the store.
 */
Ext.define(&#39;Ext.data.TreeStore&#39;, {
    extend: &#39;Ext.data.Store&#39;,
    alias: &#39;store.tree&#39;,
    requires: [
        &#39;Ext.util.Sorter&#39;,
        &#39;Ext.data.TreeModel&#39;,
        &#39;Ext.data.NodeInterface&#39;
    ],

<span id='Ext-data-TreeStore-property-isTreeStore'>    /**
</span>     * @property {Boolean} isTreeStore
     * `true` in this class to identify an object as an instantiated TreeStore, or subclass thereof.
     */
    isTreeStore: true,

    config: {
<span id='Ext-data-TreeStore-cfg-root'>        /**
</span>         * @cfg {Ext.data.TreeModel/Ext.data.NodeInterface/Object} root
         * The root node for this store. For example:
         *
         *     root: {
         *         expanded: true,
         *         text: &quot;My Root&quot;,
         *         children: [
         *             { text: &quot;Child 1&quot;, leaf: true },
         *             { text: &quot;Child 2&quot;, expanded: true, children: [
         *                 { text: &quot;GrandChild&quot;, leaf: true }
         *             ] }
         *         ]
         *     }
         *
         * Setting the `root` config option is the same as calling {@link #setRootNode}.
         *
         * It&#39;s important to note that setting expanded to true on the root node will cause
         * the tree store to attempt to load.  This will occur regardless the value of 
         * {@link Ext.data.ProxyStore#autoLoad autoLoad}. If you you do not want the store 
         * to load on instantiation, ensure expanded is false and load the store when you&#39;re ready.
         * 
         */
        root: null,

<span id='Ext-data-TreeStore-cfg-rootVisible'>        /**
</span>         * @cfg {Boolean} rootVisible `false` to not include the root node in this Stores collection.
         * @accessor
         */
        rootVisible: false,

<span id='Ext-data-TreeStore-cfg-defaultRootProperty'>        /**
</span>         * @cfg {String} [defaultRootProperty=&quot;children&quot;]
         */
        defaultRootProperty: &#39;children&#39;,

<span id='Ext-data-TreeStore-cfg-parentIdProperty'>        /**
</span>         * @cfg {String} [parentIdProperty]
         * This config allows node data to be returned from the server in linear format without having to structure it into `children`
         * arrays.
         *
         * This property specifies which property name in the raw node data yields the id of the parent node.
         *
         * For example the following data would be read into a geographic tree by configuring the TreeStore with `parentIdProperty: &#39;parentId&#39;`.
         * The node data contains an upward link to a parent node.
         *
         *     data: [{
         *         name: &#39;North America&#39;,
         *         id: &#39;NA&#39;
         *     }, {
         *         name: &#39;Unites States&#39;,
         *         id: &#39;USA&#39;,
         *         parentId: &#39;NA&#39;
         *     }, {
         *         name: &#39;Redwood City&#39;,
         *         leaf: true,
         *         parentId: &#39;USA&#39;
         *     }, {
         *         name: &#39;Frederick, MD&#39;,
         *         leaf: true,
         *         parentId: &#39;USA&#39;
         *     }]
         *
         */
        parentIdProperty: null,

<span id='Ext-data-TreeStore-cfg-clearOnLoad'>        /**
</span>         * @cfg {Boolean} [clearOnLoad=true]
         * Remove previously existing child nodes before loading.
         */
        clearOnLoad : true,

<span id='Ext-data-TreeStore-cfg-clearRemovedOnLoad'>        /**
</span>         * @cfg {Boolean} [clearRemovedOnLoad=true]
         * If `true`, when a node is reloaded, any records in the {@link #removed} record collection that were previously descendants of the node being reloaded will be cleared from the {@link #removed} collection.
         * Only applicable if {@link #clearOnLoad} is `true`.
         */
        clearRemovedOnLoad: true,

<span id='Ext-data-TreeStore-cfg-nodeParam'>        /**
</span>         * @cfg {String} [nodeParam=&quot;node&quot;]
         * The name of the parameter sent to the server which contains the identifier of the node.
         */
        nodeParam: &#39;node&#39;,

<span id='Ext-data-TreeStore-cfg-defaultRootId'>        /**
</span>         * @cfg {String} [defaultRootId=&quot;root&quot;]
         * The default root id.
         */
        defaultRootId: &#39;root&#39;,

<span id='Ext-data-TreeStore-cfg-defaultRootText'>        /**
</span>         * @cfg {String} [defaultRootText=&quot;Root&quot;]
         * The default root text (if not specified)
         */
        defaultRootText: &#39;Root&#39;,

<span id='Ext-data-TreeStore-cfg-folderSort'>        /**
</span>         * @cfg {Boolean} [folderSort=false]
         * Set to true to automatically prepend a leaf sorter.
         */
        folderSort: false,

<span id='Ext-data-TreeStore-cfg-pageSize'>        /**
</span>         * @cfg {Number} pageSize
         * @hide
         */
        pageSize: null // Not valid for TreeStore. Paging parameters must not be passed.
    },

<span id='Ext-data-TreeStore-cfg-filterer'>    /**
</span>     * @cfg {String} [filterer=topdown]
     * The order in which to prioritize how filters are applied to nodes.
     *
     * The default, `&#39;topdown&#39;` means that if a parent node does *not* pass the filter, then the branch
     * ends there, and no descendant nodes are filtered in, even if they would pass the filter.
     *
     * By specifying `&#39;bottomup&#39;`, if a leaf node passes the filter, then all its ancestor nodes are filtered
     * in to allow it to be visible.
     */
    filterer: &#39;topdown&#39;,

<span id='Ext-data-TreeStore-cfg-lazyFill'>    /**
</span>     * @cfg {Boolean} [lazyFill=false]
     * Set to true to prevent child nodes from being loaded until the the node is
     * expanded or loaded explicitly.
     */
    lazyFill: false,

<span id='Ext-data-TreeStore-property-fillCount'>    fillCount: 0,
</span><span id='Ext-data-TreeStore-property-bulkUpdate'>    bulkUpdate: 0,
</span><span id='Ext-data-TreeStore-property-nodesToUnregister'>    nodesToUnregister: 0,
</span>
<span id='Ext-data-TreeStore-cfg-fields'>    /**
</span>     * @cfg {Object[]/String[]} fields
     * @inheritdoc Ext.data.Model#cfg-fields
     * 
     * @localdoc **Note:** If you wish to create a Tree*Grid*, and configure your tree with a 
     * {@link Ext.panel.Table#cfg-columns columns} configuration, it is possible to 
     * define the set of fields you wish to use in the Store instead of configuring the 
     * store with a {@link #cfg-model}.
     *
     * By default, the Store uses an {@link Ext.data.TreeModel}. If you configure 
     * fields, it uses a subclass of {@link Ext.data.TreeModel} defined with the set of 
     * fields that you specify (in addition to the fields which it uses for storing 
     * internal state).
     */

    _silentOptions: {
        silent: true
    },

<span id='Ext-data-TreeStore-property-implicitModel'>    implicitModel: &#39;Ext.data.TreeModel&#39;,
</span>
<span id='Ext-data-TreeStore-method-constructor'>    constructor: function(config) {
</span>        var me = this;

        me.byIdMap = {};

        me.callParent([config]);

        // The following events are fired on this TreeStore by the bubbling from NodeInterface.fireEvent
<span id='Ext-data-TreeStore-event-nodeappend'>        /**
</span>         * @event nodeappend
         * @inheritdoc Ext.data.NodeInterface#append
         */
<span id='Ext-data-TreeStore-event-noderemove'>        /**
</span>         * @event noderemove
         * @inheritdoc Ext.data.NodeInterface#remove
         */
<span id='Ext-data-TreeStore-event-nodemove'>        /**
</span>         * @event nodemove
         * @inheritdoc Ext.data.NodeInterface#move
         */
<span id='Ext-data-TreeStore-event-nodeinsert'>        /**
</span>         * @event nodeinsert
         * @inheritdoc Ext.data.NodeInterface#insert
         */
<span id='Ext-data-TreeStore-event-nodebeforeappend'>        /**
</span>         * @event nodebeforeappend
         * @inheritdoc Ext.data.NodeInterface#beforeappend
         */
<span id='Ext-data-TreeStore-event-nodebeforeremove'>        /**
</span>         * @event nodebeforeremove
         * @inheritdoc Ext.data.NodeInterface#beforeremove
         */
<span id='Ext-data-TreeStore-event-nodebeforemove'>        /**
</span>         * @event nodebeforemove
         * @inheritdoc Ext.data.NodeInterface#beforemove
         */
<span id='Ext-data-TreeStore-event-nodebeforeinsert'>        /**
</span>         * @event nodebeforeinsert
         * @inheritdoc Ext.data.NodeInterface#beforeinsert
         */
<span id='Ext-data-TreeStore-event-nodeexpand'>        /**
</span>         * @event nodeexpand
         * @inheritdoc Ext.data.NodeInterface#expand
         */
<span id='Ext-data-TreeStore-event-nodecollapse'>        /**
</span>         * @event nodecollapse
         * @inheritdoc Ext.data.NodeInterface#collapse
         */
<span id='Ext-data-TreeStore-event-nodebeforeexpand'>        /**
</span>         * @event nodebeforeexpand
         * @inheritdoc Ext.data.NodeInterface#beforeexpand
         */
<span id='Ext-data-TreeStore-event-nodebeforecollapse'>        /**
</span>         * @event nodebeforecollapse
         * @inheritdoc Ext.data.NodeInterface#beforecollapse
         */
<span id='Ext-data-TreeStore-event-nodesort'>        /**
</span>         * @event nodesort
         * @inheritdoc Ext.data.NodeInterface#sort
         */

        //&lt;debug&gt;
        if (Ext.isDefined(me.nodeParameter)) {
            if (Ext.isDefined(Ext.global.console)) {
                Ext.global.console.warn(&#39;Ext.data.TreeStore: nodeParameter has been deprecated. Please use nodeParam instead.&#39;);
            }
            me.nodeParam = me.nodeParameter;
            delete me.nodeParameter;
        }
        //&lt;/debug&gt;
    },

<span id='Ext-data-TreeStore-event-rootchange'>    /**
</span>     * @event rootchange
     * Fires any time the tree&#39;s root node changes.
     * @param {Ext.data.TreeModel/Ext.data.NodeInterface} newRoot The new root
     * @param {Ext.data.TreeModel/Ext.data.NodeInterface} oldRoot The old root
     */

    applyFields: function(fields, oldFields) {
        var me = this;

        if (fields) {
            if (me.defaultRootProperty !== me.self.prototype.config.defaultRootProperty) {
                // Use concat. Must not mutate incoming configs
                fields = fields.concat({
                    name: me.defaultRootProperty,
                    type: &#39;auto&#39;,
                    defaultValue: null,
                    persist: false
                });
            }
        }
        me.callParent([fields, oldFields]);
    },

<span id='Ext-data-TreeStore-method-onSorterEndUpdate'>    // TreeStore has to do right things upon SorterCollection update
</span>    onSorterEndUpdate: function() {
        var me = this,
            sorterCollection = me.getSorters(),
            sorters = sorterCollection.getRange(),
            rootNode = me.getRoot(),
            folderSort = me.getFolderSort();

        me.fireEvent(&#39;beforesort&#39;, me, sorters);

        // Only load or sort if there are sorters
        if (rootNode &amp;&amp; (folderSort || sorters.length)) {
            if (me.getRemoteSort()) {
                if (sorters.length) {
                    me.load({
                        callback: function() {
                            me.fireEvent(&#39;sort&#39;, me, sorters);
                        }
                    });
                }
            } else {
                rootNode.sort(this.getSortFn(), true);

                // Don&#39;t fire the event if we have no sorters
                me.fireEvent(&#39;datachanged&#39;, me);
                me.fireEvent(&#39;refresh&#39;, me);
                me.fireEvent(&#39;sort&#39;, me, sorters);
            }
        }
        // Sort event must fire when sorters collection is updated to empty.
        else {
            me.fireEvent(&#39;sort&#39;, me, sorters);
        }
    },

<span id='Ext-data-TreeStore-method-updateFolderSort'>    updateFolderSort: function(folderSort) {
</span>        this.needsFolderSort = folderSort;
        this.onSorterEndUpdate();
    },

<span id='Ext-data-TreeStore-method-getSortFn'>    getSortFn: function() {
</span>        return this._sortFn || (this._sortFn = this.createSortFn());
    },

<span id='Ext-data-TreeStore-method-createSortFn'>    createSortFn: function() {
</span>        var me = this,
            sortersSortFn = this.sorters.getSortFn();

        return function(node1, node2) {
            var node1FolderOrder, node2FolderOrder,
                result = 0;

            if (me.needsFolderSort) {
                // Primary comparator puts Folders before leaves.
                node1FolderOrder = node1.data.leaf ? 1 : 0;
                node2FolderOrder = node2.data.leaf ? 1 : 0;
                result = node1FolderOrder - node2FolderOrder;
            }

            if (me.needsIndexSort &amp;&amp; result === 0) {
                result = node1.data.index - node2.data.index;
            }
            return result || sortersSortFn(node1, node2);
        };
    },

<span id='Ext-data-TreeStore-method-getTotalCount'>    getTotalCount: function() {
</span>        return this.getCount();
    },

<span id='Ext-data-TreeStore-method-afterEdit'>    afterEdit: function(node, modifiedFieldNames) {
</span>        var me = this,
            parentNode = node.parentNode,
            rootVisible = me.getRootVisible(),
            isHiddenRoot = !parentNode &amp;&amp; !rootVisible,
            prevVisibleNodeIndex,
            isVisible = node.get(&#39;visible&#39;),
            toAdd,
            removeStart;

        // If the node visibility flag is not matched by the Store state, correct it.
        // The hidden root node is a special case. That never appears in the flat store
        // so skip processing for that.
        if (!isHiddenRoot &amp;&amp; isVisible !== me.contains(node)) {

            // If we are restoring the node to visibility, then insert
            // at the correct point if this TreeStore considers the node visible
            // (visible flag set, and all ancestors expanded and visible)
            if (isVisible) {
                if (!parentNode || me.isVisible(node)) {
                    toAdd = [node];

                    // Collect visible descendants. Same operation as expanding
                    if (node.isExpanded()) {
                        me.handleNodeExpand(node, node.childNodes, toAdd);
                    }

                    prevVisibleNodeIndex = node.previousSibling ?
                        me.indexOfPreviousVisibleNode(node.previousSibling) :
                        (parentNode ? me.indexOf(parentNode) : -1);
                    me.insert(prevVisibleNodeIndex + 1, toAdd);
                }
            }
            // If we are hiding the node, remove it and all its descendants.
            else {
                removeStart = me.indexOf(node);
                me.removeAt(removeStart, me.indexOfNextVisibleNode(node) - removeStart);
            }
        }
        // Modification of other fields must lead to node filtering if we are
        // local filtering. Update the flat store though onFilterEndUpdate.
        // Data modification takes place during initial setup of root node
        // so ignore that.
        else if (me.getRoot() &amp;&amp; me.needsLocalFilter()) {
            me.onFilterEndUpdate(me.getFilters());
        }
        me.callParent([node, modifiedFieldNames]);
    },

<span id='Ext-data-TreeStore-method-afterReject'>    afterReject : function(record) {
</span>        var me = this;
        // Must pass the 5th param (modifiedFieldNames) as null, otherwise the
        // event firing machinery appends the listeners &quot;options&quot; object to the arg list
        // which may get used as the modified fields array by a handler.
        // This array is used for selective grid cell updating by Grid View.
        // Null will be treated as though all cells need updating.
        if (me.contains(record)) {
            me.onUpdate(record, Ext.data.Model.REJECT, null);
            me.fireEvent(&#39;update&#39;, me, record, Ext.data.Model.REJECT, null);
        }
    },

<span id='Ext-data-TreeStore-method-afterCommit'>    afterCommit : function(record, modifiedFieldNames) {
</span>        var me = this;
        if (!modifiedFieldNames) {
            modifiedFieldNames = null;
        }
        if (me.contains(record)) {
            me.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
            me.fireEvent(&#39;update&#39;, me, record, Ext.data.Model.COMMIT, modifiedFieldNames);
        }
    },

<span id='Ext-data-TreeStore-method-updateRootVisible'>    updateRootVisible: function(rootVisible) {
</span>        var rootNode = this.getRoot(),
            data;

        if (rootNode) {
            data = this.getData();
            if (rootVisible) {
                data.insert(0, rootNode);
            } else {
                data.remove(rootNode);
            }
        }
    },

<span id='Ext-data-TreeStore-method-updateTrackRemoved'>    updateTrackRemoved: function(trackRemoved) {
</span>        this.callParent(arguments);
        this.removedNodes = this.removed;
        this.removed = null;
    },

<span id='Ext-data-TreeStore-method-onDestroyRecords'>    onDestroyRecords: function(records, operation, success) {
</span>        if (success) {
            this.removedNodes.length = 0;
        }
    },

<span id='Ext-data-TreeStore-method-updateProxy'>    updateProxy: function(proxy) {
</span>        var reader;
        // The proxy sets a parameter to carry the entity ID based upon the Operation&#39;s id
        // That parameter name defaults to &quot;id&quot;.
        // TreeStore however uses a nodeParam configuration to specify the entity id
        if (proxy) {
            if (proxy.setIdParam) {
                proxy.setIdParam(this.getNodeParam());
            }

            // Readers in a TreeStore&#39;s proxy have to use a special rootProperty which defaults to &quot;children&quot;
            reader = proxy.getReader();
            if (Ext.isEmpty(reader.getRootProperty())) {
                reader.setRootProperty(this.getDefaultRootProperty());
            }
        }
    },

<span id='Ext-data-TreeStore-method-setProxy'>    setProxy: function(proxy) {
</span>        this.changingProxy = true;
        this.callParent([proxy]);
        this.changingProxy = false;
    },

<span id='Ext-data-TreeStore-method-updateModel'>    updateModel: function(model) {
</span>        if (model) {
            var isNode = model.prototype.isNode;

            // Ensure that the model has the required interface to function as a tree node.
            Ext.data.NodeInterface.decorate(model);

            // If we just had to decorate a raw Model to upgrade it to be a NodeInterface
            // then we need to build new extractor functions on the reader.
            if (!isNode &amp;&amp; !this.changingProxy) {
                this.getProxy().getReader().buildExtractors(true);
            }
        }
    },

<span id='Ext-data-TreeStore-method-onCollectionFilter'>    onCollectionFilter: Ext.emptyFn,
</span><span id='Ext-data-TreeStore-method-onFilterEndUpdate'>    // We add listeners to the FilterCollection and do the filtering in a hierarchical
</span>    // way. We are not interested in notifications as an observer on the data collection.

    onFilterEndUpdate: function(filters) {
        var me = this,
            length = filters.length,
            root = me.getRoot(),
            childNodes, childNode,
            filteredNodes, i;

        if (!me.getRemoteFilter()) {
            if (length) {
                me.doFilter(root);
            } else {
                root.cascade({
                    after: function(node) {
                        // Set visible field silently: do not fire update events to views.
                        // Views will receive refresh event from onNodeFilter.
                        node.set(&#39;visible&#39;, true, me._silentOptions);
                    }
                });
            }
            if (length) {
                filteredNodes = [];
                childNodes = root.childNodes;
                for (i = 0, length = childNodes.length; i &lt; length; i++) {
                    childNode = childNodes[i];
                    if (childNode.get(&#39;visible&#39;)) {
                        filteredNodes.push(childNode);
                    }
                }
            } else {
                filteredNodes = root.childNodes;
            }
            me.onNodeFilter(root, filteredNodes);
            root.fireEvent(&#39;filterchange&#39;, root, filteredNodes);

            // Inhibit AbstractStore&#39;s implementation from firing the refresh event.
            // We fire it in the onNodeFilter.
            me.suppressNextFilter = true;
            me.callParent([filters]);
            me.suppressNextFilter = false;
        } else {
            me.callParent([filters]);
        }
    },

<span id='Ext-data-TreeStore-method-onNodeFilter'>    /**
</span>     * @private
     *
     * Called from filter/clearFilter. Refreshes the view based upon
     * the new filter setting.
     */
    onNodeFilter: function(root, childNodes) {
        var me = this,
            data = me.getData(),
            toAdd = [];

        // Honour rootVisible.
        if (me.getRootVisible() &amp;&amp; root.get(&#39;visible&#39;)) {
            toAdd.push(root);
        }

        me.handleNodeExpand(root, childNodes, toAdd);

        // Do not relay the splicing&#39;s add&amp;remove events.
        // We inform interested parties about filtering through a refresh event.
        me.suspendEvents();
        data.splice(0, data.getCount(), toAdd);
        me.resumeEvents();

        if (!me.suppressNextFilter) {
            me.fireEvent(&#39;datachanged&#39;, me);
            me.fireEvent(&#39;refresh&#39;, me);
        }
    },

<span id='Ext-data-TreeStore-method-onBeforeNodeExpand'>    /**
</span>     * Called from a node&#39;s expand method to ensure that child nodes are available.
     *
     * This ensures that the child nodes are available before calling the passed callback.
     * @private
     * @param {Ext.data.NodeInterface} node The node being expanded.
     * @param {Function} callback The function to run after the expand finishes
     * @param {Object} scope The scope in which to run the callback function
     * @param {Array} args The extra args to pass to the callback after the new child nodes
     */
    onBeforeNodeExpand: function(node, callback, scope, args) {
        var me = this,
            storeReader,
            nodeProxy,
            nodeReader,
            reader,
            children,
            callbackArgs;

        // childNodes are loaded: go ahead with expand
        // This will also expand phantom nodes with childNodes.
        if (node.isLoaded()) {
            callbackArgs = [node.childNodes];
            if (args) {
                callbackArgs.push.apply(callbackArgs, args);
            }
            Ext.callback(callback, scope || node, callbackArgs);
        }
        // The node is loading
        else if (node.isLoading()) {
            me.on(&#39;load&#39;, function() {
                callbackArgs = [node.childNodes];
                if (args) {
                    callbackArgs.push.apply(callbackArgs, args);
                }
                Ext.callback(callback, scope || node, callbackArgs);
            }, me, {
                single: true,
                priority: 1001
            });
        }
        // There are unloaded child nodes in the raw data because of the lazy configuration, load them then call back.
        else {

            // With heterogeneous nodes, different levels may require differently configured readers to extract children.
            // For example a &quot;Disk&quot; node type may configure it&#39;s proxy reader with root: &#39;folders&#39;, while a &quot;Folder&quot; node type
            // might configure its proxy reader with root: &#39;files&#39;. Or the root property could be a configured-in accessor.
            storeReader = me.getProxy().getReader();
            nodeProxy = node.getProxy();
            nodeReader = nodeProxy ? nodeProxy.getReader() : null;

            // If the node&#39;s reader was configured with a special root (property name which defines the children array) use that.
            reader = nodeReader &amp;&amp; nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;

            // 1. If the raw data read in for the node contains a root (children array), then read it.
            // 2. If a phantom w/o any children, it should still be processed if expanded so check for
            //    that here as well. See EXTJS-13509.
            children = reader.getRoot(node.raw || node.data);

            // Load locally if there are local children, or it&#39;s a phantom (client side only) node.
            // Ensure that programmatically added new root nodes which could be phantom are able to kick off remote requests.
            if (children || (node.phantom &amp;&amp; !node.isRoot())) {
                // Extract records from the raw data. Allow the node being expanded to dictate its child type
                if (children) {
                    me.fillNode(node, reader.extractData(children, {
                        model: node.childType,
                        recordCreator : me.recordCreator
                    }));
                }

                callbackArgs = [node.childNodes];

                if (args) {
                    callbackArgs.push.apply(callbackArgs, args);
                }

                Ext.callback(callback, scope || node, callbackArgs);
            }
            // Node needs loading
            else {
                me.read({
                    node: node,
                    // We use onChildNodesAvailable here because we want trigger to
                    // the loading event after we&#39;ve loaded children
                    onChildNodesAvailable: function() {
                        // Clear the callback, since if we&#39;re introducing a custom one,
                        // it may be re-used on reload
                        delete me.lastOptions.onChildNodesAvailable;
                        callbackArgs = [node.childNodes];
                        if (args) {
                            callbackArgs.push.apply(callbackArgs, args);
                        }
                        Ext.callback(callback, scope || node, callbackArgs);
                    }
                });
                // Requests for node expansion must be immediate
                me.flushLoad();
            }
        }
    },

<span id='Ext-data-TreeStore-method-onNodeExpand'>    // Called from a node&#39;s onChildNodesAvailable method to
</span>    // insert the newly available child nodes below the parent.
    onNodeExpand: function(parent, records) {
        var me = this,
            insertIndex = me.indexOf(parent) + 1,
            toAdd = [];

        me.handleNodeExpand(parent, records, toAdd);

        // If a hidden root is being expanded for the first time, it&#39;s not an insert operation
        if (!me.refreshCounter &amp;&amp; parent.isRoot() &amp;&amp; !parent.get(&#39;visible&#39;)) {
            me.loadRecords(toAdd);
        }
        // The add event from this insertion is handled by TreeView.onAdd.
        // That implementation calls parent and then ensures the previous sibling&#39;s joining lines are correct.
        else {
            me.insert(insertIndex, toAdd);
        }
    },

<span id='Ext-data-TreeStore-method-handleNodeExpand'>    // Collects child nodes to remove into the passed toRemove array.
</span>    // When available, all descendant nodes are pushed into that array using recursion.
    handleNodeExpand: function(parent, records, toAdd) {
        var me = this,
            ln = records ? records.length : 0,
            i, record;

        // If parent is not visible, nothing to do (unless parent is the root)
        if (parent !== this.getRoot() &amp;&amp; !me.isVisible(parent)) {
            return;
        }

        if (ln) {
            // The view items corresponding to these are rendered.
            // Loop through and expand any of the non-leaf nodes which are expanded
            for (i = 0; i &lt; ln; i++) {
                record = records[i];

                // If the TreePanel has not set its visible flag to false, add to new node array
                if (record.get(&#39;visible&#39;)) {
                    // Add to array being collected by recursion when child nodes are loaded.
                    // Must be done here in loop so that child nodes are inserted into the stream in place
                    // in recursive calls.
                    toAdd.push(record);

                    if (record.isExpanded()) {
                        if (record.isLoaded()) {
                            // Take a shortcut - appends to toAdd array
                            me.handleNodeExpand(record, record.childNodes, toAdd);
                        }
                        else {
                            // Might be asynchronous if child nodes are not immediately available
                            record.set(&#39;expanded&#39;, false);
                            record.expand();
                        }
                    }
                }
            }
        }
    },

<span id='Ext-data-TreeStore-method-onNodeCollapse'>    /**
</span>     * @private
     * Called from a node&#39;s collapse method
     */
    onNodeCollapse: function(parent, records, callback, scope) {
        var me = this,
            collapseIndex = me.indexOf(parent) + 1,
            lastNodeIndexPlus;

        // Only remove what is visible and therefore in the collection side of this store
        if (me.needsLocalFilter()) {
            records = Ext.Array.filter(records, me.filterVisible);
        }

        // Only attempt to remove the records if they are there.
        // Collapsing an ancestor node *immediately removes from the view, ALL its descendant nodes at all levels*.
        // But if the collapse was recursive, all descendant root nodes will still fire their
        // events. But we must ignore those events here - we have nothing to do.
        if (records.length &amp;&amp; me.isVisible(parent)) {

            // Calculate the index *one beyond* the last node we are going to remove.
            lastNodeIndexPlus = me.indexOfNextVisibleNode(parent);

            // Remove the whole collapsed node set.
            me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
        }
        Ext.callback(callback, scope);
    },

<span id='Ext-data-TreeStore-method-indexOfNextVisibleNode'>    /**
</span>     * @private
     * Gets the index of next visible node at either the same sibling level or a higher level.
     *
     * This is to facilitate bulk removal of visible descendant nodes. eg in the following case
     * TreeStore.indexOfNextVisibleNode(bletch) must return indexOf(belch) - the next sibling.
     *
     * But TreeStore.indexOfNextVisibleNode(blivit) and TreeStore.indexOfNextVisibleNode(screeble)
     * and TreeStore.indexOfNextVisibleNode(poot) must also return return indexOf(belch)
     *
     *      foo
     *      ├ bar
     *      ├ bletch
     *      │ ├ zarg
     *      │ └ blivit
     *      │   ├ ik
     *      │   └ screeble
     *      │     ├ raz
     *      │     └ poot
     *      ├ belch
     *      apresfoo
     *
     * This is so that removal of nodes at full depth can be optimized into one removeAt(start, length) call.
     */
    indexOfNextVisibleNode: function(node) {
        var result;

        while (node.parentNode) {
            // Find the next visible sibling (filtering may have knocked out intervening nodes)
            for (result = node.nextSibling; result &amp;&amp; !result.get(&#39;visible&#39;); result = result.nextSibling) {
                // This block is intentionally left blank
            }

            // If found, we&#39;re done.
            if (result) {
                return this.indexOf(result);
            }

            // If there is no next sibling, we try to find the parent node&#39;s next visible sibling.
            node = node.parentNode;
        }

        // No subsequent visible siblings
        return this.getCount();
    },

<span id='Ext-data-TreeStore-method-indexOfPreviousVisibleNode'>    /**
</span>     * @private
     * Gets the index of previous visible node at either the same sibling level or a higher level *inclusive*
     * of passed node.
     *
     * This is to facilitate insertion of nodes in a filtered tree. eg in the following case
     * TreeStore.indexOfPreviousVisibleNode(bletch) must return indexOf(bar) - the previous sibling.
     *
     * But TreeStore.indexOfPreviousVisibleNode(belch) must return indexOf(raz) because
     * poot is filtered out of visibility.
     *
     *      foo
     *      ├ bar
     *      ├ bletch
     *      │ ├ zarg
     *      │ └ blivit
     *      │   ├ ik
     *      │   │ ├screeble
     *      │   │ └ raz
     *      │   └ poot&lt;filtered out&gt;
     *      ├ belch
     *      apresfoo
     *
     */
    indexOfPreviousVisibleNode: function(node) {
        var result;

        // Find the previous visible sibling (filtering may have knocked out intervening nodes)
        for (result = node; result &amp;&amp; !result.get(&#39;visible&#39;); result = result.previousSibling) {
            // This block is intentionally left blank
        }

        // If found, and there are child nodes, do the same operation on the last child
        if (result) {
            if (result.isExpanded() &amp;&amp; result.lastChild) {
                return this.indexOfPreviousVisibleNode(result.lastChild);
            }
        }
        // If there is no previous visible sibling, we use the parent node.
        // We only even ATTEMPT to insert into the flat store children of visible nodes.
        else {
            result = node.parentNode;
        }

        return this.indexOf(result);
    },

<span id='Ext-data-TreeStore-method-filterNew'>    /**
</span>     * @private
     * Filter function for new records.
     */
    filterNew: function(item) {
        // Root nodes are always generated on the client side, and therefore phantom.
        // But they should never be included in the new records list.
        return !item.get(&#39;root&#39;) &amp;&amp; this.callParent([item]);
    },

<span id='Ext-data-TreeStore-method-filterRejects'>    /**
</span>     * @private
     * Filter function for rejected records.
     */
    filterRejects: function(item) {
        // Root nodes are always generated on the client side, and therefore phantom.
        // But they should never be included in the rejects list.
        return !item.get(&#39;root&#39;) &amp;&amp; this.callParent([item]);
    },

<span id='Ext-data-TreeStore-method-getNewRecords'>    getNewRecords: function() {
</span>        return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterNew, this);
    },

<span id='Ext-data-TreeStore-method-getRejectRecords'>    getRejectRecords: function() {
</span>        return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterRejects, this);
    },

<span id='Ext-data-TreeStore-method-getUpdatedRecords'>    getUpdatedRecords: function() {
</span>        return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterUpdated);
    },

<span id='Ext-data-TreeStore-method-beforeNodeRemove'>    // Called from a node&#39;s removeChild &amp; removeAll methods *before* the node(s) is/are unhooked from siblings and parent.
</span>    // We calculate the range of visible nodes affected by the removal.
    // For example in the tree below, if the &quot;bletch&quot; node was being removed, we would have to remove
    // bletch, zarg, blivit, ik, screeble, razz and poot.
    //
    //      foo
    //      ├ bar
    //      ├ bletch
    //      │ ├ zarg
    //      │ └ blivit
    //      │   ├ ik
    //      │   └ screeble
    //      │     ├ raz
    //      │     └ poot
    //      ├ belch
    //      apresfoo
    //
    // If there are expanded nodes, descendants will be in this store and need removing too.
    // These values are used in onNodeRemove below, after the node has been unhooked from its siblings and parent.
    // The [start, length] range parameter list for the flat store removeAt call is calculated and returned
    // before the calling NodeInterface method removes child nodes.
    beforeNodeRemove: function(parentNode, childNodes, isMove, removeRange) {
        if (!Ext.isArray(childNodes)) {
            childNodes = [ childNodes ];
        }
        var me = this,
            len = childNodes.length,
            // Must use class-specific removedNodes property.
            // Regular Stores add to the &quot;removed&quot; property on CollectionRemove.
            // TreeStores are having records removed all the time; node collapse removes.
            // TreeStores add to the &quot;removedNodes&quot; property onNodeRemove
            removed = me.removedNodes,
            i,
            startNode;

        // Skip to the first visible node.
        for (i = 0; !startNode &amp;&amp; i &lt; len; i++) {
            if (childNodes[i].get(&#39;visible&#39;)) {
                startNode = childNodes[i];
            }
        }

        // Calculate the range of contiguous *VISIBLE* nodes that the childNodes array represents.
        // This is used by the calling code AFTER it has detached the tree structure.
        if (startNode) {
            removeRange[0] = me.indexOf(childNodes[0]);
            removeRange[1] = me.indexOfNextVisibleNode(childNodes[childNodes.length - 1]) - removeRange[0];
        } else {
            removeRange[0] = -1;
            removeRange[1] = 0;
        }

        // The code above calculated the range of nodes that are below expanded parents and not filtered out.
        // That will be used to removed the block from the flat store, thereby updating any dependent UIs.
        // 
        // We now have to walk the descendant tree for nodes which were not in the Store due to not being visible.
        // This means either below a collapsed parent, or filtered out (visible property false)
        //
        // For example, in the tree below, imagine &quot;bletch&quot; is being removed, &quot;zarg&quot; is filtered out of visibility
        // and the &quot;blivit&quot; node is collasped.
        //
        //  foo
        //  ├ bar
        //  ├ bletch
        //  │ ├ zarg   &lt;- this is filtered out and therefore not visible
        //  │ └ blivit &lt;- this is collapsed. ik, screeble, raz and poot are NOT in the Collection
        //  │   ├ ik
        //  │   └ screeble
        //  │     ├ raz
        //  │     └ poot
        //  ├ belch
        //  apresfoo
        //
        // the above code would only collect &quot;bletch&quot; and &quot;blivit&quot;.
        // We now have to collect bletch, zarg, blivit, uk, screeble, raz and poot.
        for (i = 0; i &lt; len; i++) {
            childNodes[i].cascade(function(node) {
                // We have to unregister all descendant nodes.
                me.unregisterNode(node, true);

                // We also have to ensure that all descendant nodes that were NOT removed above (ones that were not in
                // the store collection due to invisibility are added to the remove tracking array...
                // IF we are tracking, and is the remove is not for moving elsewhere in the tree.
                if (removed &amp;&amp; !isMove) {
                    // Don&#39;t push interally moving, or phantom (client side only), or erasing (informing server through its own proxy) records onto removed
                    // or which have been through a drop operation which will already have registered as to remove.
                    if (!node.phantom &amp;&amp; !node.erasing &amp;&amp; !me.loading) {
                        // Store the index the record was removed from so that rejectChanges can re-insert at the correct place.
                        // The record&#39;s index property won&#39;t do, as that is the index in the overall dataset when Store is buffered.
                        node.removedFrom = me.indexOf(node);
                        removed.push(node);

                        // Removal of a non-phantom record which is NOT erasing (informing the server through its own proxy)
                        // requires that the store be synced at some point.
                        me.needsSync = true;
                    }
                }
            });
        }
    },

<span id='Ext-data-TreeStore-method-afterDrop'>    // The drop operation of a Model calls afterDrop on attached stores which removes that model from
</span>    // the store&#39;s collection, and the store reacts to that.
    // The drop operation on a tree NodeInterface object must not affect the Store. It must calllParent
    // to ensure associations are dropped too, but presence in a TreeStore is handled between the
    // NodeInterface object and the TreeStore persona of the store, NOT its Store persona.
    afterDrop: Ext.emptyFn,

<span id='Ext-data-TreeStore-method-onNodeRemove'>    // Called from a node&#39;s removeChild &amp; removeAll methods *after* the node is unhooked from siblings and parent.
</span>    // Remove the visible descendant nodes that we calculated in beforeRemoveNode above.
    onNodeRemove: function(parentNode, childNodes, isMove, removeRange) {
        var me = this;

        // Prevent the me.removeAt call which removes *VISIBLE* nodes when this store has a UI attached
        // from syncing. We sync at the end.
        me.suspendAutoSync();

        // Remove all visible descendants from store.
        // Only visible nodes are present in the store.
        // Superclass&#39;s onCollectionRemove will handle unjoining.
        // That will not add to removed list. TreeStores keep a different list and we add to it below.
        // Set removeIsMove flag correctly for onCollectionRemove to do the right thing.
        if (removeRange[0] !== -1) {
            me.removeIsMove = isMove;
            me.removeAt.apply(me, removeRange);
            me.removeIsMove = false;
        }

        me.resumeAutoSync();
    },

<span id='Ext-data-TreeStore-method-onNodeAppend'>    /**
</span>     * @private
     *
     * Called from a node&#39;s appendChild method.
     */
    onNodeAppend: function(parent, node, index) {
        this.onNodeInsert(parent, node, index);
    },

<span id='Ext-data-TreeStore-method-onNodeInsert'>    /**
</span>     * @private
     *
     * Called from a node&#39;s insertBefore method.
     */
    onNodeInsert: function(parent, node, index) {
        var me = this,
            data = node.raw || node.data,
            // Must use class-specific removedNodes property.
            // Regular Stores add to the &quot;removed&quot; property on CollectionRemove.
            // TreeStores are having records removed all the time; node collapse removes.
            // TreeStores add to the &quot;removedNodes&quot; property onNodeRemove
            removed = me.removedNodes,
            storeReader,
            nodeProxy,
            nodeReader,
            reader,
            dataRoot,
            storeInsertionPoint;

        if (parent &amp;&amp; me.needsLocalFilter()) {
            me.doFilter(parent);
        }

        me.beginUpdate();

        // Only react to a node append if it is to a node which is expanded.
        if (me.isVisible(node)) {

            // Calculate the insertion point into the flat store.
            // If the new node is the first, then it goes after the parent node.
            if (index === 0 || !node.previousSibling) {
                storeInsertionPoint = me.indexOf(parent);
            }
            // Otherwise it has to go after the previous visible node which has
            // to be calculated. See indexOfPreviousVisibleNode for explanation.
            else {
                storeInsertionPoint = me.indexOfPreviousVisibleNode(node.previousSibling);
            }

            // The reaction to collection add joins the node to this Store
            me.insert(storeInsertionPoint + 1, node);
            if (!node.isLeaf() &amp;&amp; node.isExpanded()) {
                if (node.isLoaded()) {
                    // Take a shortcut
                    me.onNodeExpand(node, node.childNodes);
                } else if (!me.fillCount) {
                    // If the node has been marked as expanded, it means the children
                    // should be provided as part of the raw data. If we&#39;re filling the nodes,
                    // the children may not have been loaded yet, so only do this if we&#39;re
                    // not in the middle of populating the nodes.
                    node.set(&#39;expanded&#39;, false);
                    node.expand();
                }
            }
        }

        // In case the node was removed and added to the removed nodes list.
        Ext.Array.remove(removed, node);

        // New nodes mean we need a sync if those nodes are phantom or dirty (have client-side only information)
        me.needsSync = me.needsSync || node.phantom || node.dirty;

        if (!node.isLeaf() &amp;&amp; !node.isLoaded() &amp;&amp; !me.lazyFill) {
            // With heterogeneous nodes, different levels may require differently configured readers to extract children.
            // For example a &quot;Disk&quot; node type may configure it&#39;s proxy reader with root: &#39;folders&#39;, while a &quot;Folder&quot; node type
            // might configure its proxy reader with root: &#39;files&#39;. Or the root property could be a configured-in accessor.
            storeReader = me.getProxy().getReader();
            nodeProxy = node.getProxy();
            nodeReader = nodeProxy ? nodeProxy.getReader() : null;

            // If the node&#39;s reader was configured with a special root (property name which defines the children array) use that.
            reader = nodeReader &amp;&amp; nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;

            dataRoot = reader.getRoot(data);
            if (dataRoot) {
                me.fillNode(node, reader.extractData(dataRoot, {
                    model: node.childType,
                    recordCreator : me.recordCreator
                }));
            }
        }
        me.endUpdate();
    },

<span id='Ext-data-TreeStore-method-registerNode'>    /**
</span>     * Registers a node so that it can be looked up by ID.
     * @private
     * @param {Ext.data.NodeInterface} node The node to register
     * @param {Boolean} [includeChildren] True to unregister any child nodes
     */
    registerNode: function(node, includeChildren) {
        var me = this,
            was = me.byIdMap[node.id],
            children, length, i;

        // Key the node hash by the node&#39;s IDs
        me.byIdMap[node.id] = node;

        // If the node requires to be informed upon register, and is not already
        // registered, keep it informed.
        if (node.onRegisterTreeNode &amp;&amp; node !== was) {
            node.onRegisterTreeNode(me)
        }

        // Keep a count of nodes which require to be informed upon unregister.
        // If we are destroyed, or change root nodes, a cascade will be
        // necessary if this is non-zero.
        if (node.onUnregisterTreeNode) {
            me.nodesToUnregister++;
        }

        if (includeChildren === true) {
            children = node.childNodes;
            length = children.length;
            for (i = 0; i &lt; length; i++) {
                me.registerNode(children[i], true);
            }
        }
    },

<span id='Ext-data-TreeStore-method-unregisterNode'>    /**
</span>     * Unregisters a node.
     * @private
     * @param {Ext.data.NodeInterface} node The node to unregister
     * @param {Boolean} [includeChildren] True to unregister any child nodes
     */
    unregisterNode: function(node, includeChildren) {
        var me = this,
            was = me.byIdMap[node.id],
            children, length, i;

        delete me.byIdMap[node.id];
        if (includeChildren === true) {
            children = node.childNodes;
            length = children.length;
            for (i = 0; i &lt; length; i++) {
                me.unregisterNode(children[i], true);
            }
        }

        // If the node requires to be informed upon unregster, and it was
        // registered, keep it informed.
        if (node.onUnregisterTreeNode &amp;&amp; node === was) {
            node.onUnregisterTreeNode(me);
            me.nodesToUnregister--;
        }
    },

<span id='Ext-data-TreeStore-method-onNodeSort'>    onNodeSort: function(node, childNodes) {
</span>        var me = this;

        // The onNodeCollapse and onNodeExpand should not sync.
        // Should be one coalesced sync if autoSync.
        me.suspendAutoSync();

        // Collapse, then expand the node to refresh the displayed node set if the node
        // is expanded, or it&#39;s the root, but the root is not visible (so cannot be expanded by the UI)
        if ((me.indexOf(node) !== -1 &amp;&amp; node.isExpanded()) || (node === me.getRoot() &amp;&amp; !me.getRootVisible())) {
            Ext.suspendLayouts();
            me.onNodeCollapse(node, childNodes);
            me.onNodeExpand(node, childNodes);
            Ext.resumeLayouts(true);
        }

        // Lift suspension. This will execute a sync if the suspension count has gone to zero
        // and this store is configured to autoSync
        me.resumeAutoSync(me.autoSync);
    },

<span id='Ext-data-TreeStore-method-applyRoot'>    applyRoot: function(newRoot) {
</span>        var me = this,
            Model = me.getModel(),
            idProperty = Model.prototype.idProperty,
            defaultRootId = me.getDefaultRootId();

        // Convert to a node. Even if they are passing a normal Model, the Model will not yet
        // have been decorated with the constructor which initializes properties, so we always
        // have to construct a new node if the passed root is not a Node.
        if (newRoot &amp;&amp; !newRoot.isNode) {
            // create a default rootNode and create internal data struct.
            newRoot = Ext.apply({
                text: me.getDefaultRootText(),
                root: true,
                isFirst: true,
                isLast: true,
                depth: 0,
                index: 0,
                parentId: null,
                allowDrag: false
            }, newRoot);
            // Ensure the root has the default root id if it has no id.
            if (defaultRootId &amp;&amp; newRoot[idProperty] === undefined) {
                newRoot[idProperty] = defaultRootId;
            }

            // Specify that the data object is raw, and converters will need to be called
            newRoot = new Model(newRoot);
        }

        return newRoot;
    },

<span id='Ext-data-TreeStore-method-updateRoot'>    updateRoot: function(newRoot, oldRoot) {
</span>        var me = this,
            oldOwner,
            initial = !oldRoot,
            toRemove,
            removeRange = [];

        // Ensure that the removedNodes array is correct, and that the base class&#39;s removed array is null
        me.getTrackRemoved();

        // We do not want an add event to fire. This is a refresh operation.
        // A refresh will be fired after the new root is set.
        me.suspendEvent(&#39;add&#39;, &#39;remove&#39;);

        // Ensure that the old root is unjoined, visible children are removed from Collection,
        // and descendants added to removed list if tracking removed.
        if (oldRoot &amp;&amp; oldRoot.isModel) {
            // root will be in flat store only if rootVisible is false
            if (me.getRootVisible()) {
                toRemove = [oldRoot];
            } else {
                toRemove = oldRoot.childNodes;
            }
            me.beforeNodeRemove(null, toRemove, false, removeRange);
            oldRoot.set(&#39;root&#39;, false);
            me.onNodeRemove(null, toRemove, false, removeRange);
            oldRoot.fireEvent(&#39;remove&#39;, null, oldRoot, false);
            oldRoot.fireEvent(&#39;rootchange&#39;, null);
            oldRoot.clearListeners();
            oldRoot.store = oldRoot.treeStore = null;

            // If rootVisible is false, the root will not have been unregistered by
            // the beforeNodeRemove call which calls a recursive unregister on all
            // *visible* nodes being removed from the flat store.
            me.unregisterNode(oldRoot);
        }

        me.getData().clear();

        // Nulling the root node is essentially clearing the store.
        // TreeStore.removeAll updates the root node to null.
        if (newRoot) {

            // Fire beforeappend, to allow veto of new root setting
            if (newRoot.fireEventArgs(&#39;beforeappend&#39;, [null, newRoot]) === false) {
                newRoot = null;
            }
            else {

                // The passed node was a childNode somewhere else; remove it from there.
                oldOwner = newRoot.parentNode;
                if (oldOwner) {
                    // The removeChild operation can be vetoed by beforeremove event handler,
                    // and returns false if so.
                    // Important: That last boolean test is informing the remove whether or not it&#39;s
                    // just a move operation within the same TreeStore
                    if (!oldOwner.removeChild(newRoot, false, false, oldOwner.getTreeStore() === me)) {
                        return;
                    }
                }

                // If the passed root was previously the rootNode of another TreeStore, it must be removed from that store
                else if ((oldOwner = newRoot.getTreeStore()) &amp;&amp; oldOwner !== me &amp;&amp; newRoot === oldOwner.getRoot()) {
                    oldOwner.setRoot(null);
                }

                // The root node is the only node bound to the TreeStore by a reference.
                // All descendant nodes acquire a reference to their TreeStore by interrogating the parentNode axis.
                // The rootNode never joins this store.
                newRoot.store = newRoot.treeStore = me;

                newRoot.set(&#39;root&#39;, true);
                // root node should never be phantom or dirty, so commit it
                newRoot.updateInfo(true, {
                    isFirst: true,
                    isLast: true,
                    depth: 0,
                    index: 0,
                    parentId: null
                });

                // We register the subtree before we proceed so relayed events (like
                // nodeappend) will be able to use getNodeById.
                me.registerNode(newRoot, true);

                // The new root fires the append and rootchange events
                newRoot.fireEvent(&#39;append&#39;, null, newRoot, false);
                newRoot.fireEvent(&#39;rootchange&#39;, newRoot);

                // Ensure the root node is filtered, registered and joined.
                me.onNodeAppend(null, newRoot, 0);

                // Because of the application of an ID, this client-created root will not be phantom.
                // Ensure it is correctly flagged as a phantom.
                // AFTER being registered and joined, otherwise onNodeInsert will set the needsSync flag.
                newRoot.phantom = true;
            }
        }

        me.fireEvent(&#39;rootchange&#39;, newRoot, oldRoot);

        // If root configure to start expanded, or we are autoLoad, we want the root&#39;s nodes in the Store.
        if (newRoot &amp;&amp; (me.getAutoLoad() || newRoot.isExpanded())) {

            // If it was configured with inline children, it will be loaded, so skip ahead to the onNodeExpand callback.
            if (newRoot.isLoaded()) {
                me.onNodeExpand(newRoot, newRoot.childNodes);
                me.fireEvent(&#39;datachanged&#39;, me);
                me.fireEvent(&#39;refresh&#39;, me);
            }
            // Root is not loaded; go through the expand mechanism to force a load
            else {
                newRoot.data.expanded = false;
                newRoot.expand(false);

                // If it&#39;s already loaded, but the store is not synchronous, then it was loaded
                // from a local children array, so we need to refresh the data.
                // A store based load goes through onProxyLoad which will fire a refresh.
                if (newRoot.isLoaded &amp;&amp; !me.getProxy().isSynchronous) {
                    me.fireEvent(&#39;datachanged&#39;, me);
                    me.fireEvent(&#39;refresh&#39;, me);
                }
            }
        } else if (!initial) {
            me.fireEvent(&#39;datachanged&#39;, me);
            me.fireEvent(&#39;refresh&#39;, me);
        }

        // Inform views that the entire structure has changed.
        me.resumeEvent(&#39;add&#39;, &#39;remove&#39;);
    },

<span id='Ext-data-TreeStore-method-doDestroy'>    doDestroy: function () {
</span>        var me = this,
            root = me.getRoot();

        // If we contain some nodes which require to be informed upon unregister
        // then we must cascade the whole tree and inform any that require it.
        // The cascade method calls the passed function on the topmost node.
        if (root &amp;&amp; me.nodesToUnregister) {
            root.cascade(function(node) {
                if (node.onUnregisterTreeNode) {
                    node.onUnregisterTreeNode(me);
                }
            });
        }

        me.callParent();
    },

<span id='Ext-data-TreeStore-method-getById'>    /**
</span>     * @method getById
     * @inheritdoc Ext.data.LocalStore
     * @localdoc **NOTE:** TreeStore&#39;s getById method will only search nodes that 
     * are expanded (all ancestor nodes are {@link Ext.data.NodeInterface#expanded 
     * expanded}: true -- {@link Ext.data.NodeInterface#isExpanded isExpanded})
     * 
     * See also {@link #getNodeById}
     */

<span id='Ext-data-TreeStore-method-each'>    /**
</span>     * Calls the specified function for each {@link Ext.data.NodeInterface node} in the store.
     *
     * When store is filtered, only loops over the filtered records unless the `bypassFilters` parameter is `true`.
     *
     * @param {Function} fn The function to call. The {@link Ext.data.Model Record} is passed as the first parameter.
     * Returning `false` aborts and exits the iteration.
     * @param {Object} [scope] The scope (`this` reference) in which the function is executed.
     * Defaults to the current {@link Ext.data.NodeInterface node} in the iteration.
     * @param {Object} [includeOptions] An object which contains options which modify how the store is traversed.
     * @param {Boolean} [includeOptions.filtered] Pass `true` to include filtered out nodes in the iteration.
     * @param {Boolean} [includeOptions.collapsed] Pass `true` to include nodes which are descendants of collapsed nodes.
     *
     * Note that the `filtered` option can also be passed as a separate parameter for
     * compatibility with previous versions.
     *
     */
    each: function(fn, scope, bypassFilters) {
        var includeCollapsed,
            i = 0;

        if (bypassFilters &amp;&amp; typeof bypassFilters === &#39;object&#39;) {
            includeCollapsed = bypassFilters.collapsed;
            bypassFilters = bypassFilters.filtered;
        }

        if (includeCollapsed) {
            this.getRoot().cascade(function(node) {
                if (bypassFilters === true || node.get(&#39;visible&#39;)) {
                    return fn.call(scope || node, node, i++);
                }
            });
        } else {
            return this.callParent([fn, scope, bypassFilters]);
        }
    },

<span id='Ext-data-TreeStore-method-collect'>    /**
</span>     * Collects unique values for a particular dataIndex from this store.
     *
     * @param {String} dataIndex The property to collect
     * @param {Object} [options] An object which contains options which modify how the store is traversed.
     * @param {Boolean} [options.allowNull] Pass true to allow null, undefined or empty string values.
     * @param {Boolean} [options.filtered] Pass `true` to collect from all records, even ones which are filtered.
     * @param {Boolean} [options.collapsed] Pass `true` to include nodes which are descendants of collapsed nodes.
     *
     * Note that the `filtered` option can also be passed as a separate parameter for
     * compatibility with previous versions.
     *
     * @return {Object[]} An array of the unique values
     */
    collect: function(dataIndex, allowNull, bypassFilters) {
        var includeCollapsed,
            map = {},
            result = [],
            strValue, value;

        if (allowNull &amp;&amp; typeof allowNull === &#39;object&#39;) {
            includeCollapsed = allowNull.collapsed;
            bypassFilters = allowNull.filtered;
            allowNull = allowNull.allowNull;
        }

        if (includeCollapsed || bypassFilters) {
            this.getRoot().cascade(function(node) {
                if (bypassFilters === true || node.get(&#39;visible&#39;)) {
                    value = node.get(dataIndex);
                    strValue = String(value);

                    if ((allowNull || !Ext.isEmpty(value)) &amp;&amp; !map[strValue]) {
                        map[strValue] = 1;
                        result.push(value);
                    }
                }

                // Do not traverse into children if this is collapsed
                // and they are not asking to include collapsed
                if (!includeCollapsed &amp;&amp; !node.isExpanded()) {
                    return false;
                }
            });
        } else {
            result = this.callParent([dataIndex, allowNull, bypassFilters]);
        }

        return result;
    },

<span id='Ext-data-TreeStore-method-getNodeById'>    /**
</span>     * Returns the record node by id regardless of visibility due to collapsed states;
     * all nodes present in the tree structure are available.
     * @param {String} id The id of the node to get.
     * @return {Ext.data.NodeInterface}
     */
    getNodeById: function(id) {
        return this.byIdMap[id] || null;
    },

<span id='Ext-data-TreeStore-method-findNode'>    /**
</span>     * Finds the first matching node in the tree by a specific field value regardless of visibility
     * due to collapsed states; all nodes present in the tree structure are searched.
     *
     * @param {String} fieldName The name of the Record field to test.
     * @param {String/RegExp} value Either a string that the field value
     * should begin with, or a RegExp to test against the field.
     * @param {Boolean} [anyMatch=true] False to match any part of the string, not just 
     * the beginning.
     * @param {Boolean} [caseSensitive=false] True for case sensitive comparison
     * @param {Boolean} [exactMatch=false] True to force exact match (^ and $ characters
     * added to the regex). Ignored if `anyMatch` is `true`.
     * @return {Ext.data.NodeInterface} The matched node or null
     */
    findNode: function(property, value, startsWith, endsWith, ignoreCase) {
        if (Ext.isEmpty(value, false)) {
            return null;
        }

        // If they are looking up by the idProperty, do it the fast way.
        if (property === this.model.idProperty &amp;&amp; arguments.length &lt; 3) {
            return this.byIdMap[value];
        }
        var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase),
            result = null;

        Ext.Object.eachValue(this.byIdMap, function(node) {
            if (node &amp;&amp; regex.test(node.get(property))) {
                result = node;
                return false;
            }
        });
        return result;
    },

<span id='Ext-data-TreeStore-method-load'>    /**
</span>     * Marks this store as needing a load. When the current executing event handler exits,
     * this store will send a request to load using its configured {@link #proxy}.
     *
     * **Be aware that it is not usually valid for a developer to call this method on a TreeStore.**
     *
     * TreeStore loads are triggered by a load request from an existing {@link Ext.data.NodeInterface tree node},
     * when the node is expanding, and it has no locally defined children in its data.
     *
     * *Note:* Even for synchronous Proxy types such as {@link Ext.data.proxy.Memory memory proxy},
     * the result will *NOT* be available in the following line of code. You must use a callback
     * in the load options, or a {@link #event-load load listener}.
     *
     * @param {Object} [options] This is passed into the {@link Ext.data.operation.Operation Operation}
     * object that is created and then sent to the proxy&#39;s {@link Ext.data.proxy.Proxy#read} function.
     * The options can also contain a node, which indicates which node is to be loaded. If not specified, it will
     * default to the root node.
     * @param {Ext.data.NodeInterface} [options.node] The tree node to load. Defaults to the store&#39;s {@link #cfg-root root node}
     * @param {Function} [options.callback] A function which is called when the response arrives.
     * @param {Ext.data.Model[]} options.callback.records Array of records.
     * @param {Ext.data.operation.Operation} options.callback.operation The Operation itself.
     * @param {Boolean} options.callback.success `true` when operation completed successfully.
     * @method load
     */
    load: function(options) {
        var node = options &amp;&amp; options.node;

        // If there is not a node it means the user hasn&#39;t defined a root node yet. In this case let&#39;s just
        // create one for them. The expanded: true will cause a load operation, so return.
        if (!node &amp; !(node = this.getRoot())) {
            node = this.setRoot({
                expanded: true
            });
            return;
        }

        // If the node kicked off its own load, then don&#39;t schedule another load.
        if (node.isLoading()) {
            return;
        }
        return this.callParent([options]);
    },

<span id='Ext-data-TreeStore-method-reload'>    /**
</span>     * Reloads the root node of this store.
     */
    reload: function(options) {
        var o = Ext.apply({}, options, this.lastOptions);

        // A reload implies root load
        o.node = this.getRoot();
        return this.load(o);
     },
        
<span id='Ext-data-TreeStore-method-flushLoad'>    /**
</span>     * Called when the event handler which called the {@link #method-load} method exits.
     */
    flushLoad: function() {
        var me = this,
            options = me.pendingLoadOptions,
            node,
            callback,
            scope,
            clearOnLoad = me.getClearOnLoad(),
            isRootLoad,
            operation, doClear;

        // If it gets called programatically before the timer fired, the listener will need cancelling.
        me.clearLoadTask();
        if (!options) {
            return;
        }

        node = options.node || me.getRoot();
        // If we are loading the root, then it is a whole store reload.
        // This is handled efficiently in onProxyLoad by firing the refresh event
        // which will completely refresh any dependent views as would be expected
        // from a load() call.
        isRootLoad = node &amp;&amp; node.isRoot();
        callback = options.callback;
        scope = options.scope;
        options.params = options.params || {};

        // If this is not a root reload.
        // If the node we are loading was expanded, we have to expand it after the load
        if (node.data.expanded &amp;&amp; !isRootLoad) {
            node.data.loaded = false;

            // Must set expanded to false otherwise the onProxyLoad-&gt;fillNode-&gt;appendChild calls will update the view.
            // We ned to update the view in the callback below.
            if (clearOnLoad) {
                node.data.expanded = false;
            }
            options.callback = function(loadedNodes, operation, success) {

                // If newly loaded nodes are to be added to the existing child node set, then we have to collapse
                // first so that they get removed from the NodeStore, and the subsequent expand will reveal the
                // newly augmented child node set.
                if (!clearOnLoad) {
                    node.collapse();
                }
                node.expand();

                // Call the original callback (if any)
                Ext.callback(callback, scope, [loadedNodes, operation, success]);
            };
        }

        // Assign the ID of the Operation so that a ServerProxy can set its idParam parameter,
        // or a REST proxy can create the correct URL
        options.id = node.getId();

        // Only add filtering and sorting options if those options are remote
        me.setLoadOptions(options);

        if (me.getRemoteSort() &amp;&amp; options.sorters) {
            me.fireEvent(&#39;beforesort&#39;, me, options.sorters);
        }

        options = Ext.apply({
            node: options.node || node,
            internalScope: me,
            internalCallback: me.onProxyLoad
        }, options);

        me.lastOptions = Ext.apply({}, options);

        // Must not be copied into lastOptions, otherwise it overrides next call.
        options.isRootLoad = isRootLoad;

        operation = me.createOperation(&#39;read&#39;, options);

        if (me.fireEvent(&#39;beforeload&#39;, me, operation) !== false) {

            // Set the loading flag early
            // Used by onNodeRemove to NOT add the removed nodes to the removed collection
            me.loading = true;

            // If this is a full root load, clear the root node and the flat data.
            if (isRootLoad) {
                if (me.getClearRemovedOnLoad()) {
                    me.removedNodes.length = 0;
                }
                if (clearOnLoad) {
                    // Unregister all descendants, but immediately reregister the root
                    // It is NOT being tipped out by this load operation
                    me.unregisterNode(node, true);
                    node.clear(false, true);
                    me.registerNode(node);

                    doClear = true;
                }
            } 
            // Load a non-root
            else {
                if (me.getTrackRemoved() &amp;&amp; me.getClearRemovedOnLoad()) {
                    // clear from the removed array any nodes that were descendants of the node being reloaded so that they do not get saved on next sync.
                    me.clearRemoved(node);
                }
                if (clearOnLoad) {
                    node.removeAll(false);
                }
            }

            if (me.loading &amp;&amp; node) {
                node.set(&#39;loading&#39;, true);
            }

            if (doClear) {
                me.clearData(true);
                // Readd the root we just cleared, since we&#39;re reloading it
                if (me.getRootVisible()) {
                    me.suspendEvents();
                    me.add(node);
                    me.resumeEvents();
                }
            }

            operation.execute();
        }

        return me;
    },

<span id='Ext-data-TreeStore-method-onProxyLoad'>    onProxyLoad: function(operation) {
</span>        var me = this,
            options = operation.initialConfig,
            successful = operation.wasSuccessful(),
            records = operation.getRecords(),
            node = options.node,
            isRootLoad = options.isRootLoad,
            scope = operation.getScope() || me,
            args = [records, operation, successful];

        if (me.destroyed) {
            return;
        }

        me.loading = false;
        node.set(&#39;loading&#39;, false);
        if (successful) {
            ++me.loadCount;
            if (!me.getClearOnLoad()) {
                records = me.cleanRecords(node, records);
            }

            // Nodes are in linear form, linked to the parent using a parentId property
            if (me.getParentIdProperty()) {
                records = me.treeify(node, records);
            }
            
            if (isRootLoad) {
                me.suspendEvent(&#39;add&#39;, &#39;update&#39;);
            }
            records = me.fillNode(node, records);
        }
        // The load event has an extra node parameter
        // (differing from the load event described in AbstractStore)
<span id='Ext-data-TreeStore-event-load'>        /**
</span>         * @event load
         * Fires whenever the store reads data from a remote data source.
         * @param {Ext.data.TreeStore} this
         * @param {Ext.data.TreeModel[]} records An array of records.
         * @param {Boolean} successful True if the operation was successful.
         * @param {Ext.data.Operation} operation The operation that triggered this load.
         * @param {Ext.data.NodeInterface} node The node that was loaded.
         */
        
        Ext.callback(options.onChildNodesAvailable, scope, args);
        if (isRootLoad) {
            me.resumeEvent(&#39;add&#39;, &#39;update&#39;);
            me.callObservers(&#39;BeforePopulate&#39;);
            me.fireEvent(&#39;datachanged&#39;, me);
            me.fireEvent(&#39;refresh&#39;, me);
            me.callObservers(&#39;AfterPopulate&#39;);
        }
        me.fireEvent(&#39;load&#39;, me, records, successful, operation, node);
    },

<span id='Ext-data-TreeStore-method-clearRemoved'>    /**
</span>     * Removes all records that used to be descendants of the passed node from the removed array
     * @private
     * @param {Ext.data.NodeInterface} node
     */
    clearRemoved: function(node) {
        var me = this,
            removed = me.removedNodes,
            id = node.getId(),
            removedLength = removed.length,
            i = removedLength,
            recordsToClear = {},
            newRemoved = [],
            removedHash = {},
            removedNode,
            targetNode,
            targetId;

        if (node === me.getRoot()) {
            // if the passed node is the root node, just reset the removed array
            me.removedNodes.length = 0;
            return;
        }

        // add removed records to a hash so they can be easily retrieved by id later
        for (; i--;) {
            removedNode = removed[i];
            removedHash[removedNode.getId()] = removedNode;
        }

        for (i = removedLength; i--;) {
            removedNode = removed[i];
            targetNode = removedNode;
            while (targetNode &amp;&amp; targetNode.getId() !== id) {
                // walk up the parent hierarchy until we find the passed node or until we get to the root node
                // lastParentId is set in nodes which have been removed.
                targetId = targetNode.get(&#39;parentId&#39;) || targetNode.get(&#39;lastParentId&#39;);
                targetNode = targetNode.parentNode || me.getNodeById(targetId) || removedHash[targetId];
            }
            if (targetNode) {
                // removed node was previously a descendant of the passed node - add it to the records to clear from &quot;removed&quot; later
                recordsToClear[removedNode.getId()] = removedNode;
            }
        }

        // create a new removed array containing only the records that are not in recordsToClear
        for (i = 0; i &lt; removedLength; i++) {
            removedNode = removed[i];
            if (!recordsToClear[removedNode.getId()]) {
                newRemoved.push(removedNode);
            }
        }

        me.removedNodes = newRemoved;
    },

<span id='Ext-data-TreeStore-method-fillNode'>    /**
</span>     * Fills a node with a series of child records.
     * @private
     * @param {Ext.data.NodeInterface} node The node to fill
     * @param {Ext.data.TreeModel[]} newNodes The records to add
     */
    fillNode: function(node, newNodes) {
        var me = this,
            newNodeCount = newNodes ? newNodes.length : 0;

        // If we&#39;re filling, increment the counter so nodes can react without doing expensive operations
        if (++me.bulkUpdate === 1) {
            me.suspendEvent(&#39;datachanged&#39;);
        };
        if (newNodeCount) {
            me.setupNodes(newNodes);
        }

        if (me.bulkUpdate === 1) {
            node.set(&#39;loaded&#39;, true);
        } else {
            node.data.loaded = true;
        }

        if (newNodes.length) {
            node.appendChild(newNodes, undefined, true);
        }
        if (!--me.bulkUpdate) {
            me.resumeEvent(&#39;datachanged&#39;);
        }
        // No need to call registerNode here, because each child will register itself as it joins
        return newNodes;
    },

<span id='Ext-data-TreeStore-method-setupNodes'>    setupNodes: function(newNodes) {
</span>        var me = this,
            sorters = me.getSorters(),
            needsIndexSort = false,
            newNodeCount = newNodes.length,
            performLocalSort = me.sortOnLoad &amp;&amp; newNodeCount &gt; 1 &amp;&amp; !me.getRemoteSort() &amp;&amp; me.getFolderSort() || sorters.length,
            performLocalFilter = me.needsLocalFilter(),
            node1, node2, i;

        // Apply any local filter to the nodes as we fill
        if (performLocalFilter) {
            me.doFilter(newNodes[0]);
        }

        // See if there are any differing index values in the new nodes. If not, then we do not have to sortByIndex
        for (i = 1; i &lt; newNodeCount; i++) {

            node1 = newNodes[i];
            node2 = newNodes[i - 1];

            // Apply any filter to the nodes as we fill
            if (performLocalFilter) {
                me.doFilter(node1);
            }
            needsIndexSort = node1.data.index !== node2.data.index;
        }

        // If there is a set of local sorters defined.
        if (performLocalSort) {
            // If sorting by index is needed, sort by index first
            me.needsIndexSort = true;
            Ext.Array.sort(newNodes, me.getSortFn());
            me.needsIndexSort = false;
        } else if (needsIndexSort) {
            Ext.Array.sort(newNodes, me.sortByIndex);
        }
    },

<span id='Ext-data-TreeStore-method-beginFill'>    // Called by a node which is appending children to itself
</span>    beginFill: function() {
        var me = this;

        if (!me.fillCount++) { // jshint ignore:line
            me.beginUpdate();
            me.suspendEvent(&#39;add&#39;, &#39;update&#39;);
            me.suspendAutoSync();
            me.fillArray = [];
        }
    },

<span id='Ext-data-TreeStore-method-endFill'>    // resume view updating and data syncing after a node fill
</span>    endFill: function(parent, nodes) {
        var me = this,
            fillArray = me.fillArray,
            i, len,
            index;

        // Keep every block of records added during the fill
        fillArray.push(nodes);

        if (! --me.fillCount) {
            me.resumeAutoSync();
            me.resumeEvent(&#39;add&#39;, &#39;update&#39;);

            // Add all blocks of records from nested beginFill calls.
            // appendChild can load local child data and recursively call appendChild.
            // This coalesces all add operations into a layout suspension
            for (i = 0, len = fillArray.length; i &lt; len; i++) {
                index = me.indexOf(fillArray[i][0]);

                // Only inform views if the blocks appended actually made it into the linear store (are visible)
                if (index !== -1) {
                    me.fireEvent(&#39;add&#39;, me, fillArray[i], index);
                }
            }
            me.fillArray = null;
            me.endUpdate();
        }
    },

<span id='Ext-data-TreeStore-method-sortByIndex'>    /**
</span>     * Sorter function for sorting records in index order
     * @private
     * @param {Ext.data.NodeInterface} node1
     * @param {Ext.data.NodeInterface} node2
     * @return {Number}
     */
    sortByIndex: function(node1, node2) {
        return node1.data.index - node2.data.index;
    },

<span id='Ext-data-TreeStore-method-onIdChanged'>    onIdChanged: function(node, oldId, newId) {
</span>        var childNodes = node.childNodes,
            len = childNodes &amp;&amp; childNodes.length,
            i;

        this.callParent(arguments);
        delete this.byIdMap[oldId];
        this.byIdMap[newId] = node;

        // Ensure all child nodes know their parent&#39;s new ID
        for (i = 0; i &lt; len; i++) {
            childNodes[i].set(&#39;parentId&#39;, newId);
        }
    },

<span id='Ext-data-TreeStore-method-treeify'>    /**
</span>     * @private
     * Converts a flat array of nodes into a tree structure.
     * Returns an array which is the childNodes array of the rootNode.
     */
    treeify: function(parentNode, records) {
        var me = this,
            loadParentNodeId = parentNode.getId(),
            parentIdProperty = me.getParentIdProperty(),
            len = records.length,
            result = [],
            nodeMap = {},
            i, node, parentId, parent, id, children;

        // Collect all nodes keyed by ID, so that regardless of order, they can all be linked to a parent.
        for (i = 0; i &lt; len; i++) {
            node = records[i];
            node.data.depth = 1;
            nodeMap[node.id] = node;
        }

        // Link child nodes up to their parents
        for (i = 0; i &lt; len; i++) {
            node = records[i];
            parentId = node.data[parentIdProperty];

            if (!(parentId || parentId === 0) || parentId === loadParentNodeId) {
                result.push(node);
            } else {
                //&lt;debug&gt;
                if (!nodeMap[parentId]) {
                    Ext.raise(&#39;Ext.data.TreeStore, Invalid parentId &quot;&#39; + parentId + &#39;&quot;&#39;);
                }
                //&lt;/debug&gt;
                parent = nodeMap[parentId];
                parent.$children = parent.$children || [];
                parent.$children.push(node);
                node.data.depth = parent.data.depth + 1;
            }
        }

        for (id in nodeMap) {
            node = nodeMap[id];
            children = node.$children;
            if (children) {
                delete node.$children;
                me.setupNodes(children);
                node.appendChild(children);
            }
            me.registerNode(node);
        }

        me.setupNodes(result);

        return result;
    },

<span id='Ext-data-TreeStore-method-cleanRecords'>    cleanRecords: function(node, records){
</span>        var nodeHash = {},
            childNodes = node.childNodes,
            i = 0,
            len  = childNodes.length,
            out = [],
            rec;

        // build a hash of all the childNodes under the current node for performance
        for (; i &lt; len; ++i) {
            nodeHash[childNodes[i].getId()] = true;
        }

        for (i = 0, len = records.length; i &lt; len; ++i) {
            rec = records[i];
            if (!nodeHash[rec.getId()]) {
                out.push(rec);
            }
        }

        return out;
    },

<span id='Ext-data-TreeStore-method-removeAll'>    removeAll: function() {
</span>        this.suspendEvents();
        this.setRoot(null);
        this.resumeEvents();
        this.callParent();
    },

<span id='Ext-data-TreeStore-method-doSort'>    doSort: function(sorterFn) {
</span>        var me = this;
        if (me.getRemoteSort()) {
            //the load function will pick up the new sorters and request the sorted data from the proxy
            me.load();
        } else {
            me.tree.sort(sorterFn, true);
            me.fireEvent(&#39;datachanged&#39;, me);
            me.fireEvent(&#39;refresh&#39;, me);
        }
        me.fireEvent(&#39;sort&#39;, me, me.sorters.getRange());
    },

<span id='Ext-data-TreeStore-method-filterVisible'>    filterVisible: function(node) {
</span>        return node.get(&#39;visible&#39;);
    },

<span id='Ext-data-TreeStore-method-isVisible'>    /**
</span>     * @inheritdoc Ext.data.NodeStore#isVisible
     */
    isVisible: function(node) {
        var parentNode = node.parentNode,
            visible = node.data.visible,
            root = this.getRoot();

        while (visible &amp;&amp; parentNode) {
            visible = parentNode.data.expanded &amp;&amp; parentNode.data.visible;
            parentNode = parentNode.parentNode;
        }
        // The passed node is visible if we ended up at the root node, and it is visible.
        // UNLESS it&#39;s the root node, and we are configured with rootVisible:false
        return visible &amp;&amp; !(node === root &amp;&amp; !this.getRootVisible());
    },

<span id='Ext-data-TreeStore-method-commitChanges'>    commitChanges: function() {
</span>        var removed = this.removedNodes;

        if (removed) {
            removed.length = 0;
        }

        this.callParent();
    },

<span id='Ext-data-TreeStore-method-getRootNode'>    /**
</span>     * Returns the root node for this tree.
     * @return {Ext.data.NodeInterface}
     * @deprecated 5.0 Use {@link #getRoot} instead
     */
    getRootNode: function() {
        return this.getRoot();
    },

<span id='Ext-data-TreeStore-method-setRootNode'>    /**
</span>     * Sets the root node for this store.  See also the {@link #root} config option.
     * @param {Ext.data.TreeModel/Ext.data.NodeInterface/Object} root
     * @return {Ext.data.NodeInterface} The new root
     * @deprecated 5.0 Use {@link #setRoot} instead
     */
    setRootNode: function(root) {
        this.setRoot(root);
        return this.getRoot();
    },

<span id='Ext-data-TreeStore-property-privates'>    privates: {
</span>        fireChangeEvent: function(record) {
            return !!this.byIdMap[record.id];
        },
        
<span id='Ext-data-TreeStore-method-getRawRemovedRecords'>        /**
</span>         * @private
         * Returns the array of nodes which have been removed since the last time this store was synced.
         *
         * This is used internally, when purging removed records after a successful sync.
         * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
         * of child nodes from their parent, *not* on removal of records from its collection. The collection
         * has records added on expand, and removed on collapse.
         */
        getRawRemovedRecords: function() {
            return this.removedNodes;
        },

        createOperation: function(type, options) {
            // Use the proxy assigned to the node by preference so that in a heterogeneous tree,
            // different node types can use different proxies and data providers.
            var me = this,
                node = options.node,
                proxy;

            // Use the node&#39;s proxy by preference if we acquired our proxy
            // from the configured Model (See ProxyStore#applyProxy)
            if (me.useModelProxy &amp;&amp; node &amp;&amp; node !== me.getRootNode()) {
                proxy = node.getProxy();
            }

            // If the node has a proxy which is different from this Store&#39;s proxy
            // then we must use that to create and manage its I/O operations.
            if (proxy &amp;&amp; proxy !== me.getProxy()) {
                return proxy.createOperation(type, options);
            } else {
                return me.callParent([type, options]);
            }
        },

<span id='Ext-data-TreeStore-method-recordCreator'>        /**
</span>         * @private
         * A function passed into {@link Ext.data.reader.Reader#extractData} which is used as a record creation function.
         * @param {Object} data Raw data to transform into a record
         * @param {Function} Model Model constructor to create a record from the passed data.
         * @return {Ext.data.Model} The resulting new Model instance.
         */
        recordCreator: function (data, Model) {
            return new Model(data);
        },

        doFilter: function(node) {
            this.filterNodes(node, this.getFilters().getFilterFn(), true);
        },

<span id='Ext-data-TreeStore-method-filterNodes'>        /**
</span>         * @private
         * Filters the passed node according to the passed function.
         *
         * If this TreeStore is configured with {@link #cfg-filterer filterer: &#39;bottomup&#39;}, leaf
         * nodes are tested according to the function. Additionally, parent nodes are filtered in
         * if any descendant leaf nodes have passed the filter test.
         *
         * Otherwise a parent node which fails the test will terminate the branch and
         * descendant nodes which pass the filter test will be filtered out.
         */
        filterNodes: function(node, filterFn, parentVisible) {
            var me = this,
                bottomUpFiltering = me.filterer === &#39;bottomup&#39;,
                // MUST call filterFn first to avoid shortcutting if parentVisible is false.
                // filterFn may have side effects, so must be called on all nodes.
                match = filterFn(node) &amp;&amp; parentVisible || (node.isRoot() &amp;&amp; !me.getRootVisible()),
                childNodes = node.childNodes,
                len = childNodes &amp;&amp; childNodes.length,
                i, matchingChildren;

            if (len) {
                for (i = 0; i &lt; len; ++i) {
                    // MUST call method first to avoid shortcutting boolean expression if matchingChildren is true
                    matchingChildren = me.filterNodes(childNodes[i], filterFn, match || bottomUpFiltering) || matchingChildren;
                }
                if (bottomUpFiltering) {
                    match = matchingChildren || match;
                }
            }

            node.set(&quot;visible&quot;, match, me._silentOptions);
            return match;
        },

        needsLocalFilter: function() {
            return !this.getRemoteFilter() &amp;&amp; this.getFilters().length;
        },

        onRemoteFilterSet: function(filters, remoteFilter) {
            // Filtering is done at the Store level for TreeStores.
            // It has to be done on a hierarchical basis.
            // The onFilterEndUpdate signal has to be passed into the root node which filters its children
            // and cascades the filter instruction downwards.
            var data = this.getData();

            data.setFilters(null);
            if (filters) {
                filters.on(&#39;endupdate&#39;, this.onFilterEndUpdate, this);
            }
        },

        onRemoteSortSet: function(sorters, remoteSort) {
            // Sorting is done at the Store level for TreeStores.
            // It has to be done on a hierarchical basis.
            // The onSorterEndUpdate signal has to be passed root node which sorts its children
            // and cascades the sort instruction downwards.
            var data = this.getData();

            data.setSorters(null);
            if (sorters) {
                sorters.on(&#39;endupdate&#39;, this.onSorterEndUpdate, this);
            }
        }
    },

<span id='Ext-data-TreeStore-property-deprecated'>    deprecated: {
</span>        5: {
            properties: {
                tree: null
            }
        }
    }
});
</pre>
</body>
</html>
