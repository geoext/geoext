<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-field-Field'>/**
</span> * Fields are used to define the members of a Model. They aren&#39;t instantiated directly;
 * instead, when we create a class that extends {@link Ext.data.Model}, it automatically
 * creates Field instances for each field configured in a {@link Ext.data.Model Model}.
 * For example, we might set up a model like this:
 *
 *     Ext.define(&#39;User&#39;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             &#39;name&#39;, &#39;email&#39;,
 *             { name: &#39;age&#39;, type: &#39;int&#39; },
 *             { name: &#39;gender&#39;, type: &#39;string&#39;, defaultValue: &#39;Unknown&#39; }
 *         ]
 *     });
 *
 * Four fields will have been created for the User Model - name, email, age and gender.
 * Note that we specified a couple of different formats here; if we only pass in the string
 * name of the field (as with name and email), the field is set up with the &#39;auto&#39; type.
 * It&#39;s as if we&#39;d done this instead:
 *
 *     Ext.define(&#39;User&#39;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             { name: &#39;name&#39;, type: &#39;auto&#39; },
 *             { name: &#39;email&#39;, type: &#39;auto&#39; },
 *             { name: &#39;age&#39;, type: &#39;int&#39; },
 *             { name: &#39;gender&#39;, type: &#39;string&#39;, defaultValue: &#39;Unknown&#39; }
 *         ]
 *     });
 *
 * # Field Types
 *
 * Fields come in various types. When declaring a field, the `type` property is used to
 * specify the type of `Field` derived class used to manage values.
 *
 * The predefined set of types are:
 *
 *  - {@link Ext.data.field.Field auto} (Default, implies no conversion)
 *  - {@link Ext.data.field.String string}
 *  - {@link Ext.data.field.Integer int}
 *  - {@link Ext.data.field.Number number}
 *  - {@link Ext.data.field.Boolean boolean}
 *  - {@link Ext.data.field.Date date}
 *
 * # Conversion
 *
 * When reading fields it is often necessary to convert the values received before using
 * them or storing them in records. To handle these cases there is the
 * `{@link #method-convert convert}` method. This method is passed the received value (as
 * well as the current record instance, but see below) and it returns the value to carry
 * forward.
 *
 * For `auto` fields there is no `{@link #method-convert convert}` method. This is for
 * efficiency. For other field types, there are often `convert` methods. You can provide
 * a `{@link #cfg-convert convert}` config when the field is defined like this:
 *
 *      {
 *          name: &#39;timestamp&#39;,
 *
 *          convert: function (value) {
 *              return new Date(value);
 *          }
 *      }
 *
 * While this can be convenient, see below for details on defining Custom Types as that is
 * often a better practice and avoids repeating these functions.
 *
 * Note that when a `defaultValue` is specified, it will also be passed through to
 * `convert` (either to the `{@link #method-convert convert}` method or to the
 * `{@link #cfg-convert convert} config)`.
 *
 * ## Calculated Values
 *
 * In some cases fields are the result of a calculation from other fields. Historically
 * this was a second role for `{@link #method-convert convert}` but that has some short
 * comings. The simpler solution is the `{@link #cfg-calculate calculate}` config.
 *
 * Values produced by `{@link #cfg-calculate calculate}` and `{@link #method-convert convert}`
 * are stored in the record as with any other field. In fact, if we define a calculated
 * &quot;firstName&quot; field and log out all of the data, we&#39;ll see this:
 *
 *     var ed = Ext.create(&#39;User&#39;, { name: &#39;Ed Spencer&#39; });
 *
 *     console.log(ed.data);
 *
 *     //outputs this:
 *     {
 *         age: 0,
 *         email: &quot;&quot;,
 *         firstName: &quot;Ed&quot;,  // calculated field
 *         gender: &quot;Unknown&quot;,
 *         name: &quot;Ed Spencer&quot;
 *     }
 *
 * ### Using `calculate`
 *
 *      {
 *          name: &#39;firstName&#39;,
 *
 *          calculate: function (data) {
 *              return data.name.split(&#39; &#39;)[0];
 *          }
 *      }
 *
 * Using `{@link #cfg-calculate calculate}` is the simplest and safest way to define a
 * calculated field. The most important part of this is that, internally, the code of the
 * supplied function is parsed to extract its dependencies. In this case, the &quot;name&quot; field
 * is the only dependency. This means that &quot;firstName&quot; will only need to be recalculated
 * when &quot;name&quot; is modified.
 *
 * **Note:** Fields used by the calculate method must be explicitly defined in the
 * {@link Ext.data.Model#cfg-fields #fields} of the model.
 *
 * ### Using `convert`
 *
 * Following is the equivalent technique using `{@link #cfg-convert convert}`
 *
 *      {
 *          name: &#39;firstName&#39;,
 *
 *          convert: function (value, record) {
 *              return record.get(&#39;name&#39;).split(&#39; &#39;)[0];
 *          },
 *
 *          depends: [ &#39;name&#39; ]
 *      }
 *
 * When a `{@link #method-convert convert}` function accepts a 2nd argument (a reference to
 * the record), it is considered a calculated field. If a `{@link #cfg-depends depends}`
 * config is not provided then this field&#39;s dependencies are unknown. In this case, the
 * `{@link #cfg-depends depends}` are provided as would be automatically determined with
 * the `{@link #cfg-calculate calculate}` config.
 *
 * ### Updating
 *
 * Fields modified with the {@link Ext.data.Model#set set} method will have their stored 
 * value set using the convert / calculate method when present.
 * 
 * For example:
 *
 *     Ext.define(&#39;MyApp.model.Employee&#39;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [{
 *             name: &#39;salary&#39;,
 *             convert: function (val) {
 *                 var startingBonus = val * .1;
 *                 return val + startingBonus;
 *             }
 *         }],
 *         convertOnSet: false
 *     });
 *     
 *     var tina = Ext.create(&#39;MyApp.model.Employee&#39;, {
 *         salary: 50000
 *     });
 *     
 *     console.log(tina.get(&#39;salary&#39;)); // logs 55000
 *     
 *     tina.set(&#39;salary&#39;, 60000);
 *     console.log(tina.get(&#39;salary&#39;)); // logs 60000
 * 
 * This default behavior can be disabled by setting the Model&#39;s 
 * `{@link Ext.data.Model#cfg-convertOnSet}` config to `false`.
 * 
 * **Note:** convertOnSet `false` only prevents the convert / calculate call when the 
 * set `fieldName` param matches the field&#39;s `{@link #name}`.  See 
 * {@link Ext.data.Model#convertOnSet convertOnSet} for additional details.
 *
 * ### Dependencies
 *
 * When a field&#39;s `{@link #method-convert convert}` method processes values from the record
 * (vs. just the field&#39;s value), it is best to also provide a `depends` config as shown
 * above. Fields that provide a `{@link #cfg-calculate calculate}` method must follow the
 * proper form for using fields so that dependencies can be extracted.
 *
 * Calculated fields are processed after other fields based on their dependencies. Fields
 * with `{@link #method-convert convert}` methods that use the provided record that do *not*
 * specify a `{@link #cfg-depends depends}` config are processed as a group after all other
 * fields since such converters can rely on anything in the record. The order of processing
 * these fields with respect to each other is unspecified and should not be relied upon.
 *
 * # Serialization
 *
 * To handle the inverse scenario of `convert` there is the `serialize` method. This
 * method is called to produce the value to send to a server based on the internal value
 * as would be returned from `convert`. In most cases, these methods should &quot;round trip&quot;
 * a value:
 *
 *      assertEqual(value, field.serialize(field.convert(value)));
 *
 * By default, only `{@link Ext.data.field.Date date}` fields have a `serialize` method.
 * Other types simply send their value unmodified.
 *
 * # Custom Types
 *
 * Developers may create their own application-specific data types by deriving from this
 * class. This is typically much better than applying multiple configuration values on
 * field instances as these often become repetitive.
 *
 * To illustrate, we define a &quot;time&quot; field type that stores a time-of-day represented as a
 * number of minutes since Midnight.
 *
 *      Ext.define(&#39;App.field.Time&#39;, {
 *          extend: &#39;Ext.data.field.Field&#39;,
 *
 *          alias: &#39;data.field.time&#39;,
 *
 *          timeFormat: &#39;g:i&#39;,
 *
 *          convert: function (value) {
 *              if (value &amp;&amp; Ext.isString(value)) {
 *                  var date = Ext.Date.parse(value, this.timeFormat);
 *                  if (!date) {
 *                      return null;
 *                  }
 *                  return (date.getHours() - 1) * 60 + date.getMinutes();
 *              }
 *              return value;
 *          }
 *      });
 *
 * ## Validation
 *
 * Custom field types can override the `{@link #method-validate validate}` method or
 * provide a set of `{@link #cfg-validators validators}`.
 *
 *      Ext.define(&#39;App.field.PhoneNumber&#39;, {
 *          extend: &#39;Ext.data.field.Field&#39;,
 *
 *          alias: &#39;data.field.phonenumber&#39;,
 *
 *          // Match U.S. phone numbers for example purposes
 *          validators: {
 *              type: &#39;format&#39;,
 *              matcher: /\d{3}\-\d{3}\-\d{4}/
 *          }
 *      });
 *
 * Once the class is defined, fields can be declared using the new type (based on its
 * `alias`) like so:
 *
 *      Ext.define(&#39;App.model.PhoneCall&#39;, {
 *          fields: [
 *              { name: &#39;startTime&#39;, type: &#39;time&#39; },
 *              { name: &#39;phoneNumber&#39;, type: &#39;phonenumber&#39; }
 *          ]
 *      });
 */
Ext.define(&#39;Ext.data.field.Field&#39;, {
    mixins: [
        &#39;Ext.mixin.Factoryable&#39;
    ],

    requires: [
        &#39;Ext.data.SortTypes&#39;,
        &#39;Ext.data.validator.Validator&#39;
    ],

    alternateClassName: &#39;Ext.data.Field&#39;,

<span id='Ext-data-field-Field-property-aliasPrefix'>    alias: &#39;data.field.auto&#39;, // also configures Factoryable
</span>
    aliasPrefix: &#39;data.field.&#39;,

<span id='Ext-data-field-Field-property-type'>    type: &#39;auto&#39;,
</span>
<span id='Ext-data-field-Field-property-factoryConfig'>    factoryConfig: {
</span>        defaultProperty: &#39;name&#39;
    },

<span id='Ext-data-field-Field-property-isDataField'>    isDataField: true,
</span><span id='Ext-data-field-Field-property-isField'>    isField: true,
</span>
    // NOTE: We do not use &quot;config: {}&quot; here because these configs are simple, never really
    // set after creation and expensive enough when processed per-instance that avoiding
    // the overhead is worth while. Remember that a large app may have many dozens of
    // entities in their data model and these may have many fields each. Easily hundreds
    // of Field instances. Using config with inherited things (like convert methods) just
    // pushes the set to the constructor where it needs to just be a normal method.

<span id='Ext-data-field-Field-cfg-allowBlank'>    /**
</span>     * @cfg {Boolean} allowBlank
     * @private
     *
     * Used for validating a {@link Ext.data.Model model}. Defaults to true. An empty value here will cause
     * {@link Ext.data.Model}.{@link Ext.data.Model#isValid isValid} to evaluate to false.
     */
    allowBlank: true,

<span id='Ext-data-field-Field-cfg-allowNull'>    /**
</span>     * @cfg {Boolean} allowNull
     *
     * Use when converting received data into a {@link Ext.data.field.Integer `int`},
     * {@link Ext.data.field.Number `float`}, {@link Ext.data.field.Boolean `bool`}
     * or {@link Ext.data.field.String `string`} type. If the value cannot be
     * parsed, `null` will be used if allowNull is true, otherwise a default value for that type will be used:
     *
     * - for `int` and `float` - `0`.
     * - for `string` - `&quot;&quot;`.
     * - for `bool` - `false`.
     *
     * Note that when parsing of {@link Ext.data.field.Date `date`} type fails, the value will
     * be `null` regardless of this setting.
     */
    allowNull: false,

<span id='Ext-data-field-Field-cfg-calculate'>    /**
</span>     * @cfg {Function} calculate
     * This config defines a simple field calculation function. A calculate method only
     * has access to the record data and should return the value of the calculated field.
     * When provided in this way, the `depends` config is automatically determined by
     * parsing the `calculate` function. For example:
     *
     *      fields: [{
     *          name: &#39;firstName&#39;,
     *          type: &#39;string&#39;
     *      },{
     *          name: &#39;lastName&#39;,
     *          type: &#39;string&#39;
     *      },{
     *          name: &#39;fullName&#39;,
     *          calculate: function (data) {
     *              return data.firstName + &#39; &#39; + data.lastName;
     *          }
     *      }]
     *
     * The above &#39;fullName&#39; field is equivalent to:
     *
     *      {
     *          name: &#39;fullName&#39;,
     *          convert: function (v, rec) {
     *              return rec.get(&#39;firstName&#39;) + &#39; &#39; + rec.get(&#39;lastName&#39;);
     *          },
     *          depends: [&#39;firstName&#39;, &#39;lastName&#39;]
     *      }
     *
     * The restrictions on form for a `calculate` method are that the accesses to field
     * values must match the following regular expression (case insensitive):
     *
     *      data.([a-z_][a-z0-9_]*)
     *      // where &#39;data&#39; is the param passed to the calculate method
     *
     * The only advantage of a `calculate` method over a `convert` method is automatic
     * determination of `depends`.
     * 
     * **Note:** The use of calculate and {@link #method-convert} are exclusive.  The 
     * calculate method will override the convert method if both are configured.
     * 
     * **Note:** Fields used by the calculate method must be explicitly defined in the
     * {@link Ext.data.Model#cfg-fields #fields} of the model.
     *
     * @param {Object} data An object with all values for each field in the parent 
     * model.  See {@link Ext.data.Model#getData getData}.
     * @return {Mixed} value The value of the calculated field
     */

<span id='Ext-data-field-Field-cfg-convert'>    /**
</span>     * @cfg {Function} convert
     * If specified this config overrides the `{@link #method-convert convert}` method. See
     * also `{@link #cfg-calculate calculate}` for simple field calculations.
     * 
     * **Note:** The use of {@link #calculate} and convert are exclusive.  The calculate 
     * method will override the convert method if both are configured.
     */

<span id='Ext-data-field-Field-cfg-critical'>    /**
</span>     * @cfg {Boolean} critical
     * A critical field is a field that must always be sent to the server even if it has
     * not changed. The most common example of such a field is the &quot;id&quot; of a record (see
     * `{@link Ext.data.Model#idProperty}` but the `{@link Ext.data.Model#versionProperty}`
     * is similarly a `critical` field.
     */
    critical: false,

<span id='Ext-data-field-Field-property-defaultInvalidMessage'>    /**
</span>     * @property {String} defaultInvalidMessage
     * The default message to present for an invalid field.
     * @since 5.0.0
     */
    defaultInvalidMessage: &#39;This field is invalid&#39;,

<span id='Ext-data-field-Field-cfg-defaultValue'>    /**
</span>     * @cfg {Object} [defaultValue=undefined]
     *
     * The default value used when the creating an instance from a raw data object,
     * and the property referenced by the `{@link Ext.data.field.Field#mapping mapping}`
     * does not exist in that data object.
     *
     * The value `undefined` prevents defaulting in a value.
     */
    defaultValue: undefined,

<span id='Ext-data-field-Field-property-definedBy'>    /**
</span>     * @property {Ext.Class} definedBy
     * The class (derived from {@link Ext.data.Model}) that defined this field.
     *
     *      Ext.define(&#39;MyApp.models.Foo&#39;, {
     *          extend: &#39;Ext.data.Model&#39;,
     *
     *          fields: [
     *              { name: &#39;bar&#39; }
     *          ],
     *          ...
     *      });
     *
     *      var barField = MyApp.models.Foo.getField(&#39;bar&#39;);
     *
     *      alert(barField.definedBy === MyApp.models.Foo); // alerts &#39;true&#39;
     *
     * When a field is inherited, this value will reference the class that originally
     * defined the field.
     *
     *      Ext.define(&#39;MyApp.models.Base&#39;, {
     *          extend: &#39;Ext.data.Model&#39;,
     *
     *          fields: [
     *              { name: &#39;foo&#39; }
     *          ],
     *          ...
     *      });
     *
     *      Ext.define(&#39;MyApp.models.Derived&#39;, {
     *          extend: &#39;MyApp.models.Base&#39;,
     *
     *          fields: [
     *              { name: &#39;bar&#39; }
     *          ],
     *          ...
     *      });
     *
     *      var fooField = MyApp.models.Derived.getField(&#39;foo&#39;);
     *
     *      alert(fooField.definedBy === MyApp.models.Base); // alerts &#39;true&#39;
     */
    definedBy: null,

<span id='Ext-data-field-Field-cfg-depends'>    /**
</span>     * @cfg {String/String[]} [depends]
     * The field name or names within the {@link Ext.data.Model Model} on which the value
     * of this field depends, and from which a new value may be calculated. These values
     * are the values used by the `convert` method. If you do not have a `convert` method
     * then this config should not be specified.
     *
     * Before using this config you should consider if using a `calculate` method instead
     * of a `convert` method would be simpler.
     *
     * Whenever any of the named fields are set using the {@link Ext.data.Model#set set}
     * method, this fields will have its `convert` method called passing the
     * {@link Ext.data.Model record} so that the dependent value can be calculated from
     * all fields which it needs.
     *
     * For example, to display a person&#39;s full name, using two separate `firstName` and
     * `lastName` fields, configure the name field like this:
     *
     *     {
     *         name: &#39;name&#39;,
     *     
     *         // Will be called whenever forename or surname fields are set
     *         convert: function (v, rec) {
     *             return rec.get(&#39;firstName&#39;) + &#39; &#39; + rec.get(&#39;lastName&#39;);
     *         },
     *     
     *         depends: [ &#39;firstName&#39;, &#39;lastName&#39; ],
     *     
     *         // It should not be returned to the server - it&#39;s not a database field
     *         persist: false
     *     }
     *
     * Note that if you do not want the calculated field to be part of the field set sent
     * back to the server when the store is synchronized, you should configure the field
     * with `persist` set to `false`.
     */
    depends: null,

<span id='Ext-data-field-Field-property-dependents'>    /**
</span>     * @property {Ext.data.field.Field[]} dependents
     * This array tracks the fields that have indicated this field in their `depends`
     * list. If no fields depend on this field, this will be `null`.
     * @readonly
     * @private
     */
    dependents: null,

<span id='Ext-data-field-Field-cfg-mapping'>    /**
</span>     * @cfg {String/Number/Function} mapping
     *
     * (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
     * {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
     * as the field name, the mapping may be omitted. A function may be passed to do complex data extraction. The examples
     * below are simple just to demonstrate the capability, typically, a function would not be used to extract such
     * simple data.
     *
     * The form of the mapping expression depends on the Reader being used.
     *
     * - {@link Ext.data.reader.Json}
     *
     *   The mapping is a string containing the javascript expression to reference the data from an element of the data
     *   item&#39;s {@link Ext.data.reader.Json#cfg-rootProperty rootProperty} Array. Defaults to the field name. If a function is passed,
     *   a single argument is received which contains the raw json object:
     *
     *       // Server returns [{&quot;name&quot;: &quot;Foo&quot;, &quot;age&quot;: 1}, {&quot;name&quot;: &quot;Bar&quot;, &quot;age&quot;: 2}]
     *       mapping: function(data) {
     *           return data.name;
     *       }
     *
     * - {@link Ext.data.reader.Xml}
     *
     *   The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
     *   {@link Ext.data.reader.Xml#record record}. Defaults to the field name. If a function is passed, a single argument
     *   is received which contains the record node:
     *
     *       // Server returns &lt;Root&gt;&lt;Person&gt;&lt;Name&gt;Foo&lt;/Name&gt;&lt;Age&gt;1&lt;/Age&gt;&lt;/Person&gt;&lt;Person&gt;&lt;Name&gt;Bar&lt;/Name&gt;&lt;Age&gt;2&lt;/Age&gt;&lt;/Person&gt;&lt;/Root&gt;
     *       mapping: function(data) {
     *           return data.firstChild.textContent;
     *       }
     *
     * - {@link Ext.data.reader.Array}
     *
     *   The mapping is a number indicating the Array index of the field&#39;s value. Defaults to the field specification&#39;s
     *   Array position. If a function is passed, a single argument is received which contains the child array.
     *
     *       // Server returns [[&quot;Foo&quot;, 1], [&quot;Bar&quot;, 2]]
     *       mapping: function(data) {
     *           return data[0];
     *       }
     *
     * If a more complex value extraction strategy is required, then configure the Field with a {@link #cfg-convert}
     * function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
     * return the desired data.
     */
    mapping: null,

<span id='Ext-data-field-Field-cfg-name'>    /**
</span>     * @cfg {String} name
     *
     * The name by which the field is referenced within the Model. This is referenced by,
     * for example, the `dataIndex` property in column definition objects passed to
     * {@link Ext.grid.property.HeaderContainer}.
     *
     * Note: In the simplest case, if no properties other than `name` are required, a
     * field definition may consist of just a String for the field name.
     */
    name: null,

<span id='Ext-data-field-Field-property-ordinal'>    /**
</span>     * @property {Number} ordinal
     *
     * The position of this field in the {@link Ext.data.Model} in which it was defined.
     */
    ordinal: undefined,

<span id='Ext-data-field-Field-cfg-persist'>    /**
</span>     * @cfg {Boolean} [persist]
     *
     * False to exclude this field from the {@link Ext.data.Model#modified} fields in a
     * record. This will also exclude the field from being written using a
     * {@link Ext.data.writer.Writer}. This option is useful when fields are used to keep
     * state on the client but do not need to be persisted to the server.
     *
     * Defaults to `false` for `calculated` fields and `true` otherwise.
     */
    persist: null,

<span id='Ext-data-field-Field-cfg-reference'>    /**
</span>     * @cfg {String/Object} [reference]
     * The {@link Ext.data.Model#entityName name} of the entity referenced by this field.
     * In most databases, this relationship is represented by a &quot;foreign key&quot;. That is, a
     * value for such a field matches the value of the {@link Ext.data.Model#idProperty id}
     * for an entity of this type.
     *
     * For further documentation, see {@link Ext.data.schema.Reference}.
     */
    reference: null,

<span id='Ext-data-field-Field-cfg-serialize'>    /**
</span>     * @cfg {Function} serialize
     * @inheritdoc #method-serialize
     */

<span id='Ext-data-field-Field-cfg-sortType'>    /**
</span>     * @cfg {Function/String} sortType
     *
     * A function which converts a Field&#39;s value to a comparable value in order to ensure
     * correct sort ordering.
     *
     * Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
     *
     *     // current sort     after sort we want
     *     // +-+------+          +-+------+
     *     // |1|First |          |1|First |
     *     // |2|Last  |          |3|Second|
     *     // |3|Second|          |2|Last  |
     *     // +-+------+          +-+------+
     *
     *     sortType: function(value) {
     *        switch (value.toLowerCase()) // native toLowerCase():
     *        {
     *           case &#39;first&#39;: return 1;
     *           case &#39;second&#39;: return 2;
     *           default: return 3;
     *        }
     *     }
     *
     * May also be set to a String value, corresponding to one of the named sort types in
     * {@link Ext.data.SortTypes}.
     */

<span id='Ext-data-field-Field-cfg-unique'>    /**
</span>     * @cfg {Boolean} [unique=false]
     * `true` if the value of this field is unique amongst all instances. When used with a
     * `reference` this describes a &quot;one-to-one&quot; relationship. It is almost always the case
     * that a `unique` field cannot also be {@link #allowBlank nullable}.
     */
    unique: false,

<span id='Ext-data-field-Field-cfg-validators'>    /**
</span>     * @cfg {Object[]} validators
     * An array of {@link Ext.data.validator.Validator validators} for this field. These
     * `validators` will only be passed a field value to validate.
     */

<span id='Ext-data-field-Field-property-rank'>    /**
</span>     * @property {Number} rank
     * This is a 1-based value that describes the dependency order of this field. This is
     * initialized to `null` (falsey) so we can cheaply topo-sort the fields of a class.
     * @private
     * @readonly
     */
    rank: null,

<span id='Ext-data-field-Field-property-stripRe'>    /**
</span>     * @property {RegExp} stripRe
     * A regular expression for stripping non-numeric characters from a numeric value.
     * This should be overridden for localization.
     * @readonly
     * @protected
     */
    stripRe: /[\$,%]/g,

<span id='Ext-data-field-Field-property-calculated'>    /**
</span>     * @property {Boolean} calculated
     * This property is `true` if this field has a `{@link #cfg-calculate calculate}`
     * method or a `{@link #method-convert convert}` method that operates on the entire
     * record as opposed to just the data value. This property is determined from the
     * `length` of the `{@link #method-convert convert}` function which means this is
     * *not* calculated:
     *
     *      convert: function (value) {
     *          return ...
     *      }
     *
     * While this *is* calculated:
     *
     *      convert: function (value, record) {
     *          return ...
     *      }
     *
     * **NOTE:** It is recommended for such fields to use `{@link #cfg-calculate calculate}`
     * or explicitly specify the fields used by `{@link #method-convert convert}` using
     * `{@link #cfg-depends depends}`.
     *
     * @readonly
     */
    calculated: false,

<span id='Ext-data-field-Field-property-evil'>    /**
</span>     * @property {Boolean} evil
     * This flag is set to true for fields that have `convert` methods which take the 2nd
     * argument (the record) and do not specify a `depends` set. Good fields indicate the
     * fields on which they depend (if any).
     * @private
     * @readonly
     */
    evil: false,

<span id='Ext-data-field-Field-property-identifier'>    /**
</span>     * @property {Boolean} identifier
     * This property is set to `true` if this is an {@link Ext.data.Model#idProperty id}
     * field.
     * @readonly
     */
    identifier: false,

<span id='Ext-data-field-Field-method-onClassExtended'>    onClassExtended: function (cls, data) {
</span>        var sortType = data.sortType,
            proto = cls.prototype,
            superValidators = proto.validators,
            validators = data.validators;

        if (sortType &amp;&amp; Ext.isString(sortType)) {
            proto.sortType = Ext.data.SortTypes[sortType];
        }

        if (validators) {
            // Force validators to be an array
            if (!Ext.isArray(validators)) {
                validators = [validators];
            }
            delete data.validators;

            // Need to join them
            if (superValidators) {
                validators = superValidators.concat(validators);
            }
            proto.validators = validators;
        }
    },

<span id='Ext-data-field-Field-property-argumentNamesRe'>    argumentNamesRe: /^function\s*\(\s*([^,\)\s]+)/,
</span><span id='Ext-data-field-Field-property-calculateRe'>    calculateRe: /[^\.a-z0-9_]([a-z_][a-z_0-9]*)\.([a-z_][a-z_0-9]*)/gi,
</span>
<span id='Ext-data-field-Field-method-constructor'>    constructor: function (config) {
</span>        var me = this,
            calculateRe = me.calculateRe,
            calculate, calculated, defaultValue, sortType,
            depends, map, match, dataProp, str, fld, validators;

        // NOTE: In bigger apps we create *lots* of these fellows so we really need to be
        // very lean here.

        if (config) {
            if (Ext.isString(config)) {
                me.name = config;
            } else {
                validators = config.validators;
                if (validators) {
                    delete config.validators;
                    me.instanceValidators = validators;
                }
                Ext.apply(me, config);
            }
        }

        if (!me.allowNull) {
            me.allowNull = !!me.reference;
        }

        calculate = me.calculate;
        depends = me.depends;

        if (calculate) {
            me.convert = me.doCalculate;

            if (!depends) {
                if (!(depends = calculate.$depends)) {
                    map = {};
                    str = calculate.toString();
                    calculate.$depends = depends = [];

                    match = me.argumentNamesRe.exec(str);
                    dataProp = match ? match[1] : &#39;data&#39;;

                    while ((match = calculateRe.exec(str))) {
                        if (dataProp === match[1] &amp;&amp; !map[fld = match[2]]) {
                            map[fld] = 1;
                            depends.push(fld);
                        }
                    }
                }

                me.depends = depends;
            }
        }

        defaultValue = me.defaultValue;
        if (me.convert) {
            me.calculated = calculated = me.convert.length &gt; 1;
            me.evil = calculated &amp;&amp; !depends;
        }

        if (me.persist === null) {
            me.persist = !calculate;
        }

        sortType = me.sortType;
        if (!me.sortType) {
            me.sortType = Ext.data.SortTypes.none;
        } else if (Ext.isString(sortType)) {
            me.sortType = Ext.data.SortTypes[sortType];
        }

        if (depends &amp;&amp; typeof depends === &#39;string&#39;) {
            me.depends = [depends];
        }

        me.cloneDefaultValue = defaultValue !== undefined &amp;&amp;
                               (Ext.isDate(defaultValue) || Ext.isArray(defaultValue) ||
                                Ext.isObject(defaultValue));
    },

<span id='Ext-data-field-Field-method-setModelValidators'>    setModelValidators: function(modelValidators) {
</span>        this._validators = null;
        this.modelValidators = modelValidators;
    },

<span id='Ext-data-field-Field-method-compileValidators'>    compileValidators: function() {
</span>        var me = this;
        me._validators = [];
        me.constructValidators(me.validators);
        me.constructValidators(me.modelValidators);
        me.constructValidators(me.instanceValidators);
    },

<span id='Ext-data-field-Field-method-constructValidators'>    constructValidators: function (validators) {
</span>        if (validators) {
            if (!(validators instanceof Array)) {
                validators = [validators];
            }

            var length = validators.length,
                all = this._validators,
                i, item;

            for (i = 0; i &lt; length; ++i) {
                item = validators[i];
                if (item.fn) {
                    item = item.fn;
                }
                all.push(Ext.Factory.dataValidator(item));
            }
        }
    },

<span id='Ext-data-field-Field-method-collate'>    /**
</span>     * Compares two values to retrieve their relative position in sort order, taking into account
     * any {@link #sortType}. Also see {@link #compare}.
     * @param {Object} value1 The first value.
     * @param {Object} value2 The second value.
     * @return {Number} `-1` if `value1` is less than `value2`. `1` if `value1` is greater than `value2`.
     * `0` otherwise.
     */
    collate: function (value1, value2) {
        var me = this,
            lhs = value1,
            rhs = value2;

        if (me.sortType) {
            lhs = me.sortType(lhs);
            rhs = me.sortType(rhs);
        }

        return (lhs === rhs) ? 0 : ((lhs &lt; rhs) ? -1 : 1);
    },

<span id='Ext-data-field-Field-method-compare'>    /**
</span>     * Compares two values to retrieve their relative position in sort order. Also see
     * {@link #collate}.
     * @param {Object} value1 The first value.
     * @param {Object} value2 The second value.
     * @return {Number} `-1` if `value1` is less than `value2`. `1` if `value1` is greater than `value2`.
     * `0` otherwise.
     */
    compare: function (value1, value2) {
        return (value1 === value2) ? 0 : ((value1 &lt; value2) ? -1 : 1);
    },

<span id='Ext-data-field-Field-method-isEqual'>    /**
</span>     * Tests whether two values are equal based on this field type.
     * This uses the {@link #compare} method to determine equality, so
     * this method should generally not be overridden.
     * @param {Object} value1 The first value.
     * @param {Object} value2 The second value.
     * @return {Boolean} `true` if the values are equal.
     */
    isEqual: function (value1, value2) {
        return this.compare(value1, value2) === 0;
    },

<span id='Ext-data-field-Field-method-convert'>    /**
</span>     * A function which converts the value provided by the Reader into the value that will
     * be stored in the record. This method can be overridden by a derived class or set as
     * a `{@link #cfg-convert convert}` config.
     *
     * If configured as `null`, then no conversion will be applied to the raw data property
     * when this Field is read. This will increase performance. but you must ensure that
     * the data is of the correct type and does not *need* converting.
     *
     * Example of convert functions:
     *
     *     function fullName(v, record){
     *         return record.data.last + &#39;, &#39; + record.data.first;
     *     }
     *
     *     function location(v, record){
     *         return !record.data.city ? &#39;&#39; : (record.data.city + &#39;, &#39; + record.data.state);
     *     }
     *
     *     Ext.define(&#39;Dude&#39;, {
     *         extend: &#39;Ext.data.Model&#39;,
     *         fields: [
     *             {name: &#39;fullname&#39;,  convert: fullName},
     *             {name: &#39;firstname&#39;, mapping: &#39;name.first&#39;},
     *             {name: &#39;lastname&#39;,  mapping: &#39;name.last&#39;},
     *             {name: &#39;city&#39;, defaultValue: &#39;unknown&#39;},
     *             &#39;state&#39;,
     *             {name: &#39;location&#39;,  convert: location}
     *         ]
     *     });
     *
     *     // create the data store
     *     var store = Ext.create(&#39;Ext.data.Store&#39;, {
     *         model: &#39;Dude&#39;,
     *         proxy: {
     *             type: &#39;memory&#39;,
     *             reader: {
     *                 type: &#39;json&#39;,
     *                 rootProperty: &#39;daRoot&#39;,
     *                 totalProperty: &#39;total&#39;
     *             }
     *         }
     *     });
     *
     *     var myData = [
     *         { key: 1,
     *           name: { first: &#39;Fat&#39;,    last:  &#39;Albert&#39; }
     *           // notice no city, state provided in data object
     *         },
     *         { key: 2,
     *           name: { first: &#39;Barney&#39;, last:  &#39;Rubble&#39; },
     *           city: &#39;Bedrock&#39;, state: &#39;Stoneridge&#39;
     *         },
     *         { key: 3,
     *           name: { first: &#39;Cliff&#39;,  last:  &#39;Claven&#39; },
     *           city: &#39;Boston&#39;,  state: &#39;MA&#39;
     *         }
     *     ];
     *
     * @method
     * @param {Mixed} value The data value as read by the Reader, if undefined will use
     * the configured `defaultValue`.
     * @param {Ext.data.Model} record The data object containing the Model as read so far
     * by the Reader. Note that the Model may not be fully populated at this point as the
     * fields are read in the order that they are defined.
     * {@link Ext.data.Model#cfg-fields fields} array.
     * @return {Mixed} The converted value for storage in the record.
     */
    convert: null,

<span id='Ext-data-field-Field-method-serialize'>    /**
</span>     * A function which converts the Model&#39;s value for this Field into a form which can be used by whatever {@link Ext.data.writer.Writer Writer}
     * is being used to sync data with the server.
     *
     * @method
     * @param {Mixed} value The Field&#39;s value - the value to be serialized.
     * @param {Ext.data.Model} record The record being serialized.
     * @return {String} The string that represents the Field&#39;s value.
     */
    serialize: null,

<span id='Ext-data-field-Field-method-validate'>    /**
</span>     * Validates the passed value for this field.
     *
     * @param {Object} value The value to validate.
     *
     * @param {String} [separator] This string is passed if the caller wants all validation
     * messages concatenated with this string between each. This can be handled as a
     * &quot;falsy&quot; value because concatenating with no separator is seldom desirable.
     *
     * @param {Ext.data.ErrorCollection} [errors] This parameter is passed if the caller
     * wants all validation results individually added to the collection.
     *
     * @return {Boolean/String} `true` if the value is valid. A string may be returned if
     * the value is not valid, to indicate an error message. Any other non `true` value
     * indicates the value is not valid. This method is not implemented by default,
     * subclasses may override it to provide an implementation.
     *
     * @protected
     * @template
     * @since 5.0.0
     */
    validate: function(value, separator, errors, record) {
        var me = this,
            ret = &#39;&#39;,
            result, validator, validators, length, i;

        if (!me._validators) {
            me.compileValidators();
        }

        validators = me._validators;

        for (i = 0, length = validators.length; i &lt; length; ++i) {
            validator = validators[i];
            result = validator.validate(value, record); 

            if (result !== true) {
                result = result || me.defaultInvalidMessage;
                if (errors) {
                    errors.add(me.name, result);
                    ret = ret || result;
                } else if (separator) {
                    if (ret) {
                        ret += separator;
                    }
                    ret += result;
                } else {
                    ret = result;
                    break;
                }
            }
        }

        return ret || true;
    },

<span id='Ext-data-field-Field-method-doCalculate'>    doCalculate: function (v, rec) {
</span>        return rec ? this.calculate(rec.data) : v;
    },

<span id='Ext-data-field-Field-method-getName'>    /**
</span>     * Gets the name for this field. See {@link #name}.
     * @return {String} name
     */
    getName: function() {
        return this.name;
    },

<span id='Ext-data-field-Field-method-getAllowBlank'>    /**
</span>     * Gets allowBlank for this field. See {@link #allowBlank}.
     * @return {Boolean} allowBlank
     */
    getAllowBlank: function() {
        return this.allowBlank;
    },

<span id='Ext-data-field-Field-method-getAllowNull'>    /**
</span>     * Gets allowNull for this field. See {@link #allowNull}.
     * @return {Boolean} allowNull
     */
    getAllowNull: function() {
        return this.allowNull;
    },

<span id='Ext-data-field-Field-method-getConvert'>    /**
</span>     * Gets converter for this field. See {@link #method-convert}.
     * @return {Function} convert
     */
    getConvert: function() {
        return this.convert;
    },

<span id='Ext-data-field-Field-method-getDefaultValue'>    /**
</span>     * Gets the defaultValue for this field. See {@link #defaultValue}.
     * @return {Object} defaultValue
     */
    getDefaultValue: function() {
        return this.defaultValue;
    },

<span id='Ext-data-field-Field-method-getDepends'>    /**
</span>     * Gets the depends for this field. See {@link #depends}.
     * @return {String[]} depends
     */
    getDepends: function() {
        return this.depends;
    },

<span id='Ext-data-field-Field-method-getMapping'>    /**
</span>     * Get the mapping for this field. See {@link #mapping}.
     * @return {Object} mapping
     */
    getMapping: function() {
        return this.mapping;
    },

<span id='Ext-data-field-Field-method-hasMapping'>    /**
</span>     * Checks if this field has a mapping applied.
     * @return {Boolean} `true` if this field has a mapping.
     */
    hasMapping: function() {
        var map = this.mapping;
        return !!(map || map === 0);
    },

<span id='Ext-data-field-Field-method-getPersist'>    /**
</span>     * Gets the persist for this field. See {@link #persist}.
     * @return {Boolean} persist
     */
    getPersist: function() {
        return this.persist;
    },

<span id='Ext-data-field-Field-method-getSortType'>    /**
</span>     * Gets the sortType for this field. See {@link #sortType}.
     * @return {Function} sortType
     */
    getSortType: function() {
        return this.sortType;
    },

<span id='Ext-data-field-Field-method-getType'>    /**
</span>     * Gets a string representation of the type of this field.
     * @return {String} type
     */
    getType: function() {
        return &#39;auto&#39;;
    },
<span id='Ext-data-field-Field-property-deprecated'>    deprecated: {
</span>        5.1: {
            methods: {
<span id='Ext-data-field-Field-method-getSortDir'>                /**
</span>                 * Gets the sortDir for this field.
                 * @return {String} sortDir
                 * @deprecated 5.1 Setting sortDir and calling getSortDir were never applied by the
                 * the Sorter.  This functionality does not natively exist on field instances.
                 */
                getSortDir: function () {
                    return this.sortDir;
                }
            }
        }
    }
});
</pre>
</body>
</html>
