<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-reader-Reader'>/**
</span> * Readers are used to interpret data to be loaded into a {@link Ext.data.Model Model} instance or a {@link
 * Ext.data.Store Store} - often in response to an AJAX request. In general there is usually no need to create
 * a Reader instance directly, since a Reader is almost always used together with a {@link Ext.data.proxy.Proxy Proxy},
 * and is configured using the Proxy&#39;s {@link Ext.data.proxy.Proxy#cfg-reader reader} configuration property:
 * 
 *     Ext.create(&#39;Ext.data.Store&#39;, {
 *         model: &#39;User&#39;,
 *         proxy: {
 *             type: &#39;ajax&#39;,
 *             url : &#39;users.json&#39;,
 *             reader: {
 *                 type: &#39;json&#39;,
 *                 rootProperty: &#39;users&#39;
 *             }
 *         },
 *     });
 *     
 * The above reader is configured to consume a JSON string that looks something like this:
 *  
 *     {
 *         &quot;success&quot;: true,
 *         &quot;users&quot;: [
 *             { &quot;name&quot;: &quot;User 1&quot; },
 *             { &quot;name&quot;: &quot;User 2&quot; }
 *         ]
 *     }
 * 
 *
 * # Loading Nested Data
 *
 * Readers have the ability to automatically load deeply-nested data objects based on the {@link Ext.data.schema.Association associations}
 * configured on each Model. Below is an example demonstrating the flexibility of these associations in a
 * fictional CRM system which manages a User, their Orders, OrderItems and Products. First we&#39;ll define the models:
 *
 *     Ext.define(&quot;User&quot;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             &#39;id&#39;, &#39;name&#39;
 *         ],
 *
 *         hasMany: {model: &#39;Order&#39;, name: &#39;orders&#39;},
 *
 *         proxy: {
 *             type: &#39;rest&#39;,
 *             url : &#39;users.json&#39;,
 *             reader: {
 *                 type: &#39;json&#39;,
 *                 rootProperty: &#39;users&#39;
 *             }
 *         }
 *     });
 *
 *     Ext.define(&quot;Order&quot;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             &#39;id&#39;, &#39;total&#39;
 *         ],
 *
 *         hasMany  : {model: &#39;OrderItem&#39;, name: &#39;orderItems&#39;, associationKey: &#39;order_items&#39;},
 *         belongsTo: &#39;User&#39;
 *     });
 *
 *     Ext.define(&quot;OrderItem&quot;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             &#39;id&#39;, &#39;price&#39;, &#39;quantity&#39;, &#39;order_id&#39;, &#39;product_id&#39;
 *         ],
 *
 *         belongsTo: [&#39;Order&#39;, {model: &#39;Product&#39;, associationKey: &#39;product&#39;}]
 *     });
 *
 *     Ext.define(&quot;Product&quot;, {
 *         extend: &#39;Ext.data.Model&#39;,
 *         fields: [
 *             &#39;id&#39;, &#39;name&#39;
 *         ],
 *
 *         hasMany: &#39;OrderItem&#39;
 *     });
 *
 * This may be a lot to take in - basically a User has many Orders, each of which is composed of several OrderItems.
 * Finally, each OrderItem has a single Product. This allows us to consume data like this:
 *
 *     {
 *         &quot;users&quot;: [
 *             {
 *                 &quot;id&quot;: 123,
 *                 &quot;name&quot;: &quot;Ed&quot;,
 *                 &quot;orders&quot;: [
 *                     {
 *                         &quot;id&quot;: 50,
 *                         &quot;total&quot;: 100,
 *                         &quot;order_items&quot;: [
 *                             {
 *                                 &quot;id&quot;      : 20,
 *                                 &quot;price&quot;   : 40,
 *                                 &quot;quantity&quot;: 2,
 *                                 &quot;product&quot; : {
 *                                     &quot;id&quot;: 1000,
 *                                     &quot;name&quot;: &quot;MacBook Pro&quot;
 *                                 }
 *                             },
 *                             {
 *                                 &quot;id&quot;      : 21,
 *                                 &quot;price&quot;   : 20,
 *                                 &quot;quantity&quot;: 3,
 *                                 &quot;product&quot; : {
 *                                     &quot;id&quot;: 1001,
 *                                     &quot;name&quot;: &quot;iPhone&quot;
 *                                 }
 *                             }
 *                         ]
 *                     }
 *                 ]
 *             }
 *         ]
 *     }
 *
 * The JSON response is deeply nested - it returns all Users (in this case just 1 for simplicity&#39;s sake), all of the
 * Orders for each User (again just 1 in this case), all of the OrderItems for each Order (2 order items in this case),
 * and finally the Product associated with each OrderItem. Now we can read the data and use it as follows:
 *
 *     var store = Ext.create(&#39;Ext.data.Store&#39;, {
 *         model: &quot;User&quot;
 *     });
 *
 *     store.load({
 *         callback: function() {
 *             //the user that was loaded
 *             var user = store.first();
 *
 *             console.log(&quot;Orders for &quot; + user.get(&#39;name&#39;) + &quot;:&quot;)
 *
 *             //iterate over the Orders for each User
 *             user.orders().each(function(order) {
 *                 console.log(&quot;Order ID: &quot; + order.getId() + &quot;, which contains items:&quot;);
 *
 *                 //iterate over the OrderItems for each Order
 *                 order.orderItems().each(function(orderItem) {
 *                     //we know that the Product data is already loaded, so we can use the synchronous getProduct
 *                     //usually, we would use the asynchronous version (see #belongsTo)
 *                     var product = orderItem.getProduct();
 *
 *                     console.log(orderItem.get(&#39;quantity&#39;) + &#39; orders of &#39; + product.get(&#39;name&#39;));
 *                 });
 *             });
 *         }
 *     });
 *
 * Running the code above results in the following:
 *
 *     Orders for Ed:
 *     Order ID: 50, which contains items:
 *     2 orders of MacBook Pro
 *     3 orders of iPhone
 */
Ext.define(&#39;Ext.data.reader.Reader&#39;, {
    alternateClassName: [&#39;Ext.data.Reader&#39;, &#39;Ext.data.DataReader&#39;],

    requires: [
        &#39;Ext.data.ResultSet&#39;,
        &#39;Ext.XTemplate&#39;,
        &#39;Ext.util.LruCache&#39;
    ],

    mixins: [
        &#39;Ext.mixin.Observable&#39;,
        &#39;Ext.mixin.Factoryable&#39;
    ],

    alias: &#39;reader.base&#39;,
<span id='Ext-data-reader-Reader-property-factoryConfig'>    factoryConfig: {
</span>        defaultType: null
    },

    config: {
<span id='Ext-data-reader-Reader-cfg-totalProperty'>        /**
</span>        * @cfg {String} [totalProperty]
        * Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
        * the whole dataset is not passed in one go, but is being paged from the remote server.
        */
        totalProperty: &#39;total&#39;,

<span id='Ext-data-reader-Reader-cfg-successProperty'>        /**
</span>        * @cfg {String} [successProperty]
        * Name of the property from which to retrieve the `success` attribute, the value of which indicates
        * whether a given request succeeded or failed (typically a boolean or &#39;true&#39;|&#39;false&#39;). See
        * {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
        */
        successProperty: &#39;success&#39;,
       
<span id='Ext-data-reader-Reader-cfg-rootProperty'>        /**
</span>         * @cfg {String/Function} rootProperty
         * The property that contains data items corresponding to the 
         * Model(s) of the configured Reader. `rootProperty` varies by Reader type.
         * 
         * ##JSON Reader 
         * `rootProperty` is a property name. It may also be a dot-separated 
         * list of property names if the root is nested. The root JSON array will be 
         * used by default.
         * 
         *     // rootPropety config
         *     rootProperty: &#39;embedded.myresults&#39;
         *     
         *     // server response
         *     {
         *         embedded: {
         *             myresults: [{
         *                 name: &#39;Scott&#39;,
         *                 age: 22
         *             }, {
         *                 name: &#39;Ramona&#39;,
         *                 age: 24
         *             }]
         *         },
         *         success: true
         *     }
         * 
         * ##XML Reader 
         * `rootProperty` is a CSS selector. The root XML element will be used
         * by default.
         * 
         *     // rootProperty config (plus record config)
         *     rootProperty: &#39;myresults&#39;,
         *     record: &#39;user&#39;
         *     
         *     // server response
         *     &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
         *     &lt;embedded&gt;
         *         &lt;myresults&gt;
         *             &lt;user&gt;
         *                 &lt;name&gt;Scott&lt;/name&gt;
         *                 &lt;age&gt;22&lt;/age&gt;
         *             &lt;/user&gt;
         *             &lt;user&gt;
         *                 &lt;name&gt;Ramona&lt;/name&gt;
         *                 &lt;age&gt;24&lt;/age&gt;
         *             &lt;/user&gt;
         *         &lt;/myresults&gt;
         *     &lt;/embedded&gt;
         * 
         * ##Array Reader 
         * `rootProperty` is not typically applicable since the data is assumed to be a
         * single-level array of arrays.  However, if the array of records is returned 
         * within a JSON response a `rootProperty` config may be used:
         * 
         *     // rootProperty config
         *     rootProperty: &#39;embedded.myresults&#39;
         *     
         *     // server response
         *     {
         *         embedded: {
         *             myresults: [[&#39;Scott&#39;, 22], [&#39;Ramona&#39;, 24]]
         *         },
         *         success: true
         *     }
         * 
         * ##rootProperty as a function
         * The `rootProperty` may also be a function that returns the root node from 
         * the dataset. For example:
         *
         *     var store = Ext.create(&#39;Ext.data.TreeStore&#39;, {
         *         proxy: {
         *             type: &#39;memory&#39;,
         *             reader: {
         *                 type: &#39;json&#39;,
         *                 rootProperty: function(data){
         *                     // Extract child nodes from the items or children property in the dataset
         *                     return data.items || data.children;
         *                 }
         *             }
         *         }, 
         *         data: {
         *             items: [{
         *                 text: &#39;item 1&#39;,
         *                 children: [{
         *                     text: &#39;child A&#39;,
         *                     leaf: true
         *                 }]
         *             }]
         *         }
         *     });
         *
         *     Ext.create(&#39;Ext.tree.Panel&#39;, {
         *         title: &#39;rootProperty as a function&#39;,
         *         width: 200,
         *         height:150,
         *         store: store,
         *         rootVisible: false,
         *         renderTo: Ext.getBody()
         *     });
         */
         rootProperty: &#39;&#39;,
    
<span id='Ext-data-reader-Reader-cfg-messageProperty'>        /**
</span>        * @cfg {String} messageProperty
        * The name of the property which contains a response message for exception handling. If you want to return a false success
        * response from the server, maybe due to some server-side validation, the messageProperty can hold the error message. For
        * example:
        *
        *     {
        *         &quot;success&quot;: false,
        *         &quot;error&quot;: &quot;There was an error with your request&quot;
        *     }
        *
        * You can retrieve this error message in a callback when loading a {@link Ext.data.Store Store} or {@link Ext.data.Model Model} like:
        *
        *     var store = new Ext.data.Store({
        *         fields : [&#39;foo&#39;],
        *         proxy  : {
        *             type   : &#39;ajax&#39;,
        *             url    : &#39;data.json&#39;,
        *             reader : {
        *                 type            : &#39;json&#39;,
        *                 rootProperty    : &#39;data&#39;,
        *                 messageProperty : &#39;error&#39;
        *             }
        *         }
        *     });
        *
        *     store.load({
        *         callback: function(records, operation, success) {
        *             if (success) {
        *                 // ...
        *             } else {
        *                 var error = operation.getError();
        *
        *                 Ext.Msg.alert(&#39;Error&#39;, error);
        *             }
        *         }
        *     });
        *
        * In this example, the callback will execute with `success` being `false` and will therefore show the {@link Ext.MessageBox#alert Ext.Msg.alert} with
        * the error string returned in the response.
        */
       messageProperty: &#39;&#39;,

<span id='Ext-data-reader-Reader-cfg-typeProperty'>       /**
</span>        * @cfg {String} [typeProperty]
        * The name of the property in a node raw data block which indicates the type of the model to be created from that raw data. Useful for heterogeneous trees.
        *
        * For example, hierarchical geographical data may look like this:
        *
        *     {
        *         nodeType: &#39;Territory&#39;,
        *         name: &#39;EMEA&#39;,
        *         children: [{
        *             nodeType: &#39;Country&#39;,
        *             name: &#39;United Kingdon&#39;,
        *             children: [{
        *                 nodeType: &#39;City&#39;,
        *                 name: &#39;London&#39;
        *             }]
        *         }]
        *     }
        *
        * You would configure the typeProperty in this case to be `&quot;nodeType&quot;` which would cause the models named &quot;Territory&quot;, &quot;Country&quot; and &quot;City&quot; to
        * be used.
        */
       typeProperty: &#39;&#39;,
    
<span id='Ext-data-reader-Reader-cfg-implicitIncludes'>        /**
</span>        * @cfg {Boolean} [implicitIncludes]
        * True to automatically parse models nested within other models in a response object. See the
        * Ext.data.reader.Reader intro docs for full explanation.
        */
        implicitIncludes: true,
    
<span id='Ext-data-reader-Reader-cfg-readRecordsOnFailure'>        /**
</span>        * @cfg {Boolean} [readRecordsOnFailure]
        * True to extract the records from a data packet even if the {@link #successProperty} returns false.
        */
        readRecordsOnFailure: true,
        
<span id='Ext-data-reader-Reader-cfg-model'>        /**
</span>         * @cfg {String/Ext.data.Model} [model]
         * The model to use for this reader. This config is only required if the reader is being used
         * without a proxy, otherwise the proxy will automatically set the model.
         */
        model: null,
        
<span id='Ext-data-reader-Reader-cfg-proxy'>        /**
</span>         * @cfg {Ext.data.proxy.Proxy} [proxy]
         * The proxy attached to this reader. Typically only needed onMetaChange so that
         * we can set the new model on the proxy.
         * @private
         */
        proxy: null,
        
<span id='Ext-data-reader-Reader-cfg-transform'>        /**
</span>         * @cfg {Function|String|Object} [transform]
         * If a transform function is set, it will be invoked just before {@link #readRecords} executes.
         * It is passed the raw (deserialized) data object. The transform function returns a data object, which can be
         * a modified version of the original data object, or a completely new data object. The transform can
         * be a function, or a method name on the Reader instance, or an object with a &#39;fn&#39; key
         * and an optional &#39;scope&#39; key.
         *
         * Example usage:
         *
         *     Ext.create(&#39;Ext.data.Store&#39;, {
         *         model: &#39;User&#39;,
         *         proxy: {
         *             type: &#39;ajax&#39;,
         *             url : &#39;users.json&#39;,
         *             reader: {
         *                 type: &#39;json&#39;,
         *                 transform: {
         *                     fn: function(data) {
         *                         // do some manipulation of the raw data object
         *                         return data;
         *                     },
         *                     scope: this
         *                 }
         *             }
         *         },
         *     });
         *
         */ 
        transform: null,
        
<span id='Ext-data-reader-Reader-cfg-keepRawData'>        /**
</span>         * @cfg {Boolean} [keepRawData] Determines if the Reader will keep raw data
         * received from the server in the {@link #rawData} property.
         *
         * While this might seem useful to do additional data processing, keeping raw data
         * might cause adverse effects such as memory leaks. It is recommended to set
         * `keepRawData` to `false` if you do not need the raw data.
         *
         * If you need to process data packet to extract additional data such as row summaries,
         * it is recommended to use {@link #transform} function for that purpose.
         *
         * Note that starting with Ext JS 6.0 the default behavior has been changed to
         * **not** keep the raw data because of the high potential for memory leaks.
         * @since 5.1.1
         */
        keepRawData: null
    },
    
<span id='Ext-data-reader-Reader-property-rawData'>    /**
</span>     * @property {Object} rawData
     * The raw data object that was last passed to {@link #readRecords}. rawData is populated 
     * based on the results of {@link Ext.data.proxy.Server#processResponse}. rawData will 
     * maintain a cached copy of the last successfully returned records. In other words, 
     * if processResponse is unsuccessful, the records from the last successful response 
     * will remain cached in rawData.
     *
     * Since Ext JS 5.1.1 you can use the {@link #keepRawData} config option to
     * control this behavior.
     */
    
<span id='Ext-data-reader-Reader-property-metaData'>    /**
</span>     * @property {Object} metaData
     * The raw meta data that was most recently read, if any. Meta data can include existing
     * Reader config options like {@link #totalProperty}, etc. that get
     * automatically applied to the Reader, and those can still be accessed directly from the Reader
     * if needed. However, meta data is also often used to pass other custom data to be processed
     * by application code. For example, it is common when reconfiguring the data model of a grid to
     * also pass a corresponding column model config to be applied to the grid. Any such data will
     * not get applied to the Reader directly (it just gets passed through and is ignored by Ext).
     * This metaData property gives you access to all meta data that was passed, including any such
     * custom data ignored by the reader.
     * 
     * This is a read-only property, and it will get replaced each time a new meta data object is
     * passed to the reader. Note that typically you would handle proxy&#39;s
     * {@link Ext.data.proxy.Proxy#metachange metachange} event which passes this exact same meta
     * object to listeners. However this property is available if it&#39;s more convenient to access it
     * via the reader directly in certain cases.
     * @readonly
     */
    
<span id='Ext-data-reader-Reader-property-isReader'>    /**
</span>     * @property {Boolean} isReader
     * `true` in this class to identify an object as an instantiated Reader, or subclass thereof.
     **/
    isReader: true,
    
<span id='Ext-data-reader-Reader-event-exception'>    /**
</span>     * @event exception
     * Fires when the reader receives improperly encoded data from the server
     * @param {Ext.data.reader.Reader} reader A reference to this reader
     * @param {XMLHttpRequest} response The XMLHttpRequest response object
     * @param {Ext.data.ResultSet} error The error object
     */

<span id='Ext-data-reader-Reader-method-constructor'>    /**
</span>     * Creates new Reader.
     * @param {Object} [config] Config object.
     */
    constructor: function(config) {
        if (config &amp;&amp; config.hasOwnProperty(&#39;root&#39;)) {
            config = Ext.apply({}, config);
            config.rootProperty = config.root;
            delete config.root;
            //&lt;debug&gt;
            Ext.log.error(&#39;Ext.data.reader.Reader: Using the deprecated &quot;root&quot; configuration. Use &quot;rootProperty&quot; instead.&#39;);
            //&lt;/debug&gt;
        }

        var me = this;
        me.duringInit = 1;
        // Will call initConfig
        me.mixins.observable.constructor.call(me, config);
        --me.duringInit;
        me.buildExtractors();
    },
    
<span id='Ext-data-reader-Reader-method-applyModel'>    applyModel: function (model) {
</span>        return Ext.data.schema.Schema.lookupEntity(model);
    },
    
<span id='Ext-data-reader-Reader-method-applyTransform'>    applyTransform: function(transform) {
</span>        if (transform) {
            if (Ext.isFunction(transform)) {
                transform = {fn:transform};
            }
            else if (transform.charAt) { // faster than Ext.isString()
                transform = { fn: this[transform] };
            }
            
            return transform.fn.bind(transform.scope || this);
        }
        
        return transform;
    },
    
<span id='Ext-data-reader-Reader-method-forceBuildExtractors'>    forceBuildExtractors: function() {
</span>        if (!this.duringInit) {
            this.buildExtractors(true);
        }
    },
    
<span id='Ext-data-reader-Reader-method-updateTotalProperty'>    updateTotalProperty: function() {
</span>        this.forceBuildExtractors();    
    },
    
<span id='Ext-data-reader-Reader-method-updateMessageProperty'>    updateMessageProperty: function() {
</span>        this.forceBuildExtractors();    
    },
    
<span id='Ext-data-reader-Reader-method-updateSuccessProperty'>    updateSuccessProperty: function() {
</span>        this.forceBuildExtractors();
    },

<span id='Ext-data-reader-Reader-method-read'>    /**
</span>     * Reads the given response object. This method normalizes the different types of response object that may be passed to it.
     * If it&#39;s an XMLHttpRequest object, hand off to the subclass&#39; {@link #getResponseData} method.
     * Else, hand off the reading of records to the {@link #readRecords} method.
     * @param {Object} response The response object. This may be either an XMLHttpRequest object or a plain JS object
     * @param {Object} [readOptions] Various options that instruct the reader on how to read the data
     * @param {Function} [readOptions.recordCreator] A function to construct the model based on the processed data. By default,
     * this just calls the model constructor and passes the raw data.
     * @return {Ext.data.ResultSet} The parsed or default ResultSet object
     */
    read: function(response, readOptions) {
        var data, result, responseText;

        if (response) {
            responseText = response.responseText
            if (responseText) {
                result = this.getResponseData(response);
                if (result &amp;&amp; result.__$isError) {
                    return new Ext.data.ResultSet({
                        total  : 0,
                        count  : 0,
                        records: [],
                        success: false,
                        message: result.msg
                    });
                } else {
                    data = this.readRecords(result, readOptions);
                }
            } else if (responseText !== &#39;&#39;) {
                data = this.readRecords(response, readOptions);
            }
        }

        return data || this.nullResultSet;
    },

<span id='Ext-data-reader-Reader-method-getNullResultSet'>    /**
</span>     * Returns the shared null result set.
     * @return {Ext.data.ResultSet} The null result set.
     * 
     * @private
     */
    getNullResultSet: function() {
        return this.nullResultSet;
    },

<span id='Ext-data-reader-Reader-method-createReadError'>    /**
</span>     * Creates an object that identifies a read error occurred.
     * @param {String} msg An error message to include
     * @return {Object} An error object
     * 
     * @private
     */
    createReadError: function(msg) {
        return {
            __$isError: true,
            msg: msg    
        };
    },

<span id='Ext-data-reader-Reader-method-readRecords'>    /**
</span>     * Abstracts common functionality used by all Reader subclasses. Each subclass is expected to call this function
     * before running its own logic and returning the Ext.data.ResultSet instance. For most Readers additional
     * processing should not be needed.
     * @param {Object} data The raw data object
     * @param {Object} [readOptions] See {@link #read} for details.
     * @return {Ext.data.ResultSet} A ResultSet object
     */
    readRecords: function(data, readOptions, /* private */ internalReadOptions) {
        var me = this,
            recordsOnly = internalReadOptions &amp;&amp; internalReadOptions.recordsOnly,
            asRoot = internalReadOptions &amp;&amp; internalReadOptions.asRoot,
            success,
            recordCount,
            records,
            root,
            total,
            value,
            message,
            transform,
            meta;

        // Extract the metadata to return with the ResultSet.
        // If found reconfigure accordingly.
        // The calling Proxy fires its metachange event if it finds metadata in the ResultSet.
        meta = me.getMeta ? me.getMeta(data) : data.metaData;
        if (meta) {
            me.onMetaChange(meta);
        }

        transform = me.getTransform();
        if (transform) {
            data = transform(data);
        }
          
        me.buildExtractors();
        
        if (me.getKeepRawData()) {
            me.rawData = data;
        }
        
        if (me.hasListeners.rawdata) {
            me.fireEventArgs(&#39;rawdata&#39;, [data]);
        }

        data = me.getData(data);
        
        success = true;
        recordCount = 0;
        records = [];
            
        if (me.getSuccessProperty()) {
            value = me.getSuccess(data);
            if (value === false || value === &#39;false&#39;) {
                success = false;
            }
        }
        
        if (me.getMessageProperty()) {
            message = me.getMessage(data);
        }

        
        // Only try and extract other data if call was successful
        if (success || me.getReadRecordsOnFailure()) {
            // If we pass an array as the data, we don&#39;t use getRoot on the data.
            // Instead the root equals to the data.
            root = (asRoot || Ext.isArray(data)) ? data : me.getRoot(data);
            
            if (root) {
                total = root.length;
            }

          if (me.getTotalProperty()) {
                value = parseInt(me.getTotal(data), 10);
                if (!isNaN(value)) {
                    total = value;
                }
            }

           if (root) {
                records = me.extractData(root, readOptions);
                recordCount = records.length;
            }
        }

        return recordsOnly ? records : new Ext.data.ResultSet({
            total    : total || recordCount,
            metadata : meta,
            count    : recordCount,
            records  : records,
            success  : success,
            message  : message
        });
    },

<span id='Ext-data-reader-Reader-method-extractData'>    /**
</span>     * Returns extracted, type-cast rows of data.
     * @param {Object[]/Object} root from server response
     * @param {Object} [readOptions] An object containing extra options.
     * @param {Function} [readOptions.model] The Model constructor to use.
     * @param {Function} [readOptions.recordCreator] A function to use to create and initialize records. By default a function
     * is supplied which creates *non-phantom* records on the assumnption that a Reader is going to be used to read server-supplied data.
     * @param {Object} [readOptions.recordCreator.data] The raw data used to create a record.
     * @param {Function} [readOptions.recordCreator.Model] The Model constructor to use to create the record.
     * @return {Array} An array of records containing the extracted data		
     * @private
     */
    extractData: function(root, readOptions) {
        var me = this,
            entityType = readOptions &amp;&amp; readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : me.getModel(),
            schema = entityType.schema,
            includes = schema.hasAssociations(entityType) &amp;&amp; me.getImplicitIncludes(),
            fieldExtractorInfo = me.getFieldExtractorInfo(entityType.fieldExtractors),
            length = root.length,
            records = new Array(length),
            typeProperty = me.getTypeProperty(),
            reader, node, nodeType, record, i;
            
        if (!length &amp;&amp; Ext.isObject(root)) {
            root = [root];
            length = 1;
        }

        for (i = 0; i &lt; length; i++) {
            record = root[i];
            if (!record.isModel) {
                // If we&#39;re given a model instance in the data, just push it on
                // without doing any conversion. Otherwise, create a record.
                node = record;

                // This Reader may be configured to produce different model types based on
                // a differentiator field in the incoming data:
                // typeProperty name be a string, a function which yields the child type, or an object: {
                //     name: &#39;mtype&#39;,
                //     namespace: &#39;MyApp&#39;
                // }
                if (typeProperty &amp;&amp; (nodeType = me.getChildType(schema, node, typeProperty))) {

                    reader = nodeType.getProxy().getReader();

                    record = reader.extractRecord(node, readOptions, nodeType,
                                schema.hasAssociations(nodeType) &amp;&amp; reader.getImplicitIncludes(),
                                reader.getFieldExtractorInfo(nodeType.fieldExtractors));
                } else {
                    record = me.extractRecord(node, readOptions, entityType, includes,
                                              fieldExtractorInfo);
                }
                
                // Generally we don&#39;t want to have references to XML documents
                // or XML nodes to hang around in memory but Trees need to be able
                // to access the raw XML node data in order to process its children.
                // See https://sencha.jira.com/browse/EXTJS-15785 and
                // https://sencha.jira.com/browse/EXTJS-14286
                if (record.isModel &amp;&amp; record.isNode) {
                    record.raw = node;
                }
            }
            if (record.onLoad) {
                record.onLoad();
            }
            records[i] = record;
        }

        return records;
    },

<span id='Ext-data-reader-Reader-method-getChildType'>    // Based upon a Reader&#39;s typeProperty config, determine the type of child node to create from the raw data
</span>    getChildType: function(schema, rawNode, typeProperty) {
        var namespace;

        switch (typeof typeProperty) {
            case &#39;string&#39;:
                return schema.getEntity(rawNode[typeProperty]);
            case &#39;object&#39;:
                namespace = typeProperty.namespace;
                return schema.getEntity((namespace ? namespace + &#39;.&#39; : &#39;&#39;) + rawNode[typeProperty.name]);
            case &#39;function&#39;:
                return schema.getEntity(typeProperty(rawNode));
        }
    },

<span id='Ext-data-reader-Reader-method-extractRecordData'>    extractRecordData: function(node, readOptions) {
</span>        var entityType = readOptions &amp;&amp; readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : this.getModel(),
            fieldExtractorInfo = this.getFieldExtractorInfo(entityType.fieldExtractors);

        return this.extractRecord(node, readOptions, entityType, false, fieldExtractorInfo);
    },

<span id='Ext-data-reader-Reader-method-extractRecord'>    extractRecord: function (node, readOptions, entityType, includes, fieldExtractorInfo) {
</span>        var me = this,
            creatorFn = (readOptions &amp;&amp; readOptions.recordCreator) || me.defaultRecordCreator,
            modelData, record;
            
        // Create a record with an empty data object.
        // Populate that data object by extracting and converting field values from raw data.
        // Must pass the ID to use because we pass no data for the constructor to pluck an ID from
        modelData = me.extractModelData(node, fieldExtractorInfo);
        record = creatorFn.call(me, modelData, entityType || me.getModel(), readOptions);
        if (includes &amp;&amp; record.isModel) {
            me.readAssociated(record, node, readOptions);
        }
        return record;
    },
    
<span id='Ext-data-reader-Reader-method-getFieldExtractorInfo'>    getFieldExtractorInfo: function(extractors) {
</span>        // If the base Ext.data.Model class is being used, there will be no extractor info
        // The raw data block will be imported unchanged.
        if (!extractors) {
            return;
        }

        var type = this.$className,
            extractor = extractors[type];
            
        // If we have no extractors, buildFieldExtractors will return null,
        // so we never need to rebuild them
        if (extractor === undefined) {
            extractors[type] = extractor = this.buildFieldExtractors();
        }   
        return extractor;
    },
    
<span id='Ext-data-reader-Reader-method-buildFieldExtractors'>    buildFieldExtractors: function() {
</span>        var fields = this.getFields(),
            len = fields.length,
            buffer = [],
            extractors = [],
            out = null,
            cnt = 0,
            field, name, i, extractor;
        
        for (i = 0; i &lt; len; ++i) {
            field = fields[i];
            extractor = this.createFieldAccessor(field);
            if (extractor) {
                name = field.name;
                // Use [] property access since we may have non-JS looking field names
                buffer.push(&#39;val = extractors[&#39; + cnt + &#39;](raw); if (val !== undefined) { data[\&#39;&#39; + name + &#39;\&#39;] = val; }&#39;);
                extractors.push(extractor);
                ++cnt;
            }
        }
        
        if (buffer.length) {
            out = {
                extractors: extractors,
                fn: new Function(&#39;raw&#39;, &#39;data&#39;, &#39;extractors&#39;, &#39;var val;&#39; + buffer.join(&#39;&#39;))  
            };
        }
        return out;
    },
    
<span id='Ext-data-reader-Reader-method-defaultRecordCreator'>    defaultRecordCreator: function (data, Model) {
</span>        var record = new Model(data);
        // If the server did not include an id in the response data, the Model constructor will mark the record as phantom.
        // We  need to set phantom to false here because records created from a server response using a reader by definition are not phantom records.
        record.phantom = false;
        return record;
    },
    
<span id='Ext-data-reader-Reader-method-getModelData'>    getModelData: function(raw) {
</span>        return {};
    },
    
<span id='Ext-data-reader-Reader-method-extractModelData'>    extractModelData: function(raw, fieldExtractorInfo) {
</span>        var data = this.getModelData(raw),
            fn;
            
        // We may not have any mappings to process
        if (fieldExtractorInfo) {
            fn = fieldExtractorInfo.fn;
            fn(raw, data, fieldExtractorInfo.extractors);
        }
        return data;
    },

<span id='Ext-data-reader-Reader-method-readAssociated'>    /**
</span>     * Loads the record associations from the data object.
     * @param {Ext.data.Model} record The record to load associations for.
     * @param {Object} data The raw data object.
     * @param {Object} readOptions See {@link #read}.
     *
     * @private
     */
    readAssociated: function(record, data, readOptions) {
        var roles = record.associations,
            key, role;
            
        for (key in roles) {
            if (roles.hasOwnProperty(key)) {
                role = roles[key];
                // The class for the other role may not have loaded yet
                if (role.cls) {
                    role.read(record, data, this, readOptions);
                }
            }
        }
    },
    
<span id='Ext-data-reader-Reader-method-getFields'>    getFields: function() {
</span>        return this.getModel().fields;
    },

<span id='Ext-data-reader-Reader-method-getData'>    /**
</span>     * @method
     * This method provides a hook to do any data transformation before the reading process
     * begins. By default this function just returns what is passed to it. It can be
     * overridden in a subclass to return something else.
     * See {@link Ext.data.reader.Xml XmlReader} for an example.
     * 
     * @param {Object} data The data object
     * @return {Object} The normalized data object
     * @protected
     * @template
     */
    getData: Ext.identityFn,

<span id='Ext-data-reader-Reader-method-getRoot'>    /**
</span>     * @method
     * This will usually need to be implemented in a subclass. Given a generic data object (the type depends on the type
     * of data we are reading), this function should return the object as configured by the Reader&#39;s &#39;root&#39; meta data config.
     * See XmlReader&#39;s getRoot implementation for an example. By default the same data object will simply be returned.
     *
     * @param {Object} data The data object
     * @return {Object} The same data object
     * @private
     */
    getRoot: Ext.identityFn,

<span id='Ext-data-reader-Reader-method-getResponseData'>    /**
</span>     * Takes a raw response object (as passed to the {@link #read} method) and returns the useful data
     * segment from it. This must be implemented by each subclass.
     * @param {Object} response The response object
     * @return {Object} The extracted data from the response. For example, a JSON object or an XML document.
     */
    getResponseData: function(response) {
        //&lt;debug&gt;
        Ext.raise(&quot;getResponseData must be implemented in the Ext.data.reader.Reader subclass&quot;);
        //&lt;/debug&gt;
    },

<span id='Ext-data-reader-Reader-method-onMetaChange'>    /**
</span>     * @private
     * Reconfigures the meta data tied to this Reader
     */
    onMetaChange : function(meta) {
        var me = this,
            fields = meta.fields,
            model,
            newModel,
            clientIdProperty,
            proxy;
        
        // save off the raw meta data
        me.metaData = meta;
        
        // set any reader-specific configs from meta if available
        if (meta.root) {
            me.setRootProperty(meta.root);
        }
        
        if (meta.totalProperty) {
            me.setTotalProperty(meta.totalProperty);
        }
        
        if (meta.successProperty) {
            me.setSuccessProperty(meta.successProperty);
        }
        
        if (meta.messageProperty) {
            me.setMessageProperty(meta.messageProperty);
        }

        clientIdProperty = meta.clientIdProperty;
        if (fields) {
            newModel = Ext.define(null, {
                extend: &#39;Ext.data.Model&#39;,
                fields: fields,
                clientIdProperty: clientIdProperty
            });
            me.setModel(newModel);
            proxy = me.getProxy();
            if (proxy) {
                proxy.setModel(newModel);
            }
        } else if (clientIdProperty) {
            model = me.getModel();
            if (model) {
                model.self.prototype.clientIdProperty = clientIdProperty;
            }
        }
    },

<span id='Ext-data-reader-Reader-method-buildExtractors'>    /**
</span>     * @private
     * This builds optimized functions for retrieving record data and meta data from an object.
     * Subclasses may need to implement their own getRoot function.
     * @param {Boolean} [force=false] True to automatically remove existing extractor functions first
     */
    buildExtractors: function(force) {
        var me = this,
            totalProp, successProp, messageProp;
            
        if (force || !me.hasExtractors) {
            totalProp = me.getTotalProperty();
            successProp = me.getSuccessProperty();
            messageProp = me.getMessageProperty(); 

            //build the extractors for all the meta data
            if (totalProp) {
                me.getTotal = me.getAccessor(totalProp);
            }

            if (successProp) {
                me.getSuccess = me.getAccessor(successProp);
            }

            if (messageProp) {
                me.getMessage = me.getAccessor(messageProp);
            }
            me.hasExtractors = true;
            return true;
        }
    },

<span id='Ext-data-reader-Reader-method-getAccessor'>    getAccessor: function(prop) {
</span>        var me = this,
            cache = me.extractorCache,
            ret, key;

        if (typeof prop === &#39;string&#39;) {
            key = me.getAccessorKey(prop);
            ret = cache.get(key);
            if (!ret) {
                ret = me.createAccessor(prop);
                cache.add(key, ret);
            }
        } else {
            ret = me.createAccessor(prop);
        }
        return ret;
    },

<span id='Ext-data-reader-Reader-method-getAccessorKey'>    getAccessorKey: function(prop) {
</span>        return this.$className + prop;
    },
    
<span id='Ext-data-reader-Reader-method-createAccessor'>    createAccessor: Ext.emptyFn,
</span>    
<span id='Ext-data-reader-Reader-method-createFieldAccessor'>    createFieldAccessor: Ext.emptyFn,
</span>
<span id='Ext-data-reader-Reader-method-destroy'>    destroy: function() {
</span>        var me = this;

        me.model = me.getTotal = me.getSuccess = me.getMessage = me.rawData = null;
        
        // Proxy could have created a sequence
        me.onMetaChange = null;
        
        // Transform function can be bound
        me.transform = null;
        
        me.callParent();
    },

<span id='Ext-data-reader-Reader-property-privates'>    privates: {
</span>        copyFrom: function(reader) {
            var me = this;

            reader.buildExtractors();
            me.getTotal = reader.getTotal;
            me.getSuccess = reader.getSuccess;
            me.getMessage = reader.getMessage;
            ++me.duringInit;
            me.setConfig(reader.getConfig());
            --me.duringInit;
            me.hasExtractors = true;
        }
    }
}, function(Cls) {
    var proto = Cls.prototype;
    Ext.apply(proto, {
        // Private. Empty ResultSet to return when response is falsy (null|undefined|empty string)
        nullResultSet: new Ext.data.ResultSet({
            total  : 0,
            count  : 0,
            records: [],
            success: true,
            message: &#39;&#39;
        })
    });

    proto.extractorCache = new Ext.util.LruCache();
});
</pre>
</body>
</html>
