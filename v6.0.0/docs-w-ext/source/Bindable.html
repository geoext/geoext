<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-mixin-Bindable'>/**
</span> * This class is intended as a mixin for classes that want to provide a &quot;bind&quot; config that
 * connects to a `ViewModel`.
 * @private
 * @since 5.0.0
 */
Ext.define(&#39;Ext.mixin.Bindable&#39;, {
<span id='Ext-mixin-Bindable-property-mixinId'>    mixinId: &#39;bindable&#39;,
</span>
    config: {
<span id='Ext-mixin-Bindable-cfg-bind'>        /**
</span>         * @cfg {Object} [bind]
         * Setting this config option adds or removes data bindings for other configs.
         * For example, to bind the `title` config:
         *
         *      var panel = Ext.create({
         *          xtype: &#39;panel&#39;,
         *          bind: {
         *              title: &#39;Hello {user.name}&#39;
         *          }
         *      });
         *
         * To dynamically add bindings:
         *
         *      panel.setBind({
         *          title: &#39;Greetings {user.name}!&#39;
         *      });
         *
         * To remove bindings:
         *
         *      panel.setBind({
         *          title: null
         *      });
         *
         * The bind expressions are presented to `{@link Ext.app.ViewModel#bind}`. The
         * `ViewModel` instance is determined by `lookupViewModel`.
         */
        bind: {
            $value: null,
            lazy: true
        },

        // @cmd-auto-dependency { aliasPrefix: &#39;controller.&#39; }
<span id='Ext-mixin-Bindable-cfg-controller'>        /**
</span>         * @cfg {String/Object/Ext.app.ViewController} controller
         * A string alias, a configuration object or an instance of a `ViewController` for
         * this container. Sample usage:
         *
         *     Ext.define(&#39;MyApp.UserController&#39;, {
         *         alias: &#39;controller.user&#39;
         *     });
         *
         *     Ext.define(&#39;UserContainer&#39;, {
         *         extend: &#39;Ext.container.container&#39;,
         *         controller: &#39;user&#39;
         *     });
         *     // Or
         *     Ext.define(&#39;UserContainer&#39;, {
         *         extend: &#39;Ext.container.container&#39;,
         *         controller: {
         *             type: &#39;user&#39;,
         *             someConfig: true
         *         }
         *     });
         *
         *     // Can also instance at runtime
         *     var ctrl = new MyApp.UserController();
         *     var view = new UserContainer({
         *         controller: ctrl
         *     });
         *
         */
        controller: null,
        
<span id='Ext-mixin-Bindable-method-getController'>        /**
</span>         * @method getController
         * Returns the {@link Ext.app.ViewController} instance associated with this 
         * component via the {@link #controller} config or {@link #setController} method.
         * @return {Ext.app.ViewController} Returns this component&#39;s ViewController or 
         * null if one was not configured
         */

<span id='Ext-mixin-Bindable-cfg-defaultListenerScope'>        /**
</span>         * @cfg {Boolean} defaultListenerScope
         * If `true`, this component will be the default scope (this pointer) for events
         * specified with string names so that the scope can be dynamically resolved. The
         * component will automatically become the defaultListenerScope if a
         * {@link #controller} is specified.
         *
         * See the introductory docs for {@link Ext.container.Container} for some sample
         * usages.
         *
         * **NOTE**: This value can only be reliably set at construction time. Setting it
         * after that time may not correctly rewire all of the potentially effected
         * listeners.
         */
        defaultListenerScope: false,

<span id='Ext-mixin-Bindable-cfg-publishes'>        /**
</span>         * @cfg {String/String[]/Object} publishes
         * One or more names of config properties that this component should publish 
         * to its ViewModel. Generally speaking, only properties defined in a class config
         * block (including ancestor config blocks and mixins) are eligible for publishing 
         * to the viewModel. Some components override this and publish their most useful 
         * configs by default. 
         * 
         * **Note:** We&#39;ll discuss publishing properties **not** found in the config block below. 
         * 
         * Values determined to be invalid by component (often form fields and model validations) 
         * will not be published to the ViewModel.
         *
         * This config uses the `{@link #cfg-reference}` to determine the name of the data
         * object to place in the `ViewModel`. If `reference` is not set then this config
         * is ignored.
         *
         * By using this config and `{@link #cfg-reference}` you can bind configs between
         * components. For example:
         *
         *      ...
         *          items: [{
         *              xtype: &#39;textfield&#39;,
         *              reference: &#39;somefield&#39;,  // component&#39;s name in the ViewModel
         *              publishes: &#39;value&#39; // value is not published by default
         *          },{
         *              ...
         *          },{
         *              xtype: &#39;displayfield&#39;,
         *              bind: &#39;You have entered &quot;{somefield.value}&quot;&#39;
         *          }]
         *      ...
         *
         * Classes must provide this config as an Object:
         *
         *      Ext.define(&#39;App.foo.Bar&#39;, {
         *          publishes: {
         *              foo: true,
         *              bar: true
         *          }
         *      });
         *
         * This is required for the config system to properly merge values from derived
         * classes.
         *
         * For instances this value can be specified as a value as show above or an array
         * or object as follows:
         *
         *      {
         *          xtype: &#39;textfield&#39;,
         *          reference: &#39;somefield&#39;,
         *          publishes: [
         *              &#39;value&#39;,
         *              &#39;rawValue&#39;,
         *              &#39;dirty&#39;
         *          ]
         *      }
         *
         *      // This achieves the same result as the above array form.
         *      {
         *          xtype: &#39;textfield&#39;,
         *          reference: &#39;somefield&#39;,
         *          publishes: {
         *              value: true,
         *              rawValue: true,
         *              dirty: true
         *          }
         *      }
         *
         * In some cases, users may want to publish a property to the viewModel that is not found in a class 
         * config block. In these situations, you may utilize {@link #publishState} if the property has a 
         * setter method.  Let&#39;s use {@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:
         *
         *       setFieldLabel: function(fieldLabel) {
         *           this.callParent(arguments);
         *           this.publishState(&#39;fieldLabel&#39;, fieldLabel);
         *       }        
         * 
         * With the above chunk of code, fieldLabel may now be published to the viewModel.
         * 
         * @since 5.0.0
         */
        publishes: {
            $value: null,
            lazy: true,
            merge: function (newValue, oldValue) {
                return this.mergeSets(newValue, oldValue);
            }
        },

<span id='Ext-mixin-Bindable-cfg-reference'>        /**
</span>         * @cfg {String} reference
         * Specifies a name for this component inside its component hierarchy. This name
         * must be unique within its {@link Ext.container.Container#referenceHolder view}
         * or its {@link Ext.app.ViewController ViewController}. See the documentation in
         * {@link Ext.container.Container} for more information about references.
         *
         * **Note**: Valid identifiers start with a letter or underscore and are followed
         * by zero or more additional letters, underscores or digits. References are case
         * sensitive.
         */
        reference: null,

        // @cmd-auto-dependency { directRef: &#39;Ext.data.Session&#39; }
<span id='Ext-mixin-Bindable-cfg-session'>        /**
</span>         * @cfg {Boolean/Object/Ext.data.Session} [session=null]
         * If provided this creates a new `Session` instance for this component. If this
         * is a `Container`, this will then be inherited by all child components.
         *
         * To create a new session you can specify `true`:
         *
         *      Ext.create({
         *          xtype: &#39;viewport&#39;,
         *          session: true,
         *
         *          items: [{
         *              ...
         *          }]
         *      });
         *
         * Alternatively, a config object can be provided:
         *
         *      Ext.create({
         *          xtype: &#39;viewport&#39;,
         *          session: {
         *              ...
         *          },
         *
         *          items: [{
         *              ...
         *          }]
         *      });
         *
         */
        session: {
            $value: null,
            lazy: true
        },

<span id='Ext-mixin-Bindable-cfg-twoWayBindable'>        /**
</span>         * @cfg {String/String[]/Object} twoWayBindable
         * This object holds a map of `config` properties that will update their binding
         * as they are modified. For example, `value` is a key added by form fields. The
         * form of this config is the same as `{@link #publishes}`.
         *
         * This config is defined so that updaters are not created and added for all
         * bound properties since most cannot be modified by the end-user and hence are
         * not appropriate for two-way binding.
         */
        twoWayBindable: {
            $value: null,
            lazy: true,
            merge: function (newValue, oldValue) {
                return this.mergeSets(newValue, oldValue);
            }
        },

        // @cmd-auto-dependency { aliasPrefix: &#39;viewmodel.&#39;, defaultType: &#39;default&#39; }
<span id='Ext-mixin-Bindable-cfg-viewModel'>        /**
</span>         * @cfg {String/Object/Ext.app.ViewModel} viewModel
         * The `ViewModel` is a data provider for this component and its children. The
         * data contained in the `ViewModel` is typically used by adding `bind` configs
         * to the components that want present or edit this data.
         *
         * When set, the `ViewModel` is created and links to any inherited `viewModel`
         * instance from an ancestor container as the &quot;parent&quot;. The `ViewModel` hierarchy,
         * once established, only supports creation or destruction of children. The
         * parent of a `ViewModel` cannot be changed on the fly.
         *
         * If this is a root-level `ViewModel`, the data model connection is made to this
         * component&#39;s associated `{@link Ext.data.Session Data Session}`. This is
         * determined by calling `getInheritedSession`.
         *
         */
        viewModel: {
            $value: null,
            lazy: true
        }
    },

<span id='Ext-mixin-Bindable-property-defaultBindProperty'>    /**
</span>     * @property {String} [defaultBindProperty]
     * This property is used to determine the property of a `bind` config that is just
     * the value. For example, if `defaultBindProperty=&quot;value&quot;`, then this shorthand
     * `bind` config:
     *
     *      bind: &#39;{name}&#39;
     *
     * Is equivalent to this object form:
     *
     *      bind: {
     *          value: &#39;{name}&#39;
     *      }
     *
     * The `defaultBindProperty` is set to &quot;value&quot; for form fields and to &quot;store&quot; for
     * grids and trees.
     * @protected
     */
    defaultBindProperty: null,

<span id='Ext-mixin-Bindable-property-validRefRe'>    /**
</span>     * @property {RegExp}
     * Regular expression used for validating `reference` values.
     * @private
     */
    validRefRe: /^[a-z_][a-z0-9_]*$/i,

<span id='Ext-mixin-Bindable-method-initInheritedState'>    /**
</span>     * Called by `getInherited` to initialize the inheritedState the first time it is
     * requested.
     * @protected
     */
    initInheritedState: function (inheritedState) {
        var me = this,
            reference = me.getReference(),
            controller = me.getController(),
            // Don&#39;t instantiate the view model here, we only need to know that
            // it exists
            viewModel = me.getConfig(&#39;viewModel&#39;, true),
            session = me.getConfig(&#39;session&#39;, true),
            defaultListenerScope = me.getDefaultListenerScope();

        if (controller) {
            inheritedState.controller = controller;
        }

        if (defaultListenerScope) {
            inheritedState.defaultListenerScope = me;
        } else if (controller) {
            inheritedState.defaultListenerScope = controller;
        }

        if (viewModel) {
            // If we&#39;re not configured with an instance, just stamp the current component as
            // the thing that holds the view model. When we ask to get the inherited view model,
            // we will know that it&#39;s not an instance yet so we need to spin it up on this component.
            // We need to initialize them from top-down, but we don&#39;t want to do it up front.
            if (!viewModel.isViewModel) {
                viewModel = me;
            }
            inheritedState.viewModel = viewModel;
        }

        // Same checks as the view model
        if (session) {
            if (!session.isSession) {
                session = me;
            }
            inheritedState.session = session;
        }

        if (reference) {
            me.referenceKey = (inheritedState.referencePath || &#39;&#39;) + reference;
            me.viewModelKey = (inheritedState.viewModelPath || &#39;&#39;) + reference;
        }
    },

<span id='Ext-mixin-Bindable-method-lookupController'>    /**
</span>     * Gets the controller that controls this view. May be a controller that belongs
     * to a view higher in the hierarchy.
     * 
     * @param {Boolean} [skipThis=false] `true` to not consider the controller directly attached
     * to this view (if it exists).
     * @return {Ext.app.ViewController} The controller. `null` if no controller is found.
     *
     * @since 5.0.1
     */
    lookupController: function(skipThis) {
        return this.getInheritedConfig(&#39;controller&#39;, skipThis) || null;
    },

<span id='Ext-mixin-Bindable-method-lookupSession'>    /**
</span>     * Returns the `Ext.data.Session` for this instance. This property may come
     * from this instance&#39;s `{@link #session}` or be inherited from this object&#39;s parent.
     * @param {Boolean} [skipThis=false] Pass `true` to ignore a `session` configured on
     * this instance and only consider an inherited session.
     * @return {Ext.data.Session}
     * @since 5.0.0
     */
    lookupSession: function (skipThis) {
        // See lookupViewModel
        var ret = skipThis ? null : this.getSession(); // may be the initGetter!
        if (!ret) {
            ret = this.getInheritedConfig(&#39;session&#39;, skipThis);
            if (ret &amp;&amp; !ret.isSession) {
                ret = ret.getInherited().session = ret.getSession();
            }
        }

        return ret || null;
    },

<span id='Ext-mixin-Bindable-method-lookupViewModel'>    /**
</span>     * Returns the `Ext.app.ViewModel` for this instance. This property may come from this
     * this instance&#39;s `{@link #viewModel}` or be inherited from this object&#39;s parent.
     * @param {Boolean} [skipThis=false] Pass `true` to ignore a `viewModel` configured on
     * this instance and only consider an inherited view model.
     * @return {Ext.app.ViewModel}
     * @since 5.0.0
     */
    lookupViewModel: function (skipThis) {
        var ret = skipThis ? null : this.getViewModel(); // may be the initGetter!

        if (!ret) {
            ret = this.getInheritedConfig(&#39;viewModel&#39;, skipThis);
            // If what we get back is a component, it means the component was configured
            // with a view model, however the construction of it has been delayed until
            // we need it. As such, go and construct it and store it on the inherited state.
            if (ret &amp;&amp; !ret.isViewModel) {
                ret = ret.getInherited().viewModel = ret.getViewModel();
            }
        }

        return ret || null;
    },

<span id='Ext-mixin-Bindable-method-publishState'>    /**
</span>     * Publish this components state to the `ViewModel`. If no arguments are given (or if
     * this is the first call), the entire state is published. This state is determined by
     * the `publishes` property.
     *
     * This method is called only by component authors.
     *
     * @param {String} [property] The name of the property to update.
     * @param {Object} [value] The value of `property`. Only needed if `property` is given.
     * @protected
     * @since 5.0.0
     */
    publishState: function (property, value) {
        var me = this,
            state = me.publishedState,
            binds = me.getBind(),
            binding = binds &amp;&amp; property &amp;&amp; binds[property],
            count = 0,
            name, publishes, vm, path;

        if (binding &amp;&amp; !binding.syncing &amp;&amp; !binding.isReadOnly()) {
            // If the binding has never fired &amp; our value is either:
            // a) undefined
            // b) null
            // c) The value we were initially configured with
            // Then we don&#39;t want to publish it back to the view model. If we do, we&#39;ll be
            // overwriting whatever is in the viewmodel and it will never have a chance to fire.
            if (!(binding.calls === 0 &amp;&amp; (value == null || value === me.getInitialConfig()[property]))) {
                binding.setValue(value);
            }
        }

        if (!(publishes = me.getPublishes())) {
            return;
        }

        if (!(vm = me.lookupViewModel())) {
            return;
        }

        // Important to access path after lookupViewModel, which will kick off
        // our inheritedState if we don&#39;t have one
        if (!(path = me.viewModelKey)) {
            return;
        }

        if (property &amp;&amp; state) {
            if (!publishes[property]) {
                return;
            }

            // If we are setting an individual property and that is not a {} or a [] then
            // check to see if it is unchanged.
            if (!(value &amp;&amp; value.constructor === Object) &amp;&amp; !(value instanceof Array)) {
                if (state[property] === value) {
                    return;
                }
            }
            path += &#39;.&#39;;
            path += property;
        } else {
            state = state || (me.publishedState = {});

            for (name in publishes) {
                ++count;
                // If there are no properties to publish this loop will not run and the
                // value = null above will remain.
                if (name === property) {
                    state[name] = value;
                } else {
                    state[name] = me[name];
                }
            }

            if (!count) { // if (no properties were put in &quot;state&quot;)
                return;
            }
            value = state;
        }

        vm.set(path, value);
    },

<span id='Ext-mixin-Bindable-property-privates'>    //=========================================================================
</span>
    privates: {
<span id='Ext-mixin-Bindable-method-addBindableUpdater'>        /**
</span>         * Ensures that the given property (if it is a Config System config) has a proper
         * &quot;updater&quot; method on this instance to sync changes to the config.
         * @param {String} property The name of the config property.
         * @private
         * @since 5.0.0
         */
        addBindableUpdater: function (property) {
            var me = this,
                configs = me.self.$config.configs,
                cfg = configs[property],
                updateName;

            // While we store the updater on this instance, the function is cached and
            // re-used across all instances.
            if (cfg &amp;&amp; !me.hasOwnProperty(updateName = cfg.names.update)) {
                me[updateName] = cfg.bindableUpdater ||
                                (cfg.root.bindableUpdater = me.makeBindableUpdater(cfg));
            }
        },

<span id='Ext-mixin-Bindable-method-applyBind'>        /**
</span>         * @param {String/Object} binds
         * @param {Object} currentBindings
         * @return {Object}
         * @private
         * @since 5.0.0
         */
        applyBind: function (binds, currentBindings) {
            if (!binds) {
                return binds;
            }
            
            var me = this,
                viewModel = me.lookupViewModel(),
                twoWayable = me.getTwoWayBindable(),
                getBindTemplateScope = me._getBindTemplateScope,
                b, property, descriptor, destroy;

            me.$hasBinds = true;
            if (!currentBindings || typeof currentBindings === &#39;string&#39;) {
                currentBindings = {};
            }

            //&lt;debug&gt;
            if (!viewModel) {
                Ext.raise(&#39;Cannot use bind config without a viewModel&#39;);
            }
            //&lt;/debug&gt;

            if (Ext.isString(binds)) {
                //&lt;debug&gt;
                if (!me.defaultBindProperty) {
                    Ext.raise(me.$className + &#39; has no defaultBindProperty - &#39;+
                                    &#39;Please specify a bind object&#39;);
                }
                //&lt;/debug&gt;

                b = binds;
                binds = {};
                binds[me.defaultBindProperty] = b;
            }

            for (property in binds) {
                descriptor = binds[property];
                b = currentBindings[property];

                if (b &amp;&amp; typeof b !== &#39;string&#39;) {
                    b.destroy();
                    b = null;
                    destroy = true;
                }

                if (descriptor) {
                    b = viewModel.bind(descriptor, me.onBindNotify, me);
                    b._config = Ext.Config.get(property);
                    b.getTemplateScope = getBindTemplateScope;

                    //&lt;debug&gt;
                    if (!me[b._config.names.set]) {
                        Ext.raise(&#39;Cannot bind &#39; + property + &#39; on &#39; + me.$className +
                                        &#39; - missing a &#39; + b._config.names.set + &#39; method.&#39;);
                    }
                    //&lt;/debug&gt;
                }

                if (destroy) {
                    delete currentBindings[property];
                } else {
                    currentBindings[property] = b;
                }

                if (twoWayable &amp;&amp; twoWayable[property]) {
                    if (destroy) {
                        me.clearBindableUpdater(property);
                    } else if (!b.isReadOnly()) {
                        me.addBindableUpdater(property);
                    }
                  }
            }

            return currentBindings;
        },

        applyController: function (controller) {
            if (controller) {
                controller = Ext.Factory.controller(controller);
                controller.setView(this);
            }
            return controller;
        },

        applyPublishes: function (all) {
            if (this.lookupViewModel()) {
                for (var property in all) {
                    this.addBindableUpdater(property);
                }
            }

            return all;
        },

        //&lt;debug&gt;
        applyReference: function (reference) {
            var validIdRe = this.validRefRe || Ext.validIdRe;
            if (reference &amp;&amp; !validIdRe.test(reference)) {
                Ext.raise(&#39;Invalid reference &quot;&#39; + reference + &#39;&quot; for &#39; + this.getId() +
                                &#39; - not a valid identifier&#39;);
            }
            return reference;
        },
        //&lt;/debug&gt;

<span id='Ext-mixin-Bindable-method-applySession'>        /**
</span>         * Transforms a Session config to a proper instance.
         * @param {Object} session
         * @return {Ext.data.Session}
         * @private
         * @since 5.0.0
         */
        applySession: function (session) {
            if (!session) {
                return null;
            }

            if (!session.isSession) {
                var parentSession = this.lookupSession(true), // skip this component
                    config = (session === true) ? {} : session;

                if (parentSession) {
                    session = parentSession.spawn(config);
                } else {
                    // Mask this use of Session from Cmd - the dependency is not ours but
                    // the caller
                    session = new Ext.data[&#39;Session&#39;](config);
                }
            }

            return session;
        },

<span id='Ext-mixin-Bindable-method-applyViewModel'>        /**
</span>         * Transforms a ViewModel config to a proper instance.
         * @param {String/Object/Ext.app.ViewModel} viewModel
         * @return {Ext.app.ViewModel}
         * @private
         * @since 5.0.0
         */
        applyViewModel: function (viewModel) {
            var me = this,
                config, session;

            if (!viewModel) {
                return null;
            }

            if (!viewModel.isViewModel) {
                config = {
                    parent: me.lookupViewModel(true), // skip this component

                    // Ensure that VM construction activity can reach the view (for
                    // example events on stores)
                    view: me
                };

                config.session = me.getSession();
                if (!session &amp;&amp; !config.parent) {
                    config.session = me.lookupSession();
                }

                if (viewModel) {
                    if (viewModel.constructor === Object) {
                        Ext.apply(config, viewModel);
                    } else if (typeof viewModel === &#39;string&#39;) {
                        config.type = viewModel;
                    }
                }

                viewModel = Ext.Factory.viewModel(config);
            }
            return viewModel;
        },

        _getBindTemplateScope: function () {
            // This method is called as a method on a Binding instance, so the &quot;this&quot; pointer
            // is that of the Binding. The &quot;scope&quot; of the Binding is the component owning it.
            return this.scope.resolveListenerScope();
        },

        clearBindableUpdater: function (property) {
            var me = this,
                configs = me.self.$config.configs,
                cfg = configs[property],
                updateName;

            if (cfg &amp;&amp; me.hasOwnProperty(updateName = cfg.names.update)) {
                if (me[updateName].$bindableUpdater) {
                    delete me[updateName];
                }
            }
        },

        destroyBindable: function() {
            var me = this,
                viewModel = me.getConfig(&#39;viewModel&#39;, true),
                session = me.getConfig(&#39;session&#39;, true),
                controller = me.getController();

            if (viewModel &amp;&amp; viewModel.isViewModel) {
                viewModel.destroy();
                me.setViewModel(null);
            }

            if (session &amp;&amp; session.isSession) {
                if (session.getAutoDestroy()) {
                    session.destroy();
                }
                me.setSession(null);
            }
            if (controller) {
                me.setController(null);
                controller.destroy();
            }
        },

<span id='Ext-mixin-Bindable-method-initBindable'>        /**
</span>         * This method triggers the lazy configs and must be called when it is time to
         * fully boot up. The configs that must be initialized are: `bind`, `publishes`,
         * `session`, `twoWayBindable` and `viewModel`.
         * @private
         * @since 5.0.0
         */
        initBindable: function () {
            this.initBindable = Ext.emptyFn;
            this.getBind();
            this.getPublishes();

            // If we have binds, the applyBind method will call getTwoWayBindable to ensure
            // we have the necessary updaters. If we have no binds then applyBind will not
            // be called and we will ignore our twoWayBindable config (which is fine).
            //
            // If we have publishes or binds then the viewModel will be requested. If not
            // this viewModel will be lazily requested by a descendant via inheritedState
            // or not at all. If there is no descendant using bind or publishes, then the
            // viewModel will sit and wait.
            //
            // As goes the fate of the viewModel so goes the fate of the session. If we
            // have requested the viewModel then the session will also be spun up. If not,
            // we wait for a descendant or the user to request them.
        },

<span id='Ext-mixin-Bindable-method-makeBindableUpdater'>        /**
</span>         * Returns an `update` method for the given Config that will call `{@link #publishState}`
         * to ensure two-way bindings (via `bind`) as well as any `publishes` are updated.
         * This method is cached on the `cfg` instance for re-use.
         * @param {Ext.Config} cfg
         * @return {Function} The updater function.
         * @private
         * @since 5.0.0
         */
        makeBindableUpdater: function (cfg) {
            var updateName = cfg.names.update,
                fn = function (newValue, oldValue) {
                    var me = this,
                        updater = me.self.prototype[updateName];

                    if (updater) {
                        updater.call(me, newValue, oldValue);
                    }
                    me.publishState(cfg.name, newValue);
                };

                fn.$bindableUpdater = true;
            
            return fn;
        },

<span id='Ext-mixin-Bindable-method-isSyncing'>        /**
</span>         * Checks if a particular binding is synchronizing the value.
         * @param {String} name The name of the property being bound to.
         * @return {Boolean} `true` if the binding is syncing.
         *
         * @protected
         */
        isSyncing: function(name) {
            var bindings = this.getBind(),
                ret = false,
                binding;

            if (bindings) {
                binding = bindings[name];
                if (binding) {
                    ret = binding.syncing &gt; 0;
                }
            }
            return ret;
        },

        onBindNotify: function (value, oldValue, binding) {
            binding.syncing = (binding.syncing + 1) || 1;
            this[binding._config.names.set](value);
            --binding.syncing;
        },

        removeBindings: function() {
            var me = this,
                bindings, key, binding;

            if (me.$hasBinds) {
                bindings = me.getBind();
                if (bindings &amp;&amp; typeof bindings !== &#39;string&#39;) {
                    for (key in bindings) {
                        binding = bindings[key];
                        binding.destroy();
                        binding._config = binding.getTemplateScope = null;
                    }
                }
            }
            me.setBind(null);
        },
        
<span id='Ext-mixin-Bindable-method-updateSession'>        /**
</span>         * Updates the session config.
         * @param {Ext.data.Session} session
         * @private
         */
        updateSession: function (session) {
            var state = this.getInherited();

            if (session) {
                state.session = session;
            } else {
                delete state.session;
            }
        },

<span id='Ext-mixin-Bindable-method-updateViewModel'>        /**
</span>         * Updates the viewModel config.
         * @param {Ext.app.ViewModel} viewModel
         * @param {Ext.app.ViewModel} oldViewModel
         * @private
         */
        updateViewModel: function (viewModel) {
            var state = this.getInherited(),
                controller = this.getController();

            if (viewModel) {
                state.viewModel = viewModel;
                viewModel.setView(this);
                if (controller) {
                    controller.initViewModel(viewModel);
                }
            } else {
                delete state.viewModel;
            }
        }
    } // private
});
</pre>
</body>
</html>
