<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-ProgressBar'>/**
</span> * An updateable progress bar component. The progress bar supports two different modes: manual and automatic.
 *
 * In manual mode, you are responsible for showing, updating (via {@link #updateProgress}) and clearing the progress bar
 * as needed from your own code. This method is most appropriate when you want to show progress throughout an operation
 * that has predictable points of interest at which you can update the control.
 *
 * In automatic mode, you simply call {@link #wait} and let the progress bar run indefinitely, only clearing it once the
 * operation is complete. You can optionally have the progress bar wait for a specific amount of time and then clear
 * itself. Automatic mode is most appropriate for timed operations or asynchronous operations in which you have no need
 * for indicating intermediate progress.
 *
 *     @example
 *     var p = Ext.create(&#39;Ext.ProgressBar&#39;, {
 *        renderTo: Ext.getBody(),
 *        width: 300
 *     });
 *
 *     // Wait for 5 seconds, then update the status el (progress bar will auto-reset)
 *     p.wait({
 *         interval: 500, //bar will move fast!
 *         duration: 50000,
 *         increment: 15,
 *         text: &#39;Updating...&#39;,
 *         scope: this,
 *         fn: function(){
 *             p.updateText(&#39;Done!&#39;);
 *         }
 *     });
 */
Ext.define(&#39;Ext.ProgressBar&#39;, {
    extend: &#39;Ext.Component&#39;,
    xtype: &#39;progressbar&#39;,
    mixins: [
        &#39;Ext.ProgressBase&#39;
    ],

    requires: [
        &#39;Ext.Template&#39;,
        &#39;Ext.CompositeElement&#39;,
        &#39;Ext.TaskManager&#39;,
        &#39;Ext.layout.component.ProgressBar&#39;
    ],

    uses: [&#39;Ext.fx.Anim&#39;],

<span id='Ext-ProgressBar-cfg-textEl'>    /**
</span>     * @cfg {String/HTMLElement/Ext.dom.Element} textEl
     * The element to render the progress text to (defaults to the progress bar&#39;s internal text element)
     */

<span id='Ext-ProgressBar-cfg-id'>    /**
</span>     * @cfg {String} id
     * The progress bar element&#39;s id (defaults to an auto-generated id)
     */

<span id='Ext-ProgressBar-cfg-baseCls'>    /**
</span>     * @cfg {String} [baseCls=&#39;x-progress&#39;]
     * The base CSS class to apply to the progress bar&#39;s wrapper element.
     */
    baseCls: Ext.baseCSSPrefix + &#39;progress&#39;,

<span id='Ext-ProgressBar-cfg-animate'>    /**
</span>     * @cfg {Boolean/Object} animate
     * True to animate the progress bar during transitions, or an animation configuration
     * (see the {@link #method-animate} method for details).
     */
    animate: false,

<span id='Ext-ProgressBar-cfg-text'>    /**
</span>     * @cfg {String} text
     * The text shown in the progress bar.
     */
    text: &#39;&#39;,

<span id='Ext-ProgressBar-property-waitTimer'>    /**
</span>     * @private
     */
    waitTimer: null,

<span id='Ext-ProgressBar-cfg-childEls'>    childEls: [
</span>        &#39;bar&#39;
    ],

<span id='Ext-ProgressBar-property-defaultBindProperty'>    defaultBindProperty: &#39;value&#39;,
</span>
<span id='Ext-ProgressBar-cfg-renderTpl'>    renderTpl: [
</span>        &#39;&lt;tpl if=&quot;internalText&quot;&gt;&#39;,
            &#39;&lt;div class=&quot;{baseCls}-text {baseCls}-text-back&quot; role=&quot;presentation&quot;&gt;{text}&lt;/div&gt;&#39;,
        &#39;&lt;/tpl&gt;&#39;,
        &#39;&lt;div id=&quot;{id}-bar&quot; data-ref=&quot;bar&quot; class=&quot;{baseCls}-bar {baseCls}-bar-{ui}&quot; role=&quot;presentation&quot; style=&quot;width:{percentage}%&quot;&gt;&#39;,
            &#39;&lt;tpl if=&quot;internalText&quot;&gt;&#39;,
                &#39;&lt;div class=&quot;{baseCls}-text&quot; role=&quot;presentation&quot;&gt;&#39;,
                    &#39;&lt;div role=&quot;presentation&quot;&gt;{text}&lt;/div&gt;&#39;,
                &#39;&lt;/div&gt;&#39;,
            &#39;&lt;/tpl&gt;&#39;,
        &#39;&lt;/div&gt;&#39;
    ],

<span id='Ext-ProgressBar-cfg-componentLayout'>    componentLayout: &#39;progressbar&#39;,
</span>    
<span id='Ext-ProgressBar-property-ariaRole'>    ariaRole: &#39;progressbar&#39;,
</span><span id='Ext-ProgressBar-property-focusable'>    focusable: true,
</span><span id='Ext-ProgressBar-cfg-tabIndex'>    tabIndex: 0,
</span>    
<span id='Ext-ProgressBar-cfg-autoEl'>    autoEl: {
</span>        &#39;aria-valuemin&#39;: &#39;0&#39;,
        &#39;aria-valuenow&#39;: &#39;0&#39;,
        &#39;aria-valuemax&#39;: &#39;100&#39;
    },

<span id='Ext-ProgressBar-event-update'>    /**
</span>     * @event update
     * Fires after each update interval
     * @param {Ext.ProgressBar} this
     * @param {Number} value The current progress value
     * @param {String} text The current progress text
     */

    initRenderData: function() {
        var me = this,
            value = me.value || 0,
            data;
        
        data = me.callParent();
        
        return Ext.apply(data, {
            internalText: !me.hasOwnProperty(&#39;textEl&#39;),
            text: me.text || Math.round(value * 100) + &#39;%&#39;,
            percentage: value * 100
        });
    },

<span id='Ext-ProgressBar-method-onRender'>    onRender: function() {
</span>        var me = this;

        me.callParent(arguments);

        // External text display
        if (me.textEl) {
            me.textEl = Ext.get(me.textEl);
            me.updateText(me.text);
        }
        // Inline text display
        else {
            // This produces a composite w/2 el&#39;s (which is why we cannot use childEls or
            // renderSelectors):
            me.textEl = me.el.select(&#39;.&#39; + me.baseCls + &#39;-text&#39;);
        }
    },
    
<span id='Ext-ProgressBar-method-afterRender'>    afterRender: function() {
</span>        var me = this;
        
        me.callParent(arguments);
        
        if (me.text) {
            me.ariaEl.dom.setAttribute(&#39;aria-valuetext&#39;, me.text);
        }
    },

<span id='Ext-ProgressBar-method-updateValue'>    updateValue: function(value) {
</span>        this.updateProgress(value);
    },

<span id='Ext-ProgressBar-method-updateProgress'>    /**
</span>     * Updates the progress bar value, and optionally its text.
     * 
     * If the text argument is not specified, then the {@link #textTpl} will be used to generate the text.
     * If there is no `textTpl`, any existing text value will be unchanged. To blank out existing text, pass `&quot;&quot;`.
     *
     * Note that even if the progress bar value exceeds 1, it will never automatically reset --
     * you are responsible for determining when the progress is complete and
     * calling {@link #reset} to clear and/or hide the control.
     * @param {Number} [value=0] A floating point value between 0 and 1 (e.g., .5)
     * @param {String} [text=&#39;&#39;] The string to display in the progress text element
     * @param {Boolean} [animate=false] Whether to animate the transition of the progress bar. If this value is not
     * specified, the default for the class is used
     * @return {Ext.ProgressBar} this
     */
    updateProgress: function(value, text, animate) {
        value = value || 0;

        var me = this,
            oldValue = me.value,
            textTpl = me.getTextTpl();

        // Ensure value is not undefined.
        me.value = value || (value = 0);

        // Empty string (falsy) must blank out the text as per docs.
        if (text != null) {
            me.autoText = false;
            me.updateText(text);
        }
        // Generate text using template and progress values.
        else if (textTpl) {
            me.autoText = false;
            me.updateText(textTpl.apply({
                value: value,
                percent: value * 100
            }));
        }
        else if (!me.text &amp;&amp; me.autoText !== false) {
            me.autoText = true;
            me.updateText(Math.round(value * 100) + &#39;%&#39;);
        }
        // Text was set the previous time but not this time. We can&#39;t
        // deduce what it should be just from the value so need to
        // reset aria-valuetext because it is no longer valid.
        else if (me.text &amp;&amp; me.ariaEl.dom) {
            me.ariaEl.dom.removeAttribute(&#39;aria-valuetext&#39;);
        }
        
        if (me.rendered &amp;&amp; !me.destroyed) {
            if (animate === true || (animate !== false &amp;&amp; me.animate)) {
                me.bar.stopAnimation();
                me.bar.animate(Ext.apply({
                    from: {
                        width: (oldValue * 100) + &#39;%&#39;
                    },
                    to: {
                        width: (value * 100) + &#39;%&#39;
                    }
                }, me.animate));
            } else {
                me.bar.setStyle(&#39;width&#39;, (value * 100) + &#39;%&#39;);
            }
            
            me.ariaEl.dom.setAttribute(&#39;aria-valuenow&#39;, Math.round(value * 100));
        }
        
        me.fireEvent(&#39;update&#39;, me, value, text);
        
        return me;
    },

<span id='Ext-ProgressBar-method-updateText'>    /**
</span>     * Updates the progress bar text. If specified, textEl will be updated, otherwise the progress bar itself will
     * display the updated text.
     * @param {String} [text=&#39;&#39;] The string to display in the progress text element
     * @return {Ext.ProgressBar} this
     */
    updateText: function(text) {
        var me = this;

        if (!me.autoText) {
            me.text = text;
        }
        
        if (me.rendered) {
            me.textEl.setHtml(text);
            
            if (!me.autoText) {
                me.ariaEl.dom.setAttribute(&#39;aria-valuetext&#39;, text);
            }
            else {
                me.ariaEl.dom.removeAttribute(&#39;aria-valuetext&#39;);
            }
        }
        
        return me;
    },

<span id='Ext-ProgressBar-method-applyText'>    applyText : function(text) {
</span>        this.updateText(text);
    },
    
<span id='Ext-ProgressBar-method-getText'>    getText: function(){
</span>        return this.text;    
    },

<span id='Ext-ProgressBar-method-wait'>    /**
</span>     * Initiates an auto-updating progress bar. A duration can be specified, in which case the progress bar will
     * automatically reset after a fixed amount of time and optionally call a callback function if specified. If no
     * duration is passed in, then the progress bar will run indefinitely and must be manually cleared by calling
     * {@link #reset}.
     *
     * Example usage:
     *
     *     var p = new Ext.ProgressBar({
     *        renderTo: &#39;my-el&#39;
     *     });
     *
     *     //Wait for 5 seconds, then update the status el (progress bar will auto-reset)
     *     var p = Ext.create(&#39;Ext.ProgressBar&#39;, {
     *        renderTo: Ext.getBody(),
     *        width: 300
     *     });
     *
     *     //Wait for 5 seconds, then update the status el (progress bar will auto-reset)
     *     p.wait({
     *        interval: 500, //bar will move fast!
     *        duration: 50000,
     *        increment: 15,
     *        text: &#39;Updating...&#39;,
     *        scope: this,
     *        fn: function(){
     *           p.updateText(&#39;Done!&#39;);
     *        }
     *     });
     *
     *     //Or update indefinitely until some async action completes, then reset manually
     *     p.wait();
     *     myAction.on(&#39;complete&#39;, function(){
     *         p.reset();
     *         p.updateText(&#39;Done!&#39;);
     *     });
     *
     * @param {Object} config (optional) Configuration options
     * @param {Number} config.duration The length of time in milliseconds that the progress bar should
     * run before resetting itself (defaults to undefined, in which case it will run indefinitely
     * until reset is called)
     * @param {Number} config.interval The length of time in milliseconds between each progress update
     * (defaults to 1000 ms)
     * @param {Boolean} config.animate Whether to animate the transition of the progress bar. If this
     * value is not specified, the default for the class is used.
     * @param {Number} config.increment The number of progress update segments to display within the
     * progress bar (defaults to 10).  If the bar reaches the end and is still updating, it will
     * automatically wrap back to the beginning.
     * @param {String} config.text Optional text to display in the progress bar element (defaults to &#39;&#39;).
     * @param {Function} config.fn A callback function to execute after the progress bar finishes auto-
     * updating.  The function will be called with no arguments.  This function will be ignored if
     * duration is not specified since in that case the progress bar can only be stopped programmatically,
     * so any required function should be called by the same code after it resets the progress bar.
     * @param {Object} config.scope The scope that is passed to the callback function (only applies when
     * duration and fn are both passed).
     * @return {Ext.ProgressBar} this
     */
    wait: function(o) {
        var me = this, scope;
            
        if (!me.waitTimer) {
            scope = me;
            o = o || {};
            if (o.text != null) {
                me.autoText = false;
            }
            me.updateText(o.text);
            me.waitTimer = Ext.TaskManager.start({
                run: function(i){
                    var inc = o.increment || 10;
                    i -= 1;
                    me.updateProgress(((((i+inc)%inc)+1)*(100/inc))*0.01, null, o.animate);
                },
                interval: o.interval || 1000,
                duration: o.duration,
                onStop: function(){
                    if (o.fn) {
                        o.fn.apply(o.scope || me);
                    }
                    me.reset();
                },
                scope: scope
            });
        }
        return me;
    },

<span id='Ext-ProgressBar-method-isWaiting'>    /**
</span>     * Returns true if the progress bar is currently in a {@link #wait} operation
     * @return {Boolean} True if waiting, else false
     */
    isWaiting: function(){
        return this.waitTimer !== null;
    },

<span id='Ext-ProgressBar-method-reset'>    /**
</span>     * Resets the progress bar value to 0 and text to empty string. If hide = true, the progress bar will also be hidden
     * (using the {@link #hideMode} property internally).
     * @param {Boolean} [hide=false] True to hide the progress bar.
     * @return {Ext.ProgressBar} this
     */
    reset: function(hide){
        var me = this;
        
        me.updateProgress(0);
        me.clearTimer();
        
        if (hide === true) {
            me.hide();
        }
        
        if (me.rendered) {
            me.ariaEl.dom.removeAttribute(&#39;aria-valuetext&#39;);
        }
        
        return me;
    },

<span id='Ext-ProgressBar-method-clearTimer'>    /**
</span>     * @private
     */
    clearTimer: function(){
        var me = this;
        
        if (me.waitTimer) {
            me.waitTimer.onStop = null; //prevent recursion
            Ext.TaskManager.stop(me.waitTimer);
            me.waitTimer = null;
        }
    },

<span id='Ext-ProgressBar-method-doDestroy'>    doDestroy: function() {
</span>        var me = this,
            bar = me.bar;
        
        me.clearTimer();
        
        if (me.rendered) {
            if (me.textEl.isComposite) {
                me.textEl.clear();
            }
            
            Ext.destroyMembers(me, &#39;textEl&#39;, &#39;progressBar&#39;);
            
            if (bar &amp;&amp; me.animate) {
                bar.stopAnimation();
            }
        }
        
        me.callParent();
    }
});
</pre>
</body>
</html>
