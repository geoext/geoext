{"version":3,"file":"vendors-node_modules_geotiff_dist-module_compression_lerc_js.ol.js","mappings":"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","sources":["webpack://ol/./node_modules/lerc/LercDecode.js","webpack://ol/./node_modules/geotiff/dist-module/compression/lerc.js"],"sourcesContent":["/* jshint forin: false, bitwise: false */\n/*\nCopyright 2015-2021 Esri\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nA copy of the license and additional notices are located with the\nsource distribution at:\n\nhttp://github.com/Esri/lerc/\n\nContributors:  Johannes Schmid, (LERC v1)\n               Chayanika Khatua, (LERC v1)\n               Wenxue Ju (LERC v1, v2.x)\n*/\n\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\n\n/**\n * a module for decoding LERC blobs\n * @module Lerc\n */\n(function() {\n  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). \n  //the exported module handles format variation autoamtically.\n\n  //the original LercDecode for Version 1\n  var LercDecode = (function() {\n\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof.\n\n    var CntZImage = {};\n\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\n\n    /**\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\n     * information about it, such as the image's width and height.\n     *\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] Decoding options, containing any of the following properties:\n     * @config {number} [inputOffset = 0]\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\n     * @config {Uint8Array} [encodedMask = null]\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\n     *        Pixel value to use for masked pixels.\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\n     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\n     * @config {boolean} [returnMask = false]\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the\n     *        input LERC data does not contain a mask, maskData will not be returned.\n     * @config {boolean} [returnEncodedMask = false]\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\n     *        encodedMask.\n     * @config {boolean} [returnFileInfo = false]\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\n     *        LERC headers and the decoding process.\n     * @config {boolean} [computeUsedBitDepths = false]\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\n     */\n    CntZImage.decode = function(input, options) {\n      options = options || {};\n\n      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\n\n      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;\n\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,\n        options.encodedMaskData, noDataValue, options.returnMask);\n\n      var result = {\n        width: parsedData.width,\n        height: parsedData.height,\n        pixelData: uncompressedData.resultPixels,\n        minValue: uncompressedData.minValue,\n        maxValue: parsedData.pixels.maxValue,\n        noDataValue: noDataValue\n      };\n\n      if (uncompressedData.resultMask) {\n        result.maskData = uncompressedData.resultMask;\n      }\n\n      if (options.returnEncodedMask && parsedData.mask) {\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\n      }\n\n      if (options.returnFileInfo) {\n        result.fileInfo = formatFileInfo(parsedData);\n        if (options.computeUsedBitDepths) {\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\n        }\n      }\n\n      return result;\n    };\n\n    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\n      var blockIdx = 0;\n      var numX = data.pixels.numBlocksX;\n      var numY = data.pixels.numBlocksY;\n      var blockWidth = Math.floor(data.width / numX);\n      var blockHeight = Math.floor(data.height / numY);\n      var scale = 2 * data.maxZError;\n      var minValue = Number.MAX_VALUE, currentValue;\n      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);\n\n      var resultPixels, resultMask;\n      resultPixels = new TypedArrayClass(data.width * data.height);\n      if (storeDecodedMask && maskBitset) {\n        resultMask = new Uint8Array(data.width * data.height);\n      }\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\n\n      var xx, yy;\n      for (var y = 0; y <= numY; y++) {\n        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);\n        if (thisBlockHeight === 0) {\n          continue;\n        }\n        for (var x = 0; x <= numX; x++) {\n          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);\n          if (thisBlockWidth === 0) {\n            continue;\n          }\n\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\n          var outStride = data.width - thisBlockWidth;\n\n          var block = data.pixels.blocks[blockIdx];\n\n          var blockData, blockPtr, constValue;\n          if (block.encoding < 2) {\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\n            if (block.encoding === 0) {\n              // block is uncompressed\n              blockData = block.rawData;\n            } else {\n              // block is bit-stuffed\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\n              blockData = blockDataBuffer;\n            }\n            blockPtr = 0;\n          }\n          else if (block.encoding === 2) {\n            // block is all 0\n            constValue = 0;\n          }\n          else {\n            // block has constant value (encoding === 3)\n            constValue = block.offset;\n          }\n\n          var maskByte;\n          if (maskBitset) {\n            for (yy = 0; yy < thisBlockHeight; yy++) {\n              if (outPtr & 7) {\n                //\n                maskByte = maskBitset[outPtr >> 3];\n                maskByte <<= outPtr & 7;\n              }\n              for (xx = 0; xx < thisBlockWidth; xx++) {\n                if (!(outPtr & 7)) {\n                  // read next byte from mask\n                  maskByte = maskBitset[outPtr >> 3];\n                }\n                if (maskByte & 128) {\n                  // pixel data present\n                  if (resultMask) {\n                    resultMask[outPtr] = 1;\n                  }\n                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                } else {\n                  // pixel data not present\n                  if (resultMask) {\n                    resultMask[outPtr] = 0;\n                  }\n                  resultPixels[outPtr++] = noDataValue;\n                }\n                maskByte <<= 1;\n              }\n              outPtr += outStride;\n            }\n          } else {\n            // mask not present, simply copy block over\n            if (block.encoding < 2) {\n              // duplicating this code block for performance reasons\n              // blockData case:\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  currentValue = blockData[blockPtr++];\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                }\n                outPtr += outStride;\n              }\n            }\n            else {\n              // constValue case:\n              minValue = minValue > constValue ? constValue : minValue;\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  resultPixels[outPtr++] = constValue;\n                }\n                outPtr += outStride;\n              }\n            }\n          }\n          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {\n            throw \"Block and Mask do not match\";\n          }\n          blockIdx++;\n        }\n      }\n\n      return {\n        resultPixels: resultPixels,\n        resultMask: resultMask,\n        minValue: minValue\n      };\n    };\n\n    var formatFileInfo = function(data) {\n      return {\n        \"fileIdentifierString\": data.fileIdentifierString,\n        \"fileVersion\": data.fileVersion,\n        \"imageType\": data.imageType,\n        \"height\": data.height,\n        \"width\": data.width,\n        \"maxZError\": data.maxZError,\n        \"eofOffset\": data.eofOffset,\n        \"mask\": data.mask ? {\n          \"numBlocksX\": data.mask.numBlocksX,\n          \"numBlocksY\": data.mask.numBlocksY,\n          \"numBytes\": data.mask.numBytes,\n          \"maxValue\": data.mask.maxValue\n        } : null,\n        \"pixels\": {\n          \"numBlocksX\": data.pixels.numBlocksX,\n          \"numBlocksY\": data.pixels.numBlocksY,\n          \"numBytes\": data.pixels.numBytes,\n          \"maxValue\": data.pixels.maxValue,\n          \"noDataValue\": data.noDataValue\n        }\n      };\n    };\n\n    var computeUsedBitDepths = function(data) {\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\n      var bitDepths = {};\n      for (var i = 0; i < numBlocks; i++) {\n        var block = data.pixels.blocks[i];\n        if (block.encoding === 0) {\n          bitDepths.float32 = true;\n        } else if (block.encoding === 1) {\n          bitDepths[block.bitsPerPixel] = true;\n        } else {\n          bitDepths[0] = true;\n        }\n      }\n\n      return Object.keys(bitDepths);\n    };\n\n    var parse = function(input, fp, skipMask) {\n      var data = {};\n\n      // File header\n      var fileIdView = new Uint8Array(input, fp, 10);\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      if (data.fileIdentifierString.trim() !== \"CntZImage\") {\n        throw \"Unexpected file identifier string: \" + data.fileIdentifierString;\n      }\n      fp += 10;\n      var view = new DataView(input, fp, 24);\n      data.fileVersion = view.getInt32(0, true);\n      data.imageType = view.getInt32(4, true);\n      data.height = view.getUint32(8, true);\n      data.width = view.getUint32(12, true);\n      data.maxZError = view.getFloat64(16, true);\n      fp += 24;\n\n      // Mask Header\n      if (!skipMask) {\n        view = new DataView(input, fp, 16);\n        data.mask = {};\n        data.mask.numBlocksY = view.getUint32(0, true);\n        data.mask.numBlocksX = view.getUint32(4, true);\n        data.mask.numBytes = view.getUint32(8, true);\n        data.mask.maxValue = view.getFloat32(12, true);\n        fp += 16;\n\n        // Mask Data\n        if (data.mask.numBytes > 0) {\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n          view = new DataView(input, fp, data.mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              var val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < data.mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n          data.mask.bitset = bitset;\n          fp += data.mask.numBytes;\n        }\n        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n        }\n      }\n\n      // Pixel Header\n      view = new DataView(input, fp, 16);\n      data.pixels = {};\n      data.pixels.numBlocksY = view.getUint32(0, true);\n      data.pixels.numBlocksX = view.getUint32(4, true);\n      data.pixels.numBytes = view.getUint32(8, true);\n      data.pixels.maxValue = view.getFloat32(12, true);\n      fp += 16;\n\n      var numBlocksX = data.pixels.numBlocksX;\n      var numBlocksY = data.pixels.numBlocksY;\n      // the number of blocks specified in the header does not take into account the blocks at the end of\n      // each row/column with a special width/height that make the image complete in case the width is not\n      // evenly divisible by the number of blocks.\n      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);\n      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\n      var blockI = 0;\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\n\n          // Block\n          var size = 0;\n          var bytesLeft = input.byteLength - fp;\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\n          var block = {};\n          data.pixels.blocks[blockI++] = block;\n          var headerByte = view.getUint8(0); size++;\n          block.encoding = headerByte & 63;\n          if (block.encoding > 3) {\n            throw \"Invalid block encoding (\" + block.encoding + \")\";\n          }\n          if (block.encoding === 2) {\n            fp++;\n            continue;\n          }\n          if ((headerByte !== 0) && (headerByte !== 2)) {\n            headerByte >>= 6;\n            block.offsetType = headerByte;\n            if (headerByte === 2) {\n              block.offset = view.getInt8(1); size++;\n            } else if (headerByte === 1) {\n              block.offset = view.getInt16(1, true); size += 2;\n            } else if (headerByte === 0) {\n              block.offset = view.getFloat32(1, true); size += 4;\n            } else {\n              throw \"Invalid block offset type\";\n            }\n\n            if (block.encoding === 1) {\n              headerByte = view.getUint8(size); size++;\n              block.bitsPerPixel = headerByte & 63;\n              headerByte >>= 6;\n              block.numValidPixelsType = headerByte;\n              if (headerByte === 2) {\n                block.numValidPixels = view.getUint8(size); size++;\n              } else if (headerByte === 1) {\n                block.numValidPixels = view.getUint16(size, true); size += 2;\n              } else if (headerByte === 0) {\n                block.numValidPixels = view.getUint32(size, true); size += 4;\n              } else {\n                throw \"Invalid valid pixel count type\";\n              }\n            }\n          }\n          fp += size;\n\n          if (block.encoding === 3) {\n            continue;\n          }\n\n          var arrayBuf, store8;\n          if (block.encoding === 0) {\n            var numPixels = (data.pixels.numBytes - 1) / 4;\n            if (numPixels !== Math.floor(numPixels)) {\n              throw \"uncompressed block has invalid length\";\n            }\n            arrayBuf = new ArrayBuffer(numPixels * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\n            var rawData = new Float32Array(arrayBuf);\n            block.rawData = rawData;\n            fp += numPixels * 4;\n          } else if (block.encoding === 1) {\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\n            var dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, dataBytes));\n            block.stuffedData = new Uint32Array(arrayBuf);\n            fp += dataBytes;\n          }\n        }\n      }\n      data.eofOffset = fp;\n      return data;\n    };\n\n    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\n      var bitMask = (1 << bitsPerPixel) - 1;\n      var i = 0, o;\n      var bitsLeft = 0;\n      var n, buffer;\n      var nmax = Math.ceil((maxValue - offset) / scale);\n      // get rid of trailing bytes that are already part of next block\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n      for (o = 0; o < numPixels; o++) {\n        if (bitsLeft === 0) {\n          buffer = src[i++];\n          bitsLeft = 32;\n        }\n        if (bitsLeft >= bitsPerPixel) {\n          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n          bitsLeft -= bitsPerPixel;\n        } else {\n          var missingBits = (bitsPerPixel - bitsLeft);\n          n = ((buffer & bitMask) << missingBits) & bitMask;\n          buffer = src[i++];\n          bitsLeft = 32 - missingBits;\n          n += (buffer >>> bitsLeft);\n        }\n        //pixel values may exceed max due to quantization\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\n      }\n      return dest;\n    };\n\n    return CntZImage;\n  })();\n\n  //version 2. Supports 2.1, 2.2, 2.3\n  var Lerc2Decode = (function() {\n    \"use strict\";\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof, following LercDecode.\n\n    /*****************************************\n    * private static class bitsutffer used by Lerc2Decode\n    *******************************************/\n    var BitStuffer = {\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\n      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits, nmax;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            dest[o] = lutArr[n];//offset + lutArr[n] * scale;\n          }\n        }\n        else {\n          nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n      },\n\n      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;\n        var buffer;\n        var dest = [];\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);//1st one\n        return dest;\n      },\n\n      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            dest[o] = lutArr[n];\n          }\n        }\n        else {\n          var nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              //no unsigned left shift\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n        return dest;\n      },\n\n      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;\n        var buffer;\n        var dest = [];\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);\n        return dest;\n      },\n\n      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          }\n          else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          dest[o] = n;\n        }\n        return dest;\n      },\n\n      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        //micro-optimizations\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          dest[o] = n;\n        }\n        return dest;\n      }\n    };\n\n    /*****************************************\n    *private static class used by Lerc2Decode\n    ******************************************/\n    var Lerc2Helpers = {\n      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant\n      computeChecksumFletcher32: function(input) {\n\n        var sum1 = 0xffff, sum2 = 0xffff;\n        var len = input.length;\n        var words = Math.floor(len / 2);\n        var i = 0;\n        while (words) {\n          var tlen = (words >= 359) ? 359 : words;\n          words -= tlen;\n          do {\n            sum1 += (input[i++] << 8);\n            sum2 += sum1 += input[i++];\n          } while (--tlen);\n\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        }\n\n        // add the straggler byte if it exists\n        if (len & 1) {\n          sum2 += sum1 += (input[i] << 8);\n        }\n        // second reduction step to reduce sums to 16 bits\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n\n        return (sum2 << 16 | sum1) >>> 0;\n      },\n\n      readHeaderInfo: function(input, data) {\n        var ptr = data.ptr;\n        var fileIdView = new Uint8Array(input, ptr, 6);\n        var headerInfo = {};\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n        if (headerInfo.fileIdentifierString.lastIndexOf(\"Lerc2\", 0) !== 0) {\n          throw \"Unexpected file identifier string (expect Lerc2 ): \" + headerInfo.fileIdentifierString;\n        }\n        ptr += 6;\n        var view = new DataView(input, ptr, 8);\n        var fileVersion = view.getInt32(0, true);\n        headerInfo.fileVersion = fileVersion;\n        ptr += 4;\n        if (fileVersion >= 3) {\n          headerInfo.checksum = view.getUint32(4, true); //nrows\n          ptr += 4;\n        }\n\n        //keys start from here\n        view = new DataView(input, ptr, 12);\n        headerInfo.height = view.getUint32(0, true); //nrows\n        headerInfo.width = view.getUint32(4, true); //ncols\n        ptr += 8;\n        if (fileVersion >= 4) {\n          headerInfo.numDims = view.getUint32(8, true);\n          ptr += 4;\n        }\n        else {\n          headerInfo.numDims = 1;\n        }\n\n        view = new DataView(input, ptr, 40);\n        headerInfo.numValidPixel = view.getUint32(0, true);\n        headerInfo.microBlockSize = view.getInt32(4, true);\n        headerInfo.blobSize = view.getInt32(8, true);\n        headerInfo.imageType = view.getInt32(12, true);\n\n        headerInfo.maxZError = view.getFloat64(16, true);\n        headerInfo.zMin = view.getFloat64(24, true);\n        headerInfo.zMax = view.getFloat64(32, true);\n        ptr += 40;\n        data.headerInfo = headerInfo;\n        data.ptr = ptr;\n\n        var checksum, keyLength;\n        if (fileVersion >= 3) {\n          keyLength = fileVersion >= 4 ? 52 : 48;\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\n          if (checksum !== headerInfo.checksum) {\n            throw \"Checksum failed.\";\n          }\n        }\n        return true;\n      },\n\n      checkMinMaxRanges: function(input, data) {\n        var headerInfo = data.headerInfo;\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\n        data.ptr += (2 * rangeBytes);\n        var i, equal = true;\n        for (i = 0; i < headerInfo.numDims; i++) {\n          if (minValues[i] !== maxValues[i]) {\n            equal = false;\n            break;\n          }\n        }\n        headerInfo.minValues = minValues;\n        headerInfo.maxValues = maxValues;\n        return equal;\n      },\n\n      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {\n        var rawData;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        return rawData;\n      },\n\n      readMask: function(input, data) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var numValidPixel = headerInfo.numValidPixel;\n\n        var view = new DataView(input, ptr, 4);\n        var mask = {};\n        mask.numBytes = view.getUint32(0, true);\n        ptr += 4;\n\n        // Mask Data\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\n          throw (\"invalid mask\");\n        }\n        var bitset, resultMask;\n        if (numValidPixel === 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          mask.bitset = bitset;\n          resultMask = new Uint8Array(numPixels);\n          data.pixels.resultMask = resultMask;\n          ptr += mask.numBytes;\n        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\n        else if (mask.numBytes > 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          view = new DataView(input, ptr, mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0, val = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n\n          resultMask = new Uint8Array(numPixels);\n          var mb = 0, k = 0;\n\n          for (k = 0; k < numPixels; k++) {\n            if (k & 7) {\n              mb = bitset[k >> 3];\n              mb <<= k & 7;\n            }\n            else {\n              mb = bitset[k >> 3];\n            }\n            if (mb & 128) {\n              resultMask[k] = 1;\n            }\n          }\n          data.pixels.resultMask = resultMask;\n\n          mask.bitset = bitset;\n          ptr += mask.numBytes;\n        }\n        data.ptr = ptr;\n        data.mask = mask;\n        return true;\n      },\n\n      readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var imageType = headerInfo.imageType;\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;\n        //data.pixels.numBytes = numBytes;\n        var rawData;\n        var mask = data.pixels.resultMask;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        if (rawData.length === numPixels * numDims) {\n          if (useBSQForOutputDim) {\n            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);\n          }\n          else {\n            data.pixels.resultPixels = rawData;\n          }\n        }\n        else  //mask\n        {\n          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\n          var z = 0, k = 0, i = 0, nStart = 0;\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k;\n                  for (i = 0; i < numDims; i++, nStart+=numPixels) {\n                    data.pixels.resultPixels[nStart] = rawData[z++];\n                  }\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    data.pixels.resultPixels[nStart + i] = rawData[z++];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = rawData[z++];\n              }\n            }\n          }\n        }\n        ptr += numBytes;\n        data.ptr = ptr;       //return data;\n        return true;\n      },\n\n      readHuffmanTree: function(input, data) {\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading code table\n        *************************/\n        var view = new DataView(input, data.ptr, 16);\n        data.ptr += 16;\n        var version = view.getInt32(0, true);\n        if (version < 2) {\n          throw \"unsupported Huffman version\";\n        }\n        var size = view.getInt32(4, true);\n        var i0 = view.getInt32(8, true);\n        var i1 = view.getInt32(12, true);\n        if (i0 >= i1) {\n          return false;\n        }\n        var blockDataBuffer = new Uint32Array(i1 - i0);\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\n        var codeTable = []; //size\n        var i, j, k, len;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };\n        }\n\n        var dataBytes = input.byteLength - data.ptr;\n        var dataWords = Math.ceil(dataBytes / 4);\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\n        var store8 = new Uint8Array(arrayBuf);\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\n        var bitPos = 0, word, srcPtr = 0;\n        word = stuffedData[0];\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            codeTable[j].second = (word << bitPos) >>> (32 - len);\n\n            if (32 - bitPos >= len) {\n              bitPos += len;\n              if (bitPos === 32) {\n                bitPos = 0;\n                srcPtr++;\n                word = stuffedData[srcPtr];\n              }\n            }\n            else {\n              bitPos += len - 32;\n              srcPtr++;\n              word = stuffedData[srcPtr];\n              codeTable[j].second |= word >>> (32 - bitPos);\n            }\n          }\n        }\n\n        //finished reading code table\n\n        /* ************************\n        * building lut\n        *************************/\n        var numBitsLUT = 0, numBitsLUTQick = 0;\n        var tree = new TreeNode();\n        for (i = 0; i < codeTable.length; i++) {\n          if (codeTable[i] !== undefined) {\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\n          }\n        }\n        if (numBitsLUT >= BITS_MAX) {\n          numBitsLUTQick = BITS_MAX;\n        }\n        else {\n          numBitsLUTQick = numBitsLUT;\n        }\n        // for debugging purpose\n        // if (numBitsLUT >= 30) {\n        //   console.log(\"WARning, large NUM LUT BITS IS \" + numBitsLUT);\n        // }\n        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            entry = [len, j];\n            if (len <= numBitsLUTQick) {\n              code = codeTable[j].second << (numBitsLUTQick - len);\n              numEntries = 1 << (numBitsLUTQick - len);\n              for (k = 0; k < numEntries; k++) {\n                decodeLut[code | k] = entry;\n              }\n            }\n            else {\n              //build tree\n              code = codeTable[j].second;\n              node = tree;\n              for (jj = len - 1; jj >= 0; jj--) {\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\n                if (currentBit) {\n                  if (!node.right) {\n                    node.right = new TreeNode();\n                  }\n                  node = node.right;\n                }\n                else {\n                  if (!node.left) {\n                    node.left = new TreeNode();\n                  }\n                  node = node.left;\n                }\n                if (jj === 0 && !node.val) {\n                  node.val = entry[1];\n                }\n              }\n            }\n          }\n        }\n        return {\n          decodeLut: decodeLut,\n          numBitsLUTQick: numBitsLUTQick,\n          numBitsLUT: numBitsLUT,\n          tree: tree,\n          stuffedData: stuffedData,\n          srcPtr: srcPtr,\n          bitPos: bitPos\n        };\n      },\n\n      readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var height = data.headerInfo.height;\n        var width = data.headerInfo.width;\n        var numPixels = width * height;\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading huffman structure info\n        *************************/\n        var huffmanInfo = this.readHuffmanTree(input, data);\n        var decodeLut = huffmanInfo.decodeLut;\n        var tree = huffmanInfo.tree;\n        //stuffedData includes huffman headers\n        var stuffedData = huffmanInfo.stuffedData;\n        var srcPtr = huffmanInfo.srcPtr;\n        var bitPos = huffmanInfo.bitPos;\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\n        var numBitsLUT = huffmanInfo.numBitsLUT;\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\n        /*************************\n        *  decode\n        ***************************/\n        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;\n        var i, j, k, ii;\n        var prevVal = 0;\n        if (bitPos > 0) {\n          srcPtr++;\n          bitPos = 0;\n        }\n        var word = stuffedData[srcPtr];\n        var deltaEncode = data.encodeMode === 1;\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\n        var resultPixels = resultPixelsAllDim;\n        var iDim;\n        // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out\n        if (numDims < 2 || deltaEncode) {\n          for (iDim = 0; iDim < numDims; iDim++) {\n            if (numDims > 1) {\n              //get the mem block of current dimension\n              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\n              prevVal = 0;\n            }\n            if (data.headerInfo.numValidPixel === width * height) { //all valid\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n    \n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n    \n                  delta = val - offset;\n                  if (deltaEncode) {\n                    if (j > 0) {\n                      delta += prevVal;    // use overflow\n                    }\n                    else if (i > 0) {\n                      delta += resultPixels[k - width];\n                    }\n                    else {\n                      delta += prevVal;\n                    }\n                    delta &= 0xFF; //overflow\n                    resultPixels[k] = delta;//overflow\n                    prevVal = delta;\n                  }\n                  else {\n                    resultPixels[k] = delta;\n                  }\n                }\n              }\n            }\n            else { //not all valid, use mask\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  if (mask[k]) {\n                    val = 0;\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUTQick) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                    {\n                      val = decodeLut[valTmpQuick][1];\n                      bitPos += decodeLut[valTmpQuick][0];\n                    }\n                    else {\n                      valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                      if (32 - bitPos < numBitsLUT) {\n                        valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                        valTmpQuick = valTmp;// >>> deltaBits;\n                      }\n                      node = tree;\n                      for (ii = 0; ii < numBitsLUT; ii++) {\n                        currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                        node = currentBit ? node.right : node.left;\n                        if (!(node.left || node.right)) {\n                          val = node.val;\n                          bitPos = bitPos + ii + 1;\n                          break;\n                        }\n                      }\n                    }\n    \n                    if (bitPos >= 32) {\n                      bitPos -= 32;\n                      srcPtr++;\n                      word = stuffedData[srcPtr];\n                    }\n    \n                    delta = val - offset;\n                    if (deltaEncode) {\n                      if (j > 0 && mask[k - 1]) {\n                        delta += prevVal;    // use overflow\n                      }\n                      else if (i > 0 && mask[k - width]) {\n                        delta += resultPixels[k - width];\n                      }\n                      else {\n                        delta += prevVal;\n                      }\n    \n                      delta &= 0xFF; //overflow\n                      resultPixels[k] = delta;//overflow\n                      prevVal = delta;\n                    }\n                    else {\n                      resultPixels[k] = delta;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        else {\n          for (k = 0, i = 0; i < height; i++) {\n            for (j = 0; j < width; j++) {\n              k = i * width + j;\n              if (!mask || mask[k]) {\n                for (iDim = 0; iDim < numDims; iDim++, k+=numPixels) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;\n                  }\n                  if (decodeLut[valTmpQuick])\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n                  resultPixels[k] = delta;\n                }\n              }\n            }\n          }\n        }\n        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\n        data.pixels.resultPixels = resultPixelsAllDim;\n        //swap for BIP layout\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {\n        {\n          //bitstuff encoding is 3\n          var headerInfo = data.headerInfo;\n          var fileVersion = headerInfo.fileVersion;\n          //var block = {};\n          var blockPtr = 0;\n          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);\n          var view = new DataView(input, data.ptr, viewByteLength);\n          var headerByte = view.getUint8(0);\n          blockPtr++;\n          var bits67 = headerByte >> 6;\n          var n = (bits67 === 0) ? 4 : 3 - bits67;\n          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit\n          var numBits = headerByte & 31;\n          var numElements = 0;\n          if (n === 1) {\n            numElements = view.getUint8(blockPtr); blockPtr++;\n          } else if (n === 2) {\n            numElements = view.getUint16(blockPtr, true); blockPtr += 2;\n          } else if (n === 4) {\n            numElements = view.getUint32(blockPtr, true); blockPtr += 4;\n          } else {\n            throw \"Invalid valid pixel count type\";\n          }\n          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff\n          //offset = offset || 0;\n          var scale = 2 * headerInfo.maxZError;\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\n          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\n          if (doLut) {\n            data.counter.lut++;\n            lutBytes = view.getUint8(blockPtr);\n            lutBitsPerElement = numBits;\n            blockPtr++;\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n\n            data.ptr += blockPtr;\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n\n            lutData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n\n            bitsPerPixel = 0;\n            while ((lutBytes - 1) >>> bitsPerPixel) {\n              bitsPerPixel++;\n            }\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            stuffedData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n            if (fileVersion >= 3) {\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            else {\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            //lutArr.unshift(0);\n            if (fileVersion >= 3) {\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n            else {\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n          }\n          else {\n            //console.debug(\"bitstuffer\");\n            data.counter.bitstuffer++;\n            bitsPerPixel = numBits;\n            data.ptr += blockPtr;\n            if (bitsPerPixel > 0) {\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n              dataWords = Math.ceil(dataBytes / 4);\n              arrayBuf = new ArrayBuffer(dataWords * 4);\n              store8 = new Uint8Array(arrayBuf);\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\n              stuffedData = new Uint32Array(arrayBuf);\n              data.ptr += dataBytes;\n              if (fileVersion >= 3) {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n              else {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n            }\n          }\n        }\n\n      },\n\n      readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var width = headerInfo.width;\n        var height = headerInfo.height;\n        var numPixels = width * height;\n        var microBlockSize = headerInfo.microBlockSize;\n        var imageType = headerInfo.imageType;\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\n        var numBlocksX = Math.ceil(width / microBlockSize);\n        var numBlocksY = Math.ceil(height / microBlockSize);\n        data.pixels.numBlocksY = numBlocksY;\n        data.pixels.numBlocksX = numBlocksX;\n        data.pixels.ptr = 0;\n        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;\n        var view, block, arrayBuf, store8, rawData;\n        var blockEncoding;\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\n        var lastBlockHeight = (height % microBlockSize) || microBlockSize;\n        var lastBlockWidth = (width % microBlockSize) || microBlockSize;\n        var offsetType, offset;\n        var numDims = headerInfo.numDims, iDim;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        var fileVersion = headerInfo.fileVersion;\n        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;\n        var isDiffEncoding;\n        var zMax = headerInfo.zMax;\n        //var resultPixelsAllDim = resultPixels;\n        var resultPixelsPrevDim;\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\n          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\n            //console.debug(\"y\" + blockY + \" x\" + blockX);\n            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;\n\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n            outStride = width - thisBlockWidth;\n\n            for (iDim = 0; iDim < numDims; iDim++) {\n              if (numDims > 1) {\n                resultPixelsPrevDim = resultPixels;\n                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);\n                zMax = headerInfo.maxValues[iDim];\n              } else {\n                resultPixelsPrevDim = null;\n              }\n              bytesLeft = input.byteLength - data.ptr;\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\n              block = {};\n              blockPtr = 0;\n              headerByte = view.getUint8(0);\n              blockPtr++;\n              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;\n              bits67 = (headerByte >> 6) & 0xFF;\n              testCode = (headerByte >> 2) & fileVersionCheckNum;    // use bits 2345 for integrity check\n              if (testCode !== (((blockX * microBlockSize) >> 3) & fileVersionCheckNum)) {\n                throw \"integrity issue\";\n              }\n\n              if (isDiffEncoding && iDim === 0) {\n                throw \"integrity issue\";\n              }\n\n              blockEncoding = headerByte & 3;\n              if (blockEncoding > 3) {\n                data.ptr += blockPtr;\n                throw \"Invalid block encoding (\" + blockEncoding + \")\";\n              }\n              else if (blockEncoding === 2) { //constant 0\n                if (isDiffEncoding) {\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        }\n                        outPtr++;\n                      }\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        outPtr++;\n                      }\n                    }\n                  }\n                }\n                data.counter.constant++;\n                data.ptr += blockPtr;\n                continue;\n              }\n              else if (blockEncoding === 0) {  //uncompressed\n                if (isDiffEncoding) {\n                  // doesn't make sense, should not happen\n                  throw \"integrity issue\";\n                }\n                data.counter.uncompressed++;\n                data.ptr += blockPtr;\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\n                bytesleft = input.byteLength - data.ptr;\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft;\n                //bit alignment\n                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));\n                store8 = new Uint8Array(arrayBuf);\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\n                rawData = new OutPixelTypeArray(arrayBuf);\n                z = 0;\n                if (mask) {\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      if (mask[outPtr]) {\n                        resultPixels[outPtr] = rawData[z++];\n                      }\n                      outPtr++;\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                else {//all valid\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      resultPixels[outPtr++] = rawData[z++];\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                data.ptr += z * dataTypeSize;\n              }\n              else { //1 or 3\n                offsetType = Lerc2Helpers.getDataTypeUsed((isDiffEncoding && imageType < 6) ? 4 : imageType, bits67);\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\n                if (blockEncoding === 3) //constant offset value\n                {\n                  data.ptr += blockPtr;\n                  data.counter.constantoffset++;\n                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\n                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n                else { //bitstuff encoding is 3\n                  data.ptr += blockPtr;\n                  //heavy lifting\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\n                  blockPtr = 0;\n                  // duplicate code to favor performance, diff encoding is for multidimension only\n                  if (isDiffEncoding) {\n                    if (mask) {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          if (mask[outPtr]) {\n                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          }\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                    else {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                  }\n                  else if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      /*****************\n      *  private methods (helper methods)\n      *****************/\n\n      formatFileInfo: function(data) {\n        return {\n          \"fileIdentifierString\": data.headerInfo.fileIdentifierString,\n          \"fileVersion\": data.headerInfo.fileVersion,\n          \"imageType\": data.headerInfo.imageType,\n          \"height\": data.headerInfo.height,\n          \"width\": data.headerInfo.width,\n          \"numValidPixel\": data.headerInfo.numValidPixel,\n          \"microBlockSize\": data.headerInfo.microBlockSize,\n          \"blobSize\": data.headerInfo.blobSize,\n          \"maxZError\": data.headerInfo.maxZError,\n          \"pixelType\": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\n          \"eofOffset\": data.eofOffset,\n          \"mask\": data.mask ? {\n            \"numBytes\": data.mask.numBytes\n          } : null,\n          \"pixels\": {\n            \"numBlocksX\": data.pixels.numBlocksX,\n            \"numBlocksY\": data.pixels.numBlocksY,\n            //\"numBytes\": data.pixels.numBytes,\n            \"maxValue\": data.headerInfo.zMax,\n            \"minValue\": data.headerInfo.zMin,\n            \"noDataValue\": data.noDataValue\n          }\n        };\n      },\n\n      constructConstantSurface: function(data, useBSQForOutputDim) {\n        var val = data.headerInfo.zMax;\n        var valMin = data.headerInfo.zMin;\n        var maxValues = data.headerInfo.maxValues;\n        var numDims = data.headerInfo.numDims;\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\n        var i = 0, k = 0, nStart = 0;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        if (mask) {\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  if (mask[k]) {\n                    resultPixels[nStart + k] = val;\n                  }\n                }\n              }  \n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    resultPixels[nStart + numDims] = maxValues[i];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                resultPixels[k] = val;\n              }\n            }\n          }\n        }\n        else {\n          if (numDims > 1 && valMin !== val) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  resultPixels[nStart + k] = val;\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                nStart = k * numDims;\n                for (i = 0; i < numDims; i++) {\n                  resultPixels[nStart + i] = maxValues[i];\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels * numDims; k++) {\n              resultPixels[k] = val;\n            }\n          }\n        }\n        return;\n      },\n\n      getDataTypeArray: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = Int8Array;\n            break;\n          case 1: //byte\n            tp = Uint8Array;\n            break;\n          case 2: //short\n            tp = Int16Array;\n            break;\n          case 3: //ushort\n            tp = Uint16Array;\n            break;\n          case 4:\n            tp = Int32Array;\n            break;\n          case 5:\n            tp = Uint32Array;\n            break;\n          case 6:\n            tp = Float32Array;\n            break;\n          case 7:\n            tp = Float64Array;\n            break;\n          default:\n            tp = Float32Array;\n        }\n        return tp;\n      },\n\n      getPixelType: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = \"S8\";\n            break;\n          case 1: //byte\n            tp = \"U8\";\n            break;\n          case 2: //short\n            tp = \"S16\";\n            break;\n          case 3: //ushort\n            tp = \"U16\";\n            break;\n          case 4:\n            tp = \"S32\";\n            break;\n          case 5:\n            tp = \"U32\";\n            break;\n          case 6:\n            tp = \"F32\";\n            break;\n          case 7:\n            tp = \"F64\";\n            break;\n          default:\n            tp = \"F32\";\n        }\n        return tp;\n      },\n\n      isValidPixelValue: function(t, val) {\n        if (val == null) {\n          return false;\n        }\n        var isValid;\n        switch (t) {\n          case 0: //char\n            isValid = val >= -128 && val <= 127;\n            break;\n          case 1: //byte  (unsigned char)\n            isValid = val >= 0 && val <= 255;\n            break;\n          case 2: //short\n            isValid = val >= -32768 && val <= 32767;\n            break;\n          case 3: //ushort\n            isValid = val >= 0 && val <= 65536;\n            break;\n          case 4: //int 32\n            isValid = val >= -2147483648 && val <= 2147483647;\n            break;\n          case 5: //uinit 32\n            isValid = val >= 0 && val <= 4294967296;\n            break;\n          case 6:\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\n            break;\n          case 7:\n            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;\n            break;\n          default:\n            isValid = false;\n        }\n        return isValid;\n      },\n\n      getDataTypeSize: function(t) {\n        var s = 0;\n        switch (t) {\n          case 0: //ubyte\n          case 1: //byte\n            s = 1;\n            break;\n          case 2: //short\n          case 3: //ushort\n            s = 2;\n            break;\n          case 4:\n          case 5:\n          case 6:\n            s = 4;\n            break;\n          case 7:\n            s = 8;\n            break;\n          default:\n            s = t;\n        }\n        return s;\n      },\n\n      getDataTypeUsed: function(dt, tc) {\n        var t = dt;\n        switch (dt) {\n          case 2: //short\n          case 4: //long\n            t = dt - tc;\n            break;\n          case 3: //ushort\n          case 5: //ulong\n            t = dt - 2 * tc;\n            break;\n          case 6: //float\n            if (0 === tc) {\n              t = dt;\n            }\n            else if (1 === tc) {\n              t = 2;\n            }\n            else {\n              t = 1;//byte\n            }\n            break;\n          case 7: //double\n            if (0 === tc) {\n              t = dt;\n            }\n            else {\n              t = dt - 2 * tc + 1;\n            }\n            break;\n          default:\n            t = dt;\n            break;\n        }\n        return t;\n      },\n\n      getOnePixel: function(block, blockPtr, offsetType, view) {\n        var temp = 0;\n        switch (offsetType) {\n          case 0: //char\n            temp = view.getInt8(blockPtr);\n            break;\n          case 1: //byte\n            temp = view.getUint8(blockPtr);\n            break;\n          case 2:\n            temp = view.getInt16(blockPtr, true);\n            break;\n          case 3:\n            temp = view.getUint16(blockPtr, true);\n            break;\n          case 4:\n            temp = view.getInt32(blockPtr, true);\n            break;\n          case 5:\n            temp = view.getUInt32(blockPtr, true);\n            break;\n          case 6:\n            temp = view.getFloat32(blockPtr, true);\n            break;\n          case 7:\n            temp = view.getFloat64(blockPtr, true);\n            break;\n          default:\n            throw (\"the decoder does not understand this pixel type\");\n        }\n        return temp;\n      },\n\n      swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {\n        var i = 0, j = 0, iDim = 0, temp = 0, swap = pixels;\n        if (numDims > 1) {\n          swap = new OutPixelTypeArray(numPixels * numDims);\n          if (inputIsBIP) {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[temp] = pixels[j++];\n              }\n            }  \n          }\n          else {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[j++] = pixels[temp];\n              }\n            }\n          }\n        }\n        return swap;\n      }\n    };\n\n    /***************************************************\n    *private class for a tree node. Huffman code is in Lerc2Helpers\n    ****************************************************/\n    var TreeNode = function(val, left, right) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    };\n\n    var Lerc2Decode = {\n      /*\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\n       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type\n       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\n       *       We can add it back later if their's a clear requirement.\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\n       * removed computeUsedBitDepths.\n       *\n       *\n       * response changes compared to LERC1\n       * 1. encodedMaskData is not available\n       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)\n       * 3. maskData is always available\n      */\n      /*****************\n      *  public properties\n      ******************/\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\n\n      /*****************\n      *  public methods\n      *****************/\n\n      /**\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\n       *\n       * @param {ArrayBuffer} input The LERC input byte stream\n       * @param {object} [options] options Decoding options\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\n       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n       */\n      decode: function(/*byte array*/ input, /*object*/ options) {\n        //currently there's a bug in the sparse array, so please do not set to false\n        options = options || {};\n        var noDataValue = options.noDataValue;\n\n        //initialize\n        var i = 0, data = {};\n        data.ptr = options.inputOffset || 0;\n        data.pixels = {};\n\n        // File header\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) {\n          return;\n        }\n\n        var headerInfo = data.headerInfo;\n        var fileVersion = headerInfo.fileVersion;\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);\n\n        // version check\n        if (fileVersion > 5) {\n          throw \"unsupported lerc version 2.\" + fileVersion;\n        }\n\n        // Mask Header\n        Lerc2Helpers.readMask(input, data);\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\n          data.pixels.resultMask = options.maskData;\n        }\n\n        var numPixels = headerInfo.width * headerInfo.height;\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\n\n        data.counter = {\n          onesweep: 0,\n          uncompressed: 0,\n          lut: 0,\n          bitstuffer: 0,\n          constant: 0,\n          constantoffset: 0\n        };\n        var useBSQForOutputDim = !options.returnPixelInterleavedDims;\n        if (headerInfo.numValidPixel !== 0) {\n          //not tested\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\n          {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else {\n            var view = new DataView(input, data.ptr, 2);\n            var bReadDataOneSweep = view.getUint8(0);\n            data.ptr++;\n            if (bReadDataOneSweep) {\n              //console.debug(\"OneSweep\");\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);\n            }\n            else {\n              //lerc2.1: //bitstuffing + lut\n              //lerc2.2: //bitstuffing + lut + huffman\n              //lerc2.3: new bitstuffer\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\n                var flagHuffman = view.getUint8(1);\n                data.ptr++;\n                data.encodeMode = flagHuffman;\n                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {\n                  throw \"Invalid Huffman flag \" + flagHuffman;\n                }\n                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman\n                  //console.log(\"Huffman\");\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n                else {\n                  //console.log(\"Tiles\");\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n              }\n              else { //lerc2.x non-8 bit data\n                //console.log(\"Tiles\");\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n              }\n            }\n          }\n        }\n\n        data.eofOffset = data.ptr;\n        var diff;\n        if (options.inputOffset) {\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect eof: dataptr \" + data.ptr + \" offset \" + options.inputOffset + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\n          }\n        }\n        else {\n          diff = data.headerInfo.blobSize - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect first band eof: dataptr \" + data.ptr + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = data.headerInfo.blobSize;\n          }\n        }\n\n        var result = {\n          width: headerInfo.width,\n          height: headerInfo.height,\n          pixelData: data.pixels.resultPixels,\n          minValue: headerInfo.zMin,\n          maxValue: headerInfo.zMax,\n          validPixelCount: headerInfo.numValidPixel,\n          dimCount: headerInfo.numDims,\n          dimStats: {\n            minValues: headerInfo.minValues,\n            maxValues: headerInfo.maxValues\n          },\n          maskData: data.pixels.resultMask\n          //noDataValue: noDataValue\n        };\n\n        //we should remove this if there's no existing client\n        //optional noDataValue processing, it's user's responsiblity\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\n          var mask = data.pixels.resultMask;\n          for (i = 0; i < numPixels; i++) {\n            if (!mask[i]) {\n              result.pixelData[i] = noDataValue;\n            }\n          }\n          result.noDataValue = noDataValue;\n        }\n        data.noDataValue = noDataValue;\n        if (options.returnFileInfo) {\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\n        }\n        return result;\n      },\n\n      getBandCount: function(/*byte array*/ input) {\n        var count = 0;\n        var i = 0;\n        var temp = {};\n        temp.ptr = 0;\n        temp.pixels = {};\n        while (i < input.byteLength - 58) {\n          Lerc2Helpers.readHeaderInfo(input, temp);\n          i += temp.headerInfo.blobSize;\n          count++;\n          temp.ptr = i;\n        }\n        return count;\n      }\n    };\n\n    return Lerc2Decode;\n  })();\n\n  var isPlatformLittleEndian = (function() {\n    var a = new ArrayBuffer(4);\n    var b = new Uint8Array(a);\n    var c = new Uint32Array(a);\n    c[0] = 1;\n    return b[0] === 1;\n  })();\n\n  var Lerc = {\n    /************wrapper**********************************************/\n    /**\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\n     *\n     * @alias module:Lerc\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] The decoding options below are optional.\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\n     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\n       * @property {number} width Width of decoded image.\n       * @property {number} height Height of decoded image.\n       * @property {array} pixels [band1, band2, ] Each band is a typed array of width*height.\n       * @property {string} pixelType The type of pixels represented in the output.\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\n       * @property {array} statistics [statistics_band1, statistics_band2, ] Each element is a statistics object representing min and max values\n    **/\n    decode: function(encodedData, options) {\n      if (!isPlatformLittleEndian) {\n        throw \"Big endian system is not supported.\";\n      }\n      options = options || {};\n      var inputOffset = options.inputOffset || 0;\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      var lerc, majorVersion;\n      if (fileIdentifierString.trim() === \"CntZImage\") {\n        lerc = LercDecode;\n        majorVersion = 1;\n      }\n      else if (fileIdentifierString.substring(0, 5) === \"Lerc2\") {\n        lerc = Lerc2Decode;\n        majorVersion = 2;\n      }\n      else {\n        throw \"Unexpected file identifier string: \" + fileIdentifierString;\n      }\n\n      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;\n      var decodedPixelBlock = {\n        width: 0,\n        height: 0,\n        pixels: [],\n        pixelType: options.pixelType,\n        mask: null,\n        statistics: []\n      };\n      var uniqueBandMaskCount = 0;\n\n      while (inputOffset < eof) {\n        var result = lerc.decode(encodedData, {\n          inputOffset: inputOffset,//for both lerc1 and lerc2\n          encodedMaskData: encodedMaskData,//lerc1 only\n          maskData: maskData,//lerc2 only\n          returnMask: iPlane === 0 ? true : false,//lerc1 only\n          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only\n          returnFileInfo: true,//for both lerc1 and lerc2\n          returnPixelInterleavedDims: options.returnPixelInterleavedDims,//for ndim lerc2 only\n          pixelType: options.pixelType || null,//lerc1 only\n          noDataValue: options.noDataValue || null//lerc1 only\n        });\n\n        inputOffset = result.fileInfo.eofOffset;\n        maskData = result.maskData;//lerc2\n        if (iPlane === 0) {\n          encodedMaskData = result.encodedMaskData;//lerc1\n          decodedPixelBlock.width = result.width;\n          decodedPixelBlock.height = result.height;\n          decodedPixelBlock.dimCount = result.dimCount || 1;\n          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\n          decodedPixelBlock.mask = maskData;\n        }\n        if (majorVersion > 1) {\n          if (maskData) {\n            bandMasks.push(maskData);\n          }\n          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\n            uniqueBandMaskCount++;\n          }\n        }\n\n        iPlane++;\n        decodedPixelBlock.pixels.push(result.pixelData);\n        decodedPixelBlock.statistics.push({\n          minValue: result.minValue,\n          maxValue: result.maxValue,\n          noDataValue: result.noDataValue,\n          dimStats: result.dimStats\n        });\n      }\n      var i, j, numPixels;\n      if (majorVersion > 1 && uniqueBandMaskCount > 1) {\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\n        decodedPixelBlock.bandMasks = bandMasks;\n        maskData = new Uint8Array(numPixels);\n        maskData.set(bandMasks[0]);\n        for (i = 1; i < bandMasks.length; i++) {\n          bandMask = bandMasks[i];\n          for (j = 0; j < numPixels; j++) {\n            maskData[j] = maskData[j] & bandMask[j];\n          }\n        }\n        decodedPixelBlock.maskData = maskData;\n      }\n\n      return decodedPixelBlock;\n    }\n  };\n\n  if (typeof define === \"function\" && define.amd) {/* jshint ignore:line */\n    //amd loaders such as dojo and requireJS\n    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\n    define([], function() { return Lerc; });/* jshint ignore:line */\n  }\n  else if (typeof module !== \"undefined\" && module.exports) {/* jshint ignore:line */\n    //commonJS module 1.0/1.1/1.1.1 systems, such as nodeJS\n    //http://wiki.commonjs.org/wiki/Modules\n    module.exports = Lerc;/* jshint ignore:line */\n  }\n  else {\n    //assign to this, most likely window\n    this.Lerc = Lerc;\n  }\n\n})();\n","import { inflate } from 'pako';\nimport Lerc from 'lerc';\nimport BaseDecoder from './basedecoder.js';\nimport { LercParameters, LercAddCompression } from '../globals.js';\n\nexport default class LercDecoder extends BaseDecoder {\n  constructor(fileDirectory) {\n    super();\n\n    this.planarConfiguration = typeof fileDirectory.PlanarConfiguration !== 'undefined' ? fileDirectory.PlanarConfiguration : 1;\n    this.samplesPerPixel = typeof fileDirectory.SamplesPerPixel !== 'undefined' ? fileDirectory.SamplesPerPixel : 1;\n\n    this.addCompression = fileDirectory.LercParameters[LercParameters.AddCompression];\n  }\n\n  decodeBlock(buffer) {\n    switch (this.addCompression) {\n      case LercAddCompression.None:\n        break;\n      case LercAddCompression.Deflate:\n        buffer = inflate(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n        break;\n      default:\n        throw new Error(`Unsupported LERC additional compression method identifier: ${this.addCompression}`);\n    }\n\n    const lercResult = Lerc.decode(buffer, { returnPixelInterleavedDims: this.planarConfiguration === 1 });\n    const lercData = lercResult.pixels[0];\n    return lercData.buffer;\n  }\n}\n"],"names":["LercDecode","CntZImage","defaultNoDataValue","decode","input","options","skipMask","encodedMaskData","parsedData","parse","inputOffset","noDataValue","uncompressedData","uncompressPixelValues","pixelType","Float32Array","returnMask","result","width","height","pixelData","resultPixels","minValue","maxValue","pixels","resultMask","maskData","returnEncodedMask","mask","bitset","returnFileInfo","fileInfo","formatFileInfo","computeUsedBitDepths","bitDepths","data","TypedArrayClass","maskBitset","storeDecodedMask","blockIdx","numX","numBlocksX","numY","numBlocksY","blockWidth","Math","floor","blockHeight","scale","maxZError","Number","MAX_VALUE","currentValue","Uint8Array","blockDataBuffer","xx","yy","y","thisBlockHeight","x","thisBlockWidth","outPtr","outStride","block","blocks","blockData","blockPtr","constValue","encoding","rawData","unstuff","stuffedData","bitsPerPixel","numValidPixels","offset","maskByte","fileIdentifierString","fileVersion","imageType","eofOffset","numBytes","numBlocks","i","float32","Object","keys","fp","fileIdView","String","fromCharCode","apply","trim","view","DataView","getInt32","getUint32","getFloat64","getFloat32","ceil","cnt","getInt16","ip","op","getUint8","val","length","actualNumBlocksX","actualNumBlocksY","Array","blockI","blockY","blockX","size","bytesLeft","byteLength","min","headerByte","offsetType","getInt8","numValidPixelsType","getUint16","arrayBuf","store8","numPixels","ArrayBuffer","set","dataBytes","dataWords","Uint32Array","src","dest","bitMask","o","bitsLeft","n","buffer","nmax","numInvalidTailBytes","missingBits","Lerc2Decode","BitStuffer","lutArr","unstuffLUT","unshift","unstuff2","bitPos","unstuffLUT2","originalUnstuff","originalUnstuff2","Lerc2Helpers","HUFFMAN_LUT_BITS_MAX","computeChecksumFletcher32","sum1","sum2","len","words","tlen","readHeaderInfo","ptr","headerInfo","lastIndexOf","checksum","numDims","numValidPixel","microBlockSize","blobSize","zMin","zMax","keyLength","checkMinMaxRanges","OutPixelTypeArray","getDataTypeArray","rangeBytes","getDataTypeSize","minValues","readSubArray","maxValues","equal","readMask","mb","k","readDataOneSweep","useBSQForOutputDim","swapDimensionOrder","z","nStart","readHuffmanTree","BITS_MAX","version","i0","i1","decodeBits","codeTable","j","first","second","word","srcPtr","numBitsLUT","numBitsLUTQick","tree","TreeNode","undefined","max","decodeLut","entry","code","numEntries","jj","currentBit","node","right","left","readHuffman","huffmanInfo","delta","valTmp","valTmpQuick","ii","prevVal","deltaEncode","encodeMode","resultPixelsAllDim","iDim","viewByteLength","bits67","doLut","numBits","numElements","lutData","lutBytes","lutBitsPerElement","counter","lut","bitstuffer","readTiles","dataTypeSize","row","col","testCode","bytesleft","blockEncoding","lastBlockHeight","lastBlockWidth","fileVersionCheckNum","isDiffEncoding","resultPixelsPrevDim","constant","uncompressed","getDataTypeUsed","getOnePixel","constantoffset","getPixelType","constructConstantSurface","valMin","t","tp","Int8Array","Int16Array","Uint16Array","Int32Array","Float64Array","isValidPixelValue","isValid","s","dt","tc","temp","getUInt32","inputIsBIP","swap","onesweep","returnPixelInterleavedDims","bReadDataOneSweep","abs","flagHuffman","diff","validPixelCount","dimCount","dimStats","getBandCount","count","isPlatformLittleEndian","a","b","c","Lerc","encodedData","lerc","majorVersion","substring","iPlane","eof","bandMasks","bandMask","decodedPixelBlock","statistics","uniqueBandMaskCount","push","define","amd","module","exports","inflate","BaseDecoder","LercParameters","LercAddCompression","LercDecoder","constructor","fileDirectory","planarConfiguration","PlanarConfiguration","samplesPerPixel","SamplesPerPixel","addCompression","AddCompression","decodeBlock","None","Deflate","Error","lercResult","lercData"],"sourceRoot":""}