<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-panel-Panel'>/**
</span> * Panel is a container that has specific functionality and structural components that make it the perfect building
 * block for application-oriented user interfaces.
 *
 * Panels are, by virtue of their inheritance from {@link Ext.container.Container}, capable of being configured with a
 * {@link Ext.container.Container#layout layout}, and containing child Components.
 *
 * When either specifying child {@link #cfg-items} of a Panel, or dynamically {@link Ext.container.Container#method-add adding}
 * Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether those
 * child elements need to be sized using one of Ext&#39;s built-in `{@link Ext.container.Container#layout layout}`
 * schemes. By default, Panels use the {@link Ext.layout.container.Auto Auto} scheme. This simply renders child
 * components, appending them one after the other inside the Container, and **does not apply any sizing** at all.
 *
 * {@img Ext.panel.Panel/panel.png Panel components}
 *
 * A Panel may also contain {@link #bbar bottom} and {@link #tbar top} toolbars, along with separate {@link
 * Ext.panel.Header header}, {@link #fbar footer} and body sections.
 *
 * Panel also provides built-in {@link #collapsible collapsible, expandable} and {@link #closable} behavior. Panels can
 * be easily dropped into any {@link Ext.container.Container Container} or layout, and the layout and rendering pipeline
 * is {@link Ext.container.Container#method-add completely managed by the framework}.
 *
 * **Note:** By default, the `{@link #closable close}` header tool _destroys_ the Panel resulting in removal of the
 * Panel and the destruction of any descendant Components. This makes the Panel object, and all its descendants
 * **unusable**. To enable the close tool to simply _hide_ a Panel for later re-use, configure the Panel with
 * `{@link #closeAction closeAction}: &#39;hide&#39;`.
 *
 * Usually, Panels are used as constituents within an application, in which case, they would be used as child items of
 * Containers, and would themselves use Ext.Components as child {@link #cfg-items}. However to illustrate simply rendering a
 * Panel into the document, here&#39;s how to do it:
 *
 *     @example
 *     Ext.create(&#39;Ext.panel.Panel&#39;, {
 *         title: &#39;Hello&#39;,
 *         width: 200,
 *         html: &#39;&lt;p&gt;World!&lt;/p&gt;&#39;,
 *         renderTo: Ext.getBody()
 *     });
 *
 * A more realistic scenario is a Panel created to house input fields which will not be rendered, but used as a
 * constituent part of a Container:
 *
 *     @example
 *     var filterPanel = Ext.create(&#39;Ext.panel.Panel&#39;, {
 *         bodyPadding: 5,  // Don&#39;t want content to crunch against the borders
 *         width: 300,
 *         title: &#39;Filters&#39;,
 *         items: [{
 *             xtype: &#39;datefield&#39;,
 *             fieldLabel: &#39;Start date&#39;
 *         }, {
 *             xtype: &#39;datefield&#39;,
 *             fieldLabel: &#39;End date&#39;
 *         }],
 *         renderTo: Ext.getBody()
 *     });
 *
 * Note that the Panel above is configured to render into the document and assigned a size. In a real world scenario,
 * the Panel will often be added inside a Container which will use a {@link #layout} to render, size and position its
 * child Components.
 *
 * Panels will often use specific {@link #layout}s to provide an application with shape and structure by containing and
 * arranging child Components:
 *
 *     @example
 *     var resultsPanel = Ext.create(&#39;Ext.panel.Panel&#39;, {
 *         title: &#39;Results&#39;,
 *         width: 600,
 *         height: 400,
 *         renderTo: Ext.getBody(),
 *         layout: {
 *             type: &#39;vbox&#39;,       // Arrange child items vertically
 *             align: &#39;stretch&#39;,    // Each takes up full width
 *             padding: 5
 *         },
 *         items: [{               // Results grid specified as a config object with an xtype of &#39;grid&#39;
 *             xtype: &#39;grid&#39;,
 *             columns: [{header: &#39;Column One&#39;}],            // One header just for show. There&#39;s no data,
 *             store: Ext.create(&#39;Ext.data.ArrayStore&#39;, {}), // A dummy empty data store
 *             flex: 1                                       // Use 1/3 of Container&#39;s height (hint to Box layout)
 *         }, {
 *             xtype: &#39;splitter&#39;   // A splitter between the two child items
 *         }, {                    // Details Panel specified as a config object (no xtype defaults to &#39;panel&#39;).
 *             title: &#39;Details&#39;,
 *             bodyPadding: 5,
 *             items: [{
 *                 fieldLabel: &#39;Data item&#39;,
 *                 xtype: &#39;textfield&#39;
 *             }], // An array of form fields
 *             flex: 2             // Use 2/3 of Container&#39;s height (hint to Box layout)
 *         }]
 *     });
 *
 * The example illustrates one possible method of displaying search results. The Panel contains a grid with the
 * resulting data arranged in rows. Each selected row may be displayed in detail in the Panel below. The {@link
 * Ext.layout.container.VBox vbox} layout is used to arrange the two vertically. It is configured to stretch child items
 * horizontally to full width. Child items may either be configured with a numeric height, or with a `flex` value to
 * distribute available space proportionately.
 *
 * This Panel itself may be a child item of, for example, a {@link Ext.tab.Panel} which 
 * will size its child items to fit within its content area.
 *
 * Using these techniques, as long as the **layout** is chosen and configured correctly, an application may have any
 * level of nested containment, all dynamically sized according to configuration, the user&#39;s preference and available
 * browser size.
 */
Ext.define(&#39;Ext.panel.Panel&#39;, {
    extend: &#39;Ext.container.Container&#39;,
    alias: &#39;widget.panel&#39;,
    alternateClassName: &#39;Ext.Panel&#39;,

    requires: [
        &#39;Ext.panel.Header&#39;,
        &#39;Ext.util.MixedCollection&#39;,
        &#39;Ext.toolbar.Toolbar&#39;,
        &#39;Ext.fx.Anim&#39;,
        &#39;Ext.panel.DD&#39;,
        &#39;Ext.XTemplate&#39;,
        &#39;Ext.layout.component.Dock&#39;,
        &#39;Ext.util.Memento&#39;
    ],

    mixins: {
        docking: &#39;Ext.container.DockingContainer&#39;
    },

<span id='Ext-panel-Panel-cfg-childEls'>    childEls: [
</span>        &#39;bodyWrap&#39;, &#39;body&#39;
    ],

<span id='Ext-panel-Panel-cfg-renderTpl'>    renderTpl: [
</span>        // headingEl can also be inserted in updateHeader
        &#39;&lt;tpl if=&quot;headingText&quot;&gt;&#39;,
            &#39;&lt;div id=&quot;{id}-headingEl&quot; data-ref=&quot;headingEl&quot; role=&quot;heading&quot;&#39;,
                &#39; class=&quot;&#39;, Ext.baseCSSPrefix, &#39;hidden-clip&quot; style=&quot;height:0&quot;&gt;&#39;,
                    &#39;{headingText}&#39;,
            &#39;&lt;/div&gt;&#39;,
        &#39;&lt;/tpl&gt;&#39;,
        &#39;&lt;tpl if=&quot;hasTabGuard&quot;&gt;{% this.renderTabGuard(out, values, \&#39;before\&#39;); %}&lt;/tpl&gt;&#39;,
        &#39;&lt;div id=&quot;{id}-bodyWrap&quot; data-ref=&quot;bodyWrap&quot; class=&quot;{baseCls}-bodyWrap&quot;&#39;,
            &#39;&lt;tpl if=&quot;bodyWrapAriaAttributes&quot;&gt;&#39;,
                &#39;&lt;tpl foreach=&quot;bodyWrapAriaAttributes&quot;&gt; {$}=&quot;{.}&quot;&lt;/tpl&gt;&#39;,
            &#39;&lt;tpl else&gt;&#39;,
                &#39; role=&quot;presentation&quot;&#39;,
            &#39;&lt;/tpl&gt;&#39;,
            &#39;&gt;&#39;,
            // If this Panel is framed, the framing template renders the docked items round the frame
            &#39;{% this.renderDockedItems(out,values,0); %}&#39;,
            &#39;&lt;div id=&quot;{id}-body&quot; data-ref=&quot;body&quot; class=&quot;{baseCls}-body&lt;tpl if=&quot;bodyCls&quot;&gt; {bodyCls}&lt;/tpl&gt;&#39;,
                &#39; {baseCls}-body-{ui}&lt;tpl if=&quot;uiCls&quot;&gt;&#39;,
                    &#39;&lt;tpl for=&quot;uiCls&quot;&gt; {parent.baseCls}-body-{parent.ui}-{.}&lt;/tpl&gt;&#39;,
                &#39;&lt;/tpl&gt;{childElCls}&quot;&#39;,
                &#39;&lt;tpl if=&quot;bodyAriaAttributes&quot;&gt;&#39;,
                    &#39;&lt;tpl foreach=&quot;bodyAriaAttributes&quot;&gt; {$}=&quot;{.}&quot;&lt;/tpl&gt;&#39;,
                &#39;&lt;tpl else&gt;&#39;,
                    &#39; role=&quot;presentation&quot;&#39;,
                &#39;&lt;/tpl&gt;&#39;,
                &#39;&lt;tpl if=&quot;bodyStyle&quot;&gt; style=&quot;{bodyStyle}&quot;&lt;/tpl&gt;&gt;&#39;,
                &#39;{%this.renderContainer(out,values);%}&#39;,
            &#39;&lt;/div&gt;&#39;,
            &#39;{% this.renderDockedItems(out,values,1); %}&#39;,
        &#39;&lt;/div&gt;&#39;,
        &#39;&lt;tpl if=&quot;hasTabGuard&quot;&gt;{% this.renderTabGuard(out, values, \&#39;after\&#39;); %}&lt;/tpl&gt;&#39;
    ],

    // &lt;editor-fold desc=&quot;Config&quot;&gt;
    // ***********************************************************************************
    // Begin Config
    // ***********************************************************************************

<span id='Ext-panel-Panel-property-headerPosition'>    // For performance reasons we give the following configs their default values on
</span>    // the class body.  This prevents the updaters from running on initialization in the
    // default configuration scenario
    headerPosition: &#39;top&#39;,
<span id='Ext-panel-Panel-property-iconAlign'>    iconAlign: &#39;left&#39;,
</span><span id='Ext-panel-Panel-property-titleAlign'>    titleAlign: &#39;left&#39;,
</span><span id='Ext-panel-Panel-property-titleRotation'>    titleRotation: &#39;default&#39;,
</span>
<span id='Ext-panel-Panel-property-beforeRenderConfig'>    beforeRenderConfig: {
</span><span id='Ext-panel-Panel-cfg-glyph'>        /**
</span>         * @cfg glyph
         * @inheritdoc Ext.panel.Header#cfg-glyph
         * @accessor
         */
        glyph: null,

<span id='Ext-panel-Panel-cfg-headerPosition'>        /**
</span>         * @cfg {&#39;top&#39;/&#39;bottom&#39;/&#39;left&#39;/&#39;right&#39;} [headerPosition=&#39;top&#39;]
         * Specify as `&#39;top&#39;`, `&#39;bottom&#39;`, `&#39;left&#39;` or `&#39;right&#39;`.
         * @accessor
         */
        headerPosition: null,

<span id='Ext-panel-Panel-cfg-icon'>        /**
</span>         * @cfg icon
         * @inheritdoc Ext.panel.Header#cfg-icon
         * @accessor
         */
        icon: null,

<span id='Ext-panel-Panel-cfg-iconAlign'>        /**
</span>         * @cfg iconAlign
         * @inheritdoc Ext.panel.Header#cfg-iconAlign
         * @accessor
         */
        iconAlign: null,

<span id='Ext-panel-Panel-cfg-iconCls'>        /**
</span>         * @cfg iconCls
         * @inheritdoc Ext.panel.Header#cfg-iconCls
         * @accessor
         */
        iconCls: null,

<span id='Ext-panel-Panel-cfg-title'>        /**
</span>         * @cfg {String/Object}
         * @inheritdoc Ext.panel.Header#title
         * @localdoc When a `title` is specified, the {@link Ext.panel.Header} will 
         * automatically be created and displayed unless {@link #header} is set to `false`.
         * @accessor
         */
        title: null,

<span id='Ext-panel-Panel-cfg-titleAlign'>        /**
</span>         * @cfg titleAlign
         * @inheritdoc Ext.panel.Header#cfg-titleAlign
         * @accessor
         */
        titleAlign: null,

<span id='Ext-panel-Panel-cfg-titleRotation'>        /**
</span>         * @cfg titleRotation
         * @inheritdoc Ext.panel.Header#cfg-titleRotation
         * @accessor
         */
        titleRotation: null
    },

<span id='Ext-panel-Panel-cfg-animCollapse'>    /**
</span>     * @cfg {Boolean/Number} animCollapse
     * `true` to animate the transition when the panel is collapsed, `false` to skip the animation (defaults to `true`
     * if the {@link Ext.fx.Anim} class is available, otherwise `false`). May also be specified as the animation
     * duration in milliseconds.
     */
    animCollapse: Ext.enableFx,

<span id='Ext-panel-Panel-cfg-bodyBorder'>    /**
</span>     * @cfg {Boolean} bodyBorder
     * A shortcut to add or remove the border on the body of a panel. In the classic theme
     * this only applies to a panel which has the {@link #frame} configuration set to `true`.
     * @since 2.3.0
     */

<span id='Ext-panel-Panel-cfg-bodyCls'>    /**
</span>     * @cfg {String/String[]} bodyCls
     * A CSS class, space-delimited string of classes, or array of classes to be applied to the panel&#39;s body element.
     * The following examples are all valid:
     *
     *     bodyCls: &#39;foo&#39;
     *     bodyCls: &#39;foo bar&#39;
     *     bodyCls: [&#39;foo&#39;, &#39;bar&#39;]
     */

<span id='Ext-panel-Panel-cfg-bodyPadding'>    /**
</span>     * @cfg {Number/String} [bodyPadding=undefined]
     * A shortcut for setting a padding style on the body element. The value can either be
     * a number to be applied to all sides, or a normal css string describing padding.
     */

<span id='Ext-panel-Panel-cfg-bodyStyle'>    /**
</span>     * @cfg {String/Object/Function} bodyStyle
     * Custom CSS styles to be applied to the panel&#39;s body element, which can be supplied as a valid CSS style string,
     * an object containing style property name/value pairs or a function that returns such a string or object.
     * For example, these two formats are interpreted to be equivalent:
     *
     *     bodyStyle: &#39;background:#ffc; padding:10px;&#39;
     *
     *     bodyStyle: {
     *         background: &#39;#ffc&#39;,
     *         padding: &#39;10px&#39;
     *     }
     *
     * @since 2.3.0
     */

<span id='Ext-panel-Panel-cfg-border'>    /**
</span>     * @cfg {Boolean} [border=true]
     * Specify as `false` to render the Panel with zero width borders.
     *
     * Leaving the value as `true` uses the selected theme&#39;s {@link Ext.panel.Panel#$panel-border-width}
     *
     * Defaults to `false` when using or extending Neptune.
     * 
     * **Note:** is ignored when {@link #frame} is set to **true**.
     */
    border: true,

<span id='Ext-panel-Panel-cfg-closable'>    /**
</span>     * @cfg {Boolean} closable
     * True to display the &#39;close&#39; tool button and allow the user to close the window, false to hide the button and
     * disallow closing the window.
     *
     * By default, when close is requested by clicking the close button in the header, the {@link #method-close} method will be
     * called. This will _{@link Ext.Component#method-destroy destroy}_ the Panel and its content meaning that it may not be
     * reused.
     *
     * To make closing a Panel _hide_ the Panel so that it may be reused, set {@link #closeAction} to &#39;hide&#39;.
     * @accessor
     */
    closable: false,

<span id='Ext-panel-Panel-cfg-closeAction'>    /**
</span>     * @cfg {String} closeAction
     * The action to take when the close header tool is clicked:
     *
     * - **`&#39;{@link #method-destroy}&#39;`** :
     *
     *   {@link #method-remove remove} the window from the DOM and {@link Ext.Component#method-destroy destroy} it and all descendant
     *   Components. The window will **not** be available to be redisplayed via the {@link #method-show} method.
     *
     * - **`&#39;{@link #method-hide}&#39;`** :
     *
     *   {@link #method-hide} the window by setting visibility to hidden and applying negative offsets. The window will be
     *   available to be redisplayed via the {@link #method-show} method.
     *
     * **Note:** This behavior has changed! setting *does* affect the {@link #method-close} method which will invoke the
     * appropriate closeAction.
     */
    closeAction: &#39;destroy&#39;,
    
    //&lt;locale&gt;
<span id='Ext-panel-Panel-cfg-closeToolText'>    /**
</span>     * @cfg {String} closeToolText Text to be announced by screen readers when the 
     * **close** {@link Ext.panel.Tool tool} is focused.  Will also be set as the close 
     * tool&#39;s {@link Ext.panel.Tool#cfg-tooltip tooltip} text.
     * 
     * **Note:** Applicable when the panel is {@link #closable}: true
     */
    closeToolText: &#39;Close panel&#39;,
    //&lt;/locale&gt;

<span id='Ext-panel-Panel-cfg-collapsed'>    /**
</span>     * @cfg {Boolean} collapsed
     * `true` to render the panel collapsed, `false` to render it expanded.
     */
    collapsed: false,

<span id='Ext-panel-Panel-cfg-collapsedCls'>    /**
</span>     * @cfg {String} collapsedCls
     * A CSS class to add to the panel&#39;s element after it has been collapsed.
     */
    collapsedCls: &#39;collapsed&#39;,

<span id='Ext-panel-Panel-cfg-collapseDirection'>    /**
</span>     * @cfg {String} collapseDirection
     * The direction to collapse the Panel when the toggle button is clicked.
     *
     * Defaults to the {@link #cfg-headerPosition}
     *
     * **Important: This config is _ignored_ for {@link #collapsible} Panels which are direct child items of a {@link
     * Ext.layout.container.Border border layout}.**
     *
     * Specify as `&#39;top&#39;`, `&#39;bottom&#39;`, `&#39;left&#39;` or `&#39;right&#39;`.
     */

<span id='Ext-panel-Panel-cfg-collapseFirst'>    /**
</span>     * @cfg {Boolean} collapseFirst
     * `true` to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in
     * the panel&#39;s title bar, `false` to render it last.
     */
    collapseFirst: true,

<span id='Ext-panel-Panel-cfg-collapsible'>    /**
</span>     * @cfg {Boolean} collapsible
     * True to make the panel collapsible and have an expand/collapse toggle Tool added into the header tool button
     * area. False to keep the panel sized either statically, or by an owning layout manager, with no toggle Tool.
     * When a panel is used in a {@link Ext.layout.container.Border border layout}, the {@link #floatable} option
     * can influence the behavior of collapsing.
     * See {@link #collapseMode} and {@link #collapseDirection}
     */
    collapsible: undefined,

<span id='Ext-panel-Panel-cfg-collapseMode'>    /**
</span>     * @cfg {String} collapseMode
     * **Important: this config is only effective for {@link #collapsible} Panels which are direct child items of a
     * {@link Ext.layout.container.Border border layout}.**
     *
     * When _not_ a direct child item of a {@link Ext.layout.container.Border border layout}, then the Panel&#39;s header
     * remains visible, and the body is collapsed to zero dimensions. If the Panel has no header, then a new header
     * (orientated correctly depending on the {@link #collapseDirection}) will be inserted to show a the title and a re-
     * expand tool.
     *
     * When a child item of a {@link Ext.layout.container.Border border layout}, this config has three possible values:
     *
     * - `undefined` - When collapsed, a placeholder {@link Ext.panel.Header Header} is injected into the layout to
     *   represent the Panel and to provide a UI with a Tool to allow the user to re-expand the Panel.
     *
     * - `&quot;header&quot;` - The Panel collapses to leave its header visible as when not inside a
     *   {@link Ext.layout.container.Border border layout}.
     *
     * - `&quot;mini&quot;` - The Panel collapses without a visible header.
     */
    
    //&lt;locale&gt;
<span id='Ext-panel-Panel-cfg-collapseToolText'>    /**
</span>     * @cfg {String} collapseToolText Text to be announced by screen readers when 
     * **collapse** {@link Ext.panel.Tool tool} is focused.  Will also be set as the 
     * collapse tool&#39;s {@link Ext.panel.Tool#cfg-tooltip tooltip} text.
     * 
     * **Note:** Applicable when the panel is {@link #collapsible}: true
     */
    collapseToolText: &#39;Collapse panel&#39;,
    
<span id='Ext-panel-Panel-cfg-expandToolText'>    /**
</span>     * @cfg {String} expandToolText Text to be announced by screen readers when 
     * **expand** {@link Ext.panel.Tool tool} is focused.  Will also be set as the 
     * expand tool&#39;s {@link Ext.panel.Tool#cfg-tooltip tooltip} text.
     * 
     * **Note:** Applicable when the panel is {@link #collapsible}: true
     */
    expandToolText: &#39;Expand panel&#39;,
    //&lt;/locale&gt;

<span id='Ext-panel-Panel-cfg-constrain'>    /**
</span>     * @cfg {Boolean} constrain
     * True to constrain the panel within its containing element, false to allow it to fall outside of its containing
     * element. By default floating components such as Windows will be rendered to `document.body`. To render and constrain the window within
     * another element specify {@link #renderTo}. Optionally the header only can be constrained
     * using {@link #constrainHeader}.
     */
    constrain: false,

<span id='Ext-panel-Panel-cfg-constrainHeader'>    /**
</span>     * @cfg {Boolean} constrainHeader
     * True to constrain the panel header within its containing element (allowing the panel body to fall outside of
     * its containing element) or false to allow the header to fall outside its containing element.
     * Optionally the entire panel can be constrained using {@link #constrain}.
     */
    constrainHeader: false,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;}
<span id='Ext-panel-Panel-cfg-dockedItems'>    /**
</span>     * @cfg {Object/Object[]} dockedItems
     * A component or series of components to be added as docked items to this panel. The docked items can be docked to
     * either the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars:
     *
     *     var panel = new Ext.panel.Panel({
     *         dockedItems: [{
     *             xtype: &#39;toolbar&#39;,
     *             dock: &#39;top&#39;,
     *             items: [{
     *                 text: &#39;Docked to the top&#39;
     *             }]
     *         }]
     *     });
     */
    dockedItems: null,

<span id='Ext-panel-Panel-cfg-buttonAlign'>    /**
</span>     * @cfg {String} buttonAlign
     * The alignment of any buttons added to this panel. Valid values are &#39;right&#39;, &#39;left&#39; and &#39;center&#39; (defaults to
     * &#39;right&#39; for buttons/fbar, &#39;left&#39; for other toolbar types).
     *
     * **NOTE:** The preferred way to specify toolbars is to use the dockedItems config. Instead of buttonAlign you
     * would add the layout: { pack: &#39;start&#39; | &#39;center&#39; | &#39;end&#39; } option to the dockedItem config.
     */

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-tbar'>    /**
</span>     * @cfg {Object/Object[]} tbar
     * Convenience config. Short for &#39;Top Bar&#39;.
     *
     *     tbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;top&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    tbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-bbar'>    /**
</span>     * @cfg {Object/Object[]} bbar
     * Convenience config. Short for &#39;Bottom Bar&#39;.
     *
     *     bbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;bottom&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    bbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-fbar'>    /**
</span>     * @cfg {Object/Object[]} fbar
     * Convenience config used for adding items to the bottom of the panel. Short for Footer Bar.
     *
     *     fbar: [
     *       { type: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;bottom&#39;,
     *         ui: &#39;footer&#39;,
     *         defaults: {
     *             minWidth: 200
     *         },
     *         items: [
     *             { xtype: &#39;component&#39;, flex: 1 },
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     *
     * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
     * each of the buttons in the fbar.
     */
    fbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-lbar'>    /**
</span>     * @cfg {Object/Object[]} lbar
     * Convenience config. Short for &#39;Left Bar&#39; (left-docked, vertical toolbar).
     *
     *     lbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;left&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    lbar: null,

    // @cmd-auto-dependency {aliasPrefix: &quot;widget.&quot;, typeProperty: &quot;xtype&quot;, defaultType: &quot;toolbar&quot;}
<span id='Ext-panel-Panel-cfg-rbar'>    /**
</span>     * @cfg {Object/Object[]} rbar
     * Convenience config. Short for &#39;Right Bar&#39; (right-docked, vertical toolbar).
     *
     *     rbar: [
     *       { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;right&#39;,
     *         items: [
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     */
    rbar: null,

<span id='Ext-panel-Panel-cfg-buttons'>    /**
</span>     * @cfg {Object/Object[]} buttons
     * Convenience config used for adding buttons docked to the bottom of the panel. This is a
     * synonym for the {@link #fbar} config.
     *
     *     buttons: [
     *       { text: &#39;Button 1&#39; }
     *     ]
     *
     * is equivalent to
     *
     *     dockedItems: [{
     *         xtype: &#39;toolbar&#39;,
     *         dock: &#39;bottom&#39;,
     *         ui: &#39;footer&#39;,
     *         defaults: {
     *             minWidth: 200
     *         },
     *         items: [
     *             { xtype: &#39;component&#39;, flex: 1 },
     *             { xtype: &#39;button&#39;, text: &#39;Button 1&#39; }
     *         ]
     *     }]
     *
     * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
     * each of the buttons in the buttons toolbar.
     */
    buttons: null,
    
<span id='Ext-panel-Panel-cfg-draggable'>    /**
</span>     * @cfg draggable
     * @inheritdoc
     * @localdoc **NOTE:** The private {@link Ext.panel.DD} class is used instead of 
     * ComponentDragger when {@link #simpleDrag} is false (_default_).  In this case you 
     * may pass a config for {@link Ext.dd.DragSource}.
     * 
     * See also {@link #dd}.
     */

<span id='Ext-panel-Panel-cfg-floatable'>    /**
</span>     * @cfg {Boolean} floatable
     * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
     * {@link Ext.layout.container.Border border layout}.**
     *
     * true to allow clicking a collapsed Panel&#39;s {@link #placeholder} to display the Panel floated above the layout,
     * false to force the user to fully expand a collapsed region by clicking the expand button to see it again.
     */
    floatable: true,

<span id='Ext-panel-Panel-cfg-frame'>    /**
</span>     * @cfg {Boolean} frame
     * True to apply a frame to the panel.
     * 
     * **Note:** `frame: true` overrides {@link #border border:false}
     */
    frame: false,

<span id='Ext-panel-Panel-cfg-frameHeader'>    /**
</span>     * @cfg {Boolean} frameHeader
     * True to apply a frame to the panel panels header (if &#39;frame&#39; is true).
     */
    frameHeader: true,


<span id='Ext-panel-Panel-cfg-header'>    /**
</span>     * @cfg {Boolean/Object} [header]
     * Pass as `false` to prevent a Header from being created and shown.
     *
     * Pass as a config object (optionally containing an `xtype`) to custom-configure this Panel&#39;s header.
     *
     * See {@link Ext.panel.Header} for all the options that may be specified here.
     *
     * A {@link Ext.panel.Header panel header} is a {@link Ext.container.Container} which contains the Panel&#39;s {@link #title} and {@link #tools}.
     * You may also configure the Panel&#39;s `header` option with its own child items which go *before* the {@link #tools}
     *
     * By default the panel {@link #title} is inserted after items configured in this config, but before any tools.
     * To insert the title at any point in the full array, specify the {@link Ext.panel.Header#cfg-titlePosition titlePosition} config:
     *
     *     new Ext.panel.Panel({
     *         title: &#39;Test&#39;,
     *         tools: [{
     *             type: &#39;refresh&#39;
     *         }, {
     *             type: &#39;help&#39;
     *         }],
     *         titlePosition: 2 // Title will come AFTER the two tools
     *         ...
     *     });
     *
     */

<span id='Ext-panel-Panel-cfg-headerOverCls'>    /**
</span>     * @cfg {String} headerOverCls
     * Optional CSS class to apply to the header element on mouseover
     */

<span id='Ext-panel-Panel-cfg-hideCollapseTool'>    /**
</span>     * @cfg {Boolean} hideCollapseTool
     * `true` to hide the expand/collapse toggle button when `{@link #collapsible} == true`, `false` to display it.
     */
    hideCollapseTool: false,


<span id='Ext-panel-Panel-cfg-manageHeight'>    /**
</span>     * @cfg {Boolean} [manageHeight=true] When true, the dock component layout writes
     * height information to the panel&#39;s DOM elements based on its shrink wrap height
     * calculation. This ensures that the browser respects the calculated height.
     * When false, the dock component layout will not write heights on the panel or its
     * body element. In some simple layout cases, not writing the heights to the DOM may
     * be desired because this allows the browser to respond to direct DOM manipulations
     * (like animations).
     */
    manageHeight: true,

<span id='Ext-panel-Panel-cfg-maskElement'>    /**
</span>     * @cfg {String} [maskElement=&quot;el&quot;]
     *
     * The name of the element property in this Panel to mask when masked by a LoadMask.
     *
     * Defaults to `&quot;el&quot;` to indicate that any LoadMask should be rendered into this Panel&#39;s encapsulating element.
     *
     * This could be configured to be `&quot;body&quot;` so that only the body is masked and toolbars and the header are still mouse-accessible.
     */
    maskElement: &#39;el&#39;,

<span id='Ext-panel-Panel-cfg-minButtonWidth'>    /**
</span>     * @cfg {Number} minButtonWidth
     * Minimum width of all footer toolbar buttons in pixels. If set, this will be used as the default
     * value for the {@link Ext.button.Button#minWidth} config of each Button added to the **footer toolbar** via the
     * {@link #fbar} or {@link #buttons} configurations. It will be ignored for buttons that have a minWidth configured
     * some other way, e.g. in their own config object or via the {@link Ext.container.Container#defaults defaults} of
     * their parent container.
     */
    minButtonWidth: 75,

<span id='Ext-panel-Panel-cfg-overlapHeader'>    /**
</span>     * @cfg {Boolean} overlapHeader
     * True to overlap the header in a panel over the framing of the panel itself. This is needed when frame:true (and
     * is done automatically for you). Otherwise it is undefined. If you manually add rounded corners to a panel header
     * which does not have frame:true, this will need to be set to true.
     */

<span id='Ext-panel-Panel-cfg-placeholder'>    /**
</span>     * @cfg {Ext.Component/Object} placeholder
     * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
     * {@link Ext.layout.container.Border border layout} when not using the `&#39;header&#39;` {@link #collapseMode}.**
     *
     * **Optional.** A Component (or config object for a Component) to show in place of this Panel when this Panel is
     * collapsed by a {@link Ext.layout.container.Border border layout}. Defaults to a generated {@link Ext.panel.Header
     * Header} containing a {@link Ext.panel.Tool Tool} to re-expand the Panel.
     */

<span id='Ext-panel-Panel-cfg-placeholderCollapseHideMode'>    /**
</span>     * @cfg {Number} [placeholderCollapseHideMode=Ext.Element.VISIBILITY]
     * The {@link Ext.dom.Element#setVisibilityMode mode} for hiding collapsed panels when
     * using {@link #collapseMode} &quot;placeholder&quot;.
     */
    //placeholderCollapseHideMode: Ext.Element.VISIBILITY,

<span id='Ext-panel-Panel-cfg-preventHeader'>    /**
</span>     * @cfg {Boolean} preventHeader
     * @deprecated 4.1.0 Use {@link #header} instead.
     * Prevent a Header from being created and shown.
     */
     preventHeader: false,

<span id='Ext-panel-Panel-cfg-shrinkWrap'>    /**
</span>     * @cfg [shrinkWrap=2]
     * @inheritdoc
     * @localdoc ##Panels (subclasses and instances)
     * 
     * By default, when a panel is configured to shrink wrap in a given dimension, only 
     * the panel&#39;s &quot;content&quot; (items and html content inside the panel body) contributes 
     * to its size, and the content of docked items is ignored. Optionally you can use 
     * the {@link #shrinkWrapDock} config to allow docked items to contribute to the 
     * panel&#39;s size as well. For example, if shrinkWrap and shrinkWrapDock are both set 
     * to true, the width of the panel would be the width of the panel&#39;s content and the 
     * panel&#39;s header text.
     */

<span id='Ext-panel-Panel-cfg-shrinkWrapDock'>    /**
</span>     * @cfg {Boolean/Number} shrinkWrapDock
     * Allows for this panel to include the {@link #dockedItems} when trying to determine 
     * the overall size of the panel. This option is only applicable when this panel is 
     * also shrink wrapping in the same dimensions. See {@link Ext.Panel#shrinkWrap} for 
     * an explanation of the configuration options.
     */
    shrinkWrapDock: false,

<span id='Ext-panel-Panel-cfg-simpleDrag'>    /**
</span>     * @cfg {Boolean} [simpleDrag=false]
     * When {@link #cfg-draggable} is `true`, Specify this as `true` to  cause the `draggable` config
     * to work the same as it does in {@link Ext.window.Window Window}. This Panel
     * just becomes movable. No DragDrop instances receive any notifications.
     * For example:
     *
     *     @example
     *     var win = Ext.create(&#39;widget.window&#39;, {
     *         height: 300,
     *         width: 300,
     *         title: &#39;Constraining Window&#39;,
     *         closable: false,
     *         items: {
     *             title: &quot;Floating Panel&quot;,
     *             width: 100,
     *             height: 100,
     *             floating: true,
     *             draggable: true,
     *             constrain: true,
     *             simpleDrag: true
     *         }
     *     });
     *     win.show();
     *     // Floating components begin life hidden
     *     win.child(&#39;[title=Floating Panel]&#39;).show();
     *
     */

<span id='Ext-panel-Panel-cfg-stateEvents'>    /**
</span>     * @cfg stateEvents
     * @inheritdoc Ext.state.Stateful#cfg-stateEvents
     * @localdoc By default the following stateEvents are added:
     * 
     *  - {@link #event-resize} - _(added by Ext.Component)_
     *  - {@link #event-collapse}
     *  - {@link #event-expand}
     */

<span id='Ext-panel-Panel-cfg-titleCollapse'>    /**
</span>     * @cfg {Boolean} titleCollapse
     * `true` to allow expanding and collapsing the panel (when `{@link #collapsible} = true`) by clicking anywhere in
     * the header bar, `false`) to allow it only by clicking to tool button). When a panel is used in a
     * {@link Ext.layout.container.Border border layout}, the {@link #floatable} option can influence the behavior of collapsing.
     */
    titleCollapse: undefined,

<span id='Ext-panel-Panel-cfg-tools'>    /**
</span>     * @cfg {Object[]/Ext.panel.Tool[]} tools
     * An array of {@link Ext.panel.Tool} configs/instances to be added to the header tool area. The tools are stored as
     * child components of the header container. They can be accessed using {@link #down} and {#query}, as well as the
     * other component methods. The toggle tool is automatically created if {@link #collapsible} is set to true.
     *
     * Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the
     * visual button. Any required functionality must be provided by adding handlers that implement the necessary
     * behavior.
     *
     * Example usage:
     *
     *     tools:[{
     *         type:&#39;refresh&#39;,
     *         tooltip: &#39;Refresh form Data&#39;,
     *         // hidden:true,
     *         handler: function(event, toolEl, panelHeader) {
     *             // refresh logic
     *         }
     *     },
     *     {
     *         type:&#39;help&#39;,
     *         tooltip: &#39;Get Help&#39;,
     *         callback: function(panel, tool, event) {
     *             // show help here
     *         }
     *     }]
     *
     * The difference between `handler` and `callback` is the signature. For details on
     * the distinction, see {@link Ext.panel.Tool}.
     */
    
<span id='Ext-panel-Panel-cfg-defaultButton'>    /**
</span>     * @cfg {String} [defaultButton] Reference name of the component to act as the default
     * button for this Panel. Default button is activated by pressing Enter key while focus
     * is contained within the Panel&#39;s {@link #defaultButtonTarget}.
     *
     * The most obvious use for `defaultButton` is submitting a form:
     *
     *      var loginWindow = new Ext.window.Window({
     *          autoShow: true,
     *          width: 300,
     *          layout: &#39;form&#39;,
     *          title: &#39;Enter login information&#39;,
     *          referenceHolder: true,
     *          defaultFocus: &#39;textfield&#39;,
     *          defaultButton: &#39;okButton&#39;,
     *          
     *          items: [{
     *              xtype: &#39;textfield&#39;,
     *              fieldLabel: &#39;User name&#39;
     *          }, {
     *              xtype: &#39;textfield&#39;,
     *              fieldLabel: &#39;Password&#39;
     *          }],
     *          
     *          buttons: [{
     *              reference: &#39;okButton&#39;,
     *              text: &#39;Login&#39;,
     *              handler: function() {
     *                  Ext.Msg.alert(&#39;Submit&#39;, &#39;Your login is being processed&#39;);
     *              }
     *          }]
     *      });
     */
    
<span id='Ext-panel-Panel-cfg-defaultButtonTarget'>    /**
</span>     * @cfg {String} [defaultButtonTarget] Name of the element that will be the target of
     * {@link #defaultButton} keydown listener. The default element is Panel body, which
     * means that pressing Enter key while focus is on docked items will not fire `defaultButton`
     * action.
     *
     * If you want `defaultButton` action to fire in docked items, set this config to `&quot;el&quot;`.
     */

    // ***********************************************************************************
    // End Config
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

<span id='Ext-panel-Panel-cfg-baseCls'>    // &lt;editor-fold desc=&quot;Properties&quot;&gt;
</span>    // ***********************************************************************************
    // Begin Properties
    // ***********************************************************************************

    baseCls: Ext.baseCSSPrefix + &#39;panel&#39;,

<span id='Ext-panel-Panel-property-body'>    /**
</span>     * @property {Ext.dom.Element} body
     * The Panel&#39;s body {@link Ext.dom.Element Element} which may be used to contain HTML content.
     * The content may be specified in the {@link #html} config, or it may be loaded using the
     * {@link #loader} config. Read-only.
     *
     * If this is used to load visible HTML elements in either way, then
     * the Panel may not be used as a Layout for hosting nested Panels.
     *
     * If this Panel is intended to be used as the host of a Layout (See {@link #layout}
     * then the body Element must not be loaded or changed - it is under the control
     * of the Panel&#39;s Layout.
     *
     * @readonly
     */

    bodyPosProps: {
        x: &#39;x&#39;,
        y: &#39;y&#39;
    },

<span id='Ext-panel-Panel-cfg-componentLayout'>    componentLayout: &#39;dock&#39;,
</span>
<span id='Ext-panel-Panel-property-contentPaddingProperty'>    /**
</span>     * @property {String} [contentPaddingProperty=&#39;bodyPadding&#39;]
     * @inheritdoc
     */
    contentPaddingProperty: &#39;bodyPadding&#39;,

<span id='Ext-panel-Panel-property-emptyArray'>    emptyArray: [],
</span>
<span id='Ext-panel-Panel-property-isPanel'>    /**
</span>     * @property {Boolean} isPanel
     * `true` in this class to identify an object as an instantiated Panel, or subclass thereof.
     */
    isPanel: true,

<span id='Ext-panel-Panel-property-defaultBindProperty'>    defaultBindProperty: &#39;title&#39;,
</span>
    // ***********************************************************************************
    // End Properties
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    // &lt;editor-fold desc=&quot;Events&quot;&gt;
    // ***********************************************************************************
    // Begin Events
    // ***********************************************************************************

<span id='Ext-panel-Panel-event-beforeclose'>    /**
</span>     * @event beforeclose
     * Fires before the user closes the panel. Return false from any listener to stop the close event being
     * fired
     * @param {Ext.panel.Panel} panel The Panel object
     */

<span id='Ext-panel-Panel-event-beforecollapse'>    /**
</span>     * @event beforecollapse
     * Fires before this panel is collapsed. Return false to prevent the collapse.
     * @param {Ext.panel.Panel} p The Panel being collapsed.
     * @param {String} direction . The direction of the collapse. One of
     *
     *   - Ext.Component.DIRECTION_TOP
     *   - Ext.Component.DIRECTION_RIGHT
     *   - Ext.Component.DIRECTION_BOTTOM
     *   - Ext.Component.DIRECTION_LEFT
     *
     * @param {Boolean} animate True if the collapse is animated, else false.
     */

<span id='Ext-panel-Panel-event-beforeexpand'>    /**
</span>     * @event beforeexpand
     * Fires before this panel is expanded. Return false to prevent the expand.
     * @param {Ext.panel.Panel} p The Panel being expanded.
     * @param {Boolean} animate True if the expand is animated, else false.
     */

<span id='Ext-panel-Panel-event-close'>    /**
</span>     * @event close
     * Fires when the user closes the panel.
     * @param {Ext.panel.Panel} panel The Panel object
     */

<span id='Ext-panel-Panel-event-collapse'>    /**
</span>     * @event collapse
     * Fires after this Panel has collapsed.
     * @param {Ext.panel.Panel} p The Panel that has been collapsed.
     */

<span id='Ext-panel-Panel-event-expand'>    /**
</span>     * @event expand
     * Fires after this Panel has expanded.
     * @param {Ext.panel.Panel} p The Panel that has been expanded.
     */

<span id='Ext-panel-Panel-event-float'>    /**
</span>     * @event float
     * Fires after a collapsed Panel has been &quot;floated&quot; by clicking on
     * it&#39;s header. Only applicable when the Panel is an item in a
     * {@link Ext.layout.container.Border Border Layout}.
     */

<span id='Ext-panel-Panel-event-glyphchange'>    /**
</span>     * @event glyphchange
     * Fired when the Panel glyph has been changed by the {@link #setGlyph} method.
     * @param {Ext.panel.Panel} this
     * @param {Number/String} newGlyph
     * @param {Number/String} oldGlyph
     */

<span id='Ext-panel-Panel-event-iconchange'>    /**
</span>     * @event iconchange
     * Fires after the Panel icon has been set or changed.
     * @param {Ext.panel.Panel} p The Panel which has the icon changed.
     * @param {String} newIcon The path to the new icon image.
     * @param {String} oldIcon The path to the previous panel icon image.
     */

<span id='Ext-panel-Panel-event-iconclschange'>    /**
</span>     * @event iconclschange
     * Fires after the Panel iconCls has been set or changed.
     * @param {Ext.panel.Panel} p The Panel which has the iconCls changed.
     * @param {String} newIconCls The new iconCls.
     * @param {String} oldIconCls The previous panel iconCls.
     */

<span id='Ext-panel-Panel-event-titlechange'>    /**
</span>     * @event titlechange
     * Fires after the Panel title has been set or changed.
     * @param {Ext.panel.Panel} p the Panel which has been resized.
     * @param {String} newTitle The new title.
     * @param {String} oldTitle The previous panel title.
     */

<span id='Ext-panel-Panel-event-unfloat'>    /**
</span>     * @event unfloat
     * Fires after a &quot;floated&quot; Panel has returned to it&#39;s collapsed state
     * as a result of the mouse leaving the Panel. Only applicable when
     * the Panel is an item in a
     * {@link Ext.layout.container.Border Border Layout}.
     */

    // ***********************************************************************************
    // End Events
    // ***********************************************************************************
    // &lt;/editor-fold&gt;

    // &lt;editor-fold desc=&quot;Component Methods&quot;&gt;
    // ***********************************************************************************
    // Begin Methods
    // ***********************************************************************************

<span id='Ext-panel-Panel-method-addBodyCls'>    /**
</span>     * Adds a CSS class to the body element. If not rendered, the class will
     * be added when the panel is rendered.
     * @param {String/String[]} cls The class to add
     * @return {Ext.panel.Panel} this
     */
    addBodyCls: function(cls) {
        var me = this,
            body = me.rendered ? me.body : me.getProtoBody();

        body.addCls(cls);
        return me;
    },

<span id='Ext-panel-Panel-method-addTool'>    /**
</span>     * Add tools to this panel
     * @param {Object[]/Ext.panel.Tool[]} tools The tools to add.
     *
     * By default the tools will be accessible via keyboard, with the exception
     * of automatically added collapse/expand and close tools.
     *
     * If you implement keyboard equivalents of your tools&#39; actions elsewhere
     * and do not want the tools to participate in keyboard navigation, you can
     * make them presentational instead:
     *
     *      panel.addTool({
     *          type: &#39;mytool&#39;,
     *          focusable: false,
     *          ariaRole: &#39;presentation&#39;,
     *          ...
     *      });
     */
    addTool: function(tools) {
        if (!Ext.isArray(tools)) {
            tools = [tools];
        }

        var me     = this,
            header = me.header,
            tLen   = tools.length,
            curTools = me.tools,
            t, tool;

        if (!header || !header.isHeader) {
            header = null;
            if (!curTools) {
                me.tools = curTools = [];
            }
        }

        for (t = 0; t &lt; tLen; t++) {
            tool = tools[t];
            tool.toolOwner = me;

            if (header) {
                header.addTool(tool);
            } else {
                // only modify the tools array if the header isn&#39;t created,
                // otherwise, defer to the header to manage
                curTools.push(tool);
            }
        }

        me.updateHeader();
    },

<span id='Ext-panel-Panel-method-addTools'>    /**
</span>     * @method
     * @protected
     * @template
     * Template method to be implemented in subclasses to add their tools after the collapsible tool.
     */
    addTools: Ext.emptyFn,

<span id='Ext-panel-Panel-method-getClosable'>    getClosable: function () {
</span>        return this.closable;
    },

<span id='Ext-panel-Panel-method-setClosable'>    setClosable: function (closable) {
</span>        var me = this,
            tab = me.tab;

        closable = !!closable;

        if (me.closable !== closable) {
            me.closable = closable;

            if (tab) {
                tab.setClosable(closable);
            }
        }
    },

<span id='Ext-panel-Panel-method-setCollapsible'>    setCollapsible: function (collapsible) {
</span>        var me = this,
            current = me.collapsible,
            collapseTool = me.collapseTool;

        me.collapsible = collapsible;

        if (collapsible &amp;&amp; !current) {
            me.updateCollapseTool();

            collapseTool = me.collapseTool;
            if (collapseTool) {
                collapseTool.show();
            }
        } else if (!collapsible &amp;&amp; current) {
            if (collapseTool) {
                collapseTool.hide();
            }
        }
    },

<span id='Ext-panel-Panel-method-addUIClsToElement'>    /**
</span>     * @inheritdoc
     */
    addUIClsToElement: function(cls) {
        var me = this,
            result = me.callParent(arguments);

        me.addBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + &#39;-body-&#39; + cls, me.baseCls + &#39;-body-&#39; + me.ui + &#39;-&#39; + cls]);
        return result;
    },

<span id='Ext-panel-Panel-method-afterCollapse'>    /**
</span>     * Invoked after the Panel is Collapsed.
     *
     * @param {Boolean} animated
     *
     * @template
     * @protected
     */
    afterCollapse: function(animated) {
        var me = this,
            ownerLayout = me.ownerLayout;

        me.isCollapsingOrExpanding = 0;
        me.updateCollapseTool();

        // The x-animating-size class sets overflow:hidden so that overflowing
        // content is clipped during animation.
        if (animated) {
            me.removeCls(Ext.baseCSSPrefix + &#39;animating-size&#39;);
        }

        if (ownerLayout) {
            ownerLayout.afterCollapse(me, animated);
        }
        
        me.setHiddenDocked();
        me.fireEvent(&#39;collapse&#39;, me);
    },

<span id='Ext-panel-Panel-method-afterExpand'>    /**
</span>     * Invoked after the Panel is Expanded.
     *
     * @param {Boolean} animated
     *
     * @template
     * @protected
     */
    afterExpand: function(animated) {
        var me = this,
            ownerLayout = me.ownerLayout;

        me.isCollapsingOrExpanding = 0;
        me.updateCollapseTool();

        // The x-animating-size class sets overflow:hidden so that overflowing
        // content is clipped during animation.
        if (animated) {
            me.removeCls(Ext.baseCSSPrefix + &#39;animating-size&#39;);
        }

        if (ownerLayout) {
            ownerLayout.afterExpand(me, animated);
        }

        me.fireEvent(&#39;expand&#39;, me);
        me.fireHierarchyEvent(&#39;expand&#39;);
    },

<span id='Ext-panel-Panel-method-doDestroy'>    doDestroy: function() {
</span>        var me = this;
        
        Ext.destroy(
            me.placeholder,
            me.ghostPanel,
            me.dd,
            me.accordionHeaderKeyNav,
            me.accordionBodyKeyNav,
            me.defaultButtonKeyNav
        );
        
        me.destroyDockedItems();
        
        me.callParent();
    },

<span id='Ext-panel-Panel-method-beforeRender'>    beforeRender: function() {
</span>        var me = this,
            wasCollapsed;

        // Ensure the protoBody exists so that initOverflow gets right answer from getOverflowEl.
        // If this Panel was applied to an existing element (such as being used as a Viewport)
        // then it will not have been created.
        me.getProtoBody();

        me.callParent();

        // Add class-specific header tools.
        // Panel adds collapsible and closable.
        me.initTools();

        // Dock the header/title unless we are configured specifically not to create a header.
        // If the panel participates in a border layout it should have the ARIA role of &#39;region&#39;.
        // In that case we need to render a heading element even if the panel is configured
        // not to have a header.
        if (!(me.preventHeader || (me.header === false)) || me.isViewportBorderChild) {
            me.updateHeader();
        }
        me.afterHeaderInit = true;

        // If we are rendering collapsed, we still need to save and modify various configs
        if (me.collapsed) {
            if (me.isPlaceHolderCollapse()) {
                if (!me.hidden) {
                    me.setHiddenState(true);

                    // This will insert the placeholder Component into the ownerCt&#39;s child collection
                    // Its getRenderTree call which is calling this will then iterate again and
                    // recreate the child items array to include the new Component. Prevent the first
                    // collapse from firing
                    me.preventCollapseFire = true;
                    me.placeholderCollapse();
                    delete me.preventCollapseFire;
                    wasCollapsed = me.collapsed;

                    // Temporarily clear the flag so that the header is rendered with a collapse tool in it.
                    // Placeholder collapse panels never really collapse, they just hide. The tool is always
                    // a collapse tool.
                    me.collapsed = false;
                }
            } else {
                me.beginCollapse();
                me.addClsWithUI(me.collapsedCls);
            }
        }

        // Restore the flag if we are being rendered initially placeholder collapsed.
        if (wasCollapsed) {
            me.collapsed = wasCollapsed;
        }
    },

<span id='Ext-panel-Panel-method-getMemento'>    /**
</span>     * @private
     * Memento Factory method
     * @param {String} name Name of the Memento (used as prefix for named Memento)
     */
    getMemento: function(name) {
        var me = this;
        if(name &amp;&amp; typeof name === &#39;string&#39;) {
            name += &#39;Memento&#39;;
            return me[name] || (me[name] = new Ext.util.Memento(me));
        }
    },


<span id='Ext-panel-Panel-method-beginCollapse'>    /**
</span>     * @private
     * Called before the change from default, configured state into the collapsed state.
     * This method may be called at render time to enable rendering in an initially collapsed state,
     * or at runtime when an existing, fully laid out Panel may be collapsed.
     * It basically saves configs which need to be clobbered for the duration of the collapsed state.
     */
    beginCollapse: function() {
        var me = this,
            lastBox = me.lastBox,
            rendered = me.rendered,
            collapseMemento = me.getMemento(&#39;collapse&#39;),
            sizeModel = me.getSizeModel(),
            header = me.header,
            reExpander;

        // When we collapse a panel, the panel is in control of one dimension (depending on
        // collapse direction) and sets that on the component. We must restore the user&#39;s
        // original value (including non-existence) when we expand. Using this technique, we
        // mimic setCalculatedSize for the dimension we do not control and setSize for the
        // one we do (only while collapsed).
        // Additionally, the panel may have a shrink wrapped width and/or height. For shrinkWrapped
        // panels this can be problematic, since a collapsed, shrink-wrapped panel has no way
        // of determining its width (or height if the collapse direction is horizontal). It is
        // therefore necessary to capture both the width and height regardless of collapse direction.
        // This allows us to set a configured width or height on the panel when it is collapsed,
        // and it will be restored to an unconfigured-width shrinkWrapped state on expand.
        collapseMemento.capture([&#39;height&#39;, &#39;minHeight&#39;, &#39;width&#39;, &#39;minWidth&#39;]);
        if (lastBox) {
            collapseMemento.capture(me.restoreDimension(), lastBox, &#39;last.&#39;);
        }
        // If the panel has a shrinkWrapped height/width and is already rendered, configure its width/height as its calculated width/height,
        // so that the collapsed header will have the same width or height as the panel did before it was collapsed.
        // If the shrinkWrapped panel has not yet been rendered, as will be the case when a panel is initially configured with
        // collapsed:true, we attempt to use the configured width/height, and fall back to minWidth or minHeight if
        // width/height has not been configured, and fall back to a value of 100 if a minWidth/minHeight has not been configured.
        if (me.collapsedVertical()) {
            if (sizeModel.width.shrinkWrap) {
                me.width = rendered ? me.getWidth() : me.width || me.minWidth || 100;
            }
            delete me.height;
            me.minHeight = 0;
        } else if (me.collapsedHorizontal()) {
            if (sizeModel.height.shrinkWrap) {
                me.height = rendered ? me.getHeight() : me.height || me.minHeight || 100;
            }
            delete me.width;
            me.minWidth = 0;
        }

        if (me.ownerCt) {
            me.ownerCt.getLayout().beginCollapse(me);
        }

        // Get a reExpander header. This will return the Panel Header if the Header is in the correct orientation
        // If we are using the Header as the reExpander, change its UI to collapsed state
        if (!me.isPlaceHolderCollapse() &amp;&amp; header !== false) {
            if (header === (reExpander = me.getReExpander())) {
                header.collapseImmune = true;
                header.getInherited().collapseImmune = true;
                header.addClsWithUI(me.getHeaderCollapsedClasses(header));

                // Ensure that the reExpander has the correct framing applied.
                if (header.rendered) {
                    header.updateFrame();
                }
            } else if (reExpander.el) {
                // We&#39;re going to use a temporary reExpander: show it.
                reExpander.el.show();
                reExpander.hidden = false;
            }
        }
        if (me.resizer) {
            me.resizer.disable();
        }
        
        if (me.rendered) {
            me.ariaEl.dom.setAttribute(&#39;aria-expanded&#39;, false);
            
            // In accordion layout, panel body has the role of tabpanel
            // and needs to be updated accordingly when the panel is collapsed
            if (me.isAccordionPanel) {
                me.body.dom.setAttribute(&#39;aria-hidden&#39;, true);
            }
        }
    },

<span id='Ext-panel-Panel-method-beginDrag'>    beginDrag: function() {
</span>        if (this.floatingDescendants) {
            this.floatingDescendants.hide();
        }
    },

<span id='Ext-panel-Panel-method-beginExpand'>    beginExpand: function() {
</span>        var me = this,
            lastBox = me.lastBox,
            collapseMemento = me.getMemento(&#39;collapse&#39;),
            restoreDimension = me.restoreDimension(),
            header = me.header,
            reExpander;

        if (collapseMemento) {
            collapseMemento.restore([&#39;minHeight&#39;, &#39;minWidth&#39;, restoreDimension]);
            if (lastBox) {
                collapseMemento.restore(restoreDimension, true, lastBox, &#39;last.&#39;);
            }
        }

        if (me.ownerCt) {
            me.ownerCt.getLayout().beginExpand(me);
        }

        if (!me.isPlaceHolderCollapse() &amp;&amp; header !== false) {
            // If we have been using our Header as the reExpander then restore the Header to expanded UI
            if (header === (reExpander = me.getReExpander())) {
                delete header.collapseImmune;
                delete header.getInherited().collapseImmune;
                header.removeClsWithUI(me.getHeaderCollapsedClasses(header));

                // Ensure that the reExpander has the correct framing applied.
                if (header.rendered) {
                    header.expanding = true;
                    header.updateFrame();
                    delete header.expanding;
                }
            } else {
                // We&#39;ve been using a temporary reExpander: hide it.
                reExpander.hidden = true;
                reExpander.el.hide();
            }
        }
        if (me.resizer) {
            me.resizer.enable();
        }
        
        if (me.rendered) {
            me.ariaEl.dom.setAttribute(&#39;aria-expanded&#39;, true);
            
            // In accordion layout, panel body has the role of tabpanel
            // and needs to be updated accordingly when the panel is expanded
            if (me.isAccordionPanel) {
                me.body.dom.setAttribute(&#39;aria-hidden&#39;, false);
            }
        }
    },

<span id='Ext-panel-Panel-method-bridgeToolbars'>    bridgeToolbars: function() {
</span>        var me = this,
            docked = [],
            minButtonWidth = me.minButtonWidth,
            fbar, fbarDefaults, fbarIsButtons;

        function initToolbar(toolbar, pos, useButtonAlign, disableFocusableContainer) {
            if (Ext.isArray(toolbar)) {
                toolbar = {
                    xtype: &#39;toolbar&#39;,
                    items: toolbar
                };
            } else if (!toolbar.isComponent) {
                // Incoming toolbar config can be a property on the prototype
                toolbar = Ext.apply({}, toolbar);
            }
            
            if (!toolbar.xtype) {
                toolbar.xtype = &#39;toolbar&#39;;
            }
            
            toolbar.dock = pos;
            
            if (disableFocusableContainer) {
                toolbar.enableFocusableContainer = false;
            }

            // Legacy support for buttonAlign (only used by buttons/fbar)
            if (useButtonAlign) {
                toolbar.layout = Ext.applyIf(toolbar.layout || {}, {
                    // default to &#39;end&#39; (right-aligned) if me.buttonAlign is undefined or invalid
                    pack: { left:&#39;start&#39;, center:&#39;center&#39; }[me.buttonAlign] || &#39;end&#39;
                });
            }
            return toolbar;
        }

        if (me.tbar) {
            docked.push(initToolbar(me.tbar, &#39;top&#39;));
            me.tbar = null;
        }

        if (me.bbar) {
            docked.push(initToolbar(me.bbar, &#39;bottom&#39;));
            me.bbar = null;
        }

        if (me.buttons) {
            me.fbar = me.buttons;
            me.buttons = null;
            fbarIsButtons = true;
        }

        if (me.fbar) {
            fbar = initToolbar(me.fbar, &#39;bottom&#39;, true, fbarIsButtons); // only we useButtonAlign
            fbar.ui = &#39;footer&#39;;

            // Apply the minButtonWidth config to buttons in the toolbar
            if (minButtonWidth) {
                fbarDefaults = fbar.defaults;
                fbar.defaults = function(config) {
                    var defaults = fbarDefaults || {},
                        // no xtype or a button instance
                        isButton = !config.xtype || config.isButton,
                        cls;

                    // Here we have an object config with an xtype, check if it&#39;s a button
                    // or a button subclass
                    if (!isButton) {
                        cls = Ext.ClassManager.getByAlias(&#39;widget.&#39; + config.xtype);
                        if (cls) {
                            isButton = cls.prototype.isButton;
                        }
                    }
                    if (isButton &amp;&amp; !(&#39;minWidth&#39; in defaults)) {
                        defaults = Ext.apply({minWidth: minButtonWidth}, defaults);
                    }
                    return defaults;
                };
            }

            docked.push(fbar);
            me.fbar = null;
        }

        if (me.lbar) {
            docked.push(initToolbar(me.lbar, &#39;left&#39;));
            me.lbar = null;
        }

        if (me.rbar) {
            docked.push(initToolbar(me.rbar, &#39;right&#39;));
            me.rbar = null;
        }

        if (me.dockedItems) {
            if (me.dockedItems.isMixedCollection) {
                me.addDocked(docked);
            } else {
                if (!Ext.isArray(me.dockedItems)) {
                    me.dockedItems = [me.dockedItems];
                }
                me.dockedItems = me.dockedItems.concat(docked);
            }
        } else {
            me.dockedItems = docked;
        }
    },

<span id='Ext-panel-Panel-method-close'>    /**
</span>     * Closes the Panel. By default, this method, removes it from the DOM, {@link Ext.Component#method-destroy destroy}s the
     * Panel object and all its descendant Components. The {@link #beforeclose beforeclose} event is fired before the
     * close happens and will cancel the close action if it returns false.
     *
     * **Note:** This method is also affected by the {@link #closeAction} setting. For more explicit control use
     * {@link #method-destroy} and {@link #method-hide} methods.
     */
    close: function() {
        if (this.fireEvent(&#39;beforeclose&#39;, this) !== false) {
            this.doClose();
        }
    },

<span id='Ext-panel-Panel-method-collapse'>    /**
</span>     * Collapses the panel body so that the body becomes hidden. Docked Components parallel to the border towards which
     * the collapse takes place will remain visible. Fires the {@link #beforecollapse} event which will cancel the
     * collapse action if it returns false.
     *
     * @param {String} [direction] The direction to collapse towards. Must be one of
     *
     *   - Ext.Component.DIRECTION_TOP
     *   - Ext.Component.DIRECTION_RIGHT
     *   - Ext.Component.DIRECTION_BOTTOM
     *   - Ext.Component.DIRECTION_LEFT
     *
     * Defaults to {@link #collapseDirection}.
     *
     * @param {Boolean/Number} [animate] True to animate the transition, else false
     * (defaults to the value of the {@link #animCollapse} panel config). May
     * also be specified as the animation duration in milliseconds.
     * @return {Ext.panel.Panel} this
     */
    collapse: function(direction, animate) {
        var me = this,
            collapseDir = direction || me.collapseDirection,
            ownerCt = me.ownerCt,
            layout = me.ownerLayout,
            rendered = me.rendered;

        if (me.isCollapsingOrExpanding) {
            return me;
        }

        if (arguments.length &lt; 2) {
            animate = me.animCollapse;
        }

        if (me.collapsed || me.fireEvent(&#39;beforecollapse&#39;, me, direction, animate) === false) {
            return me;
        }

        if (layout &amp;&amp; layout.onBeforeComponentCollapse) {
            if (layout.onBeforeComponentCollapse(me) === false) {
                return me;
            }
        }

        if (rendered &amp;&amp; ownerCt &amp;&amp; me.isPlaceHolderCollapse()) {
            return me.placeholderCollapse(direction, animate);
        }

        me.collapsed = collapseDir;
        if (rendered) {
            me.beginCollapse();
        }

        me.getInherited().collapsed = true;
        me.fireHierarchyEvent(&#39;collapse&#39;);

        if (rendered) {
            me.doCollapseExpand(1, animate);
        }
        return me;
    },

<span id='Ext-panel-Panel-method-collapsedHorizontal'>    collapsedHorizontal: function () {
</span>        var dir = this.getCollapsed();
        return dir === &#39;left&#39; || dir === &#39;right&#39;;
    },

<span id='Ext-panel-Panel-method-collapsedVertical'>    collapsedVertical: function () {
</span>        var dir = this.getCollapsed();
        return dir === &#39;top&#39; || dir === &#39;bottom&#39;;
    },

<span id='Ext-panel-Panel-method-convertCollapseDir'>    /**
</span>     * converts a collapsdDir into an anchor argument for Element.slideIn
     * overridden in rtl mode to switch &quot;l&quot; and &quot;r&quot;
     */
    convertCollapseDir: function(collapseDir) {
        return collapseDir.substr(0, 1);
    },

<span id='Ext-panel-Panel-method-createGhost'>    createGhost: function(cls) {
</span>         var me = this,
             header = me.header,
             frame = me.frame &amp;&amp; !me.alwaysFramed;

        return {
            xtype: &#39;panel&#39;,
            hidden: false,
            header: header ? {
                titleAlign: header.getTitleAlign()
            } : null,
            ui: frame ? me.ui.replace(/-framed$/, &#39;&#39;) : me.ui,
            id: me.id + &#39;-ghost&#39;,
            renderTo: Ext.getBody(),
            // The ghost&#39;s opacity causes the resize handles to obscure the frame in
            // IE, so always force resizable to be false.
            resizable: false,

            // The ghost must not be draggable (the actual class instantiated my be draggable in its prototype)
            draggable: false,

            // Tools are explicitly copied.
            closable: false,

            focusable: false,
            floating: true,
            alignOnScroll: false,
            shadow: false,
            frame: frame,
            shim: me.shim,
            alwaysFramed: me.alwaysFramed,
            overlapHeader: me.overlapHeader,
            headerPosition: me.getHeaderPosition(),
            titleRotation: me.getTitleRotation(),
            baseCls: me.baseCls,
            getRefOwner: function () {
                return me.getRefOwner();
            },
            cls: me.baseCls + &#39;-ghost &#39; + (cls || &#39;&#39;)
        };
    },

<span id='Ext-panel-Panel-method-createReExpander'>    createReExpander: function(direction, defaults) {
</span>        var me = this,
            isLeft = direction === &#39;left&#39;,
            isRight = direction === &#39;right&#39;,
            isVertical = isLeft || isRight,
            ownerCt = me.ownerCt,
            header = me.header,
            result = Ext.apply({
                hideMode: &#39;offsets&#39;,
                title: me.getTitle(),
                titleAlign: me.getTitleAlign(),
                vertical: isVertical,
                textCls: me.headerTextCls,
                icon: me.getIcon(),
                iconCls: me.getIconCls(),
                iconAlign: me.getIconAlign(),
                glyph: me.getGlyph(),
                baseCls: me.self.prototype.baseCls + &#39;-header&#39;,
                ui: me.ui,
                frame: me.frame &amp;&amp; me.frameHeader,
                ignoreParentFrame: me.frame || me.overlapHeader,
                ignoreBorderManagement: me.frame || me.ignoreHeaderBorderManagement,
                indicateDrag: me.draggable,
                collapseImmune: true,
                ariaRole: me.ariaRole,
                preventRefocus: true,
                ownerCt: (ownerCt &amp;&amp; me.collapseMode === &#39;placeholder&#39;) ? ownerCt : me,
                ownerLayout: me.componentLayout,
                forceOrientation: true,
                margin: me.margin,
                // When placeholder is focused, focus the expander tool.
                // TODO: When https://sencha.jira.com/browse/EXTJS-19718 is
                // fixed, this should not be needed.
                // placeholder is a FocusableContainer
                defaultFocus: &#39;tool[isDefaultExpandTool]&#39;
            }, defaults);

        // If we&#39;re in mini mode, set the placeholder size to only 1px since
        // we don&#39;t need it to show up.
        if (me.collapseMode === &#39;mini&#39;) {
            if (isVertical) {
                result.width = 1;
            } else {
                result.height = 1;
            }
        }
        
        if (header) {
            Ext.apply(result, {
                enableFocusableContainer: header.enableFocusableContainer,
                activeChildTabIndex: header.activeChildTabIndex,
                inactiveChildTabIndex: header.inactiveChildTabIndex,
                allowFocusingDisabledChildren: header.allowFocusingDisabledChildren
            });
        }

        // Create the re expand tool
        // For UI consistency reasons, collapse:left reExpanders, and region: &#39;west&#39; placeHolders
        // have the re expand tool at the *top* with a bit of space.
        if (!me.hideCollapseTool) {
            if (isLeft || (isRight &amp;&amp; me.isPlaceHolderCollapse())) {
                // adjust the title position if the collapse tool needs to be at the
                // top of a vertical header
                result.titlePosition = 1;
            }
            result.tools = [{
                xtype: &#39;tool&#39;,
                type: &#39;expand-&#39; + me.getOppositeDirection(direction),
                isDefaultExpandTool: true,
                uiCls: [&#39;top&#39;],
                handler: me.toggleCollapse,
                scope: me,
                tooltip: me.expandToolText
            }];
        }
        result = new Ext.panel.Header(result);
        result.addClsWithUI(me.getHeaderCollapsedClasses(result));
        
        result.expandTool = result.down(&#39;tool[isDefaultExpandTool=true]&#39;);
        
        return result;
    },

<span id='Ext-panel-Panel-method-doClose'>    /**
</span>     * @private
     */
    doClose: function() {
        this.fireEvent(&#39;close&#39;, this);
        this[this.closeAction]();
    },

<span id='Ext-panel-Panel-method-doCollapseExpand'>    doCollapseExpand: function (flags, animate) {
</span>        var me = this,
            originalAnimCollapse = me.animCollapse,
            ownerLayout = me.ownerLayout;

        // we need to temporarily set animCollapse to the animate value here because ContextItem
        // uses the animCollapse property to determine if the collapse/expand should be animated
        me.animCollapse = animate;

        // Flag used by the layout ContextItem to impose an animation policy based upon the
        // collapse direction and the animCollapse setting.
        me.isCollapsingOrExpanding = flags;

        // The x-animating-size class sets overflow:hidden so that overflowing
        // content is clipped during animation.
        if (animate) {
            me.addCls(Ext.baseCSSPrefix + &#39;animating-size&#39;);
        }

        if (ownerLayout &amp;&amp; !animate) {
            ownerLayout.onContentChange(me);
        } else {
            me.updateLayout({ isRoot: true });
        }

        // set animCollapse back to its original value
        me.animCollapse = originalAnimCollapse;

        return me;
    },

<span id='Ext-panel-Panel-method-endDrag'>    endDrag: function() {
</span>        if (this.floatingDescendants) {
            this.floatingDescendants.show();
        }
    },

<span id='Ext-panel-Panel-method-expand'>    /**
</span>     * Expands the panel body so that it becomes visible.  Fires the {@link #beforeexpand} event which will
     * cancel the expand action if it returns false.
     * @param {Boolean} [animate] True to animate the transition, else false
     * (defaults to the value of the {@link #animCollapse} panel config).  May
     * also be specified as the animation duration in milliseconds.
     * @return {Ext.panel.Panel} this
     */
    expand: function(animate) {
        var me = this,
            layout = me.ownerLayout,
            rendered = me.rendered;

        if (me.isCollapsingOrExpanding) {
            return me;
        }

        if (!arguments.length) {
            animate = me.animCollapse;
        }

        if (!me.collapsed &amp;&amp; !me.floatedFromCollapse) {
            return me;
        }


        if (me.fireEvent(&#39;beforeexpand&#39;, me, animate) === false) {
            return me;
        }

        if (layout &amp;&amp; layout.onBeforeComponentExpand) {
            if (layout.onBeforeComponentExpand(me) === false) {
                return me;
            }
        }

        delete me.getInherited().collapsed;

        if (rendered &amp;&amp; me.isPlaceHolderCollapse()) {
            return me.placeholderExpand(animate);
        }

        me.restoreHiddenDocked();
        if (rendered) {
            me.beginExpand();
        }
        me.collapsed = false;

        if (me.rendered) {
            me.doCollapseExpand(2, animate);
        }
        return me;
    },

<span id='Ext-panel-Panel-method-findReExpander'>    findReExpander: function (direction) {
</span>        var me = this,
            c = Ext.Component,
            dockedItems = me.dockedItems.items,
            dockedItemCount = dockedItems.length,
            comp, i;

        // never use the header if we&#39;re in collapseMode mini
        if (me.collapseMode === &#39;mini&#39;) {
            return;
        }

        switch (direction) {
            case c.DIRECTION_TOP:
            case c.DIRECTION_BOTTOM:

                // Attempt to find a reExpander Component (docked in a horizontal orientation)
                // Also, collect all other docked items which we must hide after collapse.
                for (i = 0; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (!comp.hidden) {
                        if (comp.isHeader &amp;&amp; (!comp.dock || comp.dock === &#39;top&#39; || comp.dock === &#39;bottom&#39;)) {
                            return comp;
                        }
                    }
                }
                break;

            case c.DIRECTION_LEFT:
            case c.DIRECTION_RIGHT:

                // Attempt to find a reExpander Component (docked in a vertical orientation)
                // Also, collect all other docked items which we must hide after collapse.
                for (i = 0; i &lt; dockedItemCount; i++) {
                    comp = dockedItems[i];
                    if (!comp.hidden) {
                        if (comp.isHeader &amp;&amp; (comp.dock === &#39;left&#39; || comp.dock === &#39;right&#39;)) {
                            return comp;
                        }
                    }
                }
                break;

            default:
                throw(&#39;Panel#findReExpander must be passed a valid collapseDirection&#39;);
        }
    },

<span id='Ext-panel-Panel-method-floatCollapsedPanel'>    floatCollapsedPanel: function() {
</span>        var me = this,
            placeholder = me.placeholder,
            splitter = me.splitter,
            phBox = Ext.util.Region.from(placeholder.getBox(false, true)),
            floatCls = Ext.panel.Panel.floatCls,
            collapsed = me.collapsed,
            layoutOwner = me.ownerCt || me,
            slideDirection, myBox, hoverlisteners = {
                mouseleave: me.onMouseLeaveFloated,
                mouseenter: me.onMouseEnterFloated,
                scope: me,
                destroyable: true
            };

        if (me.isSliding) {
            return;
        }

        // Already floated
        if (me.el.hasCls(floatCls)) {
            me.slideOutFloatedPanel();
            return;
        }
        me.isSliding = true;

        // Lay out in fully expanded mode to ensure we are at the correct size, and collect our expanded box
        placeholder.el.hide();
        placeholder.hidden = true;
        me.el.show();
        me.setHiddenState(false);
        me.collapsed = false;
        layoutOwner.updateLayout();

        // Then go back immediately to collapsed state from which to initiate the float into view.
        placeholder.el.show();
        placeholder.hidden = false;
        me.el.hide();
        me.setHiddenState(true);
        me.collapsed = collapsed;
        layoutOwner.updateLayout();
        myBox = me.getBox(false, true);
        if (me.fireEvent(&#39;beginfloat&#39;, me) === false) {
            return;
        }

        me.slideOutTask = me.slideOutTask || new Ext.util.DelayedTask(me.slideOutFloatedPanel, me);

        // Tap/mousedown/mousemove outside the floated element, its placeholder, or its splitter slides it back.
        me.pointerLeaveListener = Ext.getDoc().on({
            mousedown: me.onFloatedPointerEvent,
            mousemove: me.onFloatedPointerEvent,
            scope: me,
            destroyable: true
        });

        if (!me.placeholderListener) {
            me.placeholderListener = placeholder.on({
                resize: me.onPlaceholderResize,
                scope: me,
                destroyable: true
            });
        }
        me.phHoverListeners = placeholder.el.on(hoverlisteners);
        me.elHoverListeners = me.el.on(hoverlisteners);

        me.el.addCls(floatCls);
        me.floated = collapsed;

        // Hide collapse tool in header if there is one (we might be headerless)
        if (me.collapseTool) {
            me.collapseTool.el.hide();
        }

        if (splitter) {
            phBox = phBox.union(splitter.getBox(false, true));
        }

        switch (me.collapsed) {
            case &#39;top&#39;:
                me.width = phBox.width;
                me.setLocalXY(myBox.x, myBox.y + phBox.height);
                break;
            case &#39;right&#39;:
                me.height = phBox.height;
                me.setLocalXY(myBox.x - phBox.width, myBox.y);
                break;
            case &#39;bottom&#39;:
                me.width = phBox.width;
                me.setLocalXY(myBox.x, myBox.y - phBox.height);
                break;
            case &#39;left&#39;:
                me.height = phBox.height;
                me.setLocalXY(myBox.x + phBox.width, myBox.y);
                break;
        }
        slideDirection = me.convertCollapseDir(me.collapsed);

        // Remember how we are really collapsed so we can restore it, but also so we can
        // become a layoutRoot while we are floated:
        me.floatedFromCollapse = me.collapsed;
        me.collapsed = false;
        me.setHiddenState(false);

        me.el.slideIn(slideDirection, {
            preserveScroll: true,
            duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration),
            listeners: {
                afteranimate: function() {
                    me.isSliding = false;
                    me.fireEvent(&#39;endfloat&#39;, me);
                    me.fireEvent(&#39;float&#39;, me);
                }
            }
        });
    },

<span id='Ext-panel-Panel-method-onFloatedPointerEvent'>    onFloatedPointerEvent: function(event) {
</span>        var me = this;

        // If any pointer event occurs inside the component tree, cancel any slideOut.
        // This includes if we are slid out and the pointer is inside the region
        // because locked grids have pointer-events: none to allow interaction with
        // the Y scroller below them.
        if (me.owns(event) || me.placeholder.owns(event) || (me.splitter &amp;&amp; me.splitter.owns(event)) || (me.floatCollapsedPanel &amp;&amp; me.el.getRegion().contains(event.getPoint()))) {
            me.slideOutTask.cancel();
        }
        // Mousemove outside, or tap outside, schedule a slideOut unless they change their minds and
        // tap/mousemove back inside within 500ms
        else {
            me.slideOutTask.delay(500);
        }
    },

<span id='Ext-panel-Panel-method-onMouseEnterFloated'>    onMouseEnterFloated: function(e) {
</span>        this.slideOutTask.cancel();
    },

<span id='Ext-panel-Panel-method-onMouseLeaveFloated'>    onMouseLeaveFloated: function(e) {
</span>        var toElement = e.getRelatedTarget();

        // If the toElement is in the component tree, do not collapse
        if (toElement &amp;&amp; (this.owns(toElement) || this.placeholder.owns(toElement))) {
            return;
        }
        this.slideOutTask.delay(500);
    },
    
<span id='Ext-panel-Panel-method-onPlaceholderResize'>    onPlaceholderResize: function(ph, newWidth, newHeight) {
</span>        var me = this,
            splitter = me.splitter,
            myBox = me.getBox(false, true),
            phBox = Ext.util.Region.from(ph.getBox(false, true));

        if (splitter) {
            phBox = phBox.union(splitter.getBox(false, true));
        }

        // Position floated panel alongside the placeholder, and sync the parallel dimension
        switch (me.floated) {
            case &#39;top&#39;:
                me.width = newWidth;
                me.setLocalY(phBox.y + phBox.height);
                break;
            case &#39;right&#39;:
                me.height = newHeight;
                me.setLocalX(phBox.x - myBox.width);
                break;
            case &#39;bottom&#39;:
                me.width = newWidth;
                me.setLocalY(phBox.y - myBox.height);
                break;
            case &#39;left&#39;:
                me.height = newHeight;
                me.setLocalX(phBox.x + phBox.width);
                break;
        }

        me.updateLayout({
            isRoot: true
        });
    },

<span id='Ext-panel-Panel-method-getAnimationProps'>    getAnimationProps: function() {
</span>        var me = this,
            props;

        props = me.callParent();
        
        if (typeof me.animCollapseDuration === &#39;number&#39;) {
            props.duration = me.animCollapseDuration;
        }
        else if (typeof me.animCollapse === &#39;number&#39;) {
            props.duration = me.animCollapse;
        }

        return props;
    },

<span id='Ext-panel-Panel-method-getCollapsed'>    /**
</span>     * Returns the current collapsed state of the panel.
     * @return {Boolean/String} False when not collapsed, otherwise the value of {@link #collapseDirection}.
     */
    getCollapsed: function() {
        var me = this;
        // The collapsed flag, when the Panel is collapsed acts as the direction in which the collapse took
        // place. It can still be tested as truthy/falsy if only a truth value is required.
        if (me.collapsed === true) {
            return me.collapseDirection;
        }
        return me.collapsed;
    },

<span id='Ext-panel-Panel-method-getCollapsedDockedItems'>    getCollapsedDockedItems: function () {
</span>        var me = this;
        return me.header === false || me.collapseMode === &#39;placeholder&#39; ? me.emptyArray : [ me.getReExpander() ];
    },

<span id='Ext-panel-Panel-method-getComponent'>    /**
</span>     * Attempts a default component lookup (see {@link Ext.container.Container#getComponent}). If the component is not found in the normal
     * items, the dockedItems are searched and the matched component (if any) returned (see {@link #getDockedComponent}). Note that docked
     * items will only be matched by component id or itemId -- if you pass a numeric index only non-docked child components will be searched.
     * @param {String/Number} comp The component id, itemId or position to find
     * @return {Ext.Component} The component (if found)
     * @since 2.3.0
     */
    getComponent: function(comp) {
        var component = this.callParent(arguments);
        if (component === undefined &amp;&amp; !Ext.isNumber(comp)) {
            // If the arg is a numeric index skip docked items
            component = this.getDockedComponent(comp);
        }
        return component;
    },

<span id='Ext-panel-Panel-method-getHeader'>    /**
</span>     * Gets the {@link Ext.panel.Header Header} for this panel.
     * @return {Ext.panel.Header}
     */
    getHeader: function() {
        return this.header;
    },

<span id='Ext-panel-Panel-method-getHeaderCollapsedClasses'>    /**
</span>     * @private
     * Create the class array to add to the Header when collapsed.
     */
    getHeaderCollapsedClasses: function(header) {
        var me = this,
            collapsedCls = me.collapsedCls,
            collapsedClasses;

        collapsedClasses = [ collapsedCls, collapsedCls + &#39;-&#39; + header.getDockName()];
        if (me.border &amp;&amp; (!me.frame || (me.frame &amp;&amp; Ext.supports.CSS3BorderRadius))) {
            collapsedClasses.push(collapsedCls + &#39;-border-&#39; + header.getDockName());
        }
        return collapsedClasses;
    },

<span id='Ext-panel-Panel-method-getOppositeDirection'>    getOppositeDirection: function(d) {
</span>        var c = Ext.Component;
        switch (d) {
            case c.DIRECTION_TOP:
                return c.DIRECTION_BOTTOM;
            case c.DIRECTION_RIGHT:
                return c.DIRECTION_LEFT;
            case c.DIRECTION_BOTTOM:
                return c.DIRECTION_TOP;
            case c.DIRECTION_LEFT:
                return c.DIRECTION_RIGHT;
        }
    },

<span id='Ext-panel-Panel-method-getPlaceholder'>    getPlaceholder: function(direction) {
</span>        var me = this,
            collapseDir = direction || me.collapseDirection,
            listeners = null,
            placeholder = me.placeholder,
            floatable = me.floatable,
            titleCollapse = me.titleCollapse;

        if (!placeholder) {
            if (floatable || (me.collapsible &amp;&amp; titleCollapse)) {
                listeners = {
                    click: {
                        // titleCollapse needs to take precedence over floatable
                        fn: function(e, target) {
                            // If the element click was specifically on the tool, that tool&#39;s handler
                            // will process it and we must not: https://sencha.jira.com/browse/EXTJS-21045
                            if (!placeholder.expandTool.el.dom.contains(arguments[1])) {
                                me[(!titleCollapse &amp;&amp; floatable) ? &#39;floatCollapsedPanel&#39; : &#39;toggleCollapse&#39;]();
                            }
                        },
                        element: &#39;el&#39;,
                        scope: me
                    }
                };
            }

            me.placeholder = placeholder = Ext.widget(me.createReExpander(collapseDir, {
                id: me.id + &#39;-placeholder&#39;,
                listeners: listeners
            }));
        }

        // User created placeholder was passed in
        if (!placeholder.placeholderFor) {
            // Handle the case of a placeholder config
            if (!placeholder.isComponent) {
                me.placeholder = placeholder = me.lookupComponent(placeholder);
            }
            Ext.applyIf(placeholder, {
                margin: me.margin,
                placeholderFor: me,
                synthetic: true // not user-defined
            });

            placeholder.addCls([Ext.baseCSSPrefix + &#39;region-collapsed-placeholder&#39;, Ext.baseCSSPrefix + &#39;region-collapsed-&#39; + collapseDir + &#39;-placeholder&#39;, me.collapsedCls]);
        }

        return placeholder;
    },

<span id='Ext-panel-Panel-method-getProtoBody'>    getProtoBody: function () {
</span>        var me = this,
            body = me.protoBody;

        if (!body) {
            me.protoBody = body = new Ext.util.ProtoElement({
                cls: me.bodyCls,
                style: me.bodyStyle,
                clsProp: &#39;bodyCls&#39;,
                styleProp: &#39;bodyStyle&#39;,
                styleIsText: true
            });
        }

        return body;
    },

<span id='Ext-panel-Panel-method-getReExpander'>    getReExpander: function (direction) {
</span>        var me = this,
            collapseDir = direction || me.collapseDirection,
            reExpander = me.reExpander || me.findReExpander(collapseDir),
            titleCollapse = me.titleCollapse,
            listeners = null;

        me.expandDirection = me.getOppositeDirection(collapseDir);

        if (!reExpander) {
            if (titleCollapse) {
                listeners = {
                    click: {
                        fn: me.toggleCollapse,
                        element: &#39;el&#39;,
                        scope: me
                    }
                };
            }
        // We did not find a Header of the required orientation: create one.
            me.reExpander = reExpander = me.createReExpander(collapseDir, {
                dock: collapseDir,
                cls: Ext.baseCSSPrefix + &#39;docked &#39; + me.baseCls + &#39;-&#39; + me.ui + &#39;-collapsed&#39;,
                isCollapsedExpander: true,
                listeners: listeners
            });

            me.dockedItems.insert(0, reExpander);
        }
        return reExpander;
    },

<span id='Ext-panel-Panel-method-getRefItems'>    getRefItems: function(deep) {
</span>        var placeholder = this.placeholder,
             result;

        // Collapsed placeholder must be queryable if it is a Container.
        if (placeholder) {
            result = [placeholder];
            if (deep &amp;&amp; placeholder.getRefItems) {
                result.push.apply(result, placeholder.getRefItems(deep));
            }
        } else {
            result = [];
        }

        // And the rest.
        result.push.apply(result, this.getDockingRefItems(deep, this.callParent([deep])));
        return result;
    },

<span id='Ext-panel-Panel-method-getState'>    getState: function() {
</span>        var me = this,
            state = me.callParent() || {},
            collapsed = me.collapsed,
            floated = me.floated,
            memento, placeholder;

        // When taking state to restore on a page refresh, floated means collapsed
        if (floated) {
            me.collapsed = floated;
        }
        state = me.addPropertyToState(state, &#39;collapsed&#39;);
        if (floated) {
            me.collapsed = collapsed;
        }

        // If a collapse has taken place, use remembered values as the dimensions.
        if (me.getCollapsed()) {
            memento = me.getMemento(&#39;collapse&#39;).data;
            state = me.addPropertyToState(state , &#39;collapsed&#39;, memento);
            placeholder = me.isPlaceHolderCollapse();

            if (me.collapsedVertical()) {
                if (placeholder) {
                    state = me.addPropertyToState(state, &#39;height&#39;);
                    delete state.width;
                } else {
                    delete state.height;
                    if (memento) {
                        state = me.addPropertyToState(state, &#39;height&#39;, memento.height);
                    }
                }
            } else {
                if (placeholder) {
                    state = me.addPropertyToState(state, &#39;width&#39;);
                    delete state.height;
                } else {
                    delete state.width;
                    if (memento) {
                        state = me.addPropertyToState(state, &#39;width&#39;, memento.width);
                    }
                }
            }
        }

        return state;
    },

<span id='Ext-panel-Panel-method-applyState'>    applyState: function(state) {
</span>        var me = this,
            collapseMemento = {},
            collapsed;

        if (state) {
            collapsed = state.collapsed;
            if(collapsed) {
                collapseMemento = me.getMemento(&#39;collapse&#39;);
                Ext.Object.merge(collapseMemento.data , collapsed);
                state.collapsed = true;
            }

            me.callParent(arguments);
        }
    },

<span id='Ext-panel-Panel-method-ghost'>    /**
</span>     * @private
     * Used for dragging.
     */
    ghost: function(cls) {
        var me = this,
            myEl = me.el,
            ghostPanel = me.ghostPanel,
            box = me.getBox(),
            header = me.header,
            ghostHeader, tools, icon, iconCls, glyph, i;

        if (!ghostPanel) {
            me.ghostPanel = ghostPanel = Ext.widget(me.createGhost(cls));
            ghostPanel.el.dom.removeAttribute(&#39;tabIndex&#39;);
        } else {
            ghostPanel.el.show();
        }
        ghostPanel.setHiddenState(false);
        ghostPanel.floatParent = me.floatParent;
        if (header &amp;&amp; !me.preventHeader) {
            ghostHeader = ghostPanel.header;
            // restore options
            ghostHeader.suspendLayouts();
            tools = ghostHeader.query(&#39;tool&#39;);
            for (i = tools.length; i--;) {
                ghostHeader.remove(tools[i]);
            }
            // reset the title position to ensure that the title gets moved into the correct
            // place after we add the tools (if the position didn&#39;t change the updater won&#39;t run)
            ghostHeader.setTitlePosition(0);
            ghostPanel.addTool(me.ghostTools());
            ghostPanel.setTitle(me.getTitle());
            ghostHeader.setTitlePosition(header.titlePosition);

            iconCls = me.getIconCls();
            if (iconCls) {
                ghostPanel.setIconCls(iconCls);
            } else {
                icon = me.getIcon();
                if (icon) {
                    ghostPanel.setIcon(icon);
                } else {
                    glyph = me.getGlyph();
                    if (glyph) {
                        ghostPanel.setGlyph(glyph);
                    }
                }
            }

            ghostHeader.addCls(Ext.baseCSSPrefix + &#39;header-ghost&#39;);
            ghostHeader.resumeLayouts(true);
        }

        ghostPanel.setPagePosition(box.x, box.y);
        ghostPanel.setSize(box.width, box.height);

        // Hide element, but do not disturb focus or clobber accessibility
        me.elVisMode = myEl.getVisibilityMode();
        myEl.setVisibilityMode(Ext.Element.CLIP);
        myEl.hide();
        return ghostPanel;
    },

<span id='Ext-panel-Panel-method-ghostTools'>    /**
</span>     * @private
     * Helper function for ghost
     */
    ghostTools: function() {
        var tools = [],
            header = this.header,
            headerTools = header ? header.query(&#39;tool[hidden=false]&#39;) : [],
            t, tLen, tool;

        if (headerTools.length) {
            t = 0;
            tLen = headerTools.length;

            for (; t &lt; tLen; t++) {
                tool = headerTools[t];

                // Some tools can be full components, and copying them into the ghost
                // actually removes them from the owning panel. You could also potentially
                // end up with duplicate DOM ids as well. To avoid any issues we just make
                // a simple bare-minimum clone of each tool for ghosting purposes.
                tools.push({
                    type: tool.type,
                    tooltip: tool.tooltip
                });
            }
        } else {
            tools = [{
                type: &#39;placeholder&#39;
            }];
        }
        return tools;
    },

<span id='Ext-panel-Panel-method-initBodyBorder'>    initBodyBorder: function() {
</span>        var me = this;

        if (me.frame &amp;&amp; me.bodyBorder) {
            if (!Ext.isNumber(me.bodyBorder)) {
                me.bodyBorder = 1;
            }
            me.getProtoBody().setStyle(&#39;border-width&#39;, this.unitizeBox(me.bodyBorder));
        }
    },

<span id='Ext-panel-Panel-method-initBodyStyles'>    /**
</span>     * Parses the {@link #bodyStyle} config if available to create a style string that will be applied to the body element.
     * This also includes {@link #bodyPadding} and {@link #bodyBorder} if available.
     * @return {String} A CSS style string with body styles, padding and border.
     * @private
     */
    initBodyStyles: function() {
        var me = this,
            body = me.getProtoBody();

        if (me.bodyPadding !== undefined) {
            if (me.layout.managePadding) {
                // If the container layout manages padding, the layout will apply the
                // padding to an inner element rather than the body element.  The
                // assumed intent is for the configured padding to override any padding
                // that is applied to the body element via style sheet rules.  It is
                // therefore necessary to set the body element&#39;s padding to &quot;0&quot;.
                body.setStyle(&#39;padding&#39;, 0);
            } else {
                body.setStyle(&#39;padding&#39;, this.unitizeBox((me.bodyPadding === true) ? 5 : me.bodyPadding));
            }
        }
        me.initBodyBorder();
    },

<span id='Ext-panel-Panel-method-initBorderProps'>    initBorderProps: function() {
</span>        var me = this;

        if (me.frame &amp;&amp; me.border &amp;&amp; me.bodyBorder === undefined) {
            me.bodyBorder = false;
        }
        if (me.frame &amp;&amp; me.border &amp;&amp; (me.bodyBorder === false || me.bodyBorder === 0)) {
            me.manageBodyBorders = true;
        }
    },

<span id='Ext-panel-Panel-method-initComponent'>    initComponent: function() {
</span>        var me = this;

        if (me.collapsible) {
        // Save state on these two events.
            me.addStateEvents([&#39;expand&#39;, &#39;collapse&#39;]);
        }
        if (me.unstyled) {
            me.setUI(&#39;plain&#39;);
        }

        if (me.frame) {
            me.setUI(me.ui + &#39;-framed&#39;);
        }

        // Backwards compatibility
        me.bridgeToolbars();

        me.initBorderProps();
        me.callParent();
        me.collapseDirection = me.collapseDirection || me.getHeaderPosition() || Ext.Component.DIRECTION_TOP;
        
        // Certain layouts will reset animCollapse to false but we&#39;d like to preserve
        // the duration to use with animations, if it was configured
        if (typeof me.animCollapse === &#39;number&#39;) {
            me.animCollapseDuration = me.animCollapse;
        }

        // Used to track hidden content elements during collapsed state
        me.hiddenOnCollapse = new Ext.dom.CompositeElement();
    },

<span id='Ext-panel-Panel-method-initItems'>    initItems: function() {
</span>        this.callParent();
        this.initDockingItems();
    },
    
<span id='Ext-panel-Panel-method-initRenderData'>    /**
</span>     * Initialized the renderData to be used when rendering the renderTpl.
     * @return {Object} Object with keys and values that are going to be applied to the renderTpl
     * @private
     */
    initRenderData: function() {
        var me = this,
            bodyWrapRole = me.bodyWrapAriaRole,
            bodyRole = me.bodyAriaRole,
            data;
        
        data = me.callParent();

        me.initBodyStyles();
        me.protoBody.writeTo(data);
        delete me.protoBody;
        
        if (me.headingText) {
            data.headingText = me.headingText;
            me.addChildEl(&#39;headingEl&#39;);
        }

        if (bodyWrapRole) {
            data.bodyWrapAriaAttributes = {
                role: bodyWrapRole
            };
            
            if (!me.ariaStaticRoles[bodyWrapRole] &amp;&amp; me.bodyWrapAriaRenderAttributes) {
                Ext.apply(data.bodyWrapAriaAttributes, me.bodyWrapAriaRenderAttributes);
            }
        }

        if (bodyRole) {
            data.bodyAriaAttributes = {
                role: bodyRole
            };
            
            if (!me.ariaStaticRoles[bodyRole] &amp;&amp; me.bodyAriaRenderAttributes) {
                Ext.apply(data.bodyAriaAttributes, me.bodyAriaRenderAttributes);
            }
        }
        
        return data;
    },

<span id='Ext-panel-Panel-method-calculateConstrainedPosition'>    /**
</span>     * @private
     * Override of Positionable method to calculate constrained position based upon possibly only
     * constraining our header.
     */
    calculateConstrainedPosition: function(constrainTo, proposedPosition, local, proposedSize) {
        var me = this,
            header = me.header,
            lastBox, fp;

        // If we are only constraining the header, ask the header for its constrained position
        // based upon the size the header will take on based upon this panel&#39;s proposedSize
        if (me.constrainHeader) {
            lastBox = header.lastBox;
            if (proposedSize) {
                if (!header.vertical) {
                    proposedSize = [proposedSize[0], lastBox ? lastBox.height : proposedSize[1]];
                } else {
                    proposedSize = [lastBox ? lastBox.width : proposedSize[0], proposedSize[1]];
                }
            } else if (lastBox) {
                proposedSize = [lastBox.width, lastBox.height];
            }
            fp = me.floatParent;
            constrainTo = constrainTo || me.constrainTo || (fp ? fp.getTargetEl() : null) || me.container || me.el.parent();
        }

        return me.callParent([constrainTo, proposedPosition, local, proposedSize]);
    },

<span id='Ext-panel-Panel-method-initTools'>    /**
</span>     * @private
     * Tools are a Panel-specific capability.
     * Panel uses initTools. Subclasses may contribute tools by implementing addTools.
     */
    initTools: function() {
        var me = this,
            tools = me.tools,
            i, toolCfg, tool;

        me.tools = [];
        for (i = tools &amp;&amp; tools.length; i; ) {
            --i;
            me.tools[i] = tool = tools[i];
            tool.toolOwner = me;
        }

        // Add a collapse tool unless configured to not show a collapse tool
        // or to not even show a header.
        if (me.collapsible &amp;&amp; !(me.hideCollapseTool || me.header === false || me.preventHeader)) {
            me.updateCollapseTool();
            // Prepend collapse tool is configured to do so.
            if (me.collapseFirst) {
                me.tools.unshift(me.collapseTool);
            }
        }

        // Add subclass-specific tools.
        me.addTools();

        if (me.pinnable) {
            me.initPinnable();
        }

        // Make Panel closable.
        if (me.closable) {
            me.addClsWithUI(&#39;closable&#39;);
            
            toolCfg = {
                xtype : &#39;tool&#39;,
                type: &#39;close&#39;,
                scope: me,
                handler: me.close,
                tooltip: me.closeToolText
            };
            
            // Same as with the collapse/expand tool, we have a way to close
            // the panel via keyboard by pressing Alt-Del key when panel&#39;s
            // title is focused; hence we do not need to have the close tool
            // in the tab order. We still need to have the tool itself for
            // pointer interaction and presentational purposes.
            // This configuration will make sure the tool is working as it was
            // in Ext JS older than 6.0.
            if (me.isAccordionPanel || me.disableCloseToolFocus) {
                toolCfg.focusable = false;
                toolCfg.ariaRole = &#39;presentation&#39;;
            }
            
            me.addTool(toolCfg);
        }

        // Append collapse tool if needed.
        if (me.collapseTool &amp;&amp; !me.collapseFirst) {
            me.addTool(me.collapseTool);
        }
    },

<span id='Ext-panel-Panel-method-isLayoutRoot'>    isLayoutRoot: function() {
</span>        if (this.floatedFromCollapse) {
            return true;
        }
        return this.callParent();
    },

<span id='Ext-panel-Panel-method-isPlaceHolderCollapse'>    isPlaceHolderCollapse: function(){
</span>        return this.collapseMode === &#39;placeholder&#39;;
    },

<span id='Ext-panel-Panel-method-isVisible'>    isVisible: function(deep){
</span>        var me = this;
        if (me.collapsed &amp;&amp; me.placeholder) {
            return me.placeholder.isVisible(deep);
        }
        return me.callParent(arguments);
    },

<span id='Ext-panel-Panel-method-onBoxReady'>    onBoxReady: function() {
</span>        var me = this,
            target;
        
        me.callParent(arguments);
        
        if (me.collapsed) {
            me.setHiddenDocked();
        }
        
        if (me.isAccordionPanel) {
            // ARIA state like expanded/collapsed are reflected
            // on the panel header&#39;s title component.
            me.ariaEl = me.header.titleCmp.el;
            me.ariaEl.dom.setAttribute(&#39;aria-expanded&#39;, !me.collapsed);
            me.ariaEl.dom.setAttribute(&#39;aria-controls&#39;, me.body.id);
            
            // Body element has the role=&quot;tabpanel&quot;; when the panel is collapsed
            // or expanded we will update ARIA attributes on the body.
            me.body.dom.setAttribute(&#39;aria-labelledby&#39;, me.header.titleCmp.id);
            me.body.dom.setAttribute(&#39;aria-hidden&#39;, !!me.collapsed);
            
            me.accordionHeaderKeyNav = new Ext.util.KeyNav({
                target: me.header.titleCmp.el,
                scope: me,
                
                left: me.navigateAccordionHeader,
                right: me.navigateAccordionHeader,
                up: me.navigateAccordionHeader,
                down: me.navigateAccordionHeader,
                home: me.navigateAccordionHeader,
                end: me.navigateAccordionHeader,
                space: me.toggleCollapse,
                enter: me.toggleCollapse,
                del: {
                    alt: true,
                    fn: me.maybeClose
                }
            });
            
            me.accordionBodyKeyNav = new Ext.util.KeyNav({
                target: me.body,
                scope: me,
                
                up: {
                    ctrl: true,
                    fn: me.navigateAccordionBody
                }
            });
        }
        
        if (me.defaultButton) {
            target = me.defaultButtonTarget ? me[me.defaultButtonTarget] : me.body;
            
            me.defaultButtonKeyNav = new Ext.util.KeyNav({
                target: target,
                scope: me,
                defaultEventAction: &#39;stopEvent&#39;,
                
                enter: me.fireDefaultButton
            });
        }
    },

<span id='Ext-panel-Panel-method-onHide'>    onHide: function(animateTarget, cb, scope) {
</span>        var me = this,
            dd = me.dd;

        // If floated out from collapse, hide the el immediately.
        // We continue with the hide from a collapsed state.
        if (me.floatedFromCollapse) {
            me.slideOutFloatedPanel(true);
        }

        if (me.draggable &amp;&amp; dd) {
            // Panels w/o headers won&#39;t have a Component Dragger.
            dd.endDrag();
        }

        if (me.collapsed &amp;&amp; me.placeholder) {
            if (me.splitter) {
                Ext.suspendLayouts();
                me.splitter.hide();
                Ext.resumeLayouts();
            }
            me.placeholder.hide();
        } else {
            me.callParent([animateTarget, cb, scope]);
        }
    },

<span id='Ext-panel-Panel-method-onRemoved'>    /**
</span>     * @method
     * @inheritdoc
     */
    onRemoved: function(destroying) {
        var me = this;

        // If we are removed but not being destroyed, ensure our placeholder is also removed but not destroyed
        // If we are being destroyed, our destroy processing will destroy the placeholder.
        // Must run before callParent because that breaks the ownerCt link
        if (me.placeholder &amp;&amp; !destroying) {
            me.ownerCt.remove(me.placeholder, false);
        }

        me.callParent(arguments);
    },

<span id='Ext-panel-Panel-method-onShow'>    onShow: function() {
</span>        var me = this;
        if (me.collapsed &amp;&amp; me.isPlaceHolderCollapse()) {
            if (me.splitter) {
                Ext.suspendLayouts();
                me.splitter.show();
                Ext.resumeLayouts();
            }
            // force hidden back to true, since this gets set by the layout
            me.setHiddenState(true);
            me.placeholderCollapse();
        } else {
            me.callParent(arguments);
        }
    },

<span id='Ext-panel-Panel-method-placeholderCollapse'>    placeholderCollapse: function(direction, animate) {
</span>        var me = this,
            ownerCt = me.ownerCt,
            collapseDir = direction || me.collapseDirection,
            floatCls = Ext.panel.Panel.floatCls,
            collapseTool = me.collapseTool,
            placeholder = me.getPlaceholder(collapseDir),
            slideInDirection;

        if (Ext.Component.layoutSuspendCount || me.isLayoutSuspended()) {
            animate = false;
        }

        me.fireEvent(&#39;beginfloat&#39;, me);
        me.isCollapsingOrExpanding = 1;

        // Upcoming layout run will ignore this Component
        me.setHiddenState(true);
        me.collapsed = collapseDir;

        if (placeholder.rendered) {
            // We may have been added to another Container from that in which we rendered the placeholder
            if (placeholder.el.dom.parentNode !== me.el.dom.parentNode) {
                me.el.dom.parentNode.insertBefore(placeholder.el.dom, me.el.dom);
            }

            placeholder.hidden = false;
            placeholder.setHiddenState(false);
            placeholder.el.show();
            ownerCt.updateLayout();
        } else {
            ownerCt.insert(ownerCt.items.indexOf(me), placeholder);
        }

        if (me.rendered) {
            // The doPlaceholderCollapse callback must not make assumptions about where
            // to restore focus to. We decide that here.
            me.focusPlaceholderExpandTool = me.focusPlaceHolder = false;

            // We assume that if collapse was caused by keyboard action
            // on focused collapse tool, the logical focus transition
            // is to placeholder&#39;s expand tool. Note that it may not be
            // the case when the user *clicked* collapse tool while focus
            // was elsewhere; in that case we dare not touch focus
            // to avoid sudden jumps.
            if (collapseTool &amp;&amp; Ext.ComponentManager.getActiveComponent() === collapseTool) {
                me.focusPlaceholderExpandTool = true;
            }
            // If the focus was otherwise owned by us, just focus the placeholder
            else if (me.containsFocus) {
                me.focusPlaceHolder = true;
            }
            
            // We MUST NOT hide using display because that resets all scroll information.
            me.el.setVisibilityMode(me.placeholderCollapseHideMode);
            
            if (animate) {
                me.el.addCls(floatCls);
                placeholder.el.hide();
                slideInDirection = me.convertCollapseDir(collapseDir);
                
                me.el.slideOut(slideInDirection, {
                    preserveScroll: true,
                    duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        scope: me,
                        afteranimate: function() {
                            var me = this,
                                placeholderEl = me.placeholder.el;
                            
                            me.el.removeCls(floatCls);
                            
                            /* We need to show the element so that slideIn will work correctly.
                             * However, if we leave it visible then it can be seen before
                             * the animation starts, causing a flicker. The solution,
                             * borrowed from date picker, is to hide it using display:none.
                             * The slideIn effect includes a call to fixDisplay() that will
                             * undo the display none at the appropriate time.
                             *
                             * Also note that presently there is no way to abort slideIn
                             * animation sequence so this callback will be fired even if
                             * the panel was removed while collapsing.
                             * In that case we must not set &quot;display: none&quot; on the placeholder
                             * because fixDisplay() will not reset it and that will break
                             * subsequent layouts if the panel is re-added back to the owner
                             * container again.
                             */
                            placeholderEl.show();
                            
                            if (me.ownerCt) {
                                placeholderEl.setStyle(&#39;display&#39;, &#39;none&#39;);
                                placeholderEl.slideIn(slideInDirection, {
                                    easing: &#39;linear&#39;,
                                    duration: 100,
                                    listeners: {
                                        afteranimate: me.doPlaceholderCollapse,
                                        scope: me
                                    }
                                });
                            }
                            else {
                                me.doPlaceholderCollapse();
                            }
                        }
                    }
                });
            }
            else {
                me.el.hide();
                me.doPlaceholderCollapse();
            }
        }
        else {
            me.isCollapsingOrExpanding = 0;
            if (!me.preventCollapseFire) {
                me.fireEvent(&#39;collapse&#39;, me);
            }
        }

        return me;
    },
    
<span id='Ext-panel-Panel-method-doPlaceholderCollapse'>    doPlaceholderCollapse: function() {
</span>        var me = this,
            placeholder = me.placeholder,
            expandTool = placeholder.expandTool,
            dom;
    
        // See the comment in placeholderCollapse().
        if (me.focusPlaceholderExpandTool &amp;&amp; expandTool) {
            expandTool.focus();
        }
    
        // However when focus was *not* on the collapse tool,
        // and we contained focus, we still need to try and
        // focus the placeholder itself since it may have been
        // configured with something focusable inside, and delegate focus handling.
        else  if (me.focusPlaceHolder) {
            placeholder.focus();
        }
        
        me.focusPlaceholderExpandTool = false;
    
        placeholder.setHiddenState(false);
    
        // Both panel *and* placeholder are collapsed,
        // but only panel is hidden. Calling setHiddenState()
        // above does not reset aria-hidden attribute.
        if (placeholder.rendered) {
            dom = placeholder.ariaEl.dom;
            dom.setAttribute(&#39;aria-hidden&#39;, false);
            dom.setAttribute(&#39;aria-expanded&#39;, false);
        }
        
        dom = me.ariaEl.dom;
        dom.setAttribute(&#39;aria-hidden&#39;, true);
        dom.setAttribute(&#39;aria-expanded&#39;, false);
    
        me.isCollapsingOrExpanding = 0;
        me.fireEvent(&#39;collapse&#39;, me);
        me.fireEvent(&#39;endfloat&#39;, me);
    },

<span id='Ext-panel-Panel-method-placeholderExpand'>    placeholderExpand: function(animate) {
</span>        var me = this,
            collapseDir = me.collapsed,
            expandTool = me.placeholder.expandTool,
            floatCls = Ext.panel.Panel.floatCls,
            center = me.ownerLayout ? me.ownerLayout.centerRegion: null,
            finalPos, floatedPos;

        // Layouts suspended - don&#39;t bother with animation shenanigans
        if (Ext.Component.layoutSuspendCount) {
            animate = false;
        }

        if (me.floatedFromCollapse) {
            floatedPos = me.getPosition(true);
            // these are the same cleanups performed by the normal slideOut mechanism:
            me.slideOutFloatedPanelBegin();
            me.slideOutFloatedPanelEnd();
            me.floated = false;
        }
        
        // We assume that if expand was caused by keyboard action on focused
        // placeholder expand tool, the logical focus transition is to the
        // panel header&#39;s collapse tool.
        // Note that it may not be the case when the user *clicked* expand tool
        // while focus was elsewhere; in that case we dare not touch focus to avoid
        // sudden jumps.
        if (expandTool &amp;&amp; Ext.ComponentManager.getActiveComponent() === expandTool) {
            me.focusHeaderCollapseTool = true;
            
            // There is an odd issue with JAWS screen reader: when expanding a panel,
            // it will announce Expand tool again before focus is forced to Collapse
            // tool. I&#39;m not sure why that happens since focus does not move from
            // Expand tool during animation; this hack should work around
            // the problem until we come up with more understanding and a proper
            // solution. The attributes are restored below in doPlaceholderExpand.
            expandTool._ariaRole = expandTool.ariaEl.dom.getAttribute(&#39;role&#39;);
            expandTool._ariaLabel = expandTool.ariaEl.dom.getAttribute(&#39;aria-label&#39;);
            
            expandTool.ariaEl.dom.setAttribute(&#39;role&#39;, &#39;presentation&#39;);
            expandTool.ariaEl.dom.removeAttribute(&#39;aria-label&#39;);
        }
        
        if (animate) {
            // Expand me and hide the placeholder
            Ext.suspendLayouts();
            me.placeholder.hide();
            me.el.show();
            me.collapsed = false;
            me.setHiddenState(false);

            // Stop the center region from moving when laid out without the placeholder there.
            // Unless we are expanding from a floated out situation. In that case, it&#39;s laid out immediately.
            if (center &amp;&amp; !floatedPos) {
                center.hidden = true;
            }

            Ext.resumeLayouts(true);
            center.hidden = false;

            if (!me.floatedFromCollapse) {
                me.fireEvent(&#39;beginfloat&#39;, me);
            }

            me.el.addCls(floatCls);

            // At this point, this Panel is arranged in its correct, expanded layout.
            // The center region has not been affected because it has been flagged as hidden.
            //
            // If we are proceeding from floated, the center region has also been arranged
            // in its new layout to accommodate this expansion, so no further layout is needed, just
            // element animation.
            //
            // If we are proceeding from fully collapsed, the center region has *not* been relayed out because
            // the UI look and feel dictates that it stays stable until the expanding panel has slid in all the
            // way, and *then* it snaps into place.

            me.isCollapsingOrExpanding = 2;

            // Floated, move it back to the floated pos, and thence into the correct place
            if (floatedPos) {
                finalPos = me.getXY();
                me.setLocalXY(floatedPos[0], floatedPos[1]);
                me.setXY([finalPos[0], finalPos[1]], {
                    duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        scope: me,
                        afteranimate: function() {
                            var me = this;
                            
                            me.el.removeCls(floatCls);
                            me.isCollapsingOrExpanding = 0;
                            me.fireEvent(&#39;expand&#39;, me);
                            me.fireEvent(&#39;endfloat&#39;, me);
                        }
                    }
                });
            }
            // Not floated, slide it in to the correct place
            else {
                me.el.hide();
                me.placeholder.el.show();
                me.placeholder.hidden = false;
                
                // Slide this Component&#39;s el back into place, after which we lay out AGAIN
                me.setHiddenState(false);
                me.el.slideIn(me.convertCollapseDir(collapseDir), {
                    preserveScroll: true,
                    duration: Ext.Number.from(animate, Ext.fx.Anim.prototype.duration),
                    listeners: {
                        afteranimate: me.doPlaceholderExpand,
                        scope: me
                    }
                });
            }
        }
        else {
            me.floated = me.collapsed = false;
            me.doPlaceholderExpand(true);
        }

        return me;
    },
    
<span id='Ext-panel-Panel-method-doPlaceholderExpand'>    doPlaceholderExpand: function(nonAnimated) {
</span>        nonAnimated = nonAnimated === true;

        var me = this,
            placeholder = me.placeholder,
            collapseTool = me.collapseTool,
            expandTool = placeholder.expandTool;
        
        if (nonAnimated) {
            Ext.suspendLayouts();
            me.show();
        }
        
        // the ordering of these two lines appears to be important in
        // IE9.  There is an odd expand issue in IE 9 in the border layout
        // example that causes the index1 child of the south dock region
        // to get &#39;hidden&#39; after a collapse / expand cycle.  See
        // EXTJSIV-5318 for details
        me.el.removeCls(Ext.panel.Panel.floatCls);
        placeholder.hide();
        
        if (nonAnimated) {
            Ext.resumeLayouts(true);
        }
        else {
            // The center region has been left in its larger size, so a layout is needed now
            me.updateLayout();
        }
        
        // This part is quite tricky in both animated and non-animated sequence.
        // After the panel is collapsed we will show the placeholder,
        // but by that time we had already lost the previous focus state.
        // The subsequent onFocusEnter on the placeholder will thusly reset
        // placeholder&#39;s previousFocus property to null; so when we hide
        // the placeholder after expanding the panel again, it can&#39;t throw focus
        // back to the panel header by iself.
        // This is why we nudge it a little here; the assumption is that
        // if panel expansion has been caused by keyboard action
        // on focused placeholder expand tool, then the logical focus transition
        // is to panel header&#39;s collapse tool.
        if (me.focusHeaderCollapseTool &amp;&amp; collapseTool) {
            collapseTool.focus();
        }
        
        me.focusHeaderCollapseTool = false;
        
        placeholder.ariaEl.dom.setAttribute(&#39;aria-expanded&#39;, true);
        me.ariaEl.dom.setAttribute(&#39;aria-expanded&#39;, true);
        
        if (expandTool &amp;&amp; expandTool._ariaRole) {
            expandTool.ariaEl.dom.setAttribute(&#39;role&#39;, expandTool._ariaRole);
            expandTool.ariaEl.dom.setAttribute(&#39;aria-label&#39;, expandTool._ariaLabel);
            expandTool._ariaRole = expandTool._ariaLabel = null;
        }
        
        me.isCollapsingOrExpanding = 0;
        me.fireEvent(&#39;expand&#39;, me);
        me.fireEvent(&#39;endfloat&#39;, me);
    },

<span id='Ext-panel-Panel-method-remove'>    remove: function(component, autoDestroy) {
</span>        var dockedItems = this.dockedItems;
        
        // When the panel is destroyed, dockedItems is nulled
        if (dockedItems &amp;&amp; dockedItems.contains(component)) {
            this.removeDocked(component, autoDestroy);
        }
        else {
            this.callParent([component, autoDestroy]);
        }
        return component;
    },

<span id='Ext-panel-Panel-method-removeBodyCls'>    /**
</span>     * Removes a CSS class from the body element.
     * @param {String/String[]} cls The class to remove
     * @return {Ext.panel.Panel} this
     */
    removeBodyCls: function(cls) {
        var me = this,
            body = me.rendered ? me.body : me.getProtoBody();

        body.removeCls(cls);
        return me;
    },

<span id='Ext-panel-Panel-method-removeUIClsFromElement'>    removeUIClsFromElement: function(cls) {
</span>        var me = this,
            result = me.callParent(arguments);

        me.removeBodyCls([Ext.baseCSSPrefix + cls, me.baseCls + &#39;-body-&#39; + cls, me.baseCls + &#39;-body-&#39; + me.ui + &#39;-&#39; + cls]);
        return result;
    },

<span id='Ext-panel-Panel-method-restoreDimension'>    restoreDimension: function(){
</span>        var dir = this.collapseDirection;
        // If we&#39;re collapsing top/bottom, we want to restore the height
        // If we&#39;re collapsing left/right, we want to restore the width
        return (dir === &#39;top&#39; || dir === &#39;bottom&#39;) ? &#39;height&#39; : &#39;width&#39;;
    },

<span id='Ext-panel-Panel-method-restoreHiddenDocked'>    restoreHiddenDocked: function(){
</span>        // Re-show Panel content which was hidden after collapse.
        this.setDockedItemsVisibility(this.hiddenOnCollapse, true);
    },

<span id='Ext-panel-Panel-method-setBodyStyle'>    /**
</span>     * Sets the body style according to the passed parameters.
     * @param {Mixed} style A full style specification string, or object, or the name of a style property to set.
     * @param {String} value If the first param was a style property name, the style property value.
     * @return {Ext.panel.Panel} this
     */
    setBodyStyle: function(style, value) {
        var me = this,
            body = me.rendered ? me.body : me.getProtoBody();

        if (Ext.isFunction(style)) {
            style = style();
        }
        if (arguments.length === 1) {
            if (Ext.isString(style)) {
                style = Ext.Element.parseStyles(style);
            }
            body.setStyle(style);
        } else {
            body.setStyle(style, value);
        }
        return me;
    },

<span id='Ext-panel-Panel-method-setBorder'>    /**
</span>     * @inheritdoc
     */
    setBorder: function(border, targetEl) {
        if (targetEl) {
            // skip out here, the panel will set the border on the body/header during rendering
            return;
        }

        var me = this,
            header = me.header;

        if (!border) {
            border = 0;
        } else if (border === true) {
            border = &#39;1px&#39;;
        } else {
            border = me.unitizeBox(border);
        }

        if (header) {
            if (header.isHeader) {
                header.setBorder(border);
            } else {
                header.border = border;
            }
        }

        if (me.rendered &amp;&amp; me.bodyBorder !== false) {
            me.body.setStyle(&#39;border-width&#39;, border);
        }
        me.updateLayout();

        me.border = border;
    },

<span id='Ext-panel-Panel-method-setCollapsed'>    /**
</span>     * Collapses or expands the panel.
     * @param {Boolean} collapsed `true` to collapse the panel, `false` to expand it.
     */
    setCollapsed: function(collapsed) {
        this[collapsed ? &#39;collapse&#39; : &#39;expand&#39;]();
    },

<span id='Ext-panel-Panel-method-setDockedItemsVisibility'>    /**
</span>     * Set visibility of docked items after the panel is collapsed or expanded
     *
     * @param {Ext.dom.CompositeElement} els
     * @param {Boolean} show
     *
     * @private
     */
    setDockedItemsVisibility: function(els, show){
        var me = this,
            items = me.getDockedItems(),
            len = items.length,
            i = 0,
            item, reExpander;

        if (me.header !== false) {
            reExpander = me.getReExpander();
        }

        for (; i &lt; len; i++) {
            item = items[i];
            if (item &amp;&amp; item !== reExpander &amp;&amp; item.el) {
                els.add(item.el);
            }
        }
        els.setStyle(&#39;visibility&#39;, show ? &#39;&#39; : &#39;hidden&#39;);
        els.clear();
    },

<span id='Ext-panel-Panel-method-setGlyph'>    setGlyph: function(glyph) {
</span>        var me = this,
            oldGlyph = me.glyph,
            header = me.header,
            placeholder = me.placeholder;

        if (glyph !== oldGlyph) {
            me.glyph = glyph;

            if (header) {
                if (header.isHeader) {
                    header.setGlyph(glyph);
                } else {
                    header.glyph = glyph;
                }
            } else if (me.rendered|| me.afterHeaderInit) {
                me.updateHeader();
            }

            if (placeholder &amp;&amp; placeholder.setGlyph) {
                placeholder.setGlyph(glyph);
            }

            me.fireEvent(&#39;glyphchange&#39;, me, glyph, oldGlyph);
        }
    },

<span id='Ext-panel-Panel-method-setIcon'>    setIcon: function(icon) {
</span>        var me = this,
            oldIcon = me.icon,
            header = me.header,
            placeholder = me.placeholder;

        if (icon !== oldIcon) {
            me.icon = icon;

            if (header) {
                if (header.isHeader) {
                    header.setIcon(icon);
                } else {
                    header.icon = icon;
                }
            } else if (me.rendered|| me.afterHeaderInit) {
                me.updateHeader();
            }

            if (placeholder &amp;&amp; placeholder.setIcon) {
                placeholder.setIcon(icon);
            }

            me.fireEvent(&#39;iconchange&#39;, me, icon, oldIcon);
        }
    },

<span id='Ext-panel-Panel-method-setIconCls'>    setIconCls: function(iconCls) {
</span>        var me = this,
            oldIconCls = me.iconCls,
            header = me.header,
            placeholder = me.placeholder;

        if (iconCls !== oldIconCls) {
            me.iconCls = iconCls;

            if (header) {
                if (header.isHeader) {
                    header.setIconCls(iconCls);
                } else {
                    header.iconCls = iconCls;
                }
            } else if (me.rendered|| me.afterHeaderInit) {
                me.updateHeader();
            }

            if (placeholder &amp;&amp; placeholder.setIconCls) {
                placeholder.setIconCls(iconCls);
            }

            me.fireEvent(&#39;iconclschange&#39;, me, iconCls, oldIconCls);
        }
    },

<span id='Ext-panel-Panel-method-setTitle'>    /**
</span>     * Sets the title of this panel.
     * @param {String} title The new title
     */
    setTitle: function(title) {
        var me = this,
            oldTitle = me.title,
            header = me.header,
            reExpander = me.reExpander,
            placeholder = me.placeholder;
        
        if (title !== oldTitle) {
            me.title = title;

            if (header) {
                if (header.isHeader) {
                    header.setTitle(title);
                }
            } else if (me.rendered || me.afterHeaderInit) {
                me.updateHeader();
            }
            
            if (me.headingEl) {
                me.headingEl.setHtml(title);
            }

            if (reExpander) {
                reExpander.setTitle(title);
            }

            if (placeholder &amp;&amp; placeholder.setTitle) {
                placeholder.setTitle(title);
            }

            me.fireEvent(&#39;titlechange&#39;, me, title, oldTitle);
        }
    },

<span id='Ext-panel-Panel-method-setHiddenDocked'>    setHiddenDocked: function(){
</span>        // Hide Panel content except reExpander using visibility to prevent focusing of contained elements.
        // Track what we hide to re-show on expand except for docked items
        // Until the panel is expanded the docked items might have been removed
        var me = this,
            toHide = new Ext.dom.CompositeElement();

        me.hiddenOnCollapse.add(me.body);
        toHide.add(me.body);
        me.setDockedItemsVisibility(toHide, false);
    },

<span id='Ext-panel-Panel-method-setUI'>    /**
</span>     * @inheritdoc
     */
    setUI: function(ui) {
        var me = this;

        me.callParent(arguments);

        if (me.header &amp;&amp; me.header.rendered) {
            me.header.setUI(ui);
        }
    },

<span id='Ext-panel-Panel-method-toggleCollapse'>    /**
</span>     * Shortcut for performing an {@link #method-expand} or {@link #method-collapse} based on the current state of the panel.
     * @return {Ext.panel.Panel} this
     */
    toggleCollapse: function() {
        return (this.collapsed || this.floatedFromCollapse) ? this.expand() : this.collapse();
    },

<span id='Ext-panel-Panel-method-updateCollapseTool'>    updateCollapseTool: function () {
</span>        var me = this,
            collapseTool = me.collapseTool,
            toolCfg;

        if (!collapseTool &amp;&amp; me.collapsible) {
            me.collapseDirection = me.collapseDirection || me.getHeaderPosition() || &#39;top&#39;;
            
            toolCfg = {
                xtype: &#39;tool&#39;,
                handler: me.toggleCollapse,
                scope: me
            };
            
            // In accordion layout panels are collapsible/expandable with keyboard
            // via the panel title that is focusable. There is no need to have a separate
            // collapse/expand tool for keyboard interaction but we still have to react
            // to mouse clicks, and historically accordion panels had coolapse tools
            // so we leave the tool but make it unfocusable and keyboard inactive.
            // Note that we do the same thing for the automatically added close tool
            // but NOT for the other tools.
            if (me.isAccordionPanel) {
                toolCfg.focusable = false;
                toolCfg.ariaRole = &#39;presentation&#39;;
            }
            
            me.collapseTool = me.expandTool = collapseTool = Ext.widget(toolCfg);
        }

        if (collapseTool) {
            if (me.collapsed &amp;&amp; !me.isPlaceHolderCollapse()) {
                collapseTool.setType(&#39;expand-&#39; + me.getOppositeDirection(me.collapseDirection));
                collapseTool.setTooltip(me.expandToolText);
            }
            else {
                collapseTool.setType(&#39;collapse-&#39; + me.collapseDirection);
                collapseTool.setTooltip(me.collapseToolText);
            }
        }
    },
    
<span id='Ext-panel-Panel-method-navigateAccordionHeader'>    navigateAccordionHeader: function(e) {
</span>        var me = this,
            key, target;
        
        key = e.getKey();
        
        switch (key) {
            case e.UP:
            case e.LEFT:
                target = me.findAccordionSibling(&#39;prev&#39;);
                break;
            
            case e.DOWN:
            case e.RIGHT:
                target = me.findAccordionSibling(&#39;next&#39;);
                break;
            
            case e.HOME:
                target = me.findAccordionSibling(&#39;first&#39;);
                break;
            
            case e.END:
                target = me.findAccordionSibling(&#39;last&#39;);
                break;
            
            // Before closing the panel we need to fall back to the previous one,
            // or to the next one if there is no previous one in the list.
            // Jumping to the first panel header does not seem logical.
            case e.DELETE:
                target = me.findAccordionSibling(&#39;prev&#39;) || me.findAccordionSibling(&#39;next&#39;);
                
                // We also need to prevent the panel from closing if it&#39;s the only one
                // panel left in the accordion layout.
                if (!target) {
                    e.doNotClose = true;
                }
                
                break;
        }
        
        // We need to stop the event in to prevent scrolling the parent container.
        e.stopEvent();
        
        if (target &amp;&amp; target !== me) {
            target.header.titleCmp.focus();
        }
    },
    
<span id='Ext-panel-Panel-method-navigateAccordionBody'>    navigateAccordionBody: function(e) {
</span>        var target;
        
        if (e.getKey() === e.UP) {
            // Ctrl-Up within the panel body should focus the header element
            target = this;
        }
        
        // These events are very particular; if they bubbled up to the panel body
        // it means they were not consumed at the origin components.
        e.stopEvent();
        
        if (target) {
            target.header.titleCmp.focus();
        }
    },
    
<span id='Ext-panel-Panel-method-findAccordionSibling'>    findAccordionSibling: function(which, forceFind) {
</span>        var me = this,
            siblingSel = &#39;[isAccordionPanel]&#39;,
            sibling;
        
        switch (which) {
            case &#39;prev&#39;:
                sibling = me.prev(siblingSel);
                
                if (!sibling) {
                    if (me.accordionWrapOver) {
                        sibling = me.ownerCt.child(siblingSel + &#39;:last&#39;);
                    }
                    else if (forceFind) {
                        sibling = me;
                    }
                }
                
                break;
            
            case &#39;next&#39;:
                sibling = me.next(siblingSel);
                
                if (!sibling) {
                    if (me.accordionWrapOver) {
                        sibling = me.ownerCt.child(siblingSel + &#39;:first&#39;);
                    }
                    else if (forceFind) {
                        sibling = me;
                    }
                }
                
                break;
            
            case &#39;first&#39;:
                sibling = me.ownerCt.child(siblingSel + &#39;:first&#39;);
                break;
            
            case &#39;last&#39;:
                sibling = me.ownerCt.child(siblingSel + &#39;:last&#39;);
                break;
        }
        
        return sibling;
    },
    
<span id='Ext-panel-Panel-method-fireDefaultButton'>    fireDefaultButton: function(e) {
</span>        var me = this,
            refHolder, btn;
        
        refHolder = me.lookupReferenceHolder(/* skipThis = */ false) || me;
        btn = refHolder.lookupReference(me.defaultButton);
        
        // We call it defaultButton but it can really be any object
        // that implements `click` method
        if (btn &amp;&amp; btn.click) {
            btn.click(e);
            
            // Stop event propagation through DOM publisher
            e.stopEvent();
            
            // ... and in case we have other listeners,
            // stop the loop in Ext.util.Event too
            return false;
        }
        //&lt;debug&gt;
        else if (!btn) {
            Ext.raise({
                msg: &#39;No component found for defaultButton reference &quot;&#39; +
                      me.defaultButton + &#39;&quot; in &#39; + me.xtype + &#39; &#39; + me.id,
                panel: me
            });
        }
        else {
            Ext.raise({
                msg: &#39;Component referenced by defaultButton config &quot;&#39; +
                      me.defaultButton + &#39;&quot; in &#39; + me.xtype + &#39; &#39; + me.id +
                      &#39; does not have click() method&#39;,
                component: btn
            });
        }
        //&lt;/debug&gt;
    },
    
<span id='Ext-panel-Panel-method-maybeClose'>    maybeClose: function(e) {
</span>        var me = this;
        
        if (me.closable) {
            me.navigateAccordionHeader(e);
            
            // Can&#39;t close the last panel in accordion
            if (!e.doNotClose) {
                me.close();
            }
        }
    },

<span id='Ext-panel-Panel-method-canFocus'>    canFocus: function(skipVisibility, includeFocusTarget) {
</span>        // If we are placeholder collapsed, then the placeholder may be focusable.
        if (this.collapsed) {
            return !!(this.placeholder &amp;&amp; this.placeholder.canFocus(skipVisibility, includeFocusTarget));
        }
        return this.mixins.focusable.canFocus.call(this, skipVisibility, includeFocusTarget);
    },

<span id='Ext-panel-Panel-method-focus'>    focus: function() {
</span>        var me = this,
            placeholder = me.placeholder;

        if (me.collapsed &amp;&amp; placeholder &amp;&amp; placeholder.canFocus()) {
            placeholder.focus.apply(placeholder, arguments);
        } else {
            me.callParent(arguments);
        }
    },
    
<span id='Ext-panel-Panel-method-onFocusEnter'>    onFocusEnter: function(e) {
</span>        var me = this,
            ariaDom = me.ariaEl.dom;
        
        me.callParent([e]);
        
        if (me.isAccordionPanel &amp;&amp; ariaDom) {
            ariaDom.setAttribute(&#39;aria-selected&#39;, true);
        }
    },
    
<span id='Ext-panel-Panel-method-onFocusLeave'>    onFocusLeave: function(e) {
</span>        var me = this,
            ariaDom = me.ariaEl.dom;
        
        me.callParent([e]);
        
        if (me.isAccordionPanel &amp;&amp; ariaDom) {
            ariaDom.setAttribute(&#39;aria-selected&#39;, &#39;false&#39;);
        }
    },

<span id='Ext-panel-Panel-method-updateHeaderPosition'>    updateHeaderPosition: function(position) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setDock(position);
        }
    },

<span id='Ext-panel-Panel-method-updateIconAlign'>    updateIconAlign: function(align) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setIconAlign(align);
        }
    },

<span id='Ext-panel-Panel-method-updateTitleAlign'>    updateTitleAlign: function(align) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setTitleAlign(align);
        }
    },

<span id='Ext-panel-Panel-method-updateTitleRotation'>    updateTitleRotation: function(rotation) {
</span>        var header = this.header;

        if (header &amp;&amp; header.isHeader) {
            header.setTitleRotation(rotation);
        }
    },

<span id='Ext-panel-Panel-method-unghost'>    /**
</span>     * @private
     */
    unghost: function(show, matchPosition, focus) {
        var me = this,
            el = me.el,
            ghostPanel = me.ghostPanel;

        if (!ghostPanel) {
            return;
        }
        // Show el first to restore the element to the original
        // visibility mode.
        el.show();
        el.setVisibilityMode(me.elVisMode);

        if (show !== false) {
            if (matchPosition !== false) {
                me.setPagePosition(ghostPanel.getXY());
            }
        } else {
            el.hide();
        }
        ghostPanel.el.hide();
        ghostPanel.setHiddenState(true);
    },

<span id='Ext-panel-Panel-method-updateHeader'>    /**
</span>     * Create, hide, or show the header component as appropriate based on the current config.
     * @private
     * @param {Boolean} force True to force the header to be created
     */
    updateHeader: function(force) {
        var me = this,
            header = me.header,
            title = me.getTitle(),
            tools = me.tools,
            icon = me.getIcon(),
            glyph = me.getGlyph(),
            iconCls = me.getIconCls(),
            hasIcon = glyph || icon || iconCls,
            ariaDom = me.ariaEl.dom,
            headerPosition = me.getHeaderPosition(),
            vertical = headerPosition === &#39;left&#39; || headerPosition === &#39;right&#39;,
            headingEl, ariaAttr;
        
        if (Ext.isObject(header) || (header !== false &amp;&amp; (force || (title || hasIcon) ||
                (tools &amp;&amp; tools.length) || (me.collapsible &amp;&amp; !me.titleCollapse)))) {
            if (header &amp;&amp; header.isHeader) {
                header.dockToEl = true;
                header.show();
            }
            else {
                // Apply the header property to the header config
                header = me.header = Ext.widget(Ext.merge({
                    xtype: &#39;header&#39;,
                    title: title,
                    titleAlign: me.getTitleAlign(),
                    vertical: vertical,
                    dock: me.getHeaderPosition() || &#39;top&#39;,
                    dockToEl: true,
                    titleRotation: me.getTitleRotation(),
                    textCls: me.headerTextCls,
                    iconCls: iconCls,
                    iconAlign: me.getIconAlign(),
                    icon: icon,
                    glyph: glyph,
                    baseCls: me.baseCls + &#39;-header&#39;,
                    tools: tools,
                    ui: me.ui,
                    id: me.id + &#39;_header&#39;,
                    overCls: me.headerOverCls,
                    indicateDrag: me.draggable,
                    frame: (me.frame || me.alwaysFramed) &amp;&amp; me.frameHeader,
                    ignoreParentFrame : me.frame || me.overlapHeader,
                    ignoreBorderManagement: me.frame || me.ignoreHeaderBorderManagement,
                    isAccordionHeader: me.isAccordionPanel,
                    ownerCt: me,
                    synthetic: true, // not user-defined
                    listeners: me.collapsible &amp;&amp; me.titleCollapse ? {
                        click: me.toggleCollapse,
                        scope: me
                    } : null
                }, me.header));
                
                // Header&#39;s onAdd mutates the tools array.
                // It replaces tool configs at each index with the instantiated tool
                // It also injects the tool instances as properties keyed by their type.
                me.addDocked(header, 0);
            }
            
            // Accordion panels are tightly coupled to their headers&#39; titleCmp
            // via aria-labelledby attribute. There should be no aria-label.
            if (me.isAccordionPanel) {
                if (ariaDom) {
                    ariaDom.setAttribute(&#39;aria-labelledby&#39;, header.id + &#39;-title&#39;);
                    ariaDom.removeAttribute(&#39;aria-label&#39;);
                }
                else {
                    ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
                    ariaAttr[&#39;aria-labelledby&#39;] = header.id + &#39;-title&#39;;
                    delete ariaAttr[&#39;aria-label&#39;];
                }
            }
            else {
                if (title) {
                    // If the panel is not an ARIA a region, it still should have
                    // an accessible name via aria-labelledby attribute unless
                    // it is a tabpanel in which case aria-labelledby points
                    // to the corresponding tab and is managed by TabPanel class.
                    if (me.ariaRole !== &#39;tabpanel&#39;) {
                        if (ariaDom) {
                            ariaDom.setAttribute(&#39;aria-labelledby&#39;, header.id + &#39;-title-textEl&#39;);
                            ariaDom.removeAttribute(&#39;aria-label&#39;);
                        }
                        else {
                            ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
                            ariaAttr[&#39;aria-labelledby&#39;] = header.id + &#39;-title-textEl&#39;;
                            delete ariaAttr[&#39;aria-label&#39;];
                        }
                    }
                }
                
                // If there is no title, just make sure no aria-label attribute was added
                else if (me.ariaRenderAttributes) {
                    delete me.ariaRenderAttributes[&#39;aria-label&#39;];
                }
            }
        }
        else {
            if (header) {
                header.hide();
            }
            
            // Title may contain HTML markup
            title = Ext.util.Format.stripTags(title);
            
            // aria-labelledby could have been set by the TabPanel.onAdd()
            if (ariaDom) {
                if (!ariaDom.hasAttribute(&#39;aria-labelledby&#39;)) {
                    if (title) {
                        ariaDom.setAttribute(&#39;aria-label&#39;, title);
                    }
                    else {
                        ariaDom.removeAttribute(&#39;aria-label&#39;);
                    }
                }
            }
            else {
                ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
                
                if (!ariaAttr[&#39;aria-labelledby&#39;]) {
                    if (title) {
                        ariaAttr[&#39;aria-label&#39;] = title;
                    }
                    else {
                        delete ariaAttr[&#39;aria-label&#39;];
                    }
                }
            }
        }

        // If the panel is a child of the Viewport that has border layout,
        // that automatically makes it a region unless the user overrode that.
        if (me.isViewportBorderChild &amp;&amp; !me.hasOwnProperty(&#39;ariaRole&#39;)) {
            me.ariaRole = &#39;region&#39;;
        }
        
        //&lt;debug&gt;
        if (me.ariaRole === &#39;region&#39; &amp;&amp; !title) {
            Ext.ariaWarn(me,
                &quot;Panel &quot; + me.id + &quot; is a region section of the application, &quot; +
                &quot;but it does not have a title. Per WAI-ARIA, all regions &quot; +
                &quot;should have a heading element that contains region&#39;s title.&quot;
            );
        }
        //&lt;/debug&gt;
        
        // An ARIA region should have a title, and a heading which we implement
        // as an element placed before all other elements within the panel&#39;s
        // main element. The headingEl is hidden via clipping to avoid
        // visual impact while still allowing it to be published to
        // Assistive Technologies such as screen readers.
        if (title &amp;&amp; me.ariaRole === &#39;region&#39;) {
            headingEl = me.headingEl;
            
            if (headingEl) {
                headingEl.setHtml(title);
            }
            else {
                if (me.rendered) {
                    me.headingEl = Ext.dom.Helper.insertFirst(me.el, {
                        tag: &#39;div&#39;,
                        id: me.id + &#39;-headingEl&#39;,
                        role: &#39;heading&#39;,
                        &#39;class&#39;: Ext.baseCSSPrefix + &#39;hidden-clip&#39;,
                        style: &#39;height:0&#39;,
                        html: title
                    }, true);
                    
                    ariaDom.removeAttribute(&#39;aria-label&#39;);
                    ariaDom.setAttribute(&#39;aria-labelledby&#39;, me.id + &#39;-headingEl&#39;);
                }
                else {
                    me.headingText = me.title;
                    
                    ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
                    ariaAttr[&#39;aria-labelledby&#39;] = me.id + &#39;-headingEl&#39;;
                    delete ariaAttr[&#39;aria-label&#39;];
                }
            }
        }
        else if (me.headingEl) {
            me.headingEl.destroy();
            me.headingEl = null;
        }
    },

    // ***********************************************************************************
    // End Methods
    // ***********************************************************************************
    // &lt;/editor-fold&gt;
    
    statics: {
<span id='Ext-panel-Panel-static-property-floatCls'>        floatCls: Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;
</span>    },

<span id='Ext-panel-Panel-property-privates'>    privates: {
</span>        addUIToElement: function() {
            var me = this;

            me.callParent(arguments);
            me.addBodyCls(me.baseCls + &#39;-body-&#39; + me.ui);
        },

        applyTargetCls: function(targetCls) {
            this.getProtoBody().addCls(targetCls);
        },

        getDefaultContentTarget: function() {
            return this.body;
        },

        getTargetEl: function() {
            var me = this;
            return me.body || me.protoBody || me.frameBody || me.el;
        },

<span id='Ext-panel-Panel-method-initDraggable'>        /**
</span>         * @private
         */
        initDraggable: function() {
            var me = this;

            // For just simple dragging like Windows
            if (me.simpleDrag) {
                me.initSimpleDraggable();
            }
            // For DD package aware dragging of Panels
            else {
<span id='Ext-panel-Panel-property-dd'>                /**
</span>                 * @property {Ext.dd.DragSource/Ext.util.ComponentDragger} dd
                 *
                 * Only present if this Panel has been configured with {@link #cfg-draggable} `true`.
                 *
                 * ##Simple dragging##
                 *
                 * If this Panel is configured {@link #cfg-simpleDrag} `true` (the default is `false`), this property
                 * will reference an instance of {@link Ext.util.ComponentDragger} (A subclass of
                 * {@link Ext.dd.DragTracker DragTracker}) which handles moving the Panel&#39;s DOM Element,
                 * and constraining according to the {@link #constrain} and {@link #constrainHeader} .
                 *
                 * This object fires various events during its lifecycle and during a drag operation.
                 *
                 * ##Complex dragging interacting with other DragDrop instances##
                 *
                 * By default, this property in a {@link #cfg-draggable} Panel will contain an instance of {@link
                    * Ext.dd.DragSource} which handles dragging the Panel.
                 *
                 * The developer must provide implementations of the abstract methods of {@link Ext.dd.DragSource} in order to
                 * supply behaviour for each stage of the drag/drop process. 
                 * 
                 * See also {@link #cfg-draggable}.
                 */
                me.dd = new Ext.panel.DD(me, Ext.isBoolean(me.draggable) ? null : me.draggable);
            }
        },

        initResizable: function(resizable) {
            this.callParent([resizable]);
            if (this.collapsed) {
                this.resizer.disable();
            }
        },

<span id='Ext-panel-Panel-method-initSimpleDraggable'>        /**
</span>         * @private
         * Override Component.initDraggable.
         * Panel (and subclasses) use the header element as the delegate.
         */
        initSimpleDraggable: function() {
            var me = this,
                dd = me.draggable;

            if (!me.header &amp;&amp; !dd.delegate) {
                me.updateHeader(true);
            }

            /*
             * Check the header here again. If for whatever reason it wasn&#39;t created in
             * updateHeader (we were configured with header: false) then we&#39;ll just ignore the rest since the
             * header acts as the drag handle.
             */
            if (me.header || dd.delegate) {
                dd = Ext.apply({
                    el: me.el,
                    delegate: me.header &amp;&amp; me.header.el
                }, dd);

                // Add extra configs if Window is specified to be constrained
                if (me.constrain || me.constrainHeader) {
                    dd.constrain = me.constrain;
                    dd.constrainDelegate = me.constrainHeader;
                    dd.constrainTo = me.constrainTo || me.container;
                }

                dd = me.dd = new Ext.util.ComponentDragger(me, dd);
                me.relayEvents(dd, [&#39;dragstart&#39;, &#39;drag&#39;, &#39;dragend&#39;]);
            }
        },

        removeUIFromElement: function() {
            var me = this;

            me.callParent(arguments);
            me.removeBodyCls(me.baseCls + &#39;-body-&#39; + me.ui);
        },

        setupRenderTpl: function (renderTpl) {
            this.callParent(arguments);
            this.setupDockingRenderTpl(renderTpl);
        },

        slideOutFloatedPanel: function(preventAnimate) {
            var me = this,
                compEl = me.el,
                collapseDirection,
                focusTarget,
                afterSlideOut = function() {
                    me.slideOutFloatedPanelEnd();
                    // this would be in slideOutFloatedPanelEnd except that the only other
                    // caller removes this cls later
                    me.el.removeCls(Ext.baseCSSPrefix + &#39;border-region-slide-in&#39;);

                    // Event fired when floated stateus ends
                    me.fireEvent(&#39;endfloat&#39;, me);
                };

            if (me.isSliding || me.destroyed) {
                return;
            }

            me.isSliding = true;
            me.floated = false;

            me.slideOutFloatedPanelBegin();
            if (preventAnimate) {
                compEl.hide();
                return afterSlideOut();
            }

            if (typeof me.collapsed === &#39;string&#39;) {
                collapseDirection = me.convertCollapseDir(me.collapsed);
            }

            me.fireEvent(&#39;beginfloat&#39;, me);
            compEl.slideOut(collapseDirection, {
                preserveScroll: true,
                duration: Ext.Number.from(me.animCollapse, Ext.fx.Anim.prototype.duration),
                listeners: {
                    afteranimate: afterSlideOut
                }
            });

            // Focus the placeholder which should delegate into itself
            if (this.containsFocus) {
                focusTarget = this.findFocusTarget();
                if (focusTarget) {
                    focusTarget.focus();
                }
            }
        },

<span id='Ext-panel-Panel-method-slideOutFloatedPanelBegin'>        /**
</span>         * This method begins the slide out of the floated panel.
         * @private
         */
        slideOutFloatedPanelBegin: function() {
            var me = this,
                placeholderEl = me.placeholder.el,
                el = me.el,
                bodyMousedownListener = me.bodyMousedownListener;

            me.collapsed = me.floatedFromCollapse;
            me.setHiddenState(true);
            me.floatedFromCollapse = null;

            // Remove mouse leave/enter monitors, and the mousedown monitor
            Ext.destroy(me.pointerLeaveListener, me.phHoverListeners, me.elHoverListeners);
            if (bodyMousedownListener) {
                me.bodyMousedownListener = bodyMousedownListener.destroy()
            }
        },

<span id='Ext-panel-Panel-method-slideOutFloatedPanelEnd'>        /**
</span>         * This method cleans up after the slide out of the floated panel.
         * @private
         */
        slideOutFloatedPanelEnd: function(suppressEvents) {
            var me = this;

            if (me.collapseTool) {
                me.collapseTool.el.show();
            }
            me.slideOutTask.cancel();
            me.isSliding = false;
            if (!suppressEvents) {
                me.fireEvent(&#39;unfloat&#39;, me);
            }
        }

    } // private
}, function() {
    var proto = this.prototype;

    proto.animCollapse = Ext.enableFx;
    proto.placeholderCollapseHideMode = Ext.Element.VISIBILITY;
});
</pre>
</body>
</html>
