<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-Date'>/**
</span> * @class Ext.Date
 * This class defines some basic methods for handling dates.
 *
 * The date parsing and formatting syntax contains a subset of
 * [PHP&#39;s `date()` function](http://www.php.net/date), and the formats that are
 * supported will provide results equivalent to their PHP versions.
 *
 * The following is a list of all currently supported formats:
 *
 *      Format      Description                                                               Example returned values
 *      ------      -----------------------------------------------------------------------   -----------------------
 *        d         Day of the month, 2 digits with leading zeros                             01 to 31
 *        D         A short textual representation of the day of the week                     Mon to Sun
 *        j         Day of the month without leading zeros                                    1 to 31
 *        l         A full textual representation of the day of the week                      Sunday to Saturday
 *        N         ISO-8601 numeric representation of the day of the week                    1 (for Monday) through 7 (for Sunday)
 *        S         English ordinal suffix for the day of the month, 2 characters             st, nd, rd or th. Works well with j
 *        w         Numeric representation of the day of the week                             0 (for Sunday) to 6 (for Saturday)
 *        z         The day of the year (starting from 0)                                     0 to 364 (365 in leap years)
 *        W         ISO-8601 week number of year, weeks starting on Monday                    01 to 53
 *        F         A full textual representation of a month, such as January or March        January to December
 *        m         Numeric representation of a month, with leading zeros                     01 to 12
 *        M         A short textual representation of a month                                 Jan to Dec
 *        n         Numeric representation of a month, without leading zeros                  1 to 12
 *        t         Number of days in the given month                                         28 to 31
 *        L         Whether it&amp;#39;s a leap year                                                  1 if it is a leap year, 0 otherwise.
 *        o         ISO-8601 year number (identical to (Y), but if the ISO week number (W)    Examples: 1998 or 2004
 *                  belongs to the previous or next year, that year is used instead)
 *        Y         A full numeric representation of a year, 4 digits                         Examples: 1999 or 2003
 *        y         A two digit representation of a year                                      Examples: 99 or 03
 *        a         Lowercase Ante meridiem and Post meridiem                                 am or pm
 *        A         Uppercase Ante meridiem and Post meridiem                                 AM or PM
 *        g         12-hour format of an hour without leading zeros                           1 to 12
 *        G         24-hour format of an hour without leading zeros                           0 to 23
 *        h         12-hour format of an hour with leading zeros                              01 to 12
 *        H         24-hour format of an hour with leading zeros                              00 to 23
 *        i         Minutes, with leading zeros                                               00 to 59
 *        s         Seconds, with leading zeros                                               00 to 59
 *        u         Decimal fraction of a second                                              Examples:
 *                  (minimum 1 digit, arbitrary number of digits allowed)                     001 (i.e. 0.001s) or
 *                                                                                            100 (i.e. 0.100s) or
 *                                                                                            999 (i.e. 0.999s) or
 *                                                                                            999876543210 (i.e. 0.999876543210s)
 *        O         Difference to Greenwich time (GMT) in hours and minutes                   Example: +1030
 *        P         Difference to Greenwich time (GMT) with colon between hours and minutes   Example: -08:00
 *        T         Timezone abbreviation of the machine running the code                     Examples: EST, MDT, PDT ...
 *        Z         Timezone offset in seconds (negative if west of UTC, positive if east)    -43200 to 50400
 *        c         ISO 8601 date represented as the local time with an offset to UTC appended.
 *                  Notes:                                                                    Examples:
 *                  1) If unspecified, the month / day defaults to the current month / day,   1991 or
 *                     the time defaults to midnight, while the timezone defaults to the      1992-10 or
 *                     browser&#39;s timezone. If a time is specified, it must include both hours 1993-09-20 or
 *                     and minutes. The &quot;T&quot; delimiter, seconds, milliseconds and timezone     1994-08-19T16:20+01:00 or
 *                     are optional.                                                          1995-07-18T17:21:28-02:00 or
 *                  2) The decimal fraction of a second, if specified, must contain at        1996-06-17T18:22:29.98765+03:00 or
 *                     least 1 digit (there is no limit to the maximum number                 1997-05-16T19:23:30,12345-0400 or
 *                     of digits allowed), and may be delimited by either a &#39;.&#39; or a &#39;,&#39;      1998-04-15T20:24:31.2468Z or
 *                  Refer to the examples on the right for the various levels of              1999-03-14T20:24:32Z or
 *                  date-time granularity which are supported, or see                         2000-02-13T21:25:33
 *                  http://www.w3.org/TR/NOTE-datetime for more info.                         2001-01-12 22:26:34
 *        C         An ISO date string as implemented by the native Date object&#39;s             1962-06-17T09:21:34.125Z
 *                  [Date.toISOString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
 *                  method. This outputs the numeric part with *UTC* hour and minute
 *                  values, and indicates this by appending the `&#39;Z&#39;` timezone
 *                  identifier.
 *        U         Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)                1193432466 or -2138434463
 *        MS        Microsoft AJAX serialized dates                                           \/Date(1238606590509)\/ (i.e. UTC milliseconds since epoch) or
 *                                                                                            \/Date(1238606590509+0800)\/
 *        time      A javascript millisecond timestamp                                        1350024476440
 *        timestamp A UNIX timestamp (same as U)                                              1350024866            
 *
 * Example usage (note that you must escape format specifiers with &#39;\\&#39; to render them as character literals):
 *
 *     // Sample date:
 *     // &#39;Wed Jan 10 2007 15:05:01 GMT-0600 (Central Standard Time)&#39;
 *     
 *     var dt = new Date(&#39;1/10/2007 03:05:01 PM GMT-0600&#39;);
 *     console.log(Ext.Date.format(dt, &#39;Y-m-d&#39;));                          // 2007-01-10
 *     console.log(Ext.Date.format(dt, &#39;F j, Y, g:i a&#39;));                  // January 10, 2007, 3:05 pm
 *     console.log(Ext.Date.format(dt, &#39;l, \\t\\he jS \\of F Y h:i:s A&#39;)); // Wednesday, the 10th of January 2007 03:05:01 PM
 *
 * Here are some standard date/time patterns that you might find helpful.  They
 * are not part of the source of Ext.Date, but to use them you can simply copy this
 * block of code into any script that is included after Ext.Date and they will also become
 * globally available on the Date object.  Feel free to add or remove patterns as needed in your code.
 *
 *     Ext.Date.patterns = {
 *         ISO8601Long:&quot;Y-m-d H:i:s&quot;,
 *         ISO8601Short:&quot;Y-m-d&quot;,
 *         ShortDate: &quot;n/j/Y&quot;,
 *         LongDate: &quot;l, F d, Y&quot;,
 *         FullDateTime: &quot;l, F d, Y g:i:s A&quot;,
 *         MonthDay: &quot;F d&quot;,
 *         ShortTime: &quot;g:i A&quot;,
 *         LongTime: &quot;g:i:s A&quot;,
 *         SortableDateTime: &quot;Y-m-d\\TH:i:s&quot;,
 *         UniversalSortableDateTime: &quot;Y-m-d H:i:sO&quot;,
 *         YearMonth: &quot;F, Y&quot;
 *     };
 *
 * Example usage:
 *
 *     var dt = new Date();
 *     console.log(Ext.Date.format(dt, Ext.Date.patterns.ShortDate));
 *
 * Developer-written, custom formats may be used by supplying both a formatting and a parsing function
 * which perform to specialized requirements. The functions are stored in {@link #parseFunctions} and {@link #formatFunctions}.
 * @singleton
 */
Ext.Date = (function () {
// @define Ext.lang.Date
// @define Ext.Date
// @require Ext
// @require Ext.lang.String
  var utilDate,
      nativeDate = Date,
      stripEscapeRe = /(\\.)/g,
      hourInfoRe = /([gGhHisucUOPZ]|MS)/,
      dateInfoRe = /([djzmnYycU]|MS)/,
      slashRe = /\\/gi,
      numberTokenRe = /\{(\d+)\}/g,
      MSFormatRe = new RegExp(&#39;\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/&#39;),
      pad = Ext.String.leftPad,

      // Most of the date-formatting functions below are the excellent work of Baron Schwartz.
      // (see http://www.xaprb.com/blog/2005/12/12/javascript-closures-for-runtime-efficiency/)
      // They generate precompiled functions from format patterns instead of parsing and
      // processing each pattern every time a date is formatted.
      code = [
        // date calculations (note: the code below creates a dependency on Ext.Number.from())
        &quot;var me = this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,&quot;,
            &quot;def = me.defaults,&quot;,
            &quot;from = Ext.Number.from,&quot;,
            &quot;results = String(input).match(me.parseRegexes[{0}]);&quot;, // either null, or an array of matched strings

        &quot;if(results){&quot;,
            &quot;{1}&quot;,

            &quot;if(u != null){&quot;, // i.e. unix time is defined
                &quot;v = new Date(u * 1000);&quot;, // give top priority to UNIX time
            &quot;}else{&quot;,
                // create Date object representing midnight of the current day;
                // this will provide us with our date defaults
                // (note: clearTime() handles Daylight Saving Time automatically)
                &quot;dt = me.clearTime(new Date);&quot;,

                &quot;y = from(y, from(def.y, dt.getFullYear()));&quot;,
                &quot;m = from(m, from(def.m - 1, dt.getMonth()));&quot;,
                &quot;dayMatched = d !== undefined;&quot;,
                &quot;d = from(d, from(def.d, dt.getDate()));&quot;,

                // Attempt to validate the day. Since it defaults to today, it may go out
                // of range, for example parsing m/Y where the value is 02/2000 on the 31st of May.
                // It will attempt to parse 2000/02/31, which will overflow to March and end up
                // returning 03/2000. We only do this when we default the day. If an invalid day value
                // was set to be parsed by the user, continue on and either let it overflow or return null
                // depending on the strict value. This will be in line with the normal Date behaviour.

                &quot;if (!dayMatched) {&quot;,
                    &quot;dt.setDate(1);&quot;,
                    &quot;dt.setMonth(m);&quot;,
                    &quot;dt.setFullYear(y);&quot;,

                    &quot;daysInMonth = me.getDaysInMonth(dt);&quot;,
                    &quot;if (d &gt; daysInMonth) {&quot;,
                        &quot;d = daysInMonth;&quot;,
                    &quot;}&quot;,
                &quot;}&quot;,

                &quot;h  = from(h, from(def.h, dt.getHours()));&quot;,
                &quot;i  = from(i, from(def.i, dt.getMinutes()));&quot;,
                &quot;s  = from(s, from(def.s, dt.getSeconds()));&quot;,
                &quot;ms = from(ms, from(def.ms, dt.getMilliseconds()));&quot;,

                &quot;if(z &gt;= 0 &amp;&amp; y &gt;= 0){&quot;,
                    // both the year and zero-based day of year are defined and &gt;= 0.
                    // these 2 values alone provide sufficient info to create a full date object

                    // create Date object representing January 1st for the given year
                    // handle years &lt; 100 appropriately
                    &quot;v = me.add(new Date(y &lt; 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y &lt; 100 ? y - 100 : 0);&quot;,

                    // then add day of year, checking for Date &quot;rollover&quot; if necessary
                    &quot;v = !strict? v : (strict === true &amp;&amp; (z &lt;= 364 || (me.isLeapYear(v) &amp;&amp; z &lt;= 365))? me.add(v, me.DAY, z) : null);&quot;,
                &quot;}else if(strict === true &amp;&amp; !me.isValid(y, m + 1, d, h, i, s, ms)){&quot;, // check for Date &quot;rollover&quot;
                    &quot;v = null;&quot;, // invalid date, so return null
                &quot;}else{&quot;,
                    &quot;if (W) {&quot;, // support ISO-8601
                        // http://en.wikipedia.org/wiki/ISO_week_date
                        //
                        // Mutually equivalent definitions for week 01 are:
                        // a. the week starting with the Monday which is nearest in time to 1 January
                        // b. the week with 4 January in it
                        // ... there are many others ...
                        //
                        // We&#39;ll use letter b above to determine the first week of the year.
                        //
                        // So, first get a Date object for January 4th of whatever calendar year is desired.
                        //
                        // Then, the first Monday of the year can easily be determined by (operating on this Date):
                        // 1. Getting the day of the week.
                        // 2. Subtracting that by one.
                        // 3. Multiplying that by 86400000 (one day in ms).
                        // 4. Subtracting this number of days (in ms) from the January 4 date (represented in ms).
                        //
                        // Example #1 ...
                        //
                        //       January 2012
                        //   Su Mo Tu We Th Fr Sa
                        //    1  2  3  4  5  6  7
                        //    8  9 10 11 12 13 14
                        //   15 16 17 18 19 20 21
                        //   22 23 24 25 26 27 28
                        //   29 30 31
                        //
                        // 1. January 4th is a Wednesday.
                        // 2. Its day number is 3.
                        // 3. Simply substract 2 days from Wednesday.
                        // 4. The first week of the year begins on Monday, January 2. Simple!
                        //
                        // Example #2 ...
                        //       January 1992
                        //   Su Mo Tu We Th Fr Sa
                        //             1  2  3  4
                        //    5  6  7  8  9 10 11
                        //   12 13 14 15 16 17 18
                        //   19 20 21 22 23 24 25
                        //   26 27 28 29 30 31
                        //
                        // 1. January 4th is a Saturday.
                        // 2. Its day number is 6.
                        // 3. Simply subtract 5 days from Saturday.
                        // 4. The first week of the year begins on Monday, December 30. Simple!
                        //
                        // v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));
                        // (This is essentially doing the same thing as above but for the week rather than the day)
                        &quot;year = y || (new Date()).getFullYear();&quot;,
                        &quot;jan4 = new Date(year, 0, 4, 0, 0, 0);&quot;,
                        &quot;d = jan4.getDay();&quot;,
                        // If the 1st is a Thursday, then the 4th will be a Sunday, so we need the appropriate
                        // day number here, which is why we use the day === checks.
                        &quot;week1monday = new Date(jan4.getTime() - ((d === 0 ? 6 : d - 1) * 86400000));&quot;,
                        // The reason for adding 43200000 (12 hours) is to avoid any complication with daylight saving
                        // switch overs. For example,  if the clock is rolled back, an hour will repeat, so adding 7 days
                        // will leave us 1 hour short (Sun &lt;date&gt; 23:00:00). By setting is to 12:00, subtraction
                        // or addition of an hour won&#39;t make any difference.
                        &quot;v = Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));&quot;,
                    &quot;} else {&quot;,
                        // plain old Date object
                        // handle years &lt; 100 properly
                        &quot;v = me.add(new Date(y &lt; 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y &lt; 100 ? y - 100 : 0);&quot;,
                    &quot;}&quot;,
                &quot;}&quot;,
            &quot;}&quot;,
        &quot;}&quot;,

        &quot;if(v){&quot;,
            // favor UTC offset over GMT offset
            &quot;if(zz != null){&quot;,
                // reset to UTC, then add offset
                &quot;v = me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);&quot;,
            &quot;}else if(o){&quot;,
                // reset to GMT, then add offset
                &quot;v = me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn == &#39;+&#39;? -1 : 1) * (hr * 60 + mn));&quot;,
            &quot;}&quot;,
        &quot;}&quot;,

        &quot;return (v != null) ? v : null;&quot;
      ].join(&#39;\n&#39;);

    // Polyfill Date&#39;s toISOString instance method where not implemented.
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString
    // TODO: Remove this when IE8 retires.
    if (!Date.prototype.toISOString) {
        Date.prototype.toISOString = function() {
            var me = this;
            return pad(me.getUTCFullYear(), 4, &#39;0&#39;) + &#39;-&#39; +
                   pad(me.getUTCMonth() + 1, 2, &#39;0&#39;) + &#39;-&#39; +
                   pad(me.getUTCDate(), 2, &#39;0&#39;) + &#39;T&#39; +
                   pad(me.getUTCHours(), 2, &#39;0&#39;) + &#39;:&#39; +
                   pad(me.getUTCMinutes(), 2, &#39;0&#39;) + &#39;:&#39; +
                   pad(me.getUTCSeconds(), 2, &#39;0&#39;) + &#39;.&#39; +
                   pad(me.getUTCMilliseconds(), 3, &#39;0&#39;) + &#39;Z&#39;;
       };
    }

<span id='Ext-Date-method-xf'>    /**
</span>     * @method xf
     * @private
     * @param format
     * Create private copy of Ext JS&#39;s `Ext.util.Format.format()` method
     * + to remove unnecessary dependency
     * + to resolve namespace conflict with MS-Ajax&#39;s implementation
     */
    function xf(format) {
        var args = Array.prototype.slice.call(arguments, 1);
        return format.replace(numberTokenRe, function(m, i) {
            return args[i];
        });
    }
  
utilDate = {
<span id='global-property-now'>    /** @ignore */
</span>    now: nativeDate.now, // always available due to polyfill in Ext.js

<span id='Ext-Date-method-toString'>    /**
</span>     * @private
     */
    toString: function(date) {
        if (!date) {
            date = new nativeDate();
        }

        return date.getFullYear() + &quot;-&quot;
            + pad(date.getMonth() + 1, 2, &#39;0&#39;) + &quot;-&quot;
            + pad(date.getDate(), 2, &#39;0&#39;) + &quot;T&quot;
            + pad(date.getHours(), 2, &#39;0&#39;) + &quot;:&quot;
            + pad(date.getMinutes(), 2, &#39;0&#39;) + &quot;:&quot;
            + pad(date.getSeconds(), 2, &#39;0&#39;);
    },

<span id='Ext-Date-method-getElapsed'>    /**
</span>     * Returns the number of milliseconds between two dates.
     * @param {Date} dateA The first date.
     * @param {Date} [dateB=new Date()] (optional) The second date.
     * @return {Number} The difference in milliseconds
     */
    getElapsed: function(dateA, dateB) {
        return Math.abs(dateA - (dateB || utilDate.now()));
    },

<span id='Ext-Date-property-useStrict'>    /**
</span>     * Global flag which determines if strict date parsing should be used.
     * Strict date parsing will not roll-over invalid dates, which is the
     * default behavior of JavaScript Date objects.
     * (see {@link #parse} for more information)
     * @type Boolean
    */
    useStrict: false,

<span id='Ext-Date-method-formatCodeToRegex'>    /**
</span>     * @private
     */
    formatCodeToRegex: function(character, currentGroup) {
        // Note: currentGroup - position in regex result array (see notes for Ext.Date.parseCodes below)
        var p = utilDate.parseCodes[character];

        if (p) {
          p = typeof p === &#39;function&#39;? p() : p;
          utilDate.parseCodes[character] = p; // reassign function result to prevent repeated execution
        }

        return p ? Ext.applyIf({
          c: p.c ? xf(p.c, currentGroup || &quot;{0}&quot;) : p.c
        }, p) : {
            g: 0,
            c: null,
            s: Ext.String.escapeRegex(character) // treat unrecognized characters as literals
        };
    },

<span id='Ext-Date-property-parseFunctions'>    /**
</span>     * An object hash in which each property is a date parsing function. The property name is the
     * format string which that function parses.
     *
     * This object is automatically populated with date parsing functions as
     * date formats are requested for Ext standard formatting strings.
     *
     * Custom parsing functions may be inserted into this object, keyed by a name which from then on
     * may be used as a format string to {@link #parse}.
     *
     * Example:
     *
     *     Ext.Date.parseFunctions[&#39;x-date-format&#39;] = myDateParser;
     *
     *  A parsing function should return a Date object, and is passed the following parameters:
     *
     * - `date`: {@link String} - The date string to parse.
     * - `strict`: {@link Boolean} - `true` to validate date strings while parsing
     * (i.e. prevent JavaScript Date &quot;rollover&quot;). __The default must be `false`.__
     * Invalid date strings should return `null` when parsed.
     *
     * To enable Dates to also be _formatted_ according to that format, a corresponding
     * formatting function must be placed into the {@link #formatFunctions} property.
     * @property parseFunctions
     * @type Object
     */
    parseFunctions: {
        &quot;MS&quot;: function(input, strict) {
            // note: the timezone offset is ignored since the MS Ajax server sends
            // a UTC milliseconds-since-Unix-epoch value (negative values are allowed)
            var r = (input || &#39;&#39;).match(MSFormatRe);
            return r ? new nativeDate(((r[1] || &#39;&#39;) + r[2]) * 1) : null;
        },
        &quot;time&quot;: function(input, strict) {
            var num = parseInt(input, 10);
            if (num || num === 0) {
                return new nativeDate(num);
            }
            return null;
        },
        &quot;timestamp&quot;: function(input, strict) {
            var num = parseInt(input, 10);
            if (num || num === 0) {
                return new nativeDate(num * 1000);
            }
            return null;
        }
    },
    parseRegexes: [],

<span id='Ext-Date-property-formatFunctions'>    /**
</span>     * An object hash in which each property is a date formatting function. The property name is the
     * format string which corresponds to the produced formatted date string.
     *
     * This object is automatically populated with date formatting functions as
     * date formats are requested for Ext standard formatting strings.
     *
     * Custom formatting functions may be inserted into this object, keyed by a name which from then on
     * may be used as a format string to {@link #format}.
     *
     * Example:
     *
     *     Ext.Date.formatFunctions[&#39;x-date-format&#39;] = myDateFormatter;
     *
     * A formatting function should return a string representation of the Date object which
     * is the scope (this) of the function.
     *
     * To enable date strings to also be _parsed_ according to that format, a corresponding
     * parsing function must be placed into the {@link #parseFunctions} property.
     * @property formatFunctions
     * @type Object
     */
    formatFunctions: {
        &quot;MS&quot;: function() {
            // UTC milliseconds since Unix epoch (MS-AJAX serialized date format (MRSF))
            return &#39;\\/Date(&#39; + this.getTime() + &#39;)\\/&#39;;
        },
        &quot;time&quot;: function(){
            return this.getTime().toString();
        },
        &quot;timestamp&quot;: function(){
            return utilDate.format(this, &#39;U&#39;);
        }
    },

    y2kYear : 50,

<span id='Ext-Date-property-MILLI'>    /**
</span>     * Date interval constant.
     * @type String
     */
    MILLI : &quot;ms&quot;,

<span id='Ext-Date-property-SECOND'>    /**
</span>     * Date interval constant.
     * @type String
     */
    SECOND : &quot;s&quot;,

<span id='Ext-Date-property-MINUTE'>    /**
</span>     * Date interval constant.
     * @type String
     */
    MINUTE : &quot;mi&quot;,

<span id='Ext-Date-property-HOUR'>    /** Date interval constant.
</span>     * @type String
     */
    HOUR : &quot;h&quot;,

<span id='Ext-Date-property-DAY'>    /**
</span>     * Date interval constant.
     * @type String
     */
    DAY : &quot;d&quot;,

<span id='Ext-Date-property-MONTH'>    /**
</span>     * Date interval constant.
     * @type String
     */
    MONTH : &quot;mo&quot;,

<span id='Ext-Date-property-YEAR'>    /**
</span>     * Date interval constant.
     * @type String
     */
    YEAR : &quot;y&quot;,

<span id='Ext-Date-property-DAYS_IN_WEEK'>    /**
</span>     * The number of days in a week.
     * @type Number
     */
    DAYS_IN_WEEK: 7,

<span id='Ext-Date-property-MONTHS_IN_YEAR'>    /**
</span>     * The number of months in a year.
     * @type Number
     */
    MONTHS_IN_YEAR: 12,

<span id='Ext-Date-property-MAX_DAYS_IN_MONTH'>    /**
</span>     * The maximum number of days in a month.
     * @type {Number}
     */
    MAX_DAYS_IN_MONTH: 31,

    SUNDAY: 0,
    MONDAY: 1,
    TUESDAY: 2,
    WEDNESDAY: 3,
    THURSDAY: 4,
    FRIDAY: 5,
    SATURDAY: 6,

<span id='Ext-Date-property-defaults'>    /**
</span>     * An object hash containing default date values used during date parsing.
     * 
     * The following properties are available:
     *
     * - `y`: {@link Number} - The default year value. Defaults to `undefined`.
     * - `m`: {@link Number} - The default 1-based month value. Defaults to `undefined`.
     * - `d`: {@link Number} - The default day value. Defaults to `undefined`.
     * - `h`: {@link Number} - The default hour value. Defaults to `undefined`.
     * - `i`: {@link Number} - The default minute value. Defaults to `undefined`.
     * - `s`: {@link Number} - The default second value. Defaults to `undefined`.
     * - `ms`: {@link Number} - The default millisecond value. Defaults to `undefined`.
     * 
     * Override these properties to customize the default date values used by the {@link #parse} method.
     * 
     * __Note:__ In countries which experience Daylight Saving Time (i.e. DST), the `h`, `i`, `s`
     * and `ms` properties may coincide with the exact time in which DST takes effect.
     * It is the responsibility of the developer to account for this.
     *
     * Example Usage:
     * 
     *     // set default day value to the first day of the month
     *     Ext.Date.defaults.d = 1;
     *
     *     // parse a February date string containing only year and month values.
     *     // setting the default day value to 1 prevents weird date rollover issues
     *     // when attempting to parse the following date string on, for example, March 31st 2009.
     *     Ext.Date.parse(&#39;2009-02&#39;, &#39;Y-m&#39;); // returns a Date object representing February 1st 2009.
     *
     * @property defaults
     * @type Object
     */
    defaults: {},

    //&lt;locale type=&quot;array&quot;&gt;
<span id='Ext-Date-property-dayNames'>    /**
</span>     * @property {String[]} dayNames
     * An array of textual day names.
     * Override these values for international dates.
     *
     * Example:
     *
     *     Ext.Date.dayNames = [
     *         &#39;SundayInYourLang&#39;,
     *         &#39;MondayInYourLang&#39;
     *         // ...
     *     ];
     */
    dayNames : [
        &quot;Sunday&quot;,
        &quot;Monday&quot;,
        &quot;Tuesday&quot;,
        &quot;Wednesday&quot;,
        &quot;Thursday&quot;,
        &quot;Friday&quot;,
        &quot;Saturday&quot;
    ],
    //&lt;/locale&gt;

    //&lt;locale type=&quot;array&quot;&gt;
<span id='Ext-Date-property-monthNames'>    /**
</span>     * @property {String[]} monthNames
     * An array of textual month names.
     * Override these values for international dates.
     *
     * Example:
     *
     *     Ext.Date.monthNames = [
     *         &#39;JanInYourLang&#39;,
     *         &#39;FebInYourLang&#39;
     *         // ...
     *     ];
     */
    monthNames : [
        &quot;January&quot;,
        &quot;February&quot;,
        &quot;March&quot;,
        &quot;April&quot;,
        &quot;May&quot;,
        &quot;June&quot;,
        &quot;July&quot;,
        &quot;August&quot;,
        &quot;September&quot;,
        &quot;October&quot;,
        &quot;November&quot;,
        &quot;December&quot;
    ],
    //&lt;/locale&gt;

    //&lt;locale type=&quot;object&quot;&gt;
<span id='Ext-Date-property-monthNumbers'>    /**
</span>     * @property {Object} monthNumbers
     * An object hash of zero-based JavaScript month numbers (with short month names as keys).
     *
     * __Note:__ keys are case-sensitive.
     * 
     * Override these values for international dates.
     *
     * Example:
     *
     *     Ext.Date.monthNumbers = {
     *         &#39;LongJanNameInYourLang&#39;: 0,
     *         &#39;ShortJanNameInYourLang&#39;:0,
     *         &#39;LongFebNameInYourLang&#39;:1,
     *         &#39;ShortFebNameInYourLang&#39;:1
     *         // ...
     *     };
     */
    monthNumbers : {
        January: 0,
        Jan: 0,
        February: 1,
        Feb: 1,
        March: 2,
        Mar: 2,
        April: 3,
        Apr: 3,
        May: 4,
        June: 5,
        Jun: 5,
        July: 6,
        Jul: 6,
        August: 7,
        Aug: 7,
        September: 8,
        Sep: 8,
        October: 9,
        Oct: 9,
        November: 10,
        Nov: 10,
        December: 11,
        Dec: 11
    },
    //&lt;/locale&gt;
    
    //&lt;locale&gt;
<span id='Ext-Date-property-defaultFormat'>    /**
</span>     * @property {String} defaultFormat
     * The date format string that the {@link Ext.util.Format#dateRenderer}
     * and {@link Ext.util.Format#date} functions use.  See {@link Ext.Date} for details.
     *
     * This may be overridden in a locale file.
     */
    defaultFormat : &quot;m/d/Y&quot;,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-Date-property-firstDayOfWeek'>    /**
</span>     * @property {Number} firstDayOfWeek
     * The day on which the week starts. `0` being Sunday, through `6` being Saturday.
     *
     * This may be overridden in a locale file.
     */
    firstDayOfWeek: 0,
    //&lt;/locale&gt;

    //&lt;locale&gt;
<span id='Ext-Date-property-weekendDays'>    /**
</span>     * @property {Number[]} weekendDays
     * The days on which weekend falls. `0` being Sunday, through `6` being Saturday.
     *
     * This may be overridden in a locale file.
     */
    weekendDays: [0, 6],
    //&lt;/locale&gt;

    //&lt;locale type=&quot;function&quot;&gt;
<span id='Ext-Date-method-getShortMonthName'>    /**
</span>     * Get the short month name for the given month number.
     * Override this function for international dates.
     * @param {Number} month A zero-based JavaScript month number.
     * @return {String} The short month name.
     */
    getShortMonthName : function(month) {
        return utilDate.monthNames[month].substring(0, 3);
    },
    //&lt;/locale&gt;

    //&lt;locale type=&quot;function&quot;&gt;
<span id='Ext-Date-method-getShortDayName'>    /**
</span>     * Get the short day name for the given day number.
     * Override this function for international dates.
     * @param {Number} day A zero-based JavaScript day number.
     * @return {String} The short day name.
     */
    getShortDayName : function(day) {
        return utilDate.dayNames[day].substring(0, 3);
    },
    //&lt;/locale&gt;

    //&lt;locale type=&quot;function&quot;&gt;
<span id='Ext-Date-method-getMonthNumber'>    /**
</span>     * Get the zero-based JavaScript month number for the given short/full month name.
     * Override this function for international dates.
     * @param {String} name The short/full month name.
     * @return {Number} The zero-based JavaScript month number.
     */
    getMonthNumber : function(name) {
        // handle camel casing for English month names (since the keys for the Ext.Date.monthNumbers hash are case sensitive)
        return utilDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
    },
    //&lt;/locale&gt;

<span id='Ext-Date-method-formatContainsHourInfo'>    /**
</span>     * Checks if the specified format contains hour information
     * @param {String} format The format to check
     * @return {Boolean} True if the format contains hour information
     * @method
     */
    formatContainsHourInfo : function(format){
        return hourInfoRe.test(format.replace(stripEscapeRe, &#39;&#39;));
    },

<span id='Ext-Date-method-formatContainsDateInfo'>    /**
</span>     * Checks if the specified format contains information about
     * anything other than the time.
     * @param {String} format The format to check
     * @return {Boolean} True if the format contains information about
     * date/day information.
     * @method
     */
    formatContainsDateInfo : function(format){
        return dateInfoRe.test(format.replace(stripEscapeRe, &#39;&#39;));
    },
    
<span id='Ext-Date-method-unescapeFormat'>    /**
</span>     * Removes all escaping for a date format string. In date formats,
     * using a &#39;\&#39; can be used to escape special characters.
     * @param {String} format The format to unescape
     * @return {String} The unescaped format
     * @method
     */
    unescapeFormat: function(format) {
        // Escape the format, since \ can be used to escape special
        // characters in a date format. For example, in a Spanish
        // locale the format may be: &#39;d \\de F \\de Y&#39;
        return format.replace(slashRe, &#39;&#39;);
    },

<span id='Ext-Date-property-formatCodes'>    /**
</span>     * The base format-code to formatting-function hashmap used by the {@link #format} method.
     * Formatting functions are strings (or functions which return strings) which
     * will return the appropriate value when evaluated in the context of the Date object
     * from which the {@link #format} method is called.
     * Add to / override these mappings for custom date formatting.
     *
     * __Note:__ `Ext.Date.format()` treats characters as literals if an appropriate mapping cannot be found.
     *
     * Example:
     *
     *     Ext.Date.formatCodes.x = &quot;Ext.util.Format.leftPad(this.getDate(), 2, &#39;0&#39;)&quot;;
     *     console.log(Ext.Date.format(new Date(), &#39;X&#39;); // returns the current day of the month
     * @type Object
     */
    formatCodes : {
        d: &quot;Ext.String.leftPad(m.getDate(), 2, &#39;0&#39;)&quot;,
        D: &quot;Ext.Date.getShortDayName(m.getDay())&quot;, // get localized short day name
        j: &quot;m.getDate()&quot;,
        l: &quot;Ext.Date.dayNames[m.getDay()]&quot;,
        N: &quot;(m.getDay() ? m.getDay() : 7)&quot;,
        S: &quot;Ext.Date.getSuffix(m)&quot;,
        w: &quot;m.getDay()&quot;,
        z: &quot;Ext.Date.getDayOfYear(m)&quot;,
        W: &quot;Ext.String.leftPad(Ext.Date.getWeekOfYear(m), 2, &#39;0&#39;)&quot;,
        F: &quot;Ext.Date.monthNames[m.getMonth()]&quot;,
        m: &quot;Ext.String.leftPad(m.getMonth() + 1, 2, &#39;0&#39;)&quot;,
        M: &quot;Ext.Date.getShortMonthName(m.getMonth())&quot;, // get localized short month name
        n: &quot;(m.getMonth() + 1)&quot;,
        t: &quot;Ext.Date.getDaysInMonth(m)&quot;,
        L: &quot;(Ext.Date.isLeapYear(m) ? 1 : 0)&quot;,
        o: &quot;(m.getFullYear() + (Ext.Date.getWeekOfYear(m) == 1 &amp;&amp; m.getMonth() &gt; 0 ? +1 : (Ext.Date.getWeekOfYear(m) &gt;= 52 &amp;&amp; m.getMonth() &lt; 11 ? -1 : 0)))&quot;,
        Y: &quot;Ext.String.leftPad(m.getFullYear(), 4, &#39;0&#39;)&quot;,
        y: &quot;(&#39;&#39; + m.getFullYear()).substring(2, 4)&quot;,
        a: &quot;(m.getHours() &lt; 12 ? &#39;am&#39; : &#39;pm&#39;)&quot;,
        A: &quot;(m.getHours() &lt; 12 ? &#39;AM&#39; : &#39;PM&#39;)&quot;,
        g: &quot;((m.getHours() % 12) ? m.getHours() % 12 : 12)&quot;,
        G: &quot;m.getHours()&quot;,
        h: &quot;Ext.String.leftPad((m.getHours() % 12) ? m.getHours() % 12 : 12, 2, &#39;0&#39;)&quot;,
        H: &quot;Ext.String.leftPad(m.getHours(), 2, &#39;0&#39;)&quot;,
        i: &quot;Ext.String.leftPad(m.getMinutes(), 2, &#39;0&#39;)&quot;,
        s: &quot;Ext.String.leftPad(m.getSeconds(), 2, &#39;0&#39;)&quot;,
        u: &quot;Ext.String.leftPad(m.getMilliseconds(), 3, &#39;0&#39;)&quot;,
        O: &quot;Ext.Date.getGMTOffset(m)&quot;,
        P: &quot;Ext.Date.getGMTOffset(m, true)&quot;,
        T: &quot;Ext.Date.getTimezone(m)&quot;,
        Z: &quot;(m.getTimezoneOffset() * -60)&quot;,

        c: function() { // ISO-8601 -- GMT format
            var c = &quot;Y-m-dTH:i:sP&quot;, code = [], i, l = c.length, e;
            for (i = 0; i &lt; l; ++i) {
                e = c.charAt(i);
                code.push(e === &quot;T&quot; ? &quot;&#39;T&#39;&quot; : utilDate.getFormatCode(e)); // treat T as a character literal
            }
            return code.join(&quot; + &quot;);
        },

        C: function() { // ISO-1601 -- browser format. UTC numerics with the &#39;Z&#39; TZ id.
            return &#39;m.toISOString()&#39;;
        },

        U: &quot;Math.round(m.getTime() / 1000)&quot;
    },

<span id='Ext-Date-method-isValid'>    /**
</span>     * Checks if the passed Date parameters will cause a JavaScript Date &quot;rollover&quot;.
     * @param {Number} year 4-digit year.
     * @param {Number} month 1-based month-of-year.
     * @param {Number} day Day of month.
     * @param {Number} hour (optional) Hour.
     * @param {Number} minute (optional) Minute.
     * @param {Number} second (optional) Second.
     * @param {Number} millisecond (optional) Millisecond.
     * @return {Boolean} `true` if the passed parameters do not cause a Date &quot;rollover&quot;, `false` otherwise.
     */
    isValid : function(year, month, day, hour, minute, second, millisecond) {
        // setup defaults
        hour = hour || 0;
        minute = minute || 0;
        second = second || 0;
        millisecond = millisecond || 0;

        // Special handling for year &lt; 100
        var dt = utilDate.add(new nativeDate(year &lt; 100 ? 100 : year, month - 1, day, hour, minute, second, millisecond), utilDate.YEAR, year &lt; 100 ? year - 100 : 0);

        return year === dt.getFullYear() &amp;&amp;
            month === dt.getMonth() + 1 &amp;&amp;
            day === dt.getDate() &amp;&amp;
            hour === dt.getHours() &amp;&amp;
            minute === dt.getMinutes() &amp;&amp;
            second === dt.getSeconds() &amp;&amp;
            millisecond === dt.getMilliseconds();
    },

<span id='Ext-Date-method-parse'>    /**
</span>     * Parses the passed string using the specified date format.
     * Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
     * The {@link #defaults} hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
     * which cannot be found in the passed string. If a corresponding default date value has not been specified in the {@link #defaults} hash,
     * the current date&#39;s year, month, day or DST-adjusted zero-hour time value will be used instead.
     * Keep in mind that the input date string must precisely match the specified format string
     * in order for the parse operation to be successful (failed parse operations return a 
     * `null` value).
     * 
     * Example:
     *
     *     //dt = Fri May 25 2007 (current date)
     *     var dt = new Date();
     *     
     *     //dt = Thu May 25 2006 (today&amp;#39;s month/day in 2006)
     *     dt = Ext.Date.parse(&quot;2006&quot;, &quot;Y&quot;);
     *     
     *     //dt = Sun Jan 15 2006 (all date parts specified)
     *     dt = Ext.Date.parse(&quot;2006-01-15&quot;, &quot;Y-m-d&quot;);
     *     
     *     //dt = Sun Jan 15 2006 15:20:01
     *     dt = Ext.Date.parse(&quot;2006-01-15 3:20:01 PM&quot;, &quot;Y-m-d g:i:s A&quot;);
     *     
     *     // attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
     *     dt = Ext.Date.parse(&quot;2006-02-29 03:20:01&quot;, &quot;Y-m-d H:i:s&quot;, true); // returns null
     *
     * @param {String} input The raw date string.
     * @param {String} format The expected date string format.
     * @param {Boolean} [strict=false] (optional) `true` to validate date strings while parsing (i.e. prevents JavaScript Date &quot;rollover&quot;).
     * Invalid date strings will return `null` when parsed.
     * @return {Date/null} The parsed Date, or `null` if an invalid date string.
     */
    parse : function(input, format, strict) {
        var p = utilDate.parseFunctions;
        if (p[format] == null) {
            utilDate.createParser(format);
        }
        return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
    },

    // Backwards compat
    parseDate: function(input, format, strict){
        return utilDate.parse(input, format, strict);
    },


<span id='Ext-Date-method-getFormatCode'>    /**
</span>     * @private
     */
    getFormatCode : function(character) {
        var f = utilDate.formatCodes[character];

        if (f) {
          f = typeof f === &#39;function&#39;? f() : f;
          utilDate.formatCodes[character] = f; // reassign function result to prevent repeated execution
        }

        // note: unknown characters are treated as literals
        return f || (&quot;&#39;&quot; + Ext.String.escape(character) + &quot;&#39;&quot;);
    },

<span id='Ext-Date-method-createFormat'>    /**
</span>     * @private
     */
    createFormat : function(format) {
        var code = [],
            special = false,
            ch = &#39;&#39;,
            i;

        for (i = 0; i &lt; format.length; ++i) {
            ch = format.charAt(i);
            if (!special &amp;&amp; ch === &quot;\\&quot;) {
                special = true;
            } else if (special) {
                special = false;
                code.push(&quot;&#39;&quot; + Ext.String.escape(ch) + &quot;&#39;&quot;);
            } else {
                if (ch === &#39;\n&#39;) {
                    code.push(&quot;&#39;\\n&#39;&quot;);
                } else {
                    code.push(utilDate.getFormatCode(ch));
                }
            }
        }
        utilDate.formatFunctions[format] = Ext.functionFactory(&quot;var m=this;return &quot; + code.join(&#39;+&#39;));
    },

<span id='Ext-Date-method-createParser'>    /**
</span>     * @private
     */
    createParser : function(format) {
        var regexNum = utilDate.parseRegexes.length,
            currentGroup = 1,
            calc = [],
            regex = [],
            special = false,
            ch = &quot;&quot;,
            i = 0,
            len = format.length,
            atEnd = [],
            obj;

        for (; i &lt; len; ++i) {
            ch = format.charAt(i);
            if (!special &amp;&amp; ch === &quot;\\&quot;) {
                special = true;
            } else if (special) {
                special = false;
                regex.push(Ext.String.escape(ch));
            } else {
                obj = utilDate.formatCodeToRegex(ch, currentGroup);
                currentGroup += obj.g;
                regex.push(obj.s);
                if (obj.g &amp;&amp; obj.c) {
                    if (obj.calcAtEnd) {
                        atEnd.push(obj.c);
                    } else {
                        calc.push(obj.c);
                    }
                }
            }
        }

        calc = calc.concat(atEnd);

        utilDate.parseRegexes[regexNum] = new RegExp(&quot;^&quot; + regex.join(&#39;&#39;) + &quot;$&quot;, &#39;i&#39;);
        utilDate.parseFunctions[format] = Ext.functionFactory(&quot;input&quot;, &quot;strict&quot;, xf(code, regexNum, calc.join(&#39;&#39;)));
    },

<span id='Ext-Date-property-parseCodes'>    /**
</span>     * @private
     */
    parseCodes : {
<span id='Ext-Date-property-d'>        /**
</span>         * Notes:
         * g = {Number} calculation group (0 or 1. only group 1 contributes to date calculations.)
         * c = {String} calculation method (required for group 1. null for group 0. {0} = currentGroup - position in regex result array)
         * s = {String} regex pattern. all matches are stored in results[], and are accessible by the calculation mapped to &#39;c&#39;
         */
        d: {
            g:1,
            c:&quot;d = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(3[0-1]|[1-2][0-9]|0[1-9])&quot; // day of month with leading zeroes (01 - 31)
        },
        j: {
            g:1,
            c:&quot;d = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(3[0-1]|[1-2][0-9]|[1-9])&quot; // day of month without leading zeroes (1 - 31)
        },
        D: function() {
            for (var a = [], i = 0; i &lt; 7; a.push(utilDate.getShortDayName(i)), ++i); // get localised short day names
            return {
                g:0,
                c:null,
                s:&quot;(?:&quot; + a.join(&quot;|&quot;) +&quot;)&quot;
            };
        },
        l: function() {
            return {
                g:0,
                c:null,
                s:&quot;(?:&quot; + utilDate.dayNames.join(&quot;|&quot;) + &quot;)&quot;
            };
        },
        N: {
            g:0,
            c:null,
            s:&quot;[1-7]&quot; // ISO-8601 day number (1 (monday) - 7 (sunday))
        },
        //&lt;locale type=&quot;object&quot; property=&quot;parseCodes&quot;&gt;
        S: {
            g:0,
            c:null,
            s:&quot;(?:st|nd|rd|th)&quot;
        },
        //&lt;/locale&gt;
        w: {
            g:0,
            c:null,
            s:&quot;[0-6]&quot; // JavaScript day number (0 (sunday) - 6 (saturday))
        },
        z: {
            g:1,
            c:&quot;z = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(\\d{1,3})&quot; // day of the year (0 - 364 (365 in leap years))
        },
        W: {
            g:1,
            c:&quot;W = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(\\d{2})&quot; // ISO-8601 week number (with leading zero)
        },
        F: function() {
            return {
                g:1,
                c:&quot;m = parseInt(me.getMonthNumber(results[{0}]), 10);\n&quot;, // get localised month number
                s:&quot;(&quot; + utilDate.monthNames.join(&quot;|&quot;) + &quot;)&quot;
            };
        },
        M: function() {
            for (var a = [], i = 0; i &lt; 12; a.push(utilDate.getShortMonthName(i)), ++i); // get localised short month names
            return Ext.applyIf({
                s:&quot;(&quot; + a.join(&quot;|&quot;) + &quot;)&quot;
            }, utilDate.formatCodeToRegex(&quot;F&quot;));
        },
        m: {
            g:1,
            c:&quot;m = parseInt(results[{0}], 10) - 1;\n&quot;,
            s:&quot;(1[0-2]|0[1-9])&quot; // month number with leading zeros (01 - 12)
        },
        n: {
            g:1,
            c:&quot;m = parseInt(results[{0}], 10) - 1;\n&quot;,
            s:&quot;(1[0-2]|[1-9])&quot; // month number without leading zeros (1 - 12)
        },
        t: {
            g:0,
            c:null,
            s:&quot;(?:\\d{2})&quot; // no. of days in the month (28 - 31)
        },
        L: {
            g:0,
            c:null,
            s:&quot;(?:1|0)&quot;
        },
        o: {
            g: 1,
            c: &quot;y = parseInt(results[{0}], 10);\n&quot;,
            s: &quot;(\\d{4})&quot; // ISO-8601 year number (with leading zero)

        },
        Y: {
            g:1,
            c:&quot;y = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(\\d{4})&quot; // 4-digit year
        },
        y: {
            g:1,
            c:&quot;var ty = parseInt(results[{0}], 10);\n&quot;
                + &quot;y = ty &gt; me.y2kYear ? 1900 + ty : 2000 + ty;\n&quot;, // 2-digit year
            s:&quot;(\\d{2})&quot;
        },
<span id='Ext-Date-property-'>        /**
</span>         * In the am/pm parsing routines, we allow both upper and lower case
         * even though it doesn&#39;t exactly match the spec. It gives much more flexibility
         * in being able to specify case insensitive regexes.
         */
        //&lt;locale type=&quot;object&quot; property=&quot;parseCodes&quot;&gt;
        a: {
            g:1,
            c:&quot;if (/(am)/i.test(results[{0}])) {\n&quot;
                + &quot;if (!h || h == 12) { h = 0; }\n&quot;
                + &quot;} else { if (!h || h &lt; 12) { h = (h || 0) + 12; }}&quot;,
            s:&quot;(am|pm|AM|PM)&quot;,
            calcAtEnd: true
        },
        //&lt;/locale&gt;
        //&lt;locale type=&quot;object&quot; property=&quot;parseCodes&quot;&gt;
        A: {
            g:1,
            c:&quot;if (/(am)/i.test(results[{0}])) {\n&quot;
                + &quot;if (!h || h == 12) { h = 0; }\n&quot;
                + &quot;} else { if (!h || h &lt; 12) { h = (h || 0) + 12; }}&quot;,
            s:&quot;(AM|PM|am|pm)&quot;,
            calcAtEnd: true
        },
        //&lt;/locale&gt;
        g: {
            g:1,
            c:&quot;h = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(1[0-2]|[0-9])&quot; //  12-hr format of an hour without leading zeroes (1 - 12)
        },
        G: {
            g:1,
            c:&quot;h = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(2[0-3]|1[0-9]|[0-9])&quot; // 24-hr format of an hour without leading zeroes (0 - 23)
        },
        h: {
            g:1,
            c:&quot;h = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(1[0-2]|0[1-9])&quot; //  12-hr format of an hour with leading zeroes (01 - 12)
        },
        H: {
            g:1,
            c:&quot;h = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(2[0-3]|[0-1][0-9])&quot; //  24-hr format of an hour with leading zeroes (00 - 23)
        },
        i: {
            g:1,
            c:&quot;i = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;([0-5][0-9])&quot; // minutes with leading zeros (00 - 59)
        },
        s: {
            g:1,
            c:&quot;s = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;([0-5][0-9])&quot; // seconds with leading zeros (00 - 59)
        },
        u: {
            g:1,
            c:&quot;ms = results[{0}]; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n&quot;,
            s:&quot;(\\d+)&quot; // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
        },
        O: {
            g:1,
            c:[
                &quot;o = results[{0}];&quot;,
                &quot;var sn = o.substring(0,1),&quot;, // get + / - sign
                    &quot;hr = o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),&quot;, // get hours (performs minutes-to-hour conversion also, just in case)
                    &quot;mn = o.substring(3,5) % 60;&quot;, // get minutes
                &quot;o = ((-12 &lt;= (hr*60 + mn)/60) &amp;&amp; ((hr*60 + mn)/60 &lt;= 14))? (sn + Ext.String.leftPad(hr, 2, &#39;0&#39;) + Ext.String.leftPad(mn, 2, &#39;0&#39;)) : null;\n&quot; // -12hrs &lt;= GMT offset &lt;= 14hrs
            ].join(&quot;\n&quot;),
            s: &quot;([+-]\\d{4})&quot; // GMT offset in hrs and mins
        },
        P: {
            g:1,
            c:[
                &quot;o = results[{0}];&quot;,
                &quot;var sn = o.substring(0,1),&quot;, // get + / - sign
                    &quot;hr = o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),&quot;, // get hours (performs minutes-to-hour conversion also, just in case)
                    &quot;mn = o.substring(4,6) % 60;&quot;, // get minutes
                &quot;o = ((-12 &lt;= (hr*60 + mn)/60) &amp;&amp; ((hr*60 + mn)/60 &lt;= 14))? (sn + Ext.String.leftPad(hr, 2, &#39;0&#39;) + Ext.String.leftPad(mn, 2, &#39;0&#39;)) : null;\n&quot; // -12hrs &lt;= GMT offset &lt;= 14hrs
            ].join(&quot;\n&quot;),
            s: &quot;([+-]\\d{2}:\\d{2})&quot; // GMT offset in hrs and mins (with colon separator)
        },
        T: {
            g:0,
            c:null,
            s:&quot;[A-Z]{1,5}&quot; // timezone abbrev. may be between 1 - 5 chars
        },
        Z: {
            g:1,
            c:&quot;zz = results[{0}] * 1;\n&quot; // -43200 &lt;= UTC offset &lt;= 50400
                  + &quot;zz = (-43200 &lt;= zz &amp;&amp; zz &lt;= 50400)? zz : null;\n&quot;,
            s:&quot;([+-]?\\d{1,5})&quot; // leading &#39;+&#39; sign is optional for UTC offset
        },
        c: function() {
            var calc = [],
                arr = [
                    utilDate.formatCodeToRegex(&quot;Y&quot;, 1), // year
                    utilDate.formatCodeToRegex(&quot;m&quot;, 2), // month
                    utilDate.formatCodeToRegex(&quot;d&quot;, 3), // day
                    utilDate.formatCodeToRegex(&quot;H&quot;, 4), // hour
                    utilDate.formatCodeToRegex(&quot;i&quot;, 5), // minute
                    utilDate.formatCodeToRegex(&quot;s&quot;, 6), // second
                    {c:&quot;ms = results[7] || &#39;0&#39;; ms = parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n&quot;}, // decimal fraction of a second (minimum = 1 digit, maximum = unlimited)
                    {c:[ // allow either &quot;Z&quot; (i.e. UTC) or &quot;-0530&quot; or &quot;+08:00&quot; (i.e. UTC offset) timezone delimiters. assumes local timezone if no timezone is specified
                        &quot;if(results[8]) {&quot;, // timezone specified
                            &quot;if(results[8] == &#39;Z&#39;){&quot;,
                                &quot;zz = 0;&quot;, // UTC
                            &quot;}else if (results[8].indexOf(&#39;:&#39;) &gt; -1){&quot;,
                                utilDate.formatCodeToRegex(&quot;P&quot;, 8).c, // timezone offset with colon separator
                            &quot;}else{&quot;,
                                utilDate.formatCodeToRegex(&quot;O&quot;, 8).c, // timezone offset without colon separator
                            &quot;}&quot;,
                        &quot;}&quot;
                    ].join(&#39;\n&#39;)}
                ],
                i,
                l;

            for (i = 0, l = arr.length; i &lt; l; ++i) {
                calc.push(arr[i].c);
            }

            return {
                g:1,
                c:calc.join(&quot;&quot;),
                s:[
                    arr[0].s, // year (required)
                    &quot;(?:&quot;, &quot;-&quot;, arr[1].s, // month (optional)
                        &quot;(?:&quot;, &quot;-&quot;, arr[2].s, // day (optional)
                            &quot;(?:&quot;,
                                &quot;(?:T| )?&quot;, // time delimiter -- either a &quot;T&quot; or a single blank space
                                arr[3].s, &quot;:&quot;, arr[4].s,  // hour AND minute, delimited by a single colon (optional). MUST be preceded by either a &quot;T&quot; or a single blank space
                                &quot;(?::&quot;, arr[5].s, &quot;)?&quot;, // seconds (optional)
                                &quot;(?:(?:\\.|,)(\\d+))?&quot;, // decimal fraction of a second (e.g. &quot;,12345&quot; or &quot;.98765&quot;) (optional)
                                &quot;(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?&quot;, // &quot;Z&quot; (UTC) or &quot;-0530&quot; (UTC offset without colon delimiter) or &quot;+08:00&quot; (UTC offset with colon delimiter) (optional)
                            &quot;)?&quot;,
                        &quot;)?&quot;,
                    &quot;)?&quot;
                ].join(&quot;&quot;)
            };
        },
        U: {
            g:1,
            c:&quot;u = parseInt(results[{0}], 10);\n&quot;,
            s:&quot;(-?\\d+)&quot; // leading minus sign indicates seconds before UNIX epoch
        }
    },

    //Old Ext.Date prototype methods.
<span id='Ext-Date-method-dateFormat'>    /**
</span>     * @private
     */
    dateFormat: function(date, format) {
        return utilDate.format(date, format);
    },

<span id='Ext-Date-method-isEqual'>    /**
</span>     * Compares if two dates are equal by comparing their values.
     * @param {Date} date1
     * @param {Date} date2
     * @return {Boolean} `true` if the date values are equal
     */
    isEqual: function(date1, date2) {
        // check we have 2 date objects
        if (date1 &amp;&amp; date2) {
            return (date1.getTime() === date2.getTime());
        }
        // one or both isn&#39;t a date, only equal if both are falsey
        return !(date1 || date2);
    },

<span id='Ext-Date-method-format'>    /**
</span>     * Formats a date given the supplied format string.
     * @param {Date} date The date to format
     * @param {String} format The format string
     * @return {String} The formatted date or an empty string if date parameter is not a JavaScript Date object
     */
    format: function(date, format) {
        var formatFunctions = utilDate.formatFunctions;

        if (!Ext.isDate(date)) {
            return &#39;&#39;;
        }

        if (formatFunctions[format] == null) {
            utilDate.createFormat(format);
        }

        return formatFunctions[format].call(date) + &#39;&#39;;
    },

<span id='Ext-Date-method-getTimezone'>    /**
</span>     * Get the timezone abbreviation of the current date (equivalent to the format specifier &#39;T&#39;).
     *
     * __Note:__ The date string returned by the JavaScript Date object&#39;s `toString()` method varies
     * between browsers (e.g. FF vs IE) and system region settings (e.g. IE in Asia vs IE in America).
     * For a given date string e.g. &quot;Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)&quot;,
     * `getTimezone()` first tries to get the timezone abbreviation from between a pair of parentheses
     * (which may or may not be present), failing which it proceeds to get the timezone abbreviation
     * from the GMT offset portion of the date string.
     * 
     *     @example
     *     var dt = new Date(&#39;9/17/2011&#39;);
     *     console.log(Ext.Date.getTimezone(dt));
     *
     * @param {Date} date The date
     * @return {String} The abbreviated timezone name (e.g. &#39;CST&#39;, &#39;PDT&#39;, &#39;EDT&#39;, &#39;MPST&#39; ...).
     */
    getTimezone : function(date) {
        // the following list shows the differences between date strings from different browsers on a WinXP SP2 machine from an Asian locale:
        //
        // Opera  : &quot;Thu, 25 Oct 2007 22:53:45 GMT+0800&quot; -- shortest (weirdest) date string of the lot
        // Safari : &quot;Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)&quot; -- value in parentheses always gives the correct timezone (same as FF)
        // FF     : &quot;Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)&quot; -- value in parentheses always gives the correct timezone
        // IE     : &quot;Thu Oct 25 22:54:35 UTC+0800 2007&quot; -- (Asian system setting) look for 3-4 letter timezone abbrev
        // IE     : &quot;Thu Oct 25 17:06:37 PDT 2007&quot; -- (American system setting) look for 3-4 letter timezone abbrev
        //
        // this crazy regex attempts to guess the correct timezone abbreviation despite these differences.
        // step 1: (?:\((.*)\) -- find timezone in parentheses
        // step 2: ([A-Z]{1,4})(?:[\-+][0-9]{4})?(?: -?\d+)?) -- if nothing was found in step 1, find timezone from timezone offset portion of date string
        // step 3: remove all non uppercase characters found in step 1 and 2
        return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, &quot;$1$2&quot;).replace(/[^A-Z]/g, &quot;&quot;);
    },

<span id='Ext-Date-method-getGMTOffset'>    /**
</span>     * Get the offset from GMT of the current date (equivalent to the format specifier &#39;O&#39;).
     * 
     *     @example
     *     var dt = new Date(&#39;9/17/2011&#39;);
     *     console.log(Ext.Date.getGMTOffset(dt));
     *
     * @param {Date} date The date
     * @param {Boolean} [colon=false] `true` to separate the hours and minutes with a colon.
     * @return {String} The 4-character offset string prefixed with + or - (e.g. &#39;-0600&#39;).
     */
    getGMTOffset : function(date, colon) {
        var offset = date.getTimezoneOffset();
        return (offset &gt; 0 ? &quot;-&quot; : &quot;+&quot;)
            + Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, &quot;0&quot;)
            + (colon ? &quot;:&quot; : &quot;&quot;)
            + Ext.String.leftPad(Math.abs(offset % 60), 2, &quot;0&quot;);
    },

<span id='Ext-Date-method-getDayOfYear'>    /**
</span>     * Get the numeric day number of the year, adjusted for leap year.
     * 
     *     @example
     *     var dt = new Date(&#39;9/17/2011&#39;);
     *     console.log(Ext.Date.getDayOfYear(dt)); // 259
     *
     * @param {Date} date The date
     * @return {Number} 0 to 364 (365 in leap years).
     */
    getDayOfYear: function(date) {
        var num = 0,
            d = utilDate.clone(date),
            m = date.getMonth(),
            i;

        for (i = 0, d.setDate(1), d.setMonth(0); i &lt; m; d.setMonth(++i)) {
            num += utilDate.getDaysInMonth(d);
        }
        return num + date.getDate() - 1;
    },

<span id='Ext-Date-method-getWeekOfYear'>    /**
</span>     * Get the numeric ISO-8601 week number of the year.
     * (equivalent to the format specifier &#39;W&#39;, but without a leading zero).
     * 
     *     @example
     *     var dt = new Date(&#39;9/17/2011&#39;);
     *     console.log(Ext.Date.getWeekOfYear(dt)); // 37
     *
     * @param {Date} date The date.
     * @return {Number} 1 to 53.
     * @method
     */
    getWeekOfYear : (function() {
        // adapted from http://www.merlyn.demon.co.uk/weekcalc.htm
        var ms1d = 864e5, // milliseconds in a day
            ms7d = 7 * ms1d; // milliseconds in a week

        return function(date) { // return a closure so constants get calculated only once
            var DC3 = nativeDate.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, // an Absolute Day Number
                AWN = Math.floor(DC3 / 7), // an Absolute Week Number
                Wyr = new nativeDate(AWN * ms7d).getUTCFullYear();

            return AWN - Math.floor(nativeDate.UTC(Wyr, 0, 7) / ms7d) + 1;
        };
    }()),

<span id='Ext-Date-method-isLeapYear'>    /**
</span>     * Checks if the current date falls within a leap year.
     * 
     *     @example
     *     var dt = new Date(&#39;1/10/2011&#39;);
     *     console.log(Ext.Date.isLeapYear(dt)); // false
     *
     * @param {Date} date The date
     * @return {Boolean} `true` if the current date falls within a leap year, `false` otherwise.
     */
    isLeapYear : function(date) {
        var year = date.getFullYear();
        return !!((year &amp; 3) === 0 &amp;&amp; (year % 100 || (year % 400 === 0 &amp;&amp; year)));
    },

<span id='Ext-Date-method-getFirstDayOfMonth'>    /**
</span>     * Get the first day of the current month, adjusted for leap year.  The returned value
     * is the numeric day index within the week (0-6) which can be used in conjunction with
     * the {@link #monthNames} array to retrieve the textual day name.
     *
     *    @example
     *    var dt = new Date(&#39;1/10/2007&#39;),
     *        firstDay = Ext.Date.getFirstDayOfMonth(dt);
     *
     *    console.log(Ext.Date.dayNames[firstDay]); // output: &#39;Monday&#39;
     *
     * @param {Date} date The date
     * @return {Number} The day number (0-6).
     */
    getFirstDayOfMonth : function(date) {
        var day = (date.getDay() - (date.getDate() - 1)) % 7;
        return (day &lt; 0) ? (day + 7) : day;
    },

<span id='Ext-Date-method-getLastDayOfMonth'>    /**
</span>     * Get the last day of the current month, adjusted for leap year.  The returned value
     * is the numeric day index within the week (0-6) which can be used in conjunction with
     * the {@link #monthNames} array to retrieve the textual day name.
     *
     *    @example
     *    var dt = new Date(&#39;1/10/2007&#39;),
     *        lastDay = Ext.Date.getLastDayOfMonth(dt);
     *
     *    console.log(Ext.Date.dayNames[lastDay]); // output: &#39;Wednesday&#39;
     *
     * @param {Date} date The date
     * @return {Number} The day number (0-6).
     */
    getLastDayOfMonth : function(date) {
        return utilDate.getLastDateOfMonth(date).getDay();
    },


<span id='Ext-Date-method-getFirstDateOfMonth'>    /**
</span>     * Get the date of the first day of the month in which this date resides.
     * @param {Date} date The date
     * @return {Date}
     */
    getFirstDateOfMonth : function(date) {
        return new nativeDate(date.getFullYear(), date.getMonth(), 1);
    },

<span id='Ext-Date-method-getLastDateOfMonth'>    /**
</span>     * Get the date of the last day of the month in which this date resides.
     * @param {Date} date The date
     * @return {Date}
     */
    getLastDateOfMonth : function(date) {
        return new nativeDate(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
    },

<span id='Ext-Date-method-getDaysInMonth'>    /**
</span>     * Get the number of days in the current month, adjusted for leap year.
     * @param {Date} date The date
     * @return {Number} The number of days in the month.
     * @method
     */
    getDaysInMonth: (function() {
        var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

        return function(date) { // return a closure for efficiency
            var m = date.getMonth();

            return m === 1 &amp;&amp; utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
        };
    }()),

    //&lt;locale type=&quot;function&quot;&gt;
<span id='Ext-Date-method-getSuffix'>    /**
</span>     * Get the English ordinal suffix of the current day (equivalent to the format specifier &#39;S&#39;).
     * @param {Date} date The date
     * @return {String} &#39;st, &#39;nd&#39;, &#39;rd&#39; or &#39;th&#39;.
     */
    getSuffix : function(date) {
        switch (date.getDate()) {
            case 1:
            case 21:
            case 31:
                return &quot;st&quot;;
            case 2:
            case 22:
                return &quot;nd&quot;;
            case 3:
            case 23:
                return &quot;rd&quot;;
            default:
                return &quot;th&quot;;
        }
    },
    //&lt;/locale&gt;

<span id='Ext-Date-method-clone'>    /**
</span>     * Creates and returns a new Date instance with the exact same date value as the called instance.
     * Dates are copied and passed by reference, so if a copied date variable is modified later, the original
     * variable will also be changed.  When the intention is to create a new variable that will not
     * modify the original instance, you should create a clone.
     *
     * Example of correctly cloning a date:
     *
     *     //wrong way:
     *     var orig = new Date(&#39;10/1/2006&#39;);
     *     var copy = orig;
     *     copy.setDate(5);
     *     console.log(orig);  // returns &#39;Thu Oct 05 2006&#39;!
     *
     *     //correct way:
     *     var orig = new Date(&#39;10/1/2006&#39;),
     *         copy = Ext.Date.clone(orig);
     *     copy.setDate(5);
     *     console.log(orig);  // returns &#39;Thu Oct 01 2006&#39;
     *
     * @param {Date} date The date.
     * @return {Date} The new Date instance.
     */
    clone : function(date) {
        return new nativeDate(date.getTime());
    },

<span id='Ext-Date-method-isDST'>    /**
</span>     * Checks if the current date is affected by Daylight Saving Time (DST).
     * @param {Date} date The date
     * @return {Boolean} `true` if the current date is affected by DST.
     */
    isDST : function(date) {
        // adapted from http://sencha.com/forum/showthread.php?p=247172#post247172
        // courtesy of @geoffrey.mcgill
        return new nativeDate(date.getFullYear(), 0, 1).getTimezoneOffset() !== date.getTimezoneOffset();
    },

<span id='Ext-Date-method-clearTime'>    /**
</span>     * Attempts to clear all time information from this Date by setting the time to midnight of the same day,
     * automatically adjusting for Daylight Saving Time (DST) where applicable.
     *
     * __Note:__ DST timezone information for the browser&#39;s host operating system is assumed to be up-to-date.
     * @param {Date} date The date
     * @param {Boolean} [clone=false] `true` to create a clone of this date, clear the time and return it.
     * @return {Date} this or the clone.
     */
    clearTime : function(date, clone) {
        // handles invalid dates preventing the browser from crashing.
        if (isNaN(date.getTime())) { 
            return date;
        }

        if (clone) {
            return utilDate.clearTime(utilDate.clone(date));
        }

        // get current date before clearing time
        var d = date.getDate(),
            hr,
            c;

        // clear time
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);

        if (date.getDate() !== d) { // account for DST (i.e. day of month changed when setting hour = 0)
            // note: DST adjustments are assumed to occur in multiples of 1 hour (this is almost always the case)
            // refer to http://www.timeanddate.com/time/aboutdst.html for the (rare) exceptions to this rule

            // increment hour until cloned date == current date
            for (hr = 1, c = utilDate.add(date, utilDate.HOUR, hr); c.getDate() !== d; hr++, c = utilDate.add(date, utilDate.HOUR, hr));

            date.setDate(d);
            date.setHours(c.getHours());
        }

        return date;
    },

<span id='Ext-Date-method-add'>    /**
</span>     * Provides a convenient method for performing basic date arithmetic. This method
     * does not modify the Date instance being called - it creates and returns
     * a new Date instance containing the resulting date value.
     *
     * Examples:
     *
     *     // Basic usage:
     *     var dt = Ext.Date.add(new Date(&#39;10/29/2006&#39;), Ext.Date.DAY, 5);
     *     console.log(dt); // returns &#39;Fri Nov 03 2006 00:00:00&#39;
     *
     *     // Negative values will be subtracted:
     *     var dt2 = Ext.Date.add(new Date(&#39;10/1/2006&#39;), Ext.Date.DAY, -5);
     *     console.log(dt2); // returns &#39;Tue Sep 26 2006 00:00:00&#39;
     *
     *      // Decimal values can be used:
     *     var dt3 = Ext.Date.add(new Date(&#39;10/1/2006&#39;), Ext.Date.DAY, 1.25);
     *     console.log(dt3); // returns &#39;Mon Oct 02 2006 06:00:00&#39;
     *
     * @param {Date} date The date to modify
     * @param {String} interval A valid date interval enum value.
     * @param {Number} value The amount to add to the current date.
     * @return {Date} The new Date instance.
     */
    add : function(date, interval, value) {
        var d = utilDate.clone(date),
            base = 0,
            day, decimalValue;

        if (!interval || value === 0) {
            return d;
        }

        decimalValue = value - parseInt(value, 10);
        value = parseInt(value, 10);

        if (value) {
            switch(interval.toLowerCase()) {
                // See EXTJSIV-7418. We use setTime() here to deal with issues related to
                // the switchover that occurs when changing to daylight savings and vice
                // versa. setTime() handles this correctly where setHour/Minute/Second/Millisecond
                // do not. Let&#39;s assume the DST change occurs at 2am and we&#39;re incrementing using add
                // for 15 minutes at time. When entering DST, we should see:
                // 01:30am
                // 01:45am
                // 03:00am // skip 2am because the hour does not exist
                // ...
                // Similarly, leaving DST, we should see:
                // 01:30am
                // 01:45am
                // 01:00am // repeat 1am because that&#39;s the change over
                // 01:30am
                // 01:45am
                // 02:00am
                // ....
                // 
                case utilDate.MILLI:
                    d.setTime(d.getTime() + value);
                    break;
                case utilDate.SECOND:
                    d.setTime(d.getTime() + value * 1000);
                    break;
                case utilDate.MINUTE:
                    d.setTime(d.getTime() + value * 60 * 1000);
                    break;
                case utilDate.HOUR:
                    d.setTime(d.getTime() + value * 60 * 60 * 1000);
                    break;
                case utilDate.DAY:
                    d.setTime(d.getTime() + value * 24 * 60 * 60 * 1000);
                    break;
                case utilDate.MONTH:
                    day = date.getDate();
                    if (day &gt; 28) {
                        day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.MONTH, value)).getDate());
                    }
                    d.setDate(day);
                    d.setMonth(date.getMonth() + value);
                    break;
                case utilDate.YEAR:
                    day = date.getDate();
                    if (day &gt; 28) {
                        day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.YEAR, value)).getDate());
                    }
                    d.setDate(day);
                    d.setFullYear(date.getFullYear() + value);
                    break;
            }
        }

        if (decimalValue) {
            switch (interval.toLowerCase()) {
                case utilDate.MILLI:    base = 1;               break;
                case utilDate.SECOND:   base = 1000;            break;
                case utilDate.MINUTE:   base = 1000*60;         break;
                case utilDate.HOUR:     base = 1000*60*60;      break;
                case utilDate.DAY:      base = 1000*60*60*24;   break;

                case utilDate.MONTH:
                    day = utilDate.getDaysInMonth(d);
                    base = 1000*60*60*24*day;
                    break;

                case utilDate.YEAR:
                    day = (utilDate.isLeapYear(d) ? 366 : 365);
                    base = 1000*60*60*24*day;
                    break;
            }
            if (base) {
                d.setTime(d.getTime() + base * decimalValue); 
            }
        }

        return d;
    },
    
<span id='Ext-Date-method-subtract'>    /**
</span>     * Provides a convenient method for performing basic date arithmetic. This method
     * does not modify the Date instance being called - it creates and returns
     * a new Date instance containing the resulting date value.
     * 
     * Examples:
     *
     *     // Basic usage:
     *     var dt = Ext.Date.subtract(new Date(&#39;10/29/2006&#39;), Ext.Date.DAY, 5);
     *     console.log(dt); // returns &#39;Tue Oct 24 2006 00:00:00&#39;
     *
     *     // Negative values will be added:
     *     var dt2 = Ext.Date.subtract(new Date(&#39;10/1/2006&#39;), Ext.Date.DAY, -5);
     *     console.log(dt2); // returns &#39;Fri Oct 6 2006 00:00:00&#39;
     *
     *      // Decimal values can be used:
     *     var dt3 = Ext.Date.subtract(new Date(&#39;10/1/2006&#39;), Ext.Date.DAY, 1.25);
     *     console.log(dt3); // returns &#39;Fri Sep 29 2006 06:00:00&#39;
     * 
     * @param {Date} date The date to modify
     * @param {String} interval A valid date interval enum value.
     * @param {Number} value The amount to subtract from the current date.
     * @return {Date} The new Date instance.
     */
    subtract: function(date, interval, value){
        return utilDate.add(date, interval, -value);
    },

<span id='Ext-Date-method-between'>    /**
</span>     * Checks if a date falls on or between the given start and end dates.
     * @param {Date} date The date to check
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} `true` if this date falls on or between the given start and end dates.
     */
    between : function(date, start, end) {
        var t = date.getTime();
        return start.getTime() &lt;= t &amp;&amp; t &lt;= end.getTime();
    },

<span id='Ext-Date-method-isWeekend'>    /**
</span>     * Checks if the date is a weekend day. Uses {@link #weekendDays}.
     * @param {Date} date The date.
     * @return {Boolean} `true` if the day falls on a weekend.
     *
     * @since 6.2.0
     */
    isWeekend: function(date) {
        return Ext.Array.indexOf(this.weekendDays, date.getDay()) &gt; -1;
    },

<span id='Ext-Date-method-utcToLocal'>    /**
</span>     * Converts the passed UTC date into a local date.
     * For example, if the passed date is:
     * `Wed Jun 01 2016 00:10:00 GMT+1000 (AUS Eastern Standard Time)`, then
     * the returned date will be `Wed Jun 01 2016 00:00:00 GMT+1000 (AUS Eastern Standard Time)`.
     * @param {Date} d The date to convert.
     * @return {Date} The date as a local. Does not modify the passed date.
     *
     * @since 6.2.0
     */
    utcToLocal: function(d) {
        return new Date(
            d.getUTCFullYear(), 
            d.getUTCMonth(), 
            d.getUTCDate(),  
            d.getUTCHours(), 
            d.getUTCMinutes(), 
            d.getUTCSeconds(),
            d.getUTCMilliseconds()
        );
    },

<span id='Ext-Date-method-localToUtc'>    /**
</span>     * Converts the passed local date into a UTC date.
     * For example, if the passed date is:
     * `Wed Jun 01 2016 00:00:00 GMT+1000 (AUS Eastern Standard Time)`, then
     * the returned date will be `Wed Jun 01 2016 10:00:00 GMT+1000 (AUS Eastern Standard Time)`.
     * @param {Date} d The date to convert.
     * @return {Date} The date as UTC. Does not modify the passed date.
     * 
     * @since 6.2.0
     */
    localToUtc: function(d) {
        return utilDate.utc(
            d.getFullYear(),
            d.getMonth(),
            d.getDate(),
            d.getHours(),
            d.getMinutes(),
            d.getSeconds(),
            d.getMilliseconds()
        );
    },

<span id='Ext-Date-method-utc'>    /**
</span>     * Create a UTC date.
     * @param {Number} year The year.
     * @param {Number} month The month.
     * @param {Number} day The day.
     * @param {Number} [hour=0] The hour.
     * @param {Number} [min=0] The minutes.
     * @param {Number} [s=0] The seconds.
     * @param {Number} [ms=0] The milliseconds.
     * @return {Date} The UTC date.
     *
     * @since 6.2.0
     */
    utc: function(year, month, day, hour, min, s, ms) {
        return new Date(Date.UTC(year, month, day, hour || 0, min || 0, s || 0, ms || 0));
    },

    //Maintains compatibility with old static and prototype window.Date methods.
    compat: function() {
        var p,
            statics = [&#39;useStrict&#39;, &#39;formatCodeToRegex&#39;, &#39;parseFunctions&#39;, &#39;parseRegexes&#39;, &#39;formatFunctions&#39;, &#39;y2kYear&#39;, &#39;MILLI&#39;, &#39;SECOND&#39;, &#39;MINUTE&#39;, &#39;HOUR&#39;, &#39;DAY&#39;, &#39;MONTH&#39;, &#39;YEAR&#39;, &#39;defaults&#39;, &#39;dayNames&#39;, &#39;monthNames&#39;, &#39;monthNumbers&#39;, &#39;getShortMonthName&#39;, &#39;getShortDayName&#39;, &#39;getMonthNumber&#39;, &#39;formatCodes&#39;, &#39;isValid&#39;, &#39;parseDate&#39;, &#39;getFormatCode&#39;, &#39;createFormat&#39;, &#39;createParser&#39;, &#39;parseCodes&#39;],
            proto = [&#39;dateFormat&#39;, &#39;format&#39;, &#39;getTimezone&#39;, &#39;getGMTOffset&#39;, &#39;getDayOfYear&#39;, &#39;getWeekOfYear&#39;, &#39;isLeapYear&#39;, &#39;getFirstDayOfMonth&#39;, &#39;getLastDayOfMonth&#39;, &#39;getDaysInMonth&#39;, &#39;getSuffix&#39;, &#39;clone&#39;, &#39;isDST&#39;, &#39;clearTime&#39;, &#39;add&#39;, &#39;between&#39;],
            sLen    = statics.length,
            pLen    = proto.length,
            stat, prot, s;

        //Append statics
        for (s = 0; s &lt; sLen; s++) {
            stat = statics[s];
            nativeDate[stat] = utilDate[stat];
        }

        //Append to prototype
        for (p = 0; p &lt; pLen; p++) {
            prot = proto[p];
            nativeDate.prototype[prot] = function() {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(this);
                return utilDate[prot].apply(utilDate, args);
            };
        }
    },

<span id='Ext-Date-method-diff'>    /**
</span>     * Calculate how many units are there between two time.
     * @param {Date} min The first time.
     * @param {Date} max The second time.
     * @param {String} unit The unit. This unit is compatible with the date interval constants.
     * @return {Number} The maximum number n of units that min + n * unit &lt;= max.
     */
    diff: function (min, max, unit) {
        var est, diff = +max - min;
        switch (unit) {
            case utilDate.MILLI:
                return diff;
            case utilDate.SECOND:
                return Math.floor(diff / 1000);
            case utilDate.MINUTE:
                return Math.floor(diff / 60000);
            case utilDate.HOUR:
                return Math.floor(diff / 3600000);
            case utilDate.DAY:
                return Math.floor(diff / 86400000);
            case &#39;w&#39;:
                return Math.floor(diff / 604800000);
            case utilDate.MONTH:
                est = (max.getFullYear() * 12 + max.getMonth()) - (min.getFullYear() * 12 + min.getMonth());
                if (utilDate.add(min, unit, est) &gt; max) {
                    return est - 1;
                }
                return est;
            case utilDate.YEAR:
                est = max.getFullYear() - min.getFullYear();
                if (utilDate.add(min, unit, est) &gt; max) {
                    return est - 1;
                } else {
                    return est;
                }
        }
    },

<span id='Ext-Date-method-align'>    /**
</span>     * Align the date to `unit`.
     * @param {Date} date The date to be aligned.
     * @param {String} unit The unit. This unit is compatible with the date interval constants.
     * @param {Number} step
     * @return {Date} The aligned date.
     */
    align: function (date, unit, step) {
        var num = new nativeDate(+date);

        switch (unit.toLowerCase()) {
            case utilDate.MILLI:
                return num;
            case utilDate.SECOND:
                num.setUTCSeconds(num.getUTCSeconds() - num.getUTCSeconds() % step);
                num.setUTCMilliseconds(0);
                return num;
            case utilDate.MINUTE:
                num.setUTCMinutes(num.getUTCMinutes() - num.getUTCMinutes() % step);
                num.setUTCSeconds(0);
                num.setUTCMilliseconds(0);
                return num;
            case utilDate.HOUR:
                num.setUTCHours(num.getUTCHours() - num.getUTCHours() % step);
                num.setUTCMinutes(0);
                num.setUTCSeconds(0);
                num.setUTCMilliseconds(0);
                return num;
            case utilDate.DAY:
                if (step === 7 || step === 14){
                    num.setUTCDate(num.getUTCDate() - num.getUTCDay() + 1);
                }
                num.setUTCHours(0);
                num.setUTCMinutes(0);
                num.setUTCSeconds(0);
                num.setUTCMilliseconds(0);
                return num;
            case utilDate.MONTH:
                num.setUTCMonth(num.getUTCMonth() - (num.getUTCMonth() - 1) % step,1);
                num.setUTCHours(0);
                num.setUTCMinutes(0);
                num.setUTCSeconds(0);
                num.setUTCMilliseconds(0);
                return num;
            case utilDate.YEAR:
                num.setUTCFullYear(num.getUTCFullYear() - num.getUTCFullYear() % step, 1, 1);
                num.setUTCHours(0);
                num.setUTCMinutes(0);
                num.setUTCSeconds(0);
                num.setUTCMilliseconds(0);
                return date;
        }
    }
};

utilDate.parseCodes.C = utilDate.parseCodes.c;

return utilDate;
}());
</pre>
</body>
</html>
