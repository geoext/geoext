<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-data-request-Ajax'>/**
</span> * This class manages a pending Ajax request. Instances of this type are created by the
 * `{@link Ext.data.Connection#request}` method.
 * @since 6.0.0
 */
Ext.define(&#39;Ext.data.request.Ajax&#39;, {
    extend: &#39;Ext.data.request.Base&#39;,
    alias:  &#39;request.ajax&#39;,
    
    requires: [
        &#39;Ext.data.flash.BinaryXhr&#39;
    ],

    statics: {

<span id='Ext-data-request-Ajax-static-method-parseStatus'>        /**
</span>         * Checks if the response status was successful
         * @param {Number} status The status code
         * @param {Object} response The Response object
         * @return {Object} An object containing success/status state
         * @private
         */
        parseStatus: function(status, response) {
            var len;

            if (response) {
                //We have to account for binary response type
                if (response.responseType === &#39;arraybuffer&#39;) {
                    len = response.byteLength;
                } else if (response.responseText) {
                    len = response.responseText.length;
                }
            }

            // see: https://prototype.lighthouseapp.com/projects/8886/tickets/129-ie-mangles-http-response-status-code-204-to-1223
            status = status == 1223 ? 204 : status;

            var success = (status &gt;= 200 &amp;&amp; status &lt; 300) || status == 304 || (status == 0 &amp;&amp; Ext.isNumber(len)),
                isException = false;

            if (!success) {
                switch (status) {
                    case 12002:
                    case 12029:
                    case 12030:
                    case 12031:
                    case 12152:
                    case 13030:
                        isException = true;
                        break;
                }
            }

            return {
                success: success,
                isException: isException
            };
        }
    },
    
<span id='Ext-data-request-Ajax-method-start'>    start: function(data) {
</span>        var me = this,
            options = me.options,
            requestOptions = me.requestOptions,
            isXdr = me.isXdr,
            xhr, headers;
        
        xhr = me.xhr = me.openRequest(options, requestOptions, me.async, me.username, me.password);

        // XDR doesn&#39;t support setting any headers
        if (!isXdr) {
            headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
        }

        if (me.async) {
            if (!isXdr) {
                xhr.onreadystatechange = Ext.Function.bind(me.onStateChange, me);
            }
        }

        if (isXdr) {
            me.processXdrRequest(me, xhr);
        }
        
        // Parent will set the timeout if needed
        me.callParent([data]);
        
        // start the request!
        xhr.send(data);
        
        if (!me.async) {
            return me.onComplete();
        }
        
        return me;
    },
    
<span id='Ext-data-request-Ajax-method-abort'>    /**
</span>     * Aborts an active request.
     */
    abort: function(force) {
        var me = this,
            xhr = me.xhr;

        if (force || me.isLoading()) {
            /*
             * Clear out the onreadystatechange here, this allows us
             * greater control, the browser may/may not fire the function
             * depending on a series of conditions.
             */
            try {
                xhr.onreadystatechange = null;
            }
            catch (e) {
                // Setting onreadystatechange to null can cause problems in IE, see
                // http://www.quirksmode.org/blog/archives/2005/09/xmlhttp_notes_a_1.html
                xhr.onreadystatechange = Ext.emptyFn;
            }
            
            xhr.abort();
            
            me.callParent([force]);
            
            me.onComplete();
            me.cleanup();
        }
    },
    
<span id='Ext-data-request-Ajax-method-cleanup'>    /**
</span>     * Cleans up any left over information from the request
     */
    cleanup: function() {
        this.xhr = null;
        delete this.xhr;
    },
    
<span id='Ext-data-request-Ajax-method-isLoading'>    isLoading: function() {
</span>        var me = this,
            xhr = me.xhr,
            state = xhr &amp;&amp; xhr.readyState,
            C = Ext.data.flash &amp;&amp; Ext.data.flash.BinaryXhr;

        if (!xhr || me.aborted || me.timedout) {
            return false;
        }

        // if there is a connection and readyState is not 0 or 4, or in case of
        // BinaryXHR, not 4
        if (C &amp;&amp; xhr instanceof C) {
            return state !== 4;
        }

        return state !== 0 &amp;&amp; state !== 4;
    },

<span id='Ext-data-request-Ajax-method-openRequest'>    /**
</span>     * Creates and opens an appropriate XHR transport for a given request on this browser.
     * This logic is contained in an individual method to allow for overrides to process all
     * of the parameters and options and return a suitable, open connection.
     * @private
     */
    openRequest: function(options, requestOptions, async, username, password) {
        var me = this,
            xhr = me.newRequest(options);

        if (username) {
            xhr.open(requestOptions.method, requestOptions.url, async, username, password);
        }
        else {
            if (me.isXdr) {
                xhr.open(requestOptions.method, requestOptions.url);
            }
            else {
                xhr.open(requestOptions.method, requestOptions.url, async);
            }
        }

        if (options.binary || me.binary) {
            if (window.Uint8Array) {
                xhr.responseType = &#39;arraybuffer&#39;;
            }
            else if (xhr.overrideMimeType) {
                // In some older non-IE browsers, e.g. ff 3.6, that do not
                // support Uint8Array, a mime type override is required so that
                // the unprocessed binary data can be read from the responseText
                // (see createResponse())
                xhr.overrideMimeType(&#39;text\/plain; charset=x-user-defined&#39;);
            //&lt;debug&gt;
            }
            else if (!Ext.isIE) {
                Ext.log.warn(&quot;Your browser does not support loading binary data using Ajax.&quot;);
            //&lt;/debug&gt;
            }
        }

        if (options.withCredentials || me.withCredentials) {
            xhr.withCredentials = true;
        }

        return xhr;
    },

<span id='Ext-data-request-Ajax-method-newRequest'>    /**
</span>     * Creates the appropriate XHR transport for a given request on this browser. On IE
     * this may be an `XDomainRequest` rather than an `XMLHttpRequest`.
     * @private
     */
    newRequest: function(options) {
        var me = this,
            xhr;

        if (options.binaryData) {
            // This is a binary data request. Handle submission differently for differnet browsers
            if (window.Uint8Array) {
                // On browsers that support this, use the native XHR object
                xhr = me.getXhrInstance();
            }
            else {
                // catch all for all other browser types
                xhr = new Ext.data.flash.BinaryXhr();
            }
        }
        else if (me.cors &amp;&amp; Ext.isIE9m) {
            xhr = me.getXdrInstance();
            me.isXdr = true;
        }
        else {
            xhr = me.getXhrInstance();
            me.isXdr = false;
        }

        return xhr;
    },

<span id='Ext-data-request-Ajax-method-setupHeaders'>    /**
</span>     * Setup all the headers for the request
     * @private
     * @param {Object} xhr The xhr object
     * @param {Object} options The options for the request
     * @param {Object} data The data for the request
     * @param {Object} params The params for the request
     */
    setupHeaders: function(xhr, options, data, params) {
        var me = this,
            headers = Ext.apply({}, options.headers || {}, me.defaultHeaders),
            contentType = me.defaultPostHeader,
            jsonData = options.jsonData,
            xmlData = options.xmlData,
            type = &#39;Content-Type&#39;,
            useHeader = me.useDefaultXhrHeader,
            key, header;

        if (!headers.hasOwnProperty(type) &amp;&amp; (data || params)) {
            if (data) {
                if (options.rawData) {
                    contentType = &#39;text/plain&#39;;
                }
                else {
                    if (xmlData &amp;&amp; Ext.isDefined(xmlData)) {
                        contentType = &#39;text/xml&#39;;
                    }
                    else if (jsonData &amp;&amp; Ext.isDefined(jsonData)) {
                        contentType = &#39;application/json&#39;;
                    }
                }
            }
            
            headers[type] = contentType;
        }

        if (useHeader &amp;&amp; !headers[&#39;X-Requested-With&#39;]) {
            headers[&#39;X-Requested-With&#39;] = me.defaultXhrHeader;
        }

        // If undefined/null, remove it and don&#39;t set the header.
        // Allow the browser to do so.
        if (headers[type] === undefined || headers[type] === null) {
            delete headers[type];
        }

        // set up all the request headers on the xhr object
        try {
            for (key in headers) {
                if (headers.hasOwnProperty(key)) {
                    header = headers[key];
                    xhr.setRequestHeader(key, header);
                }
            }
        }
        catch(e) {
            // TODO Request shouldn&#39;t fire events from its owner
            me.owner.fireEvent(&#39;exception&#39;, key, header);
        }
        
        return headers;
    },

<span id='Ext-data-request-Ajax-method-getXdrInstance'>    /**
</span>     * Creates the appropriate XDR transport for this browser.
     * - IE 7 and below don&#39;t support CORS
     * - IE 8 and 9 support CORS with native XDomainRequest object
     * - IE 10 (and above?) supports CORS with native XMLHttpRequest object
     * @private
     */
    getXdrInstance: function() {
        var xdr;

        if (Ext.ieVersion &gt;= 8) {
            xdr = new XDomainRequest();
        }
        else {
            Ext.raise({
                msg: &#39;Your browser does not support CORS&#39;
            });
        }

        return xdr;
    },

<span id='Ext-data-request-Ajax-property-getXhrInstance'>    /**
</span>     * Creates the appropriate XHR transport for this browser.
     * @private
     */
    getXhrInstance: (function() {
        var options = [function() {
            return new XMLHttpRequest();
        }, function() {
            return new ActiveXObject(&#39;MSXML2.XMLHTTP.3.0&#39;); // jshint ignore:line
        }, function() {
            return new ActiveXObject(&#39;MSXML2.XMLHTTP&#39;); // jshint ignore:line
        }, function() {
            return new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); // jshint ignore:line
        }], i = 0,
            len = options.length,
            xhr;

        for (; i &lt; len; ++i) {
            try {
                xhr = options[i];
                xhr();
                break;
            } catch(e) {
            }
        }
        return xhr;
    }()),

<span id='Ext-data-request-Ajax-method-processXdrRequest'>    processXdrRequest: function(request, xhr) {
</span>        var me = this;

        // Mutate the request object as per XDR spec.
        delete request.headers;

        request.contentType = request.options.contentType || me.defaultXdrContentType;

        xhr.onload = Ext.Function.bind(me.onStateChange, me, [true]);
        xhr.onerror = xhr.ontimeout = Ext.Function.bind(me.onStateChange, me, [false]);
    },

<span id='Ext-data-request-Ajax-method-processXdrResponse'>    processXdrResponse: function(response, xhr) {
</span>        // Mutate the response object as per XDR spec.
        response.getAllResponseHeaders = function() {
            return [];
        };
        
        response.getResponseHeader = function() {
            return &#39;&#39;;
        };
        
        response.contentType = xhr.contentType || this.defaultXdrContentType;
    },

<span id='Ext-data-request-Ajax-method-onStateChange'>    onStateChange: function(xdrResult) {
</span>        var me = this,
            xhr = me.xhr,
            globalEvents = Ext.GlobalEvents;

        // Using CORS with IE doesn&#39;t support readyState so we fake it.
        if ((xhr &amp;&amp; xhr.readyState == 4) || me.isXdr) {
            me.clearTimer();
            
            me.onComplete(xdrResult);
            
            me.cleanup();
            
            if (globalEvents.hasListeners.idle) {
                globalEvents.fireEvent(&#39;idle&#39;);
            }
        }
    },
    
<span id='Ext-data-request-Ajax-method-onComplete'>    /**
</span>     * To be called when the request has come back from the server
     * @param {Object} request
     * @return {Object} The response
     * @private
     */
    onComplete: function(xdrResult) {
        var me = this,
            owner = me.owner,
            options = me.options,
            xhr = me.xhr,
            failure = { success: false, isException: false },
            result, success, response;
        
        if (!xhr || me.destroyed) {
            return me.result = failure;
        }
        
        try {
            result = Ext.data.request.Ajax.parseStatus(xhr.status, xhr);
            
            if (result.success) {
                // This is quite difficult to reproduce, however if we abort a request
                // just before it returns from the server, occasionally the status will be
                // returned correctly but the request is still yet to be complete.
                result.success = xhr.readyState === 4;
            }
        }
        catch (e) {
            // In some browsers we can&#39;t access the status if the readyState is not 4,
            // so the request has failed
            result = failure;
        }
        
        success = me.success = me.isXdr ? xdrResult : result.success;

        if (success) {
            response = me.createResponse(xhr);
            
            if (owner.hasListeners.requestcomplete) {
                owner.fireEvent(&#39;requestcomplete&#39;, owner, response, options);
            }
            
            if (options.success) {
                Ext.callback(options.success, options.scope, [response, options]);
            }
        }
        else {
            if (result.isException || me.aborted || me.timedout) {
                response = me.createException(xhr);
            }
            else {
                response = me.createResponse(xhr);
            }
            
            if (owner.hasListeners.requestexception) {
                owner.fireEvent(&#39;requestexception&#39;, owner, response, options);
            }
            
            if (options.failure) {
                Ext.callback(options.failure, options.scope, [response, options]);
            }
        }
        
        me.result = response;
        
        if (options.callback) {
            Ext.callback(options.callback, options.scope, [options, success, response]);
        }
        
        owner.onRequestComplete(me);
        
        me.callParent([xdrResult]);
        
        return response;
    },

<span id='Ext-data-request-Ajax-method-createResponse'>    /**
</span>     * Creates the response object
     * @param {Object} request
     * @private
     */
    createResponse: function(xhr) {
        var me = this,
            isXdr = me.isXdr,
            headers = {},
            lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, &#39;\n&#39;).split(&#39;\n&#39;),
            count = lines.length,
            line, index, key, response, byteArray;

        while (count--) {
            line = lines[count];
            index = line.indexOf(&#39;:&#39;);
            
            if (index &gt;= 0) {
                key = line.substr(0, index).toLowerCase();
                
                if (line.charAt(index + 1) == &#39; &#39;) {
                    ++index;
                }
                
                headers[key] = line.substr(index + 1);
            }
        }
        
        response = {
            request: me,
            requestId: me.id,
            status: xhr.status,
            statusText: xhr.statusText,
            getResponseHeader: function(header) {
                return headers[header.toLowerCase()];
            },
            getAllResponseHeaders: function() {
                return headers;
            }
        };

        if (isXdr) {
            me.processXdrResponse(response, xhr);
        }

        if (me.binary) {
            response.responseBytes = me.getByteArray(xhr);
        }
        else {
            // an error is thrown when trying to access responseText or responseXML
            // on an xhr object with responseType of &#39;arraybuffer&#39;, so only attempt
            // to set these properties in the response if we&#39;re not dealing with
            // binary data
            response.responseText = xhr.responseText;
            response.responseXML = xhr.responseXML;
        }

        return response;
    },

<span id='Ext-data-request-Ajax-method-destroy'>    destroy: function() {
</span>        this.xhr = null;
        
        this.callParent();
    },
    
<span id='Ext-data-request-Ajax-property-privates'>    privates: {
</span><span id='Ext-data-request-Ajax-method-getByteArray'>        /**
</span>         * Gets binary data from the xhr response object and returns it as a byte array
         * @param {Object} xhr the xhr response object
         * @return {Uint8Array/Array}
         * @private
         */
        getByteArray: function(xhr) {
            var response = xhr.response,
                responseBody = xhr.responseBody,
                Cls = Ext.data.flash &amp;&amp; Ext.data.flash.BinaryXhr,
                byteArray, responseText, len, i;
            
            if (xhr instanceof Cls) {
                // If this was a BinaryXHR request via flash, we already have the bytes ready
                byteArray = xhr.responseBytes;
            }
            else if (window.Uint8Array) {
                // Modern browsers (including IE10) have a native byte array
                // which can be created by passing the ArrayBuffer (returned as
                // the xhr.response property) to the Uint8Array constructor.
                byteArray = response ? new Uint8Array(response) : [];
            }
            else if (Ext.isIE9p) {
                // In IE9 and below the responseBody property contains a byte array
                // but it is not directly accessible using javascript.
                // In IE9p we can get the bytes by constructing a VBArray
                // using the responseBody and then converting it to an Array.
                try {
                    byteArray = new VBArray(responseBody).toArray(); // jshint ignore:line
                }
                catch(e) {
                    // If the binary response is empty, the VBArray constructor will
                    // choke on the responseBody.  We can&#39;t simply do a null check
                    // on responseBody because responseBody is always falsy when it
                    // contains binary data.
                    byteArray = [];
                }
            }
            else if (Ext.isIE) {
                // IE8 and below also have a VBArray constructor, but throw a
                // &quot;VBArray Expected&quot; error if you try to pass the responseBody to
                // the VBArray constructor.
                // http://msdn.microsoft.com/en-us/library/ye3x9by3%28v=vs.71%29.aspx
                // so we have to use vbscript injection to access the bytes
                if (!this.self.vbScriptInjected) {
                    this.injectVBScript();
                }
                
                getIEByteArray(xhr.responseBody, byteArray = []); // jshint ignore:line
            }
            else {
                // in other older browsers make a best-effort attempt to read the
                // bytes from responseText
                byteArray = [];
                responseText = xhr.responseText;
                len = responseText.length;
                
                for (i = 0; i &lt; len; i++) {
                    // Some characters have an extra byte 0xF7 in the high order
                    // position. Throw away the high order byte and then push the
                    // result onto the byteArray.
                    byteArray.push(responseText.charCodeAt(i) &amp; 0xFF);
                }
            }
            
            return byteArray;
        },

<span id='Ext-data-request-Ajax-method-injectVBScript'>        /**
</span>         * Injects a vbscript tag containing a &#39;getIEByteArray&#39; method for reading
         * binary data from an xhr response in IE8 and below.
         * @private
         */
        injectVBScript: function() {
            var scriptTag = document.createElement(&#39;script&#39;);
            
            scriptTag.type = &#39;text/vbscript&#39;;
            scriptTag.text = [
                &#39;Function getIEByteArray(byteArray, out)&#39;,
                    &#39;Dim len, i&#39;,
                    &#39;len = LenB(byteArray)&#39;,
                    &#39;For i = 1 to len&#39;,
                        &#39;out.push(AscB(MidB(byteArray, i, 1)))&#39;,
                    &#39;Next&#39;,
                &#39;End Function&#39;
            ].join(&#39;\n&#39;);
            
            Ext.getHead().dom.appendChild(scriptTag);
            
            this.self.vbScriptInjected = true;
        }
    }
});
</pre>
</body>
</html>
