<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-String'>/**
</span> * @class Ext.String
 *
 * A collection of useful static methods to deal with strings.
 * @singleton
 */
Ext.String = (function() {
// @define Ext.lang.String
// @define Ext.String
// @require Ext
// @require Ext.lang.Array
    var trimRegex     = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g,
        escapeRe      = /(&#39;|\\)/g,
        escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g,
        basicTrimRe   = /^\s+|\s+$/g,
        whitespaceRe  = /\s+/,
        varReplace    = /(^[^a-z]*|[^\w])/gi,
        charToEntity,
        entityToChar,
        charToEntityRegex,
        entityToCharRegex,
        htmlEncodeReplaceFn = function(match, capture) {
            return charToEntity[capture];
        },
        htmlDecodeReplaceFn = function(match, capture) {
            return (capture in entityToChar) ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
        },
        boundsCheck = function(s, other){
            if (s === null || s === undefined || other === null || other === undefined) {
                return false;
            }

            return other.length &lt;= s.length; 
        },
        fromCharCode = String.fromCharCode,
        ExtString;

    return ExtString = {

<span id='Ext-String-method-fromCodePoint'>        /**
</span>         * Creates a string created by using the specified sequence of code points.
         * @param {Number...} codePoint Codepoints from which to build the string.
         * @return {String} A string built from the sequence of code points passed.
         */
        fromCodePoint: String.fromCodePoint || function() {
            var codePoint,
                result = &#39;&#39;,
                codeUnits = [],
                index = -1,
                length = arguments.length;

            while (++index &lt; length) {
                codePoint = Number(arguments[index]);
                if (
                    !isFinite(codePoint) ||       // `NaN`, `+Infinity`, or `-Infinity`
                    codePoint &lt; 0 ||              // not a valid Unicode code point
                    codePoint &gt; 0x10FFFF ||       // not a valid Unicode code point
                    Math.floor(codePoint) !== codePoint // not an integer
                ) {
                    Ext.raise(&#39;Invalid code point: &#39; + codePoint);
                }
                if (codePoint &lt;= 0xFFFF) { // BMP code point
                    codeUnits.push(codePoint);
                } else { // Astral code point; split in surrogate halves
                    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                    codePoint -= 0x10000;
                    codeUnits.push((codePoint &gt;&gt; 10) + 0xD800, (codePoint % 0x400) + 0xDC00);
                }
                if (index + 1 === length) {
                    result += fromCharCode(codeUnits);
                    codeUnits.length = 0;
                }
            }
            return result;
        },

<span id='Ext-String-method-insert'>        /**
</span>         * Inserts a substring into a string.
         * @param {String} s The original string.
         * @param {String} value The substring to insert.
         * @param {Number} index The index to insert the substring. Negative indexes will insert from the end of
         * the string. Example: 
         *
         *     Ext.String.insert(&quot;abcdefg&quot;, &quot;h&quot;, -1); // abcdefhg
         *
         * @return {String} The value with the inserted substring
         */
        insert: function(s, value, index) {
            if (!s) {
                return value;
            }
            
            if (!value) {
                return s;
            }
            
            var len = s.length;
            
            if (!index &amp;&amp; index !== 0) {
                index = len;
            }
            
            if (index &lt; 0) {
                index *= -1;
                if (index &gt;= len) {
                    // negative overflow, insert at start
                    index = 0;
                } else {
                    index = len - index;
                }
            }
            
            if (index === 0) {
                s = value + s;
            } else if (index &gt;= s.length) {
                s += value;
            } else {
                s = s.substr(0, index) + value + s.substr(index);
            }
            return s;
        },
        
<span id='Ext-String-method-startsWith'>        /**
</span>         * Checks if a string starts with a substring
         * @param {String} s The original string
         * @param {String} start The substring to check
         * @param {Boolean} [ignoreCase=false] True to ignore the case in the comparison
         */
        startsWith: function(s, start, ignoreCase){
            var result = boundsCheck(s, start);
            
            if (result) {
                if (ignoreCase) {
                    s = s.toLowerCase();
                    start = start.toLowerCase();
                }
                result = s.lastIndexOf(start, 0) === 0;
            }
            return result;
        },
        
<span id='Ext-String-method-endsWith'>        /**
</span>         * Checks if a string ends with a substring
         * @param {String} s The original string
         * @param {String} end The substring to check
         * @param {Boolean} [ignoreCase=false] True to ignore the case in the comparison
         */
        endsWith: function(s, end, ignoreCase){
            var result = boundsCheck(s, end);
            
            if (result) {
                if (ignoreCase) {
                    s = s.toLowerCase();
                    end = end.toLowerCase();
                }
                result = s.indexOf(end, s.length - end.length) !== -1;
            }
            return result;
        },

<span id='Ext-String-method-createVarName'>        /**
</span>         * Converts a string of characters into a legal, parse-able JavaScript `var` name as long as the passed
         * string contains at least one alphabetic character. Non alphanumeric characters, and *leading* non alphabetic
         * characters will be removed.
         * @param {String} s A string to be converted into a `var` name.
         * @return {String} A legal JavaScript `var` name.
         */
        createVarName: function(s) {
            return s.replace(varReplace, &#39;&#39;);
        },

<span id='Ext-String-method-htmlEncode'>        /**
</span>         * Convert certain characters (&amp;, &lt;, &gt;, &#39;, and &quot;) to their HTML character equivalents for literal display in web pages.
         * @param {String} value The string to encode.
         * @return {String} The encoded text.
         * @method
         */
        htmlEncode: function(value) {
            return (!value) ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
        },

<span id='Ext-String-method-htmlDecode'>        /**
</span>         * Convert certain characters (&amp;, &lt;, &gt;, &#39;, and &quot;) from their HTML character equivalents.
         * @param {String} value The string to decode.
         * @return {String} The decoded text.
         * @method
         */
        htmlDecode: function(value) {
            return (!value) ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
        },
        
<span id='Ext-String-method-hasHtmlCharacters'>        /**
</span>         * Checks if a string has values needing to be html encoded.
         * @private
         * @param {String} s The string to test
         * @return {Boolean} `true` if the string contains HTML characters
         */
        hasHtmlCharacters: function(s) {
            return charToEntityRegex.test(s);
        },

<span id='Ext-String-method-addCharacterEntities'>        /**
</span>         * Adds a set of character entity definitions to the set used by
         * {@link Ext.String#htmlEncode} and {@link Ext.String#htmlDecode}.
         *
         * This object should be keyed by the entity name sequence,
         * with the value being the textual representation of the entity.
         *
         *      Ext.String.addCharacterEntities({
         *          &#39;&amp;amp;Uuml;&#39;:&#39;Ü&#39;,
         *          &#39;&amp;amp;ccedil;&#39;:&#39;ç&#39;,
         *          &#39;&amp;amp;ntilde;&#39;:&#39;ñ&#39;,
         *          &#39;&amp;amp;egrave;&#39;:&#39;è&#39;
         *      });
         *      var s = Ext.String.htmlEncode(&quot;A string with entities: èÜçñ&quot;);
         *
         * __Note:__ the values of the character entities defined on this object are expected
         * to be single character values.  As such, the actual values represented by the
         * characters are sensitive to the character encoding of the JavaScript source
         * file when defined in string literal form. Script tags referencing server
         * resources with character entities must ensure that the &#39;charset&#39; attribute
         * of the script node is consistent with the actual character encoding of the
         * server resource.
         *
         * The set of character entities may be reset back to the default state by using
         * the {@link Ext.String#resetCharacterEntities} method
         *
         * @param {Object} newEntities The set of character entities to add to the current
         * definitions.
         */
        addCharacterEntities: function(newEntities) {
            var charKeys = [],
                entityKeys = [],
                key, echar;
            for (key in newEntities) {
                echar = newEntities[key];
                entityToChar[key] = echar;
                charToEntity[echar] = key;
                charKeys.push(echar);
                entityKeys.push(key);
            }
            charToEntityRegex = new RegExp(&#39;(&#39; + charKeys.join(&#39;|&#39;) + &#39;)&#39;, &#39;g&#39;);
            entityToCharRegex = new RegExp(&#39;(&#39; + entityKeys.join(&#39;|&#39;) + &#39;|&amp;#[0-9]{1,5};&#39; + &#39;)&#39;, &#39;g&#39;);
        },

<span id='Ext-String-method-resetCharacterEntities'>        /**
</span>         * Resets the set of character entity definitions used by
         * {@link Ext.String#htmlEncode} and {@link Ext.String#htmlDecode} back to the
         * default state.
         */
        resetCharacterEntities: function() {
            charToEntity = {};
            entityToChar = {};
            // add the default set
            this.addCharacterEntities({
                &#39;&amp;amp;&#39;     :   &#39;&amp;&#39;,
                &#39;&amp;gt;&#39;      :   &#39;&gt;&#39;,
                &#39;&amp;lt;&#39;      :   &#39;&lt;&#39;,
                &#39;&amp;quot;&#39;    :   &#39;&quot;&#39;,
                &#39;&amp;#39;&#39;     :   &quot;&#39;&quot;
            });
        },

<span id='Ext-String-method-urlAppend'>        /**
</span>         * Appends content to the query string of a URL, handling logic for whether to place
         * a question mark or ampersand.
         * @param {String} url The URL to append to.
         * @param {String} string The content to append to the URL.
         * @return {String} The resulting URL
         */
        urlAppend : function(url, string) {
            if (!Ext.isEmpty(string)) {
                return url + (url.indexOf(&#39;?&#39;) === -1 ? &#39;?&#39; : &#39;&amp;&#39;) + string;
            }

            return url;
        },

<span id='Ext-String-method-trim'>        /**
</span>         * Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
         *
         *     var s = &#39;  foo bar  &#39;;
         *     alert(&#39;-&#39; + s + &#39;-&#39;);                   //alerts &quot;- foo bar -&quot;
         *     alert(&#39;-&#39; + Ext.String.trim(s) + &#39;-&#39;);  //alerts &quot;-foo bar-&quot;
         *
         * @param {String} string The string to trim.
         * @return {String} The trimmed string.
         */
        trim: function(string) {
            if (string) {
                string = string.replace(trimRegex, &quot;&quot;);
            }
            return string || &#39;&#39;;
        },

<span id='Ext-String-method-capitalize'>        /**
</span>         * Capitalize the first letter of the given string.
         * @param {String} string
         * @return {String}
         */
        capitalize: function(string) {
            if (string) {
                string = string.charAt(0).toUpperCase() + string.substr(1);
            }
            return string || &#39;&#39;;
        },

<span id='Ext-String-method-uncapitalize'>        /**
</span>         * Uncapitalize the first letter of a given string.
         * @param {String} string
         * @return {String}
         */
        uncapitalize: function(string) {
            if (string) {
                string = string.charAt(0).toLowerCase() + string.substr(1);
            }
            return string || &#39;&#39;;
        },

<span id='Ext-String-method-ellipsis'>        /**
</span>         * Truncate a string and add an ellipsis (&#39;...&#39;) to the end if it exceeds the specified length.
         * @param {String} value The string to truncate.
         * @param {Number} length The maximum length to allow before truncating.
         * @param {Boolean} [word=false] `true` to try to find a common word break.
         * @return {String} The converted text.
         */
        ellipsis: function(value, length, word) {
            if (value &amp;&amp; value.length &gt; length) {
                if (word) {
                    var vs = value.substr(0, length - 2),
                    index = Math.max(vs.lastIndexOf(&#39; &#39;), vs.lastIndexOf(&#39;.&#39;), vs.lastIndexOf(&#39;!&#39;), vs.lastIndexOf(&#39;?&#39;));
                    if (index !== -1 &amp;&amp; index &gt;= (length - 15)) {
                        return vs.substr(0, index) + &quot;...&quot;;
                    }
                }
                return value.substr(0, length - 3) + &quot;...&quot;;
            }
            return value;
        },

<span id='Ext-String-method-escapeRegex'>        /**
</span>         * Escapes the passed string for use in a regular expression.
         * @param {String} string The string to escape.
         * @return {String} The escaped string.
         */
        escapeRegex: function(string) {
            return string.replace(escapeRegexRe, &quot;\\$1&quot;);
        },

<span id='Ext-String-method-createRegex'>        /**
</span>         * Creates a `RegExp` given a string `value` and optional flags. For example, the
         * following two regular expressions are equivalent.
         *
         *      var regex1 = Ext.String.createRegex(&#39;hello&#39;);
         *
         *      var regex2 = /^hello$/i;
         *
         * The following two regular expressions are also equivalent:
         *
         *      var regex1 = Ext.String.createRegex(&#39;world&#39;, false, false, false);
         *
         *      var regex2 = /world/;
         *
         * @param {String/RegExp} value The String to convert to a `RegExp`.
         * @param {Boolean} [startsWith=true] Pass `false` to allow a match to start 
         * anywhere in the string. By default the `value` will match only at the start 
         * of the string.
         * @param {Boolean} [endsWith=true] Pass `false` to allow the match to end before
         * the end of the string. By default the `value` will match only at the end of the
         * string.
         * @param {Boolean} [ignoreCase=true] Pass `false` to make the `RegExp` case
         * sensitive (removes the &#39;i&#39; flag).
         * @since 5.0.0
         * @return {RegExp}
         */
        createRegex: function (value, startsWith, endsWith, ignoreCase) {
            var ret = value;

            if (value != null &amp;&amp; !value.exec) { // not a regex
                ret = ExtString.escapeRegex(String(value));

                if (startsWith !== false) {
                    ret = &#39;^&#39; + ret;
                }
                if (endsWith !== false) {
                    ret += &#39;$&#39;;
                }

                ret = new RegExp(ret, (ignoreCase !== false) ? &#39;i&#39; : &#39;&#39;);
            }

            return ret;
        },

<span id='Ext-String-method-escape'>        /**
</span>         * Escapes the passed string for &#39; and \.
         * @param {String} string The string to escape.
         * @return {String} The escaped string.
         */
        escape: function(string) {
            return string.replace(escapeRe, &quot;\\$1&quot;);
        },

<span id='Ext-String-method-toggle'>        /**
</span>         * Utility function that allows you to easily switch a string between two alternating values.  The passed value
         * is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
         * they are already different, the first value passed in is returned.  Note that this method returns the new value
         * but does not change the current string.
         *
         *     // alternate sort directions
         *     sort = Ext.String.toggle(sort, &#39;ASC&#39;, &#39;DESC&#39;);
         *
         *     // instead of conditional logic:
         *     sort = (sort === &#39;ASC&#39; ? &#39;DESC&#39; : &#39;ASC&#39;);
         *
         * @param {String} string The current string.
         * @param {String} value The value to compare to the current string.
         * @param {String} other The new value to use if the string already equals the first value passed in.
         * @return {String} The new value.
         */
        toggle: function(string, value, other) {
            return string === value ? other : value;
        },

<span id='Ext-String-method-leftPad'>        /**
</span>         * Pads the left side of a string with a specified character.  This is especially useful
         * for normalizing number and date strings.  Example usage:
         *
         *     var s = Ext.String.leftPad(&#39;123&#39;, 5, &#39;0&#39;);
         *     // s now contains the string: &#39;00123&#39;
         *
         * @param {String} string The original string.
         * @param {Number} size The total length of the output string.
         * @param {String} [character=&#39; &#39;] (optional) The character with which to pad the original string.
         * @return {String} The padded string.
         */
        leftPad: function(string, size, character) {
            var result = String(string);
            character = character || &quot; &quot;;
            while (result.length &lt; size) {
                result = character + result;
            }
            return result;
        },

<span id='Ext-String-method-repeat'>        /**
</span>         * Returns a string with a specified number of repetitions a given string pattern.
         * The pattern be separated by a different string.
         *
         *      var s = Ext.String.repeat(&#39;---&#39;, 4); // = &#39;------------&#39;
         *      var t = Ext.String.repeat(&#39;--&#39;, 3, &#39;/&#39;); // = &#39;--/--/--&#39;
         *
         * @param {String} pattern The pattern to repeat.
         * @param {Number} count The number of times to repeat the pattern (may be 0).
         * @param {String} sep An option string to separate each pattern.
         */
        repeat: function(pattern, count, sep) {
            if (count &lt; 1) {
                count = 0;
            }
            for (var buf = [], i = count; i--; ) {
                buf.push(pattern);
            }
            return buf.join(sep || &#39;&#39;);
        },

<span id='Ext-String-method-splitWords'>        /**
</span>         * Splits a string of space separated words into an array, trimming as needed. If the
         * words are already an array, it is returned.
         *
         * @param {String/Array} words
         */
        splitWords: function (words) {
            if (words &amp;&amp; typeof words == &#39;string&#39;) {
                return words.replace(basicTrimRe, &#39;&#39;).split(whitespaceRe);
            }
            return words || [];
        }
    };
}());

// initialize the default encode / decode entities
Ext.String.resetCharacterEntities();

<span id='Ext-method-htmlEncode'>/**
</span> * Old alias to {@link Ext.String#htmlEncode}
 * @deprecated Use {@link Ext.String#htmlEncode} instead
 * @method htmlEncode
 * @member Ext
 * @inheritdoc Ext.String#htmlEncode
 */
Ext.htmlEncode = Ext.String.htmlEncode;


<span id='Ext-method-htmlDecode'>/**
</span> * Old alias to {@link Ext.String#htmlDecode}
 * @deprecated Use {@link Ext.String#htmlDecode} instead
 * @method htmlDecode
 * @member Ext
 * @inheritdoc Ext.String#htmlDecode
 */
Ext.htmlDecode = Ext.String.htmlDecode;

<span id='Ext-method-urlAppend'>/**
</span> * Old alias to {@link Ext.String#urlAppend}
 * @deprecated Use {@link Ext.String#urlAppend} instead
 * @method urlAppend
 * @member Ext
 * @inheritdoc Ext.String#urlAppend
 */
Ext.urlAppend = Ext.String.urlAppend;
</pre>
</body>
</html>
