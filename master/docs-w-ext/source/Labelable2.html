<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-form-Labelable'>/**
</span> * A mixin which allows a component to be configured and decorated with a label and/or error message as is
 * common for form fields. This is used by e.g. Ext.form.field.Base and Ext.form.FieldContainer
 * to let them be managed by the Field layout.
 *
 * NOTE: This mixin is mainly for internal library use and most users should not need to use it directly. It
 * is more likely you will want to use one of the component classes that import this mixin, such as
 * Ext.form.field.Base or Ext.form.FieldContainer.
 *
 * Use of this mixin does not make a component a field in the logical sense, meaning it does not provide any
 * logic or state related to values or validation; that is handled by the related Ext.form.field.Field
 * mixin. These two mixins may be used separately (for example Ext.form.FieldContainer is Labelable but not a
 * Field), or in combination (for example Ext.form.field.Base implements both and has logic for connecting the
 * two.)
 *
 * Component classes which use this mixin should use the Field layout
 * or a derivation thereof to properly size and position the label and message according to the component config.
 * They must also call the {@link #initLabelable} method during component initialization to ensure the mixin gets
 * set up correctly.
 */
Ext.define(&quot;Ext.form.Labelable&quot;, {
    extend: 'Ext.Mixin',

    requires: [
        'Ext.XTemplate',
        'Ext.overrides.dom.Element'
    ],

<span id='Ext-form-Labelable-property-isLabelable'>    isLabelable: true,
</span>
<span id='Ext-form-Labelable-property-mixinConfig'>    mixinConfig: {
</span>        id: 'labelable',

        on: {
            beforeRender: 'beforeLabelRender',
            onRender: 'onLabelRender'
        }
    },

    config: {
<span id='Ext-form-Labelable-cfg-childEls'>        childEls: [
</span><span id='Ext-form-Labelable-property-labelEl'>            /**
</span>             * @property {Ext.dom.Element} labelEl
             * The label Element for this component. Only available after the component has been rendered.
             */
            'labelEl',

<span id='Ext-form-Labelable-property-bodyEl'>            /**
</span>             * @property {Ext.dom.Element} bodyEl
             * The div Element wrapping the component's contents. Only available after the component has been rendered.
             */
            'bodyEl',

<span id='Ext-form-Labelable-property-errorEl'>            /**
</span>             * @property {Ext.dom.Element} errorEl
             * The div Element that will contain the component's error message(s). Note that depending on the configured
             * {@link #msgTarget}, this element may be hidden in favor of some other form of presentation, but will always
             * be present in the DOM for use by assistive technologies.
             */
            'errorEl',

            'errorWrapEl',
            'ariaErrorEl',
            'ariaStatusEl',
            'ariaHelpEl',
            'labelTextEl'
        ]
    },

<span id='Ext-form-Labelable-cfg-labelableRenderTpl'>    /**
</span>     * @cfg {String/String[]/Ext.XTemplate} labelableRenderTpl
     * The rendering template for the field decorations. Component classes using this mixin
     * should include logic to use this as their {@link Ext.Component#renderTpl renderTpl},
     * and implement the {@link #getSubTplMarkup} method to generate the field body content.
     * @private
     */
    labelableRenderTpl: [
        '{beforeLabelTpl}',
        '&lt;label id=&quot;{id}-labelEl&quot; data-ref=&quot;labelEl&quot; class=&quot;{labelCls} {labelCls}-{ui} {labelClsExtra} ',
                '{childElCls} {unselectableCls}&quot; style=&quot;{labelStyle}&quot;',
                '&lt;tpl if=&quot;inputId &amp;&amp; !skipLabelForAttribute&quot;&gt; for=&quot;{inputId}&quot;&lt;/tpl&gt;',
                ' {labelAttrTpl}&gt;',
            '&lt;span class=&quot;{labelInnerCls} {labelInnerCls}-{ui}&quot; style=&quot;{labelInnerStyle}&quot;&gt;',
            '{beforeLabelTextTpl}',
            '&lt;span id=&quot;{id}-labelTextEl&quot; data-ref=&quot;labelTextEl&quot; class=&quot;{labelTextCls}&quot;&gt;',
                '&lt;tpl if=&quot;fieldLabel&quot;&gt;{fieldLabel}',
                    '&lt;tpl if=&quot;labelSeparator&quot;&gt;{labelSeparator}&lt;/tpl&gt;',
                '&lt;/tpl&gt;',
            '&lt;/span&gt;',
            '{afterLabelTextTpl}',
            '&lt;/span&gt;',
        '&lt;/label&gt;',
        '{afterLabelTpl}',
        '&lt;div id=&quot;{id}-bodyEl&quot; data-ref=&quot;bodyEl&quot; role=&quot;presentation&quot;',
            ' class=&quot;{baseBodyCls} {baseBodyCls}-{ui}&lt;tpl if=&quot;fieldBodyCls&quot;&gt;',
            ' {fieldBodyCls} {fieldBodyCls}-{ui}&lt;/tpl&gt; {growCls} {extraFieldBodyCls}&quot;',
            '&lt;tpl if=&quot;bodyStyle&quot;&gt; style=&quot;{bodyStyle}&quot;&lt;/tpl&gt;&gt;',
            '{beforeBodyEl}',
            '{beforeSubTpl}',
            '{[values.$comp.getSubTplMarkup(values)]}',
            '{afterSubTpl}',
            '{afterBodyEl}',
            // ARIA elements serve different purposes:
            // - ariaHelpEl may contain optional hints about the field, such as
            //   expected format. This text is static and usually does not change
            //   once rendered. It is also optional.
            // - ariaStatusEl is used to convey status of the field. Validation errors
            //   are rendered here, as well as other information that might be helpful
            //   to Assistive Technology users exploring the app in browse mode.
            // - ariaErrorEl is used for announcing dynamic changes in the field state,
            //   so that AT users receive updates while in forms mode.
            //
            // Both ariaHelpEl and ariaStatusEl are referenced by the field's input element
            // via aria-describedby.
            '&lt;tpl if=&quot;renderAriaElements&quot;&gt;',
                '&lt;tpl if=&quot;ariaHelp&quot;&gt;',
                    '&lt;span id=&quot;{id}-ariaHelpEl&quot; data-ref=&quot;ariaHelpEl&quot;',
                        ' class=&quot;' + Ext.baseCSSPrefix + 'hidden-offsets&quot;&gt;',
                        '{ariaHelp}',
                    '&lt;/span&gt;',
                '&lt;/tpl&gt;',
                '&lt;span id=&quot;{id}-ariaStatusEl&quot; data-ref=&quot;ariaStatusEl&quot; aria-hidden=&quot;true&quot;',
                    ' class=&quot;' + Ext.baseCSSPrefix + 'hidden-offsets&quot;&gt;',
                    '{ariaStatus}',
                '&lt;/span&gt;',
                '&lt;span id=&quot;{id}-ariaErrorEl&quot; data-ref=&quot;ariaErrorEl&quot; aria-hidden=&quot;true&quot; aria-live=&quot;assertive&quot;',
                    ' class=&quot;' + Ext.baseCSSPrefix + 'hidden-clip&quot;&gt;',
                '&lt;/span&gt;',
            '&lt;/tpl&gt;',
        '&lt;/div&gt;',
        '&lt;tpl if=&quot;renderError&quot;&gt;',
            '&lt;div id=&quot;{id}-errorWrapEl&quot; data-ref=&quot;errorWrapEl&quot; class=&quot;{errorWrapCls} {errorWrapCls}-{ui}',
                ' {errorWrapExtraCls}&quot; style=&quot;{errorWrapStyle}&quot;&gt;',
                '&lt;div role=&quot;presentation&quot; id=&quot;{id}-errorEl&quot; data-ref=&quot;errorEl&quot; ',
                    'class=&quot;{errorMsgCls} {invalidMsgCls} {invalidMsgCls}-{ui}&quot; ',
                    'data-anchorTarget=&quot;{tipAnchorTarget}&quot;&gt;',
                '&lt;/div&gt;',
            '&lt;/div&gt;',
        '&lt;/tpl&gt;',
        {
            disableFormats: true
        }
    ],

<span id='Ext-form-Labelable-cfg-activeErrorsTpl'>    /**
</span>     * @cfg {String/String[]/Ext.XTemplate} activeErrorsTpl
     * The template used to format the Array of error messages passed to {@link #setActiveErrors} into a single HTML
     * string. if the {@link #msgTarget} is title, it defaults to a list separated by new lines. Otherwise, it
     * renders each message as an item in an unordered list.
     */
    activeErrorsTpl: undefined,

<span id='Ext-form-Labelable-property-htmlActiveErrorsTpl'>    htmlActiveErrorsTpl: [
</span>        '&lt;tpl if=&quot;errors &amp;&amp; errors.length&quot;&gt;',
            '&lt;ul class=&quot;{listCls}&quot;&gt;',
                '&lt;tpl for=&quot;errors&quot;&gt;&lt;li&gt;{.}&lt;/li&gt;&lt;/tpl&gt;',
            '&lt;/ul&gt;',
        '&lt;/tpl&gt;'
    ],

<span id='Ext-form-Labelable-property-plaintextActiveErrorsTpl'>    plaintextActiveErrorsTpl: [
</span>        '&lt;tpl if=&quot;errors &amp;&amp; errors.length&quot;&gt;',
            '&lt;tpl for=&quot;errors&quot;&gt;&lt;tpl if=&quot;xindex &amp;gt; 1&quot;&gt;\n&lt;/tpl&gt;{.}&lt;/tpl&gt;',
        '&lt;/tpl&gt;'
    ],
    
<span id='Ext-form-Labelable-property-ariaActiveErrorsTpl'>    ariaActiveErrorsTpl: [
</span>        '&lt;tpl if=&quot;errors &amp;&amp; errors.length&quot;&gt;',
            '&lt;tpl for=&quot;errors&quot; between=&quot;. &quot;&gt;{.}&lt;/tpl&gt;',
        '&lt;/tpl&gt;'
    ],

<span id='Ext-form-Labelable-property-isFieldLabelable'>    /**
</span>     * @property {Boolean} isFieldLabelable
     * Flag denoting that this object is labelable as a field. Always true.
     */
    isFieldLabelable: true,

<span id='Ext-form-Labelable-cfg-formItemCls'>    /**
</span>     * @cfg {String} formItemCls
     * A CSS class to be applied to the outermost element to denote that it is participating in the form field layout.
     */
    formItemCls: Ext.baseCSSPrefix + 'form-item',

<span id='Ext-form-Labelable-cfg-labelCls'>    /**
</span>     * @cfg {String} labelCls
     * The CSS class to be applied to the label element. This (single) CSS class is used to formulate the renderSelector
     * and drives the field layout where it is concatenated with a hyphen ('-') and {@link #labelAlign}. To add
     * additional classes, use {@link #labelClsExtra}.
     */
    labelCls: Ext.baseCSSPrefix + 'form-item-label',

<span id='Ext-form-Labelable-property-topLabelCls'>    /**
</span>     * @private
     */
    topLabelCls: Ext.baseCSSPrefix + 'form-item-label-top',
<span id='Ext-form-Labelable-property-rightLabelCls'>    rightLabelCls: Ext.baseCSSPrefix + 'form-item-label-right',
</span><span id='Ext-form-Labelable-property-labelInnerCls'>    labelInnerCls: Ext.baseCSSPrefix + 'form-item-label-inner',
</span><span id='Ext-form-Labelable-property-labelTextCls'>    labelTextCls: Ext.baseCSSPrefix + 'form-item-label-text',
</span><span id='Ext-form-Labelable-property-topLabelSideErrorCls'>    topLabelSideErrorCls: Ext.baseCSSPrefix + 'form-item-label-top-side-error',
</span>
<span id='Ext-form-Labelable-cfg-labelClsExtra'>    /**
</span>     * @cfg {String} labelClsExtra
     * An optional string of one or more additional CSS classes to add to the label element. Defaults to empty.
     */

<span id='Ext-form-Labelable-cfg-errorMsgCls'>    /**
</span>     * @cfg {String} errorMsgCls
     * The CSS class to be applied to the error message element.
     */
    errorMsgCls: Ext.baseCSSPrefix + 'form-error-msg',

<span id='Ext-form-Labelable-property-errorWrapCls'>    errorWrapCls: Ext.baseCSSPrefix + 'form-error-wrap',
</span><span id='Ext-form-Labelable-property-errorWrapSideCls'>    errorWrapSideCls: Ext.baseCSSPrefix + 'form-error-wrap-side',
</span><span id='Ext-form-Labelable-property-errorWrapUnderCls'>    errorWrapUnderCls: Ext.baseCSSPrefix + 'form-error-wrap-under',
</span><span id='Ext-form-Labelable-property-errorWrapUnderSideLabelCls'>    errorWrapUnderSideLabelCls: Ext.baseCSSPrefix + 'form-error-wrap-under-side-label',
</span>
<span id='Ext-form-Labelable-cfg-baseBodyCls'>    /**
</span>     * @cfg {String} baseBodyCls
     * The CSS class to be applied to the body content element.
     */
    baseBodyCls: Ext.baseCSSPrefix + 'form-item-body',

<span id='Ext-form-Labelable-property-invalidIconCls'>    invalidIconCls: Ext.baseCSSPrefix + 'form-invalid-icon',
</span>
<span id='Ext-form-Labelable-property-invalidUnderCls'>    invalidUnderCls: Ext.baseCSSPrefix + 'form-invalid-under',
</span>
<span id='Ext-form-Labelable-property-noLabelCls'>    noLabelCls: Ext.baseCSSPrefix + 'form-item-no-label',
</span>
<span id='Ext-form-Labelable-cfg-fieldBodyCls'>    /**
</span>     * @cfg {String} fieldBodyCls
     * An extra CSS class to be applied to the body content element in addition to {@link #baseBodyCls}.
     */
    fieldBodyCls: '',

<span id='Ext-form-Labelable-property-extraFieldBodyCls'>    extraFieldBodyCls: '',
</span>
<span id='Ext-form-Labelable-cfg-invalidCls'>    /**
</span>     * @cfg {String} invalidCls
     * The CSS class to use when marking the component invalid.
     */
    invalidCls : Ext.baseCSSPrefix + 'form-invalid',

<span id='Ext-form-Labelable-cfg-fieldLabel'>    /**
</span>     * @cfg {String} fieldLabel
     * The label for the field. It gets appended with the {@link #labelSeparator}, and its position and sizing is
     * determined by the {@link #labelAlign} and {@link #labelWidth} configs.
     */
    fieldLabel: undefined,

<span id='Ext-form-Labelable-cfg-labelAlign'>    /**
</span>     * @cfg {String} labelAlign
     * Controls the position and alignment of the {@link #fieldLabel}. Valid values are:
     *
     *   - &quot;left&quot; (the default) - The label is positioned to the left of the field, with its text aligned to the left.
     *     Its width is determined by the {@link #labelWidth} config.
     *   - &quot;top&quot; - The label is positioned above the field.
     *   - &quot;right&quot; - The label is positioned to the left of the field, with its text aligned to the right.
     *     Its width is determined by the {@link #labelWidth} config.
     */
    labelAlign : 'left',

<span id='Ext-form-Labelable-cfg-labelWidth'>    /**
</span>     * @cfg {Number} labelWidth
     * The width of the {@link #fieldLabel} in pixels. Only applicable if {@link #labelAlign}
     * is set to &quot;left&quot; or &quot;right&quot;.
     */
    labelWidth: 100,

<span id='Ext-form-Labelable-cfg-labelPad'>    /**
</span>     * @cfg {Number} labelPad
     * The amount of space in pixels between the {@link #fieldLabel} and the field body.
     * This defaults to `5` for compatibility with Ext JS 4, however, as of Ext JS 5
     * the space between the label and the body can optionally be determined by the theme
     * using the {@link #$form-label-horizontal-spacing} (for side-aligned labels) and
     * {@link #$form-label-vertical-spacing} (for top-aligned labels) SASS variables.
     * In order for the stylesheet values as to take effect, you must use a labelPad value
     * of `null`.
     */
    labelPad: 5,

    //&lt;locale&gt;
<span id='Ext-form-Labelable-cfg-labelSeparator'>    /**
</span>     * @cfg {String} labelSeparator
     * Character(s) to be inserted at the end of the {@link #fieldLabel label text}.
     *
     * Set to empty string to hide the separator completely.
     */
    labelSeparator : ':',
    //&lt;/locale&gt;

<span id='Ext-form-Labelable-cfg-labelStyle'>    /**
</span>     * @cfg {String} labelStyle
     * A CSS style specification string to apply directly to this field's label.
     */
    
<span id='Ext-form-Labelable-cfg-hideLabel'>    /**
</span>     * @cfg {Boolean} hideLabel
     * Set to true to completely hide the label element ({@link #fieldLabel} and {@link #labelSeparator}). Also see
     * {@link #hideEmptyLabel}, which controls whether space will be reserved for an empty fieldLabel.
     */
    hideLabel: false,

<span id='Ext-form-Labelable-cfg-hideEmptyLabel'>    /**
</span>     * @cfg {Boolean} hideEmptyLabel
     * When set to true, the label element ({@link #fieldLabel} and {@link #labelSeparator}) will be automatically
     * hidden if the {@link #fieldLabel} is empty. Setting this to false will cause the empty label element to be
     * rendered and space to be reserved for it; this is useful if you want a field without a label to line up with
     * other labeled fields in the same form.
     *
     * If you wish to unconditionall hide the label even if a non-empty fieldLabel is configured, then set the
     * {@link #hideLabel} config to true.
     */
    hideEmptyLabel: true,

<span id='Ext-form-Labelable-cfg-preventMark'>    /**
</span>     * @cfg {Boolean} preventMark
     * true to disable displaying any {@link #setActiveError error message} set on this object.
     */
    preventMark: false,

<span id='Ext-form-Labelable-cfg-autoFitErrors'>    /**
</span>     * @cfg {Boolean} autoFitErrors
     * Whether to adjust the component's body width to make room for 'side'
     * {@link #msgTarget error messages}.
     */
    autoFitErrors: true,

<span id='Ext-form-Labelable-cfg-msgTarget'>    /**
</span>     * @cfg {String} msgTarget
     * The location where the error message text should display. Must be one of the following values:
     *
     *   - `qtip` Display a quick tip containing the message when the user hovers over the field.
     *     This is the default.
     *
     *     **{@link Ext.tip.QuickTipManager#init} must have been called for this setting to work.**
     *
     *   - `title` Display the message in a default browser title attribute popup.
     *   - `under` Add a block div beneath the field containing the error message.
     *   - `side` Add an error icon to the right of the field, displaying the message in a popup on hover.
     *   - `none` Don't display any error message. This might be useful if you are implementing custom error display.
     *   - `[element id]` Add the error message directly to the innerHTML of the specified element.
     */
    msgTarget: 'qtip',

<span id='Ext-form-Labelable-property-msgTargets'>    /**
</span>     * @private
     * Map for msg target lookup, if target is not in this map it is assumed
     * to be an element id
     */
    msgTargets: {
        qtip: 1,
        title: 1,
        under: 1,
        side: 1,
        none: 1
    },

<span id='Ext-form-Labelable-cfg-activeError'>    /**
</span>     * @cfg {String} activeError
     * If specified, then the component will be displayed with this value as its active error when first rendered. Use
     * {@link #setActiveError} or {@link #unsetActiveError} to change it after component creation.
     */

<span id='Ext-form-Labelable-property-noWrap'>    /**
</span>     * @private
     * Tells the layout system that the height can be measured immediately because the width does not need setting.
     */
    noWrap: true,
    
<span id='Ext-form-Labelable-cfg-ariaHelp'>    /**
</span>     * @cfg {String} [ariaHelp] Optional text description for this object. This text will be
     * announced to Assistive Technology users when the object is focused.
     */
    ariaHelp: undefined,
    
    //&lt;/locale&gt;
<span id='Ext-form-Labelable-cfg-ariaErrorText'>    /**
</span>     * @cfg {String} ariaErrorText Localized announcement text for validation errors. This text
     * will be used by Assistive Technologies such as screen readers to alert the users when
     * field validation fails.
     *
     * This config is used with {@link Ext.String.format}. '{0}' will be replaced with the actual
     * error message(s), '{1}' will be replaced with field label.
     */
    ariaErrorText: 'Input error. {0}.',
<span id='Ext-form-Labelable-property-labelableInsertions'>    //&lt;/locale&gt;
</span>
    labelableInsertions: [

<span id='Ext-form-Labelable-cfg-beforeBodyEl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeBodyEl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * at the beginning of the input containing element. If an `XTemplate` is used, the component's {@link Ext.Component#renderData render data}
         * serves as the context.
         */
        'beforeBodyEl',

<span id='Ext-form-Labelable-cfg-afterBodyEl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterBodyEl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * at the end of the input containing element. If an `XTemplate` is used, the component's {@link Ext.Component#renderData render data}
         * serves as the context.
         */
        'afterBodyEl',

<span id='Ext-form-Labelable-cfg-beforeLabelTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeLabelTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * before the label element. If an `XTemplate` is used, the component's {@link Ext.Component#renderData render data}
         * serves as the context.
         */
        'beforeLabelTpl',

<span id='Ext-form-Labelable-cfg-afterLabelTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterLabelTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * after the label element. If an `XTemplate` is used, the component's {@link Ext.Component#renderData render data}
         * serves as the context.
         */
        'afterLabelTpl',

<span id='Ext-form-Labelable-cfg-beforeSubTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeSubTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * before the {@link #getSubTplMarkup subTpl markup}. If an `XTemplate` is used, the
         * component's {@link Ext.Component#renderData render data} serves as the context.
         */
        'beforeSubTpl',

<span id='Ext-form-Labelable-cfg-afterSubTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterSubTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * after the {@link #getSubTplMarkup subTpl markup}. If an `XTemplate` is used, the
         * component's {@link Ext.Component#renderData render data} serves as the context.
         */
        'afterSubTpl',

<span id='Ext-form-Labelable-cfg-beforeLabelTextTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} beforeLabelTextTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * before the label text. If an `XTemplate` is used, the component's {@link Ext.Component#renderData render data}
         * serves as the context.
         */
        'beforeLabelTextTpl',

<span id='Ext-form-Labelable-cfg-afterLabelTextTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} afterLabelTextTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * after the label text. If an `XTemplate` is used, the component's {@link Ext.Component#renderData render data}
         * serves as the context.
         */
        'afterLabelTextTpl',

<span id='Ext-form-Labelable-cfg-labelAttrTpl'>        /**
</span>         * @cfg {String/Array/Ext.XTemplate} labelAttrTpl
         * An optional string or `XTemplate` configuration to insert in the field markup
         * inside the label element (as attributes). If an `XTemplate` is used, the component's
         * {@link Ext.Component#renderData render data} serves as the context.
         */
        'labelAttrTpl'
    ],

    statics: {
<span id='Ext-form-Labelable-static-method-initTip'>        /**
</span>         * Use a custom QuickTip instance separate from the main QuickTips singleton, so that we
         * can give it a custom frame style. Responds to errorqtip rather than the qtip property.
         * @static
         * @private
         */
        initTip: function() {
            var tip = this.tip,
                cfg, copy;

            if (tip) {
                return;
            }

            cfg = {
                id: 'ext-form-error-tip',
                //&lt;debug&gt;
                // tell the spec runner to ignore this element when checking if the dom is clean
                sticky: true,
                //&lt;/debug&gt;
                ui: 'form-invalid'
            };

            // On Touch devices, tapping the target shows the qtip
            if (Ext.supports.Touch) {
                cfg.dismissDelay = 0;
                cfg.anchor = 'top';
                cfg.showDelay = 0;
                cfg.showOnTap = true;
                cfg.listeners = {
                    beforeshow: function() {
                        this.minWidth = Ext.fly(this.activeTarget.el).getWidth();
                    }
                };
            }
            tip = this.tip = Ext.create('Ext.tip.QuickTip', cfg);
            copy = Ext.apply({}, tip.tagConfig);
            copy.attribute = 'errorqtip';
            tip.setTagConfig(copy);
        },

<span id='Ext-form-Labelable-static-method-destroyTip'>        /**
</span>         * Destroy the error tip instance.
         * @static
         */
        destroyTip: function() {
            this.tip = Ext.destroy(this.tip);
        }
    },

<span id='Ext-form-Labelable-event-errorchange'>    /**
</span>     * @event errorchange
     * Fires when the active error message is changed via {@link #setActiveError}.
     * @param {Ext.form.Labelable} this
     * @param {String} error The active error message
     */

<span id='Ext-form-Labelable-method-initLabelable'>    /**
</span>     * Performs initialization of this mixin. Component classes using this mixin should call this method during their
     * own initialization.
     */
    initLabelable: function() {
        var me = this,
            padding = me.padding;

        // This Component is rendered as a table. Padding doesn't work on tables
        // Before padding can be applied to the encapsulating table element, copy the padding into
        // an extraMargins property which is to be added to all computed margins post render :(
        if (padding) {
            me.padding = undefined;
            me.extraMargins = Ext.Element.parseBox(padding);
        }

        // IE8 hack for https://sencha.jira.com/browse/EXTJS-17536.
        // Need to force a relayout of the display:table form item.
        // TODO: Remove when IE8 retires.
        if (Ext.isIE8) {
            me.restoreDisplay = Ext.Function.createDelayed(me.doRestoreDisplay, 0, me);
        }

        if (!me.activeErrorsTpl) {
            if (me.msgTarget === 'title') {
                me.activeErrorsTpl = me.plaintextActiveErrorsTpl;
            } else {
                me.activeErrorsTpl = me.htmlActiveErrorsTpl;
            }
        }

        me.addCls([me.formItemCls, me.formItemCls + '-' + me.ui]);

        // Prevent first render of active error, at Field render time from signalling a change from undefined to &quot;
        me.lastActiveError = '';

        // bubbleEvents on the prototype of a mixin won't work, so call enableBubble
        me.enableBubble('errorchange');
    },

<span id='Ext-form-Labelable-method-trimLabelSeparator'>    /**
</span>     * Returns the trimmed label by slicing off the label separator character. Can be overridden.
     * @return {String} The trimmed field label, or empty string if not defined
     */
    trimLabelSeparator: function() {
        var me = this,
            separator = me.labelSeparator,
            label = me.fieldLabel || '',
            lastChar = label.substr(label.length - 1);

        // if the last char is the same as the label separator then slice it off otherwise just return label value
        return lastChar === separator ? label.slice(0, -1) : label;
    },

<span id='Ext-form-Labelable-method-getFieldLabel'>    /**
</span>     * Returns the label for the field. Defaults to simply returning the {@link #fieldLabel} config. Can be overridden
     * to provide a custom generated label.
     * @template
     * @return {String} The configured field label, or empty string if not defined
     */
    getFieldLabel: function() {
        return this.trimLabelSeparator();
    },

<span id='Ext-form-Labelable-method-setFieldLabel'>    /**
</span>     * Set the label of this field.
     * @param {String} label The new label. The {@link #labelSeparator} will be automatically appended to the label
     * string.
     */
    setFieldLabel: function(label){
        label = label || '';

        var me = this,
            separator = me.labelSeparator,
            labelEl = me.labelEl,
            errorWrapEl = me.errorWrapEl,
            sideLabel = (me.labelAlign !== 'top'),
            noLabelCls = me.noLabelCls,
            errorWrapUnderSideLabelCls = me.errorWrapUnderSideLabelCls;

        me.fieldLabel = label;
        if (me.rendered) {
            if (Ext.isEmpty(label) &amp;&amp; me.hideEmptyLabel) {
                me.addCls(noLabelCls);
                if (sideLabel &amp;&amp; errorWrapEl) {
                    errorWrapEl.removeCls(errorWrapUnderSideLabelCls);
                }
            } else {
                if (separator) {
                    label = me.trimLabelSeparator() + separator;
                }

                me.labelTextEl.dom.innerHTML = label;
                me.removeCls(noLabelCls);
                if (sideLabel &amp;&amp; errorWrapEl) {
                    errorWrapEl.addCls(errorWrapUnderSideLabelCls);
                }
            }
            me.updateLayout();
        }
    },

<span id='Ext-form-Labelable-method-setHideLabel'>    setHideLabel: function(hideLabel) {
</span>        var me = this;

        if (hideLabel !== me.hideLabel) {
            me.hideLabel = hideLabel;
            if (me.rendered) {
                me[hideLabel ? 'addCls' : 'removeCls'](me.noLabelCls);
                me.updateLayout();
            }
        }
    },

<span id='Ext-form-Labelable-method-setHideEmptyLabel'>    setHideEmptyLabel: function(hideEmptyLabel) {
</span>        var me = this,
            hide;

        if (hideEmptyLabel !== me.hideEmptyLabel) {
            me.hideEmptyLabel = hideEmptyLabel;
            if (me.rendered &amp;&amp; !me.hideLabel) {
                hide = hideEmptyLabel &amp;&amp; !me.getFieldLabel();
                me[hide ? 'addCls' : 'removeCls'](me.noLabelCls);
                me.updateLayout();
            }
        }
    },

<span id='Ext-form-Labelable-method-getInsertionRenderData'>    getInsertionRenderData: function (data, names) {
</span>        var i = names.length,
            name, value;

        while (i--) {
            name = names[i];
            value = this[name];

            if (value) {
                if (typeof value !== 'string') {
                    if (!value.isTemplate) {
                        value = Ext.XTemplate.getTpl(this, name);
                    }
                    value = value.apply(data);
                }
            }

            data[name] = value || '';
        }

        return data;
    },

<span id='Ext-form-Labelable-method-getLabelableRenderData'>    /**
</span>     * Generates the arguments for the field decorations {@link #labelableRenderTpl
     * rendering template}.
     * @param {Object} data optional object to use as the base data object.  If provided,
     * this method will add properties to the base object instead of creating a new one.
     * @return {Object} The template arguments
     * @protected
     */
    getLabelableRenderData: function() {
        var me = this,
            labelAlign = me.labelAlign,
            topLabel = (labelAlign === 'top'),
            rightLabel = (labelAlign === 'right'),
            sideError = (me.msgTarget === 'side'),
            underError = (me.msgTarget === 'under'),
            errorMsgCls = me.errorMsgCls,
            labelPad = me.labelPad,
            labelWidth = me.labelWidth,
            labelClsExtra = me.labelClsExtra || '',
            errorWrapExtraCls = sideError ? me.errorWrapSideCls : me.errorWrapUnderCls,
            labelStyle = '',
            labelInnerStyle = '',
            labelVisible = me.hasVisibleLabel(),
            autoFitErrors = me.autoFitErrors,
            defaultBodyWidth = me.defaultBodyWidth,
            bodyStyle, data;

        if (topLabel) {
            labelClsExtra += ' ' + me.topLabelCls;
            if (labelPad) {
                labelInnerStyle = 'padding-bottom:' + labelPad + 'px;';
            }
            if (sideError &amp;&amp; !autoFitErrors) {
                labelClsExtra += ' ' + me.topLabelSideErrorCls;
            }
        } else {
            if (rightLabel) {
                labelClsExtra += ' ' + me.rightLabelCls;
            }
            if (labelPad) {
                labelStyle += me.getHorizontalPaddingStyle() + labelPad + 'px;';
            }
            labelStyle += 'width:' + (labelWidth + (labelPad ? labelPad : 0)) + 'px;';
            // inner label needs width as well so that setting width on the outside
            // that is smaller than the natural width, will be ensured to take width
            // away from the body, and not the label.
            labelInnerStyle = 'width:' + labelWidth + 'px';
        }

        if (labelVisible) {
            if (!topLabel &amp;&amp; underError) {
                errorWrapExtraCls += ' ' + me.errorWrapUnderSideLabelCls;
            }
        }

        if (defaultBodyWidth) {
            // This is here to support textfield's deprecated &quot;size&quot; config
            bodyStyle = 'min-width:' + defaultBodyWidth + 'px;max-width:' +
                defaultBodyWidth + 'px;';
        }

        data = {
            id: me.id,
            inputId: me.getInputId(),
            labelCls: me.labelCls,
            labelClsExtra: labelClsExtra,
            labelStyle: labelStyle + (me.labelStyle || ''),
            labelInnerStyle: labelInnerStyle,
            labelInnerCls: me.labelInnerCls,
            labelTextCls: me.labelTextCls,
            skipLabelForAttribute: !!me.skipLabelForAttribute,
            unselectableCls: Ext.Element.unselectableCls,
            bodyStyle: bodyStyle,
            baseBodyCls: me.baseBodyCls,
            fieldBodyCls: me.fieldBodyCls,
            extraFieldBodyCls: me.extraFieldBodyCls,
            errorWrapCls: me.errorWrapCls,
            errorWrapExtraCls: errorWrapExtraCls,
            renderError: sideError || underError,
            invalidMsgCls: sideError ? me.invalidIconCls : underError ? me.invalidUnderCls : '',
            errorMsgCls: errorMsgCls,
            growCls: me.grow ? me.growCls : '',
            tipAnchorTarget: me.id + '-inputEl',
            errorWrapStyle: (sideError &amp;&amp; !autoFitErrors) ?
                    'visibility:hidden' : 'display:none',
            fieldLabel: me.getFieldLabel(),
            labelSeparator: me.labelSeparator,
            renderAriaElements: !!me.renderAriaElements,
            ariaStatus: ''
        };
        
        if (me.ariaHelp) {
            data.ariaHelp = Ext.String.htmlEncode(me.ariaHelp);
        }

        me.getInsertionRenderData(data, me.labelableInsertions);

        return data;
    },

<span id='Ext-form-Labelable-method-getHorizontalPaddingStyle'>    // hook for rtl
</span>    getHorizontalPaddingStyle: function() {
        return 'padding-right:';
    },

<span id='Ext-form-Labelable-method-beforeLabelRender'>    beforeLabelRender: function() {
</span>        var me = this;
        me.setFieldDefaults(me.getInherited().fieldDefaults);
        if (me.ownerLayout) {
            me.addCls(Ext.baseCSSPrefix + me.ownerLayout.type + '-form-item');
        }
        if (!me.hasVisibleLabel()) {
            me.addCls(me.noLabelCls);
        }
    },

<span id='Ext-form-Labelable-method-onLabelRender'>    onLabelRender: function() {
</span>        var me = this,
            style = {},
            ExtElement = Ext.Element,
            errorWrapEl = me.errorWrapEl,
            margins, side;

        if (errorWrapEl) {
            errorWrapEl.setVisibilityMode((me.msgTarget === 'side' &amp;&amp; !me.autoFitErrors) ?
                ExtElement.VISIBILITY : ExtElement.DISPLAY);
        }

        if (me.extraMargins) {
            margins = me.el.getMargin();
            for (side in margins) {
                if (margins.hasOwnProperty(side)) {
                    style['margin-' + side] = (margins[side] + me.extraMargins[side]) + 'px';
                }
            }
            me.el.setStyle(style);
        }
    },

<span id='Ext-form-Labelable-method-hasVisibleLabel'>    /**
</span>     * Checks if the field has a visible label
     * @return {Boolean} True if the field has a visible label
     */
    hasVisibleLabel: function(){
        if (this.hideLabel) {
            return false;
        }
        return !(this.hideEmptyLabel &amp;&amp; !this.getFieldLabel());
    },

<span id='Ext-form-Labelable-method-getSubTplMarkup'>    /**
</span>     * Gets the markup to be inserted into the outer template's bodyEl. Defaults to empty string, should be implemented
     * by classes including this mixin as needed.
     * @return {String} The markup to be inserted
     * @protected
     */
    getSubTplMarkup: function() {
        return '';
    },

<span id='Ext-form-Labelable-method-getInputId'>    /**
</span>     * Get the input id, if any, for this component. This is used as the &quot;for&quot; attribute on the label element.
     * Implementing subclasses may also use this as e.g. the id for their own input element.
     * @return {String} The input id
     */
    getInputId: function() {
        return '';
    },

<span id='Ext-form-Labelable-method-getActiveError'>    /**
</span>     * Gets the active error message for this component, if any. This does not trigger validation on its own, it merely
     * returns any message that the component may already hold.
     * @return {String} The active error message on the component; if there is no error, an empty string is returned.
     */
    getActiveError : function() {
        return this.activeError || '';
    },

<span id='Ext-form-Labelable-method-hasActiveError'>    /**
</span>     * Tells whether the field currently has an active error message. This does not trigger validation on its own, it
     * merely looks for any message that the component may already hold.
     * @return {Boolean}
     */
    hasActiveError: function() {
        return !!this.getActiveError();
    },

<span id='Ext-form-Labelable-method-setActiveError'>    /**
</span>     * Sets the active error message to the given string. This replaces the entire error message contents with the given
     * string. Also see {@link #setActiveErrors} which accepts an Array of messages and formats them according to the
     * {@link #activeErrorsTpl}. Note that this only updates the error message element's text and attributes, you'll
     * have to call doComponentLayout to actually update the field's layout to match. If the field extends {@link
     * Ext.form.field.Base} you should call {@link Ext.form.field.Base#markInvalid markInvalid} instead.
     * @param {String} msg The error message
     */
    setActiveError: function(msg) {
        this.setActiveErrors(msg);
    },

<span id='Ext-form-Labelable-method-getActiveErrors'>    /**
</span>     * Gets an Array of any active error messages currently applied to the field. This does not trigger validation on
     * its own, it merely returns any messages that the component may already hold.
     * @return {String[]} The active error messages on the component; if there are no errors, an empty Array is
     * returned.
     */
    getActiveErrors: function() {
        return this.activeErrors || [];
    },

<span id='Ext-form-Labelable-method-setActiveErrors'>    /**
</span>     * Set the active error message to an Array of error messages. The messages are formatted into a single message
     * string using the {@link #activeErrorsTpl}. Also see {@link #setActiveError} which allows setting the entire error
     * contents with a single string. Note that this only updates the error message element's text and attributes,
     * you'll have to call doComponentLayout to actually update the field's layout to match. If the field extends
     * {@link Ext.form.field.Base} you should call {@link Ext.form.field.Base#markInvalid markInvalid} instead.
     * @param {String[]} errors The error messages
     */
    setActiveErrors: function(errors) {
        var me = this,
            errorWrapEl = me.errorWrapEl,
            msgTarget = me.msgTarget,
            isSide = msgTarget === 'side',
            isQtip = msgTarget === 'qtip',
            ariaErrorEl = me.ariaErrorEl,
            actionEl, activeError, tpl, targetEl, ariaTpl, errStr, errText;

        errors = Ext.Array.from(errors);
        tpl = me.lookupTpl('activeErrorsTpl');

        me.activeErrors = errors;
        activeError = me.activeError = tpl.apply({
            fieldLabel: me.fieldLabel,
            errors: errors,
            listCls: Ext.baseCSSPrefix + 'list-plain'
        });

        me.renderActiveError();

        if (me.rendered) {
            actionEl = me.getActionEl();
            
            if (isSide) {
                me.errorEl.dom.setAttribute('data-errorqtip', activeError);
            }
            else if (isQtip) {
                actionEl.dom.setAttribute('data-errorqtip', activeError);
            }
            else if (msgTarget === 'title') {
                actionEl.dom.setAttribute('title', activeError);
            }

            // If msgTarget is title, setting an alert is redundant for ARIA purposes
            if (msgTarget !== 'title' &amp;&amp; ariaErrorEl) {
                ariaTpl = me.lookupTpl('ariaActiveErrorsTpl');
                errStr = ariaTpl.apply({ errors: errors });
                
                // Setting innerHTML on aria-live element will replace inner text node,
                // and the browser will fire DOM change event even if the text is the same.
                // We don't want the announcement to repeat if the text hasn't changed.
                errText = Ext.String.formatEncode(me.ariaErrorText, errStr, me.fieldLabel);
                
                if (ariaErrorEl.dom.innerHTML !== errText) {
                    ariaErrorEl.dom.innerHTML = errText;
                }
                
                // ariaStatusEl is not aria-live so it's OK to change it every time.
                // Contents will be announced only upon focusing the field.
                me.ariaStatusEl.dom.innerHTML = Ext.String.htmlEncode(errStr);
            }
            
            if (isSide || isQtip) {
                Ext.form.Labelable.initTip();
            }

            if (!me.msgTargets[msgTarget]) {
                targetEl = Ext.get(msgTarget);

                if (targetEl) {
                    targetEl.dom.innerHTML = activeError;
                }
            }
        }

        if (errorWrapEl) {
            errorWrapEl.setVisible(errors.length &gt; 0);
            if (isSide &amp;&amp; me.autoFitErrors) {
                me.labelEl.addCls(me.topLabelSideErrorCls);
            }
            me.updateLayout();
        }
    },

<span id='Ext-form-Labelable-method-unsetActiveError'>    /**
</span>     * Clears the active error message(s). Note that this only clears the error message element's text and attributes,
     * you'll have to call doComponentLayout to actually update the field's layout to match. If the field extends {@link
     * Ext.form.field.Base} you should call {@link Ext.form.field.Base#clearInvalid clearInvalid} instead.
     */
    unsetActiveError: function() {
        var me = this,
            errorWrapEl = me.errorWrapEl,
            ariaErrorEl = me.ariaErrorEl,
            msgTarget = me.msgTarget,
            restoreDisplay = me.restoreDisplay,
            actionEl, targetEl;

        if (me.hasActiveError()) {
            delete me.activeError;
            delete me.activeErrors;
            me.renderActiveError();

            if (me.rendered) {
                actionEl = me.getActionEl();
                
                if (msgTarget === 'qtip') {
                    actionEl.dom.removeAttribute('data-errorqtip');
                }
                else if (msgTarget === 'title') {
                    actionEl.dom.removeAttribute('title');
                }
                
                if (msgTarget !== 'title' &amp;&amp; ariaErrorEl) {
                    ariaErrorEl.dom.innerHTML = me.ariaStatusEl.dom.innerHTML = '';
                }

                if (!me.msgTargets[msgTarget]) {
                    targetEl = Ext.get(msgTarget);

                    if (targetEl) {
                        targetEl.dom.innerHTML = '';
                    }
                }

                if (errorWrapEl) {
                    errorWrapEl.hide();
                    if (msgTarget === 'side' &amp;&amp; me.autoFitErrors) {
                        me.labelEl.removeCls(me.topLabelSideErrorCls);
                    }
                    me.updateLayout();

                    // IE8 hack for https://sencha.jira.com/browse/EXTJS-17536.
                    // Need to force a relayout of the display:table form item.
                    // TODO: Remove when IE8 retires.
                    if (restoreDisplay) {
                        me.el.dom.style.display = 'block';
                        me.restoreDisplay();
                    }
                }
            }
        }
    },

<span id='Ext-form-Labelable-method-doRestoreDisplay'>    doRestoreDisplay: function() {
</span>        // IE8 hack for https://sencha.jira.com/browse/EXTJS-17536.
        // Need to force a relayout of the display:table form item.
        // TODO: Remove this method when IE8 retires.
        var el = this.el;
        if (el &amp;&amp; el.dom) {
            el.dom.style.display = '';
        }
    },

<span id='Ext-form-Labelable-method-renderActiveError'>    /**
</span>     * @private
     * Updates the rendered DOM to match the current activeError. This only updates the content and
     * attributes, you'll have to call doComponentLayout to actually update the display.
     */
    renderActiveError: function() {
        var me = this,
            activeError = me.getActiveError(),
            hasError = !!activeError;

        if (activeError !== me.lastActiveError) {
            me.lastActiveError = activeError;
            me.fireEvent('errorchange', me, activeError);
        }

        if (me.rendered &amp;&amp; !me.destroyed &amp;&amp; !me.preventMark) {
            me.toggleInvalidCls(hasError);
            // Update the errorEl (There will only be one if msgTarget is 'side' or 'under') with the error message text
            if (me.errorEl) {
                me.errorEl.dom.innerHTML = activeError;
            }
        }
    },

<span id='Ext-form-Labelable-method-toggleInvalidCls'>    /**
</span>     * @private
     * Add/remove invalid class(es)
     * @param {Boolean} hasError
     */
    toggleInvalidCls: function(hasError) {
        this.el[hasError ? 'addCls' : 'removeCls'](this.invalidCls);
    },

<span id='Ext-form-Labelable-method-setFieldDefaults'>    /**
</span>     * Applies a set of default configuration values to this Labelable instance. For each of the properties in the given
     * object, check if this component hasOwnProperty that config; if not then it's inheriting a default value from its
     * prototype and we should apply the default value.
     * @param {Object} defaults The defaults to apply to the object.
     */
    setFieldDefaults: function(defaults) {
        var key;

        for (key in defaults) {
            if (!this.hasOwnProperty(key)) {
                this[key] = defaults[key];
            }
        }
    }
}, function() {
    if (Ext.supports.Touch) {
        this.prototype.msgTarget = 'side';
    }
});
</pre>
</body>
</html>
