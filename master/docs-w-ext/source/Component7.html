<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-layout-component-Component'>/**
</span> * This class is intended to be extended or created via the {@link Ext.Component#componentLayout layout}
 * configuration property.  See {@link Ext.Component#componentLayout} for additional details.
 * @private
 */
Ext.define(&#39;Ext.layout.component.Component&#39;, {
    extend: &#39;Ext.layout.Layout&#39;,

<span id='Ext-layout-component-Component-property-type'>    type: &#39;component&#39;,
</span>
<span id='Ext-layout-component-Component-property-isComponentLayout'>    isComponentLayout: true,
</span>
<span id='Ext-layout-component-Component-property-nullBox'>    nullBox: {},
</span>
<span id='Ext-layout-component-Component-property-usesContentHeight'>    usesContentHeight: true,
</span><span id='Ext-layout-component-Component-property-usesContentWidth'>    usesContentWidth: true,
</span><span id='Ext-layout-component-Component-property-usesHeight'>    usesHeight: true,
</span><span id='Ext-layout-component-Component-property-usesWidth'>    usesWidth: true,
</span>
<span id='Ext-layout-component-Component-property-widthCache'>    widthCache: {},
</span><span id='Ext-layout-component-Component-property-heightCache'>    heightCache: {},
</span>
<span id='Ext-layout-component-Component-method-beginLayoutCycle'>    beginLayoutCycle: function (ownerContext, firstCycle) {
</span>        var me = this,
            owner = me.owner,
            ownerCtContext = ownerContext.ownerCtContext,
            heightModel = ownerContext.heightModel,
            widthModel = ownerContext.widthModel,
            body = owner.el.dom === document.body,
            lastBox = owner.lastBox || me.nullBox,
            lastSize = owner.el.lastBox || me.nullBox,
            dirty = !body,
            isTopLevel = ownerContext.isTopLevel,
            ownerLayout, v, width, height;

        me.callParent([ownerContext, firstCycle]);

        if (firstCycle) {
            if (me.usesContentWidth) {
                ++ownerContext.consumersContentWidth;
            }
            if (me.usesContentHeight) {
                ++ownerContext.consumersContentHeight;
            }
            if (me.usesWidth) {
                ++ownerContext.consumersWidth;
            }
            if (me.usesHeight) {
                ++ownerContext.consumersHeight;
            }

            if (ownerCtContext &amp;&amp; !ownerCtContext.hasRawContent) {
                ownerLayout = owner.ownerLayout;

                if (ownerLayout) {
                    if (ownerLayout.usesWidth) {
                        ++ownerContext.consumersWidth;
                    }
                    if (ownerLayout.usesHeight) {
                        ++ownerContext.consumersHeight;
                    }
                }
            }
        }

        // we want to publish configured dimensions as early as possible and since this is
        // a write phase...

        if (widthModel.configured) {
            // If the owner.el is the body, owner.width is not dirty (we don&#39;t want to write
            // it to the body el). For other el&#39;s, the width may already be correct in the
            // DOM (e.g., it is rendered in the markup initially). If the width is not
            // correct in the DOM, this is only going to be the case on the first cycle.
            width = owner[widthModel.names.width];
            if (isTopLevel &amp;&amp; widthModel.calculatedFrom) {
                width = lastBox.width;
            }

            if (!body) {
                dirty = me.setWidthInDom ||
                        (firstCycle ? width !== lastSize.width : widthModel.constrained);
            }

            
            ownerContext.setWidth(width, dirty);
        } else if (isTopLevel) {
            if (widthModel.calculated) {
                v = lastBox.width;
                ownerContext.setWidth(v, /*dirty=*/v !== lastSize.width);
            }

            v = lastBox.x;
            ownerContext.setProp(&#39;x&#39;, v, /*dirty=*/v !== lastSize.x);
        }

        if (heightModel.configured) {
            height = owner[heightModel.names.height];
            if (isTopLevel &amp;&amp; heightModel.calculatedFrom) {
                height = lastBox.height;
            }

            if (!body) {
                dirty = firstCycle ? height !== lastSize.height
                                   : heightModel.constrained;
            }

            ownerContext.setHeight(height, dirty);
        } else if (isTopLevel) {
            if (heightModel.calculated) {
                v = lastBox.height;
                ownerContext.setHeight(v, v !== lastSize.height);
            }

            v = lastBox.y;
            ownerContext.setProp(&#39;y&#39;, v, /*dirty=*/v !== lastSize.y);
        }
    },

<span id='Ext-layout-component-Component-method-finishedLayout'>    finishedLayout: function(ownerContext) {
</span>        var me = this,
            elementChildren = ownerContext.children,
            owner = me.owner,
            len, i, elContext, lastBox, props;

        // NOTE: In the code below we cannot use getProp because that will generate a layout dependency

        // Set lastBox on managed child Elements.
        // So that ContextItem.constructor can snag the lastBox for use by its undo method.
        if (elementChildren) {
            len = elementChildren.length;
            for (i = 0; i &lt; len; i++) {
                elContext = elementChildren[i];
                elContext.el.lastBox = elContext.props;
            }
        }

        // Cache the size from which we are changing so that notifyOwner can notify the owningComponent with all essential information
        ownerContext.previousSize = me.lastComponentSize;

        // Cache the currently layed out size
        me.lastComponentSize = owner.el.lastBox = props = ownerContext.props;
        
        // lastBox is a copy of the defined props to allow save/restore of these (panel
        // collapse needs this)
        lastBox = owner.lastBox || (owner.lastBox = {});
        lastBox.x = props.x;
        lastBox.y = props.y;
        lastBox.width = props.width;
        lastBox.height = props.height;
        lastBox.invalid = false;
        
        me.callParent([ownerContext]);
    },
    
<span id='Ext-layout-component-Component-method-notifyOwner'>    notifyOwner: function(ownerContext) {
</span>        var me = this,
            currentSize = me.lastComponentSize,
            prevSize = ownerContext.previousSize;

        me.owner.afterComponentLayout(currentSize.width, currentSize.height, 
            prevSize ? prevSize.width : undefined, prevSize ? prevSize.height : undefined);
    },

<span id='Ext-layout-component-Component-method-getTarget'>    /**
</span>     * Returns the owner component&#39;s resize element.
     * @return {Ext.dom.Element}
     */
    getTarget : function() {
        return this.owner.el;
    },

<span id='Ext-layout-component-Component-method-getRenderTarget'>    /**
</span>     * Returns the element into which rendering must take place. Defaults to the owner Component&#39;s encapsulating element.
     *
     * May be overridden in Component layout managers which implement an inner element.
     * @return {Ext.dom.Element}
     */
    getRenderTarget : function() {
        return this.owner.el;
    },

<span id='Ext-layout-component-Component-method-cacheTargetInfo'>    cacheTargetInfo: function(ownerContext) {
</span>        var me = this,
            targetInfo = me.targetInfo,
            target;

        if (!targetInfo) {
            target = ownerContext.getEl(&#39;getTarget&#39;, me);

            me.targetInfo = targetInfo = {
                padding: target.getPaddingInfo(),
                border: target.getBorderInfo()
            };
        }

        return targetInfo;
    },

<span id='Ext-layout-component-Component-method-measureAutoDimensions'>    measureAutoDimensions: function (ownerContext, dimensions) {
</span>        // Subtle But Important:
        // 
        // We don&#39;t want to call getProp/hasProp et.al. unless we in fact need that value
        // for our results! If we call it and don&#39;t need it, the layout manager will think
        // we depend on it and will schedule us again should it change.

        var me = this,
            owner = me.owner,
            containerLayout = owner.layout,
            heightModel = ownerContext.heightModel,
            widthModel = ownerContext.widthModel,
            boxParent = ownerContext.boxParent,
            isBoxParent = ownerContext.isBoxParent,
            target = ownerContext.target,
            props = ownerContext.props,
            isContainer,
            ret = {
                gotWidth: false,
                gotHeight: false,
                isContainer: (isContainer = !ownerContext.hasRawContent)
            },
            hv = dimensions || 3,
            zeroWidth, zeroHeight,
            needed = 0,
            got = 0,
            ready, size, temp, key, cache;

        // Note: this method is called *a lot*, so we have to be careful not to waste any
        // time or make useless calls or, especially, read the DOM when we can avoid it.

        //---------------------------------------------------------------------
        // Width

        if (widthModel.shrinkWrap &amp;&amp; ownerContext.consumersContentWidth) {
            ++needed;
            zeroWidth = !(hv &amp; 1); // jshint ignore:line

            if (isContainer) {
                // as a componentLayout for a container, we rely on the container layout to
                // produce contentWidth...
                if (zeroWidth) {
                    ret.contentWidth = 0;
                    ret.gotWidth = true;
                    ++got;
                } else if ((ret.contentWidth = ownerContext.getProp(&#39;contentWidth&#39;)) !== undefined) {
                    ret.gotWidth = true;
                    ++got;
                }
            } else {
                size = props.contentWidth;

                if (typeof size === &#39;number&#39;) { // if (already determined)
                    ret.contentWidth = size;
                    ret.gotWidth = true;
                    ++got;
                } else {
                    if (zeroWidth) {
                        ready = true;
                    } else if (!ownerContext.hasDomProp(&#39;containerChildrenSizeDone&#39;)) {
                        ready = false;
                    } else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
                        // if we have no boxParent, we are ready, but a shrinkWrap boxParent
                        // artificially provides width early in the measurement process so
                        // we are ready to go in that case as well...
                        ready = true;
                    } else {
                        // lastly, we have a boxParent that will be given a width, so we
                        // can wait for that width to be set in order to properly measure
                        // whatever is inside...
                        ready = boxParent.hasDomProp(&#39;width&#39;);
                    }

                    if (ready) {
                        if (zeroWidth) {
                            temp = 0;
                        } else if (containerLayout &amp;&amp; containerLayout.measureContentWidth) {
                            // Allow the container layout to do the measurement since it
                            // may have a better idea of how to do it even with no items:
                            temp = containerLayout.measureContentWidth(ownerContext);
                        } else {
                            if (target.cacheWidth) {
                                // if all instances of a given xtype/UI are the same size, only read the DOM once
                                // to measure the first instance.  Thereafter, retrieve the width from the cache.
                                key = target.xtype + &#39;-&#39; + target.ui;
                                cache = me.widthCache;
                                temp = cache[key] || (cache[key] = me.measureContentWidth(ownerContext));
                            } else {
                                temp = me.measureContentWidth(ownerContext);
                            }
                        }

                        if (!isNaN(ret.contentWidth = temp)) {
                            ownerContext.setContentWidth(temp, true);
                            ret.gotWidth = true;
                            ++got;
                        }
                    }
                }
            }
        } else if (widthModel.natural &amp;&amp; ownerContext.consumersWidth) {
            ++needed;
            size = props.width;
            // zeroWidth does not apply

            if (typeof size === &#39;number&#39;) { // if (already determined)
                ret.width = size;
                ret.gotWidth = true;
                ++got;
            } else {
                if (isBoxParent || !boxParent) {
                    ready = true;
                } else {
                    // lastly, we have a boxParent that will be given a width, so we
                    // can wait for that width to be set in order to properly measure
                    // whatever is inside...
                    ready = boxParent.hasDomProp(&#39;width&#39;);
                }

                if (ready) {
                    if (!isNaN(ret.width = me.measureOwnerWidth(ownerContext))) {
                        ownerContext.setWidth(ret.width, false);
                        ret.gotWidth = true;
                        ++got;
                    }
                }
            }
        }

        //---------------------------------------------------------------------
        // Height

        if (heightModel.shrinkWrap &amp;&amp; ownerContext.consumersContentHeight) {
            ++needed;
            zeroHeight = !(hv &amp; 2); // jshint ignore:line

            if (isContainer) {
                // don&#39;t ask unless we need to know...
                if (zeroHeight) {
                    ret.contentHeight = 0;
                    ret.gotHeight = true;
                    ++got;
                } else if ((ret.contentHeight = ownerContext.getProp(&#39;contentHeight&#39;)) !== undefined) {
                    ret.gotHeight = true;
                    ++got;
                }
            } else {
                size = props.contentHeight;

                if (typeof size === &#39;number&#39;) { // if (already determined)
                    ret.contentHeight = size;
                    ret.gotHeight = true;
                    ++got;
                } else {
                    if (zeroHeight) {
                        ready = true;
                    } else if (!ownerContext.hasDomProp(&#39;containerChildrenSizeDone&#39;)) {
                        ready = false;
                    } else if (owner.noWrap) {
                        ready = true;
                    } else if (!widthModel.shrinkWrap) {
                        // fixed width, so we need the width to determine the height...
                        ready = (ownerContext.bodyContext || ownerContext).hasDomProp(&#39;width&#39;);// &amp;&amp; (!ownerContext.bodyContext || ownerContext.bodyContext.hasDomProp(&#39;width&#39;));
                    } else if (isBoxParent || !boxParent || boxParent.widthModel.shrinkWrap) {
                        // if we have no boxParent, we are ready, but an autoWidth boxParent
                        // artificially provides width early in the measurement process so
                        // we are ready to go in that case as well...
                        ready = true;
                    } else {
                        // lastly, we have a boxParent that will be given a width, so we
                        // can wait for that width to be set in order to properly measure
                        // whatever is inside...
                        ready = boxParent.hasDomProp(&#39;width&#39;);
                    }

                    if (ready) {
                        if (zeroHeight) {
                            temp = 0;
                        } else if (containerLayout &amp;&amp; containerLayout.measureContentHeight) {
                            // Allow the container layout to do the measurement since it
                            // may have a better idea of how to do it even with no items:
                            temp = containerLayout.measureContentHeight(ownerContext);
                        } else {
                           if (target.cacheHeight) {
                                // if all instances of a given xtype/UI are the same size, only read the DOM once
                                // to measure the first instance.  Thereafter, retrieve the height from the cache.
                                key = target.xtype + &#39;-&#39; + target.ui;
                                cache = me.heightCache;
                                temp = cache[key] || (cache[key] = me.measureContentHeight(ownerContext));
                            } else {
                                temp = me.measureContentHeight(ownerContext);
                            }
                        }

                        if (!isNaN(ret.contentHeight = temp)) {
                            ownerContext.setContentHeight(temp, true);
                            ret.gotHeight = true;
                            ++got;
                        }
                    }
                }
            }
        } else if (heightModel.natural &amp;&amp; ownerContext.consumersHeight) {
            ++needed;
            size = props.height;
            // zeroHeight does not apply

            if (typeof size === &#39;number&#39;) { // if (already determined)
                ret.height = size;
                ret.gotHeight = true;
                ++got;
            } else {
                if (isBoxParent || !boxParent) {
                    ready = true;
                } else {
                    // lastly, we have a boxParent that will be given a width, so we
                    // can wait for that width to be set in order to properly measure
                    // whatever is inside...
                    ready = boxParent.hasDomProp(&#39;width&#39;);
                }

                if (ready) {
                    if (!isNaN(ret.height = me.measureOwnerHeight(ownerContext))) {
                        ownerContext.setHeight(ret.height, false);
                        ret.gotHeight = true;
                        ++got;
                    }
                }
            }
        }

        if (boxParent) {
            ownerContext.onBoxMeasured();
        }

        ret.gotAll = got === needed;
        // see if we can avoid calling this method by storing something on ownerContext.
        return ret;
    },

<span id='Ext-layout-component-Component-method-measureContentWidth'>    measureContentWidth: function (ownerContext) {
</span>        // contentWidth includes padding, but not border, framing or margins
        return ownerContext.el.getWidth() - ownerContext.getFrameInfo().width;
    },

<span id='Ext-layout-component-Component-method-measureContentHeight'>    measureContentHeight: function (ownerContext) {
</span>        // contentHeight includes padding, but not border, framing or margins
        return ownerContext.el.getHeight() - ownerContext.getFrameInfo().height;
    },

<span id='Ext-layout-component-Component-method-measureOwnerHeight'>    measureOwnerHeight: function (ownerContext) {
</span>        return ownerContext.el.getHeight();
    },

<span id='Ext-layout-component-Component-method-measureOwnerWidth'>    measureOwnerWidth: function (ownerContext) {
</span>        return ownerContext.el.getWidth();
    }
});
</pre>
</body>
</html>
