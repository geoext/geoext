<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-panel-Table'>/**
</span> * This class is the base class for both {@link Ext.tree.Panel TreePanel} and
 * {@link Ext.grid.Panel GridPanel}.
 *
 * TablePanel aggregates:
 *
 *  - a Selection Model
 *  - a View
 *  - a Store
 *  - Ext.grid.header.Container
 * 
 * @mixins Ext.grid.locking.Lockable
 */
Ext.define('Ext.panel.Table', {
    extend: 'Ext.panel.Panel',

    xtype: 'tablepanel',
    
    requires: [
        'Ext.layout.container.Fit'
    ],

    uses: [
        'Ext.selection.RowModel',
        'Ext.selection.CellModel',
        'Ext.selection.CheckboxModel',
        'Ext.grid.plugin.BufferedRenderer',
        'Ext.grid.header.Container',
        'Ext.grid.locking.Lockable',
        'Ext.grid.NavigationModel',
        'Ext.grid.RowContext'
    ],

<span id='Ext-panel-Table-property-extraBaseCls'>    extraBaseCls: Ext.baseCSSPrefix + 'grid',
</span><span id='Ext-panel-Table-property-extraBodyCls'>    extraBodyCls: Ext.baseCSSPrefix + 'grid-body',
</span><span id='Ext-panel-Table-property-actionableModeCls'>    actionableModeCls: Ext.baseCSSPrefix + 'grid-actionable',
</span><span id='Ext-panel-Table-property-noHeaderBordersCls'>    noHeaderBordersCls: Ext.baseCSSPrefix + 'no-header-borders',
</span>
<span id='Ext-panel-Table-property-defaultBindProperty'>    defaultBindProperty: 'store',
</span>
<span id='Ext-panel-Table-cfg-layout'>    layout: 'fit',
</span>
<span id='Ext-panel-Table-property-manageLayoutScroll'>    manageLayoutScroll: false,
</span>
<span id='Ext-panel-Table-property-ariaRole'>    ariaRole: 'presentation',
</span>
    config: {
<span id='Ext-panel-Table-cfg-selection'>        /**
</span>         * @cfg {Ext.data.Model} selection
         * The selected model. Typically used with {@link #bind binding}.
         */
        selection: null,

<span id='Ext-panel-Table-cfg-record'>        /**
</span>         * @cfg {Ext.grid.CellContext/Ext.data.Model/Number} record
         * The focused cell, model or index. Typically used with {@link #bind binding}.
         *
         * If bound to a record (such as a selection), the first cell will be focused.
         */
        focused: null,

<span id='Ext-panel-Table-cfg-headerBorders'>        /**
</span>         * @cfg {Boolean} [headerBorders=`true`]
         * To show no borders around grid headers, configure this as `false`.
         */
        headerBorders: true,

<span id='Ext-panel-Table-cfg-hideHeaders'>        /**
</span>         * @cfg {Boolean} [hideHeaders]
         * By default, visibility of headers is managed automatically based upon
         * whether there is textual content to display.
         * This configuration is only necessary if you want to disable automatic
         * header visibility management.
         *
         * If no columns have a {@link Ext.grid.column.Column#title text} config
         * (for example in the case of a {@link Ext.tree.Panel TreePanel} with no
         * columns specified), and no columns have {@link Ext.grid.column.Column#columns child columns}
         * then headers are hidden.
         *
         * If this status changes - if the column set ever goes from none having
         * text, to one having text or vice versa), then the visibility of headers
         * will be recalculated.
         *
         * Configure as `true` to hide column headers. Configure as `false` to show
         * column headers even if none of them have text.
         *
         */
        hideHeaders: null
    },

<span id='Ext-panel-Table-cfg-publishes'>    publishes: ['selection'],
</span><span id='Ext-panel-Table-cfg-twoWayBindable'>    twoWayBindable: ['selection'],
</span>
<span id='Ext-panel-Table-cfg-autoLoad'>    /**
</span>     * @cfg {Boolean} [autoLoad=false]
     * Use `true` to load the store as soon as this component is fully constructed. It is
     * best to initiate the store load this way to allow this component and potentially
     * its plugins (such as `{@link Ext.grid.filters.Filters}`) to be ready to load.
     */
    autoLoad: false,

<span id='Ext-panel-Table-cfg-variableRowHeight'>    /**
</span>     * @cfg {Boolean} [variableRowHeight=false]
     * @deprecated 5.0.0 Use {@link Ext.grid.column.Column#variableRowHeight} instead.
     * Configure as `true` if the row heights are not all the same height as the first row.
     */
    variableRowHeight: false,

<span id='Ext-panel-Table-cfg-numFromEdge'>    /**
</span>     * @cfg {Number} [numFromEdge]
     * This configures the zone which causes new rows to be appended to the view. As soon as the edge
     * of the rendered grid is this number of rows from the edge of the viewport, the view is moved.
     */
    numFromEdge: 2,

<span id='Ext-panel-Table-cfg-trailingBufferZone'>    /**
</span>     * @cfg {Number} [trailingBufferZone]
     * TableViews are buffer rendered in 5.x and above which means that only the visible subset of data rows
     * are rendered into the DOM. These are removed and added as scrolling demands.
     *
     * This configures the number of extra rows to render on the trailing side of scrolling
     * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
     */
    trailingBufferZone: 10,

<span id='Ext-panel-Table-cfg-leadingBufferZone'>    /**
</span>     * @cfg {Number} [leadingBufferZone]
     * TableViews are buffer rendered in 5.x and above which means that only the visible subset of data rows
     * are rendered into the DOM. These are removed and added as scrolling demands.
     *
     * This configures the number of extra rows to render on the leading side of scrolling
     * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
     */
    leadingBufferZone: 20,

<span id='Ext-panel-Table-property-hasView'>    /**
</span>     * @property {Boolean} hasView
     * True to indicate that a view has been injected into the panel.
     */
    hasView: false,

<span id='Ext-panel-Table-property-items'>    /**
</span>     * @property items
     * @hide
     */

<span id='Ext-panel-Table-cfg-viewType'>    /**
</span>     * @cfg {String} viewType
     * An xtype of view to use. This is automatically set to 'tableview' by {@link Ext.grid.Panel Grid}
     * and to 'treeview' by {@link Ext.tree.Panel Tree}.
     * @protected
     */
    viewType: null,

<span id='Ext-panel-Table-cfg-viewConfig'>    /**
</span>     * @cfg {Object} viewConfig
     * A config object that will be applied to the grid's UI view. Any of the config options available for
     * {@link Ext.view.Table} can be specified here. This option is ignored if {@link #view} is specified.
     */

<span id='Ext-panel-Table-cfg-rowViewModel'>     /**
</span>     * @cfg {String/Object} rowViewModel
     * The type or a config object specifying the type of the ViewModel to instantiate when creating ViewModels for records
     * to which {@link Ext.grid.column.Widget widgets in widget columns}, and widgets in a
     * {@link Ext.grid.plugin.RowWidget RowWidget} row bind.
     */

<span id='Ext-panel-Table-cfg-view'>    /**
</span>     * @cfg {Ext.view.Table} view
     * The {@link Ext.view.Table} used by the grid. Use {@link #viewConfig} to just supply some config options to
     * view (instead of creating an entire View instance).
     */

<span id='Ext-panel-Table-cfg-selType'>    /**
</span>     * @cfg {String} [selType]
     * An xtype of selection model to use. This is used to create selection model if just
     * a config object or nothing at all given in {@link #selModel} config.
     *
     * @deprecated 5.1.0 Use the {@link #selModel}'s `type` property. Or, if no other
     * configs are required, use the string form of selModel.
     */

<span id='Ext-panel-Table-cfg-selModel'>    /**
</span>     * @cfg {Ext.selection.Model/Object/String} [selModel=rowmodel]
     * A {@link Ext.selection.Model selection model} instance or config object, or the selection model class's alias string.
     *
     * In latter case its `type` property determines to which type of selection model this config is applied.
     */

<span id='Ext-panel-Table-cfg-multiSelect'>    /**
</span>     * @cfg {Boolean} [multiSelect=false]
     * True to enable 'MULTI' selection mode on selection model.
     * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} 'MULTI' instead.
     */

<span id='Ext-panel-Table-cfg-simpleSelect'>    /**
</span>     * @cfg {Boolean} [simpleSelect=false]
     * True to enable 'SIMPLE' selection mode on selection model.
     * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} 'SIMPLE' instead.
     */

<span id='Ext-panel-Table-cfg-store'>    /**
</span>     * @cfg {Ext.data.Store/String/Object} store (required)
     * The data source to which the grid / tree is bound. Acceptable values for this 
     * property are:
     *
     *   - **any {@link Ext.data.Store Store} class / subclass**
     *   - **an {@link Ext.data.Store#storeId ID of a store}**
     *   - **a {@link Ext.data.Store Store} config object**.  When passing a config you can 
     *   specify the store type by alias.  Passing a config object with a store type will 
     *   dynamically create a new store of that type when the grid / tree is instantiated.
     *
     * For example:
     * 
     *     Ext.define('MyApp.store.Customers', {
     *         extend: 'Ext.data.Store',
     *         alias: 'store.customerstore',
     *         fields: ['name']
     *     });
     *     
     *     Ext.create({
     *         xtype: 'gridpanel',
     *         renderTo: document.body,
     *         store: {
     *             type: 'customerstore',
     *             data: [{
     *                 name: 'Foo'
     *             }]
     *         },
     *         columns: [{
     *             text: 'Name',
     *             dataIndex: 'name'
     *         }]
     *     });
     */

<span id='Ext-panel-Table-cfg-scroll'>    /**
</span>     * @cfg {String/Boolean} scroll
     * Scrollers configuration. Valid values are 'both', 'horizontal' or 'vertical'.
     * True implies 'both'. False implies 'none'.
     * @deprecated 5.1.0 Use {@link #scrollable} instead
     */

<span id='Ext-panel-Table-cfg-reserveScrollbar'>    /**
</span>     * @cfg {Boolean} [reserveScrollbar=false]
     * Set this to true to **always** leave a scrollbar sized space at the end of the grid content when
     * fitting content into the width of the grid.
     *
     * If the grid's record count fluctuates enough to hide and show the scrollbar regularly, this setting
     * avoids the multiple layouts associated with switching from scrollbar present to scrollbar not present.
     */

<span id='Ext-panel-Table-cfg-columns'>    /**
</span>     * @cfg {Ext.grid.column.Column[]/Object} columns
     * An array of {@link Ext.grid.column.Column column} definition objects which define all columns that appear in this
     * grid. Each column definition provides the header text for the column, and a definition of where the data for that
     * column comes from.
     *
     * This can also be a configuration object for a {@link Ext.grid.header.Container HeaderContainer} which may override
     * certain default configurations if necessary. For example, the special layout may be overridden to use a simpler
     * layout, or one can set default values shared by all columns:
     * 
     *     columns: {
     *         items: [
     *             {
     *                 text: &quot;Column A&quot;,
     *                 dataIndex: &quot;field_A&quot;
     *             },{
     *                 text: &quot;Column B&quot;,
     *                 dataIndex: &quot;field_B&quot;
     *             }, 
     *             ...
     *         ],
     *         defaults: {
     *             flex: 1
     *         }
     *     }
     */

<span id='Ext-panel-Table-cfg-forceFit'>    /**
</span>     * @cfg {Boolean} forceFit
     * True to force the columns to fit into the available width. Headers are first sized according to configuration,
     * whether that be a specific width, or flex. Then they are all proportionally changed in width so that the entire
     * content width is used. For more accurate control, it is more optimal to specify a flex setting on the columns
     * that are to be stretched &amp; explicit widths on columns that are not.
     */

<span id='Ext-panel-Table-cfg-features'>    /**
</span>     * @cfg {Ext.grid.feature.Feature[]/Object[]/Ext.enums.Feature[]} features
     * An array of grid Features to be added to this grid. Can also be just a single feature instead of array.
     *
     * Features config behaves much like {@link #plugins}.
     * A feature can be added by either directly referencing the instance:
     *
     *     features: [Ext.create('Ext.grid.feature.GroupingSummary', {groupHeaderTpl: 'Subject: {name}'})],
     *
     * By using config object with ftype:
     *
     *     features: [{ftype: 'groupingsummary', groupHeaderTpl: 'Subject: {name}'}],
     *
     * Or with just a ftype:
     *
     *     features: ['grouping', 'groupingsummary'],
     *
     * See {@link Ext.enums.Feature} for list of all ftypes.
     */

<span id='Ext-panel-Table-cfg-deferRowRender'>    /**
</span>     * @cfg {Boolean} [deferRowRender=false]
     * Configure as `true` to enable deferred row rendering.
     *
     * This allows the View to execute a refresh quickly, with the update of the row structure deferred so
     * that layouts with GridPanels appear, and lay out more quickly.
     */
    deferRowRender: false,
     
<span id='Ext-panel-Table-cfg-sortableColumns'>    /**
</span>     * @cfg {Boolean} [sortableColumns=true]
     * False to disable column sorting via clicking the header and via the Sorting menu items.
     */
    sortableColumns: true,

<span id='Ext-panel-Table-cfg-multiColumnSort'>    /**
</span>     * @cfg {Boolean} [multiColumnSort=false]
     * Configure as `true` to have columns remember their sorted state after other columns have been clicked upon to sort.
     *
     * As subsequent columns are clicked upon, they become the new primary sort key.
     *
     * The maximum number of sorters allowed in a Store is configurable via its underlying data collection. See {@link Ext.util.Collection#multiSortLimit}
     */
    multiColumnSort: false,

<span id='Ext-panel-Table-cfg-enableLocking'>    /**
</span>     * @cfg {Boolean} [enableLocking=false]
     * Configure as `true` to enable locking support for this grid. Alternatively, locking will also be automatically
     * enabled if any of the columns in the {@link #columns columns} configuration contain a {@link Ext.grid.column.Column#locked locked} config option.
     * 
     * A locking grid is processed in a special way. The configuration options are cloned and *two* grids are created to be the locked (left) side
     * and the normal (right) side. This Panel becomes merely a {@link Ext.container.Container container} which arranges both in an {@link Ext.layout.container.HBox HBox} layout.
     * 
     * {@link #plugins Plugins} may be targeted at either locked, or unlocked grid, or, both, in which case the plugin is cloned and used on both sides.
     * 
     * Plugins may also be targeted at the containing locking Panel.
     * 
     * This is configured by specifying a `lockableScope` property in your plugin which may have the following values:
     * 
     *  * `&quot;both&quot;` (the default) - The plugin is added to both grids
     *  * `&quot;top&quot;` - The plugin is added to the containing Panel
     *  * `&quot;locked&quot;` - The plugin is added to the locked (left) grid
     *  * `&quot;normal&quot;` - The plugin is added to the normal (right) grid
     *
     * If `both` is specified, then each copy of the plugin gains a property `lockingPartner` which references its sibling on the other side so that they
     * can synchronize operations is necessary.
     * 
     * {@link #features Features} may also be configured with `lockableScope` and may target the locked grid, the normal grid or both grids. Features
     * also get a `lockingPartner` reference injected.
     */
    enableLocking: false,

<span id='Ext-panel-Table-property-scrollerOwner'>    /**
</span>     * @private
     * Used to determine where to go down to find views
     * this is here to support locking.
     */
    scrollerOwner: true,

<span id='Ext-panel-Table-cfg-enableColumnMove'>    /**
</span>     * @cfg {Boolean} [enableColumnMove=true]
     * False to disable column dragging within this grid.
     */
    enableColumnMove: true,
    
<span id='Ext-panel-Table-cfg-sealedColumns'>    /**
</span>     * @cfg {Boolean} [sealedColumns=false]
     * True to constrain column dragging so that a column cannot be dragged in or out of it's
     * current group. Only relevant while {@link #enableColumnMove} is enabled.
     */
    sealedColumns: false,

<span id='Ext-panel-Table-cfg-enableColumnResize'>    /**
</span>     * @cfg {Boolean} [enableColumnResize=true]
     * False to disable column resizing within this grid.
     */
    enableColumnResize: true,

<span id='Ext-panel-Table-cfg-enableColumnHide'>    /**
</span>     * @cfg {Boolean} [enableColumnHide=true]
     * False to disable column hiding within this grid.
     */

<span id='Ext-panel-Table-cfg-columnLines'>    /**
</span>     * @cfg {Boolean} columnLines Adds column line styling
     */

<span id='Ext-panel-Table-cfg-rowLines'>    /**
</span>     * @cfg {Boolean} [rowLines=true] Adds row line styling
     */
    rowLines: true,

<span id='Ext-panel-Table-cfg-disableSelection'>    /**
</span>     * @cfg {Boolean} [disableSelection=false]
     * True to disable selection model.
     */

<span id='Ext-panel-Table-cfg-emptyText'>    /**
</span>     * @cfg {String} emptyText Default text (HTML tags are accepted) to display in the 
     * Panel body when the Store is empty. When specified, and the Store is empty, the 
     * text will be rendered inside a DIV with the CSS class &quot;x-grid-empty&quot;. The emptyText 
     * will not display until the first load of the associated store by default. If you 
     * want the text to be displayed prior to the first store load use the 
     * {@link Ext.view.Table#deferEmptyText deferEmptyText} config in the {@link #viewConfig} config.
     */
    
<span id='Ext-panel-Table-cfg-allowDeselect'>    /**
</span>     * @cfg {Boolean} [allowDeselect=false]
     * True to allow deselecting a record. This config is forwarded to {@link Ext.selection.Model#allowDeselect}.
     */
    
<span id='Ext-panel-Table-cfg-bufferedRenderer'>    /**
</span>     * @cfg {Boolean} [bufferedRenderer=true]
     * Buffered rendering is enabled by default.
     * 
     * Configure as `false` to disable buffered rendering. See {@link Ext.grid.plugin.BufferedRenderer}.
     *
     * @since 5.0.0
     */
    bufferedRenderer: true,

<span id='Ext-panel-Table-cfg-stateEvents'>    /**
</span>     * @cfg stateEvents
     * @inheritdoc Ext.state.Stateful#cfg-stateEvents
     * @localdoc By default the following stateEvents are added:
     * 
     *  - {@link #event-resize} - _(added by Ext.Component)_
     *  - {@link #event-collapse} - _(added by Ext.panel.Panel)_
     *  - {@link #event-expand} - _(added by Ext.panel.Panel)_
     *  - {@link #event-columnresize}
     *  - {@link #event-columnmove}
     *  - {@link #event-columnhide}
     *  - {@link #event-columnshow}
     *  - {@link #event-sortchange}
     *  - {@link #event-filterchange}
     *  - {@link #event-groupchange}
     */

<span id='Ext-panel-Table-property-optimizedColumnMove'>    /**
</span>     * @property {Boolean} optimizedColumnMove
     * If you are writing a grid plugin or a {Ext.grid.feature.Feature Feature} which creates a column-based structure which
     * needs a view refresh when columns are moved, then set this property in the grid.
     *
     * An example is the built in {@link Ext.grid.feature.AbstractSummary Summary} Feature. This creates summary rows, and the
     * summary columns must be in the same order as the data columns. This plugin sets the `optimizedColumnMove` to `false.
     */

<span id='Ext-panel-Table-property-ownerGrid'>    /**
</span>     * @property {Ext.panel.Table} ownerGrid
     * A reference to the top-level owning grid component.
     * 
     * This is a reference to this GridPanel if this GridPanel is not part of a locked grid arrangement.
     * @readonly
     * @private
     * @since 5.0.0
     */
    ownerGrid: null,

<span id='Ext-panel-Table-property-colLinesCls'>    colLinesCls: Ext.baseCSSPrefix + 'grid-with-col-lines',
</span><span id='Ext-panel-Table-property-rowLinesCls'>    rowLinesCls: Ext.baseCSSPrefix + 'grid-with-row-lines',
</span><span id='Ext-panel-Table-property-noRowLinesCls'>    noRowLinesCls: Ext.baseCSSPrefix + 'grid-no-row-lines',
</span><span id='Ext-panel-Table-property-hiddenHeaderCtCls'>    hiddenHeaderCtCls: Ext.baseCSSPrefix + 'grid-header-ct-hidden',
</span><span id='Ext-panel-Table-property-hiddenHeaderCls'>    hiddenHeaderCls: Ext.baseCSSPrefix + 'grid-header-hidden',
</span><span id='Ext-panel-Table-property-resizeMarkerCls'>    resizeMarkerCls: Ext.baseCSSPrefix + 'grid-resize-marker',
</span><span id='Ext-panel-Table-property-emptyCls'>    emptyCls: Ext.baseCSSPrefix + 'grid-empty',
</span>
<span id='Ext-panel-Table-property-focusable'>    // The TablePanel claims to be focusable, but it does not place a tabIndex
</span>    // on any of its elements.
    // Its focus implementation delegates to its view. TableViews are focusable.
    focusable: true,

<span id='Ext-panel-Table-event-viewready'>    /**
</span>     * @event viewready
     * Fires when the grid view is available (use this for selecting a default row).
     * @param {Ext.panel.Table} this
     */

    constructor: function (config) {
        var me = this,
            topGrid = config &amp;&amp; config.ownerGrid,
            store;

        me.ownerGrid = topGrid || me;

<span id='Ext-panel-Table-property-actionables'>        /**
</span>         * @property {Array} actionables An array of objects which register themselves with a grid panel using
         * {@link #registerActionable} which are consulted upon entry into actionable mode.
         *
         * These must implement the following methods:
         *
         *    - activateCell Called when actionable mode is requested upon a cell. A {@link Ext.grid.CellContext CellContext}
         *    object is passed. If that cell is actionable by the terms of the callee, the callee should return `true` if it
         *    ascertains that the cell is actionable, and that it now contains focusable elements which may be tabbed to. 
         *    - activateRow Called when the user enters actionable mode in a row. The row DOM is passed. Actionables
         *    should take any action they need to prime the row for cell activation which happens as users TAB from cell to cell.
         * @readonly
         */
        me.actionables = topGrid ? topGrid.actionables : []; // One shared array when there's a lockable at the top

        me.callParent([config]);

        store = me.store;

        // Any further changes become stateful.
        store.trackStateChanges = true;

        if (me.autoLoad) {
            // Note: if there is a store bound by a VM, we (might) do the load in #setStore.
            if (!store.isEmptyStore) {
                store.load();
            }
        }
    },

<span id='Ext-panel-Table-method-registerActionable'>    /**
</span>     * 
     * @param {Object} actionable An object which has an interest in the implementation of actionable mode in
     * this grid.
     *
     * An actionable object may be a Plugin which upon activation injects tabbable elements or Components into
     * a grid row.
     */
    registerActionable: function(actionable) {
        // If a lockableScope: 'both' plugin/feature registers on each side, only include it in the actionables once.
        Ext.Array.include(this.actionables, actionable);
    },

<span id='Ext-panel-Table-method-initComponent'>    initComponent: function() {
</span>        //&lt;debug&gt;
        if (this.verticalScroller) {
            Ext.raise(&quot;The verticalScroller config is not supported.&quot;);
        }
        if (!this.viewType) {
            Ext.raise(&quot;You must specify a viewType config.&quot;);
        }
        if (this.headers) {
            Ext.raise(&quot;The headers config is not supported. Please specify columns instead.&quot;);
        }
        //&lt;/debug&gt;

        var me = this,
            headerCtCfg = me.columns || me.colModel || [],
            store, view, i, len, bufferedRenderer, columns, viewScroller, headerCt, headerCtScroller;

        // Look up the configured Store. If none configured, use the fieldless, empty Store
        // defined in Ext.data.Store.
        store = me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store');
        
        me.enableLocking = me.enableLocking || me.hasLockedColumns(headerCtCfg);

        // Construct the plugins now rather than in the constructor of AbstractComponent because the component may have a subclass
        // that has overridden initComponent and defined plugins in it. For plugins like RowExpander that rely upon a grid feature,
        // this is a problem because the view needs to know about all its features before it's constructed. Constructing the plugins
        // now ensures that plugins defined in the instance config or in initComponent are all constructed before the view.
        // See EXTJSIV-11927.
        //
        // Note that any components that do not inherit from this class will still have their plugins constructed in
        // AbstractComponent:initComponent.
        if (me.plugins) {
            me.plugins = me.constructPlugins();
        }

        // Add the row/column line classes to the body element so that the settings are not inherited by docked grids (https://sencha.jira.com/browse/EXTJSIV-9263).
        if (me.columnLines) {
            me.addBodyCls(me.colLinesCls);
        }

        me.addBodyCls(me.rowLines ? me.rowLinesCls : me.noRowLinesCls);
        me.addBodyCls(me.extraBodyCls);

        // If any of the Column objects contain a locked property, and are not processed, this is a lockable TablePanel, a
        // special view will be injected by the Ext.grid.locking.Lockable mixin, so no processing of .
        if (me.enableLocking) {
            me.self.mixin('lockable', Ext.grid.locking.Lockable);
            me.injectLockable();
            headerCt = me.headerCt;
        }
        // Not lockable - create the HeaderContainer
        else {
            // It's a fully instantiated HeaderContainer
            if (headerCtCfg.isRootHeader) {
                me.headerCt = headerCt = headerCtCfg;
                headerCt.grid = me;
                headerCt.forceFit = !!me.forceFit;
                headerCt.$initParent = me;

                // If it's an instance then the column managers were already created and bound to the headerCt.
                me.columnManager = headerCt.columnManager;
                me.visibleColumnManager = headerCt.visibleColumnManager;
            }
            // It's an array of Column definitions, or a config object of a HeaderContainer
            else {
                if (Ext.isArray(headerCtCfg)) {
                    headerCtCfg = {
                        items: headerCtCfg
                    };
                }
                me.headerCt = headerCt = new Ext.grid.header.Container(Ext.apply(headerCtCfg, {
                    grid: me,
                    $initParent: me,
                    forceFit: me.forceFit,
                    sortable: me.sortableColumns,
                    enableColumnMove: me.enableColumnMove,
                    enableColumnResize: me.enableColumnResize,
                    columnLines: me.columnLines,
                    sealed: me.sealedColumns
                }));
            }

            if (Ext.isDefined(me.enableColumnHide)) {
                headerCt.enableColumnHide = me.enableColumnHide;
            }
        }

        // Maintain backward compatibiliy by providing the initial leaf column set as a property.
        me.columns = columns = headerCt.getGridColumns();

        me.scrollTask = new Ext.util.DelayedTask(me.syncHorizontalScroll, me);

        me.cls = (me.cls || '') + (' ' + me.extraBaseCls);

        // autoScroll is not a valid configuration
        delete me.autoScroll;

        bufferedRenderer = me.plugins &amp;&amp; Ext.Array.findBy(me.plugins, function(p) {
            return p.isBufferedRenderer;
        });

        // If we find one in the plugins, just use that.
        if (bufferedRenderer) {
            me.bufferedRenderer = bufferedRenderer;
        }

        // If this TablePanel is lockable (Either configured lockable, or any of the defined columns has a 'locked' property)
        // then a special lockable view containing 2 side-by-side grids will have been injected so we do not need to set up any UI.
        if (!me.hasView) {

            // If the store is paging blocks of the dataset in, then it can only be sorted remotely.
            // And if the store is not remoteSort, then we cannot sort it at all.
            if (store.isBufferedStore &amp;&amp; !store.getRemoteSort()) {
                for (i = 0, len = columns.length; i &lt; len; i++) {
                    columns[i].sortable = false;
                }
            }

            me.relayHeaderCtEvents(headerCt);
            me.features = me.features || [];
            if (!Ext.isArray(me.features)) {
                me.features = [me.features];
            }
            me.dockedItems = [].concat(me.dockedItems || []);
            me.dockedItems.unshift(headerCt);
            me.viewConfig = me.viewConfig || {};

            // AbstractDataView will look up a Store configured as an object
            // getView converts viewConfig into a View instance
            view = me.getView();

            me.items = [view];
            me.hasView = true;

            // Attach this Panel to the Store
            me.bindStore(store, true);

            me.mon(view, {
                viewready: me.onViewReady,
                refresh: me.onRestoreHorzScroll,
                scope: me
            });

            // Decide upon hideHeaders configuration based on columns having content or not.
            // Scroll syncing will be set up with the view's scroller if headers are visible.
            me.syncHeaderVisibility();
        }

        // Whatever kind of View we have, be it a TableView, or a LockingView, we are interested in the selection model
        me.selModel = me.view.getSelectionModel();

        // We update the bound selection whenever the selectionchange event fires.
        // Even a CellModel, or a SpreadsheetModel in cell selection mode can yield
        // the *records* that are selected, and it is the first record which is published
        // to the selection property.
        me.selModel.on({
            scope: me,
            lastselectedchanged: me.updateBindSelection,
            selectionchange: me.updateBindSelection
        });

        // Relay events from the View whether it be a LockingView, or a regular GridView
        me.relayEvents(me.view, [
<span id='Ext-panel-Table-event-beforeitemlongpress'>            /**
</span>             * @event beforeitemlongpress
             * @inheritdoc Ext.view.View#beforeitemlongpress
             */
             'beforeitemlongpress',
<span id='Ext-panel-Table-event-beforeitemmousedown'>            /**
</span>             * @event beforeitemmousedown
             * @inheritdoc Ext.view.View#beforeitemmousedown
             */
            'beforeitemmousedown',
<span id='Ext-panel-Table-event-beforeitemmouseup'>            /**
</span>             * @event beforeitemmouseup
             * @inheritdoc Ext.view.View#beforeitemmouseup
             */
            'beforeitemmouseup',
<span id='Ext-panel-Table-event-beforeitemmouseenter'>            /**
</span>             * @event beforeitemmouseenter
             * @inheritdoc Ext.view.View#beforeitemmouseenter
             */
            'beforeitemmouseenter',
<span id='Ext-panel-Table-event-beforeitemmouseleave'>            /**
</span>             * @event beforeitemmouseleave
             * @inheritdoc Ext.view.View#beforeitemmouseleave
             */
            'beforeitemmouseleave',
<span id='Ext-panel-Table-event-beforeitemclick'>            /**
</span>             * @event beforeitemclick
             * @inheritdoc Ext.view.View#beforeitemclick
             */
            'beforeitemclick',
<span id='Ext-panel-Table-event-beforeitemdblclick'>            /**
</span>             * @event beforeitemdblclick
             * @inheritdoc Ext.view.View#beforeitemdblclick
             */
            'beforeitemdblclick',
<span id='Ext-panel-Table-event-beforeitemcontextmenu'>            /**
</span>             * @event beforeitemcontextmenu
             * @inheritdoc Ext.view.View#beforeitemcontextmenu
             */
            'beforeitemcontextmenu',
<span id='Ext-panel-Table-event-itemlongpress'>            /**
</span>             * @event itemlongpress
             * @inheritdoc Ext.view.View#itemlongpress
             */
            'itemlongpress',
<span id='Ext-panel-Table-event-itemmousedown'>            /**
</span>             * @event itemmousedown
             * @inheritdoc Ext.view.View#itemmousedown
             */
            'itemmousedown',
<span id='Ext-panel-Table-event-itemmouseup'>            /**
</span>             * @event itemmouseup
             * @inheritdoc Ext.view.View#itemmouseup
             */
            'itemmouseup',
<span id='Ext-panel-Table-event-itemmouseenter'>            /**
</span>             * @event itemmouseenter
             * @inheritdoc Ext.view.View#itemmouseenter
             */
            'itemmouseenter',
<span id='Ext-panel-Table-event-itemmouseleave'>            /**
</span>             * @event itemmouseleave
             * @inheritdoc Ext.view.View#itemmouseleave
             */
            'itemmouseleave',
<span id='Ext-panel-Table-event-itemclick'>            /**
</span>             * @event itemclick
             * @inheritdoc Ext.view.View#itemclick
             */
            'itemclick',
<span id='Ext-panel-Table-event-itemdblclick'>            /**
</span>             * @event itemdblclick
             * @inheritdoc Ext.view.View#itemdblclick
             */
            'itemdblclick',
<span id='Ext-panel-Table-event-itemcontextmenu'>            /**
</span>             * @event itemcontextmenu
             * @inheritdoc Ext.view.View#itemcontextmenu
             */
            'itemcontextmenu',
<span id='Ext-panel-Table-event-beforecellclick'>            /**
</span>             * @event beforecellclick
             * @inheritdoc Ext.view.Table#beforecellclick
             */
            'beforecellclick',
<span id='Ext-panel-Table-event-cellclick'>            /**
</span>             * @event cellclick
             * @inheritdoc Ext.view.Table#cellclick
             */
            'cellclick',
<span id='Ext-panel-Table-event-beforecelldblclick'>            /**
</span>             * @event beforecelldblclick
             * @inheritdoc Ext.view.Table#beforecelldblclick
             */
            'beforecelldblclick',
<span id='Ext-panel-Table-event-celldblclick'>            /**
</span>             * @event celldblclick
             * @inheritdoc Ext.view.Table#celldblclick
             */
            'celldblclick',
<span id='Ext-panel-Table-event-beforecellcontextmenu'>            /**
</span>             * @event beforecellcontextmenu
             * @inheritdoc Ext.view.Table#beforecellcontextmenu
             */
            'beforecellcontextmenu',
<span id='Ext-panel-Table-event-cellcontextmenu'>            /**
</span>             * @event cellcontextmenu
             * @inheritdoc Ext.view.Table#cellcontextmenu
             */
            'cellcontextmenu',
<span id='Ext-panel-Table-event-beforecellmousedown'>            /**
</span>             * @event beforecellmousedown
             * @inheritdoc Ext.view.Table#beforecellmousedown
             */
            'beforecellmousedown',
<span id='Ext-panel-Table-event-cellmousedown'>            /**
</span>             * @event cellmousedown
             * @inheritdoc Ext.view.Table#cellmousedown
             */
            'cellmousedown',
<span id='Ext-panel-Table-event-beforecellmouseup'>            /**
</span>             * @event beforecellmouseup
             * @inheritdoc Ext.view.Table#beforecellmouseup
             */
            'beforecellmouseup',
<span id='Ext-panel-Table-event-cellmouseup'>            /**
</span>             * @event cellmouseup
             * @inheritdoc Ext.view.Table#cellmouseup
             */
            'cellmouseup',
<span id='Ext-panel-Table-event-beforecellkeydown'>            /**
</span>             * @event beforecellkeydown
             * @inheritdoc Ext.view.Table#beforecellkeydown
             */
            'beforecellkeydown',
<span id='Ext-panel-Table-event-cellkeydown'>            /**
</span>             * @event cellkeydown
             * @inheritdoc Ext.view.Table#cellkeydown
             */
            'cellkeydown',
<span id='Ext-panel-Table-event-rowclick'>            /**
</span>             * @event rowclick
             * @inheritdoc Ext.view.Table#rowclick
             */
            'rowclick',
<span id='Ext-panel-Table-event-rowdblclick'>            /**
</span>             * @event rowdblclick
             * @inheritdoc Ext.view.Table#rowdblclick
             */
            'rowdblclick',
<span id='Ext-panel-Table-event-rowcontextmenu'>            /**
</span>             * @event rowcontextmenu
             * @inheritdoc Ext.view.Table#rowcontextmenu
             */
            'rowcontextmenu',
<span id='Ext-panel-Table-event-rowmousedown'>            /**
</span>             * @event rowmousedown
             * @inheritdoc Ext.view.Table#rowmousedown
             */
            'rowmousedown',
<span id='Ext-panel-Table-event-rowmouseup'>            /**
</span>             * @event rowmouseup
             * @inheritdoc Ext.view.Table#rowmouseup
             */
            'rowmouseup',
<span id='Ext-panel-Table-event-rowkeydown'>            /**
</span>             * @event rowkeydown
             * @inheritdoc Ext.view.Table#rowkeydown
             */
            'rowkeydown',
<span id='Ext-panel-Table-event-beforeitemkeydown'>            /**
</span>             * @event beforeitemkeydown
             * @inheritdoc Ext.view.Table#beforeitemkeydown
             */
            'beforeitemkeydown',
<span id='Ext-panel-Table-event-itemkeydown'>            /**
</span>             * @event itemkeydown
             * @inheritdoc Ext.view.Table#itemkeydown
             */
            'itemkeydown',
<span id='Ext-panel-Table-event-beforeitemkeyup'>            /**
</span>             * @event beforeitemkeyup
             * @inheritdoc Ext.view.Table#beforeitemkeyup
             */
            'beforeitemkeyup',
<span id='Ext-panel-Table-event-itemkeyup'>            /**
</span>             * @event itemkeyup
             * @inheritdoc Ext.view.Table#itemkeyup
             */
            'itemkeyup',
<span id='Ext-panel-Table-event-beforeitemkeypress'>            /**
</span>             * @event beforeitemkeypress
             * @inheritdoc Ext.view.Table#beforeitemkeypress
             */
            'beforeitemkeypress',
<span id='Ext-panel-Table-event-itemkeypress'>            /**
</span>             * @event itemkeypress
             * @inheritdoc Ext.view.Table#itemkeypress
             */
            'itemkeypress',
<span id='Ext-panel-Table-event-beforecontainermousedown'>            /**
</span>             * @event beforecontainermousedown
             * @inheritdoc Ext.view.View#beforecontainermousedown
             */
            'beforecontainermousedown',
<span id='Ext-panel-Table-event-beforecontainermouseup'>            /**
</span>             * @event beforecontainermouseup
             * @inheritdoc Ext.view.View#beforecontainermouseup
             */
            'beforecontainermouseup',
<span id='Ext-panel-Table-event-beforecontainermouseover'>            /**
</span>             * @event beforecontainermouseover
             * @inheritdoc Ext.view.View#beforecontainermouseover
             */
            'beforecontainermouseover',
<span id='Ext-panel-Table-event-beforecontainermouseout'>            /**
</span>             * @event beforecontainermouseout
             * @inheritdoc Ext.view.View#beforecontainermouseout
             */
            'beforecontainermouseout',
<span id='Ext-panel-Table-event-beforecontainerclick'>            /**
</span>             * @event beforecontainerclick
             * @inheritdoc Ext.view.View#beforecontainerclick
             */
            'beforecontainerclick',
<span id='Ext-panel-Table-event-beforecontainerdblclick'>            /**
</span>             * @event beforecontainerdblclick
             * @inheritdoc Ext.view.View#beforecontainerdblclick
             */
            'beforecontainerdblclick',
<span id='Ext-panel-Table-event-beforecontainercontextmenu'>            /**
</span>             * @event beforecontainercontextmenu
             * @inheritdoc Ext.view.View#beforecontainercontextmenu
             */
            'beforecontainercontextmenu',
<span id='Ext-panel-Table-event-beforecontainerkeydown'>            /**
</span>             * @event beforecontainerkeydown
             * @inheritdoc Ext.view.View#beforecontainerkeydown
             */
            'beforecontainerkeydown',
<span id='Ext-panel-Table-event-beforecontainerkeyup'>            /**
</span>             * @event beforecontainerkeyup
             * @inheritdoc Ext.view.View#beforecontainerkeyup
             */
            'beforecontainerkeyup',
<span id='Ext-panel-Table-event-beforecontainerkeypress'>            /**
</span>             * @event beforecontainerkeypress
             * @inheritdoc Ext.view.View#beforecontainerkeypress
             */
            'beforecontainerkeypress',
<span id='Ext-panel-Table-event-containermouseup'>            /**
</span>             * @event containermouseup
             * @inheritdoc Ext.view.View#containermouseup
             */
            'containermouseup',
<span id='Ext-panel-Table-event-containermousedown'>            /**
</span>             * @event containermousedown
             * @inheritdoc Ext.view.View#containermousedown
             */
            'containermousedown',
<span id='Ext-panel-Table-event-containermouseover'>            /**
</span>             * @event containermouseover
             * @inheritdoc Ext.view.View#containermouseover
             */
            'containermouseover',
<span id='Ext-panel-Table-event-containermouseout'>            /**
</span>             * @event containermouseout
             * @inheritdoc Ext.view.View#containermouseout
             */
            'containermouseout',
<span id='Ext-panel-Table-event-containerclick'>            /**
</span>             * @event containerclick
             * @inheritdoc Ext.view.View#containerclick
             */
            'containerclick',
<span id='Ext-panel-Table-event-containerdblclick'>            /**
</span>             * @event containerdblclick
             * @inheritdoc Ext.view.View#containerdblclick
             */
            'containerdblclick',
<span id='Ext-panel-Table-event-containercontextmenu'>            /**
</span>             * @event containercontextmenu
             * @inheritdoc Ext.view.View#containercontextmenu
             */
            'containercontextmenu',
<span id='Ext-panel-Table-event-containerkeydown'>            /**
</span>             * @event containerkeydown
             * @inheritdoc Ext.view.View#containerkeydown
             */
            'containerkeydown',
<span id='Ext-panel-Table-event-containerkeyup'>            /**
</span>             * @event containerkeyup
             * @inheritdoc Ext.view.View#containerkeyup
             */
            'containerkeyup',
<span id='Ext-panel-Table-event-containerkeypress'>            /**
</span>             * @event containerkeypress
             * @inheritdoc Ext.view.View#containerkeypress
             */
            'containerkeypress',
<span id='Ext-panel-Table-event-beforeselect'>            /**
</span>             * @event beforeselect
             * @inheritdoc Ext.selection.RowModel#beforeselect
             */
            'beforeselect',
<span id='Ext-panel-Table-event-select'>            /**
</span>             * @event select
             * @inheritdoc Ext.selection.RowModel#select
             */
            'select',
<span id='Ext-panel-Table-event-beforedeselect'>            /**
</span>             * @event beforedeselect
             * @inheritdoc Ext.selection.RowModel#beforedeselect
             */
            'beforedeselect',
<span id='Ext-panel-Table-event-deselect'>            /**
</span>             * @event deselect
             * @inheritdoc Ext.selection.RowModel#deselect
             */
            'deselect',
            
<span id='Ext-panel-Table-event-beforerowexit'>            /**
</span>             * @event beforerowexit
             * @inheritdoc Ext.view.Table#beforerowexit
             */
            'beforerowexit'
        ]);

        // Only relay the event if it's not SpreadsheetModel.
        // SpreadsheetModel fires it directly through the Panel.
        if (!me.selModel.isSpreadsheetModel) {
            me.relayEvents(me.view, [
<span id='Ext-panel-Table-event-selectionchange'>                /**
</span>                 * @event selectionchange
                 * @inheritdoc Ext.selection.Model#selectionchange
                 */
                'selectionchange'
            ]);
        }

        me.callParent();
        if (me.enableLocking) {
            me.afterInjectLockable();
        } else {
            delete headerCt.$initParent;
        }
        me.addStateEvents(['columnresize', 'columnmove', 'columnhide', 'columnshow', 'sortchange', 'filterchange', 'groupchange']);
        
        // rowBody feature events
<span id='Ext-panel-Table-event-beforerowbodymousedown'>        /**
</span>         * @event beforerowbodymousedown
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodymousedown
         */

<span id='Ext-panel-Table-event-beforerowbodymouseup'>        /**
</span>         * @event beforerowbodymouseup
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodymouseup
         */

<span id='Ext-panel-Table-event-beforerowbodyclick'>        /**
</span>         * @event beforerowbodyclick
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodyclick
         */

<span id='Ext-panel-Table-event-beforerowbodydblclick'>        /**
</span>         * @event beforerowbodydblclick
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodydblclick
         */

<span id='Ext-panel-Table-event-beforerowbodycontextmenu'>        /**
</span>         * @event beforerowbodycontextmenu
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodycontextmenu
         */
    
<span id='Ext-panel-Table-event-beforerowbodylongpress'>        /**
</span>         * @event beforerowbodylongpress
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodylongpress
         */

<span id='Ext-panel-Table-event-beforerowbodykeydown'>        /**
</span>         * @event beforerowbodykeydown
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodykeydown
         */

<span id='Ext-panel-Table-event-beforerowbodykeyup'>        /**
</span>         * @event beforerowbodykeyup
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodykeyup
         */

<span id='Ext-panel-Table-event-beforerowbodykeypress'>        /**
</span>         * @event beforerowbodykeypress
         * @preventable
         * @inheritdoc Ext.view.Table#event-beforerowbodykeypress
         */

<span id='Ext-panel-Table-event-rowbodymousedown'>        /**
</span>         * @event rowbodymousedown
         * @inheritdoc Ext.view.Table#event-rowbodymousedown
         */

<span id='Ext-panel-Table-event-rowbodymouseup'>        /**
</span>         * @event rowbodymouseup
         * @inheritdoc Ext.view.Table#event-rowbodymouseup
         */

<span id='Ext-panel-Table-event-rowbodyclick'>        /**
</span>         * @event rowbodyclick
         * @inheritdoc Ext.view.Table#event-rowbodyclick
         */

<span id='Ext-panel-Table-event-rowbodydblclick'>        /**
</span>         * @event rowbodydblclick
         * @inheritdoc Ext.view.Table#event-rowbodydblclick
         */

<span id='Ext-panel-Table-event-rowbodycontextmenu'>        /**
</span>         * @event rowbodycontextmenu
         * @inheritdoc Ext.view.Table#event-rowbodycontextmenu
         */
    
<span id='Ext-panel-Table-event-rowbodylongpress'>        /**
</span>         * @event rowbodylongpress
         * @inheritdoc Ext.view.Table#event-rowbodylongpress
         */

<span id='Ext-panel-Table-event-rowbodykeydown'>        /**
</span>         * @event rowbodykeydown
         * @inheritdoc Ext.view.Table#event-rowbodykeydown
         */

<span id='Ext-panel-Table-event-rowbodykeyup'>        /**
</span>         * @event rowbodykeyup
         * @inheritdoc Ext.view.Table#event-rowbodykeyup
         */

<span id='Ext-panel-Table-event-rowbodykeypress'>        /**
</span>         * @event rowbodykeypress
         * @inheritdoc Ext.view.Table#event-rowbodykeypress
         */
    },

<span id='Ext-panel-Table-method-syncHeaderVisibility'>    syncHeaderVisibility: function() {
</span>        var me = this,
            headerCt = me.headerCt,
            columns = headerCt.items.items,
            len = columns.length,
            currentHideHeaderState = headerCt.height === 0,
            hideHeaders = !!len,
            column, colText, i, viewScroller;

        // If we have not been configured with hideHeaders, then set it if
        // there ARE columns and none of the columns has header text or child columns.
        // For example, a simple tree with an automatically inserted TreeColumn.
        if (me.hideHeaders != null) {
            hideHeaders = me.hideHeaders;
        } else {
            // Loop until we find a column with content.
            for (i = 0; hideHeaders &amp;&amp; i &lt; len; i++) {
                column = columns[i];
                colText = column.text;

                // If any column was configured with text *that is not &amp;nbsp;* or child columns, then
                // we must show headers.
                if ((colText &amp;&amp; colText !== '\u00a0') || column.columns || (column.isGroupHeader &amp;&amp; column.items.items.length)) {
                    hideHeaders = false;
                }
            }
        }

        if (!headerCt.rendered || hideHeaders !== currentHideHeaderState) {            
            headerCt.setHeight(hideHeaders ? 0 : null);
            headerCt.hiddenHeaders = hideHeaders;
            me.headerCt.toggleCls(me.hiddenHeaderCtCls, hideHeaders);
            me.toggleCls(me.hiddenHeaderCls, hideHeaders);
            if (!hideHeaders) {
                headerCt.setScrollable({
                    x: false,
                    y: false
                });
                viewScroller = me.view.getScrollable();
                if (viewScroller) {
                    headerCt.getScrollable().addPartner(viewScroller, 'x');
                }
            }
        }
    },

<span id='Ext-panel-Table-method-updateHideHeaders'>    updateHideHeaders: function(hideHeaders) {
</span>        // Must only update the visibility after all configuration is finished.
        // initComponent calls syncHeaderVisibility
        if (!this.isConfiguring) {
            this.syncHeaderVisibility();
        }
    },

<span id='Ext-panel-Table-method-beforeRender'>    beforeRender: function() {
</span>        var me = this,
            bufferedRenderer = me.bufferedRenderer,
            ariaAttr;

        // If this is the topmost container of a lockable assembly, add the special class body
        if (me.lockable) {
            me.getProtoBody().addCls(me.lockingBodyCls);
        }
        
        // Don't create a buffered renderer for a locked grid.
        else {
            // If we're auto heighting, we can't buffered render, so don't create it
            if (bufferedRenderer &amp;&amp; me.getSizeModel().height.auto) {
                //&lt;debug&gt;
                if (bufferedRenderer.isBufferedRenderer) {
                    Ext.raise('Cannot use buffered rendering with auto height');
                }
                //&lt;/debug&gt;
                me.bufferedRenderer = bufferedRenderer = false;
            }
        
            if (bufferedRenderer &amp;&amp; !bufferedRenderer.isBufferedRenderer) {
                // Create a BufferedRenderer as a plugin if we have not already configured with one.
                bufferedRenderer = {
                    xclass: 'Ext.grid.plugin.BufferedRenderer'
                };
                Ext.copy(bufferedRenderer, me, 'variableRowHeight,numFromEdge,trailingBufferZone,leadingBufferZone,scrollToLoadBuffer', true);
                me.bufferedRenderer = me.addPlugin(bufferedRenderer);
            }
            
            ariaAttr = me.ariaRenderAttributes || (me.ariaRenderAttributes = {});
            ariaAttr['aria-readonly'] = !me.isEditable;
            ariaAttr['aria-multiselectable'] = me.selModel.selectionMode !== 'SINGLE';
        }
        
        me.callParent(arguments);
    },

<span id='Ext-panel-Table-method-beforeLayout'>    beforeLayout: function() {
</span>        var lockable = this.mixins.lockable;

        if (lockable) {
            lockable.beforeLayout.call(this);
        }

        this.callParent();
    },

<span id='Ext-panel-Table-method-afterLayout'>    afterLayout: function(layout) {
</span>        var lockable = this.mixins.lockable;

        if (lockable) {
            lockable.syncLockableLayout.call(this, layout);
        }

        this.callParent([layout]);
    },

<span id='Ext-panel-Table-method-onHide'>    onHide: function(animateTarget, cb, scope) {
</span>        this.getView().onOwnerGridHide();
        this.callParent([animateTarget, cb, scope]);
    },

<span id='Ext-panel-Table-method-onShow'>    onShow: function() {
</span>        this.callParent();
        this.getView().onOwnerGridShow();
    },

<span id='Ext-panel-Table-method-getHeaderContainer'>    /**
</span>     * Gets the {@link Ext.grid.header.Container headercontainer} for this grid / tree.
     * @return {Ext.grid.header.Container} headercontainer
     *
     * **Note:** While a locked grid / tree will return an instance of
     * {@link Ext.grid.locking.HeaderContainer} you will code to the
     * {@link Ext.grid.header.Container} API.
     */
    getHeaderContainer: function () {
        return this.getView().getHeaderCt();
    },

<span id='Ext-panel-Table-method-getColumns'>    /**
</span>     * @inheritdoc Ext.grid.header.Container#getGridColumns
     */
    getColumns: function () {
        return this.getColumnManager().getColumns();
    },

<span id='Ext-panel-Table-method-getVisibleColumns'>    /**
</span>     * @inheritdoc Ext.grid.header.Container#getVisibleGridColumns
     */
    getVisibleColumns: function () {
        return this.getVisibleColumnManager().getColumns();
    },

<span id='Ext-panel-Table-method-getScrollable'>    getScrollable: function() {
</span>        // Lockable grids own a separate Y scroller which scrolls both grids in a single
        // scrolling element.
        // Regaular grids return their view's scroller.
        return this.scrollable || this.view.getScrollable();
    },

<span id='Ext-panel-Table-method-focus'>    focus: function() {
</span>        // TablePanel is not focusable, but allow a call to delegate into the view
        this.getView().focus();
    },
    
<span id='Ext-panel-Table-method-disableColumnHeaders'>    /**
</span>     * Disables interaction with, and masks this grid's column headers.
     */
    disableColumnHeaders: function() {
        this.headerCt.disable();
    },

<span id='Ext-panel-Table-method-enableColumnHeaders'>    /**
</span>     * Enables interaction with, and unmasks this grid's column headers after a call to {#disableColumnHeaders}.
     */
    enableColumnHeaders: function() {
        this.headerCt.enable();
    },

<span id='Ext-panel-Table-method-hasLockedColumns'>    /**
</span>     * @private
     * Determine if there are any columns with a locked configuration option.
     */
    hasLockedColumns: function(columns) {
        var i,
            len,
            column;

        // Fully instantiated HeaderContainer
        if (columns.isRootHeader) {
            columns = columns.items.items;
        }
        // Config object with items
        else if (Ext.isObject(columns)) {
            columns = columns.items;
        }
        for (i = 0, len = columns.length; i &lt; len; i++) {
            column = columns[i];
            if (!column.processed &amp;&amp; column.locked) {
                return true;
            }
        }
    },

<span id='Ext-panel-Table-method-relayHeaderCtEvents'>    relayHeaderCtEvents: function (headerCt) {
</span>        this.relayEvents(headerCt, [
<span id='Ext-panel-Table-event-columnresize'>            /**
</span>             * @event columnresize
             * @inheritdoc Ext.grid.header.Container#columnresize
             */
            'columnresize',
<span id='Ext-panel-Table-event-columnmove'>            /**
</span>             * @event columnmove
             * @inheritdoc Ext.grid.header.Container#columnmove
             */
            'columnmove',
<span id='Ext-panel-Table-event-columnhide'>            /**
</span>             * @event columnhide
             * @inheritdoc Ext.grid.header.Container#columnhide
             */
            'columnhide',
<span id='Ext-panel-Table-event-columnshow'>            /**
</span>             * @event columnshow
             * @inheritdoc Ext.grid.header.Container#columnshow
             */
            'columnshow',
<span id='Ext-panel-Table-event-columnschanged'>            /**
</span>             * @event columnschanged
             * @inheritdoc Ext.grid.header.Container#columnschanged
             */
            'columnschanged',
<span id='Ext-panel-Table-event-sortchange'>            /**
</span>             * @event sortchange
             * @inheritdoc Ext.grid.header.Container#sortchange
             */
            'sortchange',
<span id='Ext-panel-Table-event-headerclick'>            /**
</span>             * @event headerclick
             * @inheritdoc Ext.grid.header.Container#headerclick
             */
            'headerclick',
<span id='Ext-panel-Table-event-headercontextmenu'>            /**
</span>             * @event headercontextmenu
             * @inheritdoc Ext.grid.header.Container#headercontextmenu
             */
            'headercontextmenu',
<span id='Ext-panel-Table-event-headertriggerclick'>            /**
</span>             * @event headertriggerclick
             * @inheritdoc Ext.grid.header.Container#headertriggerclick
             */
            'headertriggerclick'
        ]);
    },

<span id='Ext-panel-Table-method-getState'>    getState: function(){
</span>        var me = this,
            state = me.callParent(),
            storeState = me.store.getState();

        state = me.addPropertyToState(state, 'columns', me.headerCt.getColumnsState());

        if (storeState) {
            state.storeState = storeState;
        }
        return state;
    },

<span id='Ext-panel-Table-method-applyState'>    applyState: function (state) {
</span>        var me = this,
            sorter = state.sort,
            storeState = state.storeState,
            store = me.store,
            columns = state.columns = me.buildColumnHash(state.columns);

        // Ensure superclass has applied *its* state.
        // Component saves dimensions (and anchor/flex) plus collapsed state.
        me.callParent(arguments);

        if (columns) {
            // Column state restoration needs to examine store state
            me.headerCt.applyColumnsState(columns, storeState);
        }

        // Old stored sort state. Deprecated and will die out.
        if (sorter) {
            if (store.getRemoteSort()) {
                // Pass false to prevent a sort from occurring.
                store.sort({
                    property: sorter.property,
                    direction: sorter.direction,
                    root: sorter.root
                }, null, false);
            } else {
                store.sort(sorter.property, sorter.direction);
            }
        }
        // New storeState which encapsulates groupers, sorters and filters.
        else if (storeState) {
            store.applyState(storeState);
        }
    },

<span id='Ext-panel-Table-method-buildColumnHash'>    buildColumnHash: function(columns) {
</span>        var len = columns.length,
            columnState,
            i,
            result;

        // Create a useable state lookup hash from which each column
        // may look up its state based upon its stateId
        // {
        //      col_name: {
        //          index: 0,
        //          width: 100,
        //          locked: true
        //      },
        //      col_details: {
        //          index: 1,
        //          width: 200,
        //          columns: {
        //              col_details_1: {
        //                  index: 0,
        //                  width: 100
        //              },
        //              col_details_2: {
        //                  index: 1,
        //                  width: 100
        //              }
        //          }
        //      },
        // }
        if (columns) {
            result = {};
            for (i = 0, len = columns.length; i &lt; len; i++) {
                columnState = columns[i];
                columnState.index = i;
                if (columnState.columns) {
                    columnState.columns = this.buildColumnHash(columnState.columns);
                }
                result[columnState.id] = columnState;
            }
            return result;
        }
    },

<span id='Ext-panel-Table-method-getStore'>    /**
</span>     * Returns the store associated with this Panel.
     * @return {Ext.data.Store} The store
     */
    getStore: function(){
        return this.store;
    },

<span id='Ext-panel-Table-method-onViewRefresh'>    onViewRefresh: function(view, records) {
</span>        this.onItemAdd(records, 0);
    },

<span id='Ext-panel-Table-method-onItemAdd'>    onItemAdd: function(records, index, nodes, view) {
</span>        var me = this,
            recCount = records.length,
            freeRowContexts = me.freeRowContexts,
            liveRowContexts = me.liveRowContexts || (me.liveRowContexts = {}),
            rowContext,
            i,
            record;

        // Ensure we have RowContexts ready for all the widget owners
        // (Widget columns or RowWidget plugin) which will be needing instantiated
        // Widgets with attached ViewModels.
        for (i = 0; i &lt; recCount; i++) {
            record = records[i];

            // We may have already been informed about the addition of this item
            // by the opposite locking partner
            if (!liveRowContexts[record.internalId]) {
                // Attempt to read from free RowContexts which may have been freed
                // by a previous item remove event. Shift of the front
                // to improve the chances of using the same RowContext for a record;
                // They were pushed on in the item remove handler.
                rowContext = freeRowContexts &amp;&amp; freeRowContexts.shift();

                // Need a new one
                if (!rowContext) {
                    rowContext = new Ext.grid.RowContext({
                        ownerGrid: me
                    });
                }
                me.liveRowContexts[record.internalId] = rowContext;
                rowContext.setRecord(record, index++);
            }
        }
    },

<span id='Ext-panel-Table-method-onItemRemove'>    onItemRemove: function(records, index, nodes, view) {
</span>        var me = this,
            freeRowContexts = me.freeRowContexts || (me.freeRowContexts = []),
            liveRowContexts = me.liveRowContexts,
            len = nodes.length,
            i,
            id,
            context;

        for (i = 0; i &lt; len; i++) {
            id = nodes[i].getAttribute('data-recordId');
            context = liveRowContexts[id];

            // We may have already been informed about the removal of this item
            // by the opposite locking partner
            if (context) {
                context.free();
                freeRowContexts.push(context);
                delete liveRowContexts[id];
            }
        }
    },

<span id='Ext-panel-Table-method-createManagedWidget'>    createManagedWidget: function(ownerId, widgetConfig, record) {
</span>        return this.liveRowContexts[record.internalId].getWidget(ownerId, widgetConfig);
    },

<span id='Ext-panel-Table-method-destroyManagedWidgets'>    destroyManagedWidgets: function(ownerId) {
</span>        var me = this,
            contexts = me.liveRowContexts,
            freeRowContexts = me.freeRowContexts,
            len = freeRowContexts &amp;&amp; freeRowContexts.length,
            i,
            recInternalId,
            rowWidgets;

        // Destroy widgets from both live contexts, and free ones
        for (recInternalId in contexts) {
            rowWidgets = contexts[recInternalId].widgets;
            if (rowWidgets) {
                Ext.destroy(rowWidgets[ownerId]);
                delete rowWidgets[ownerId];
            }
        }
        for (i = 0; i &lt; len; i++) {
            rowWidgets = freeRowContexts[i].widgets;
            if (rowWidgets) {
                Ext.destroy(rowWidgets[ownerId]);
                delete rowWidgets[ownerId];
            }
        }
    },

<span id='Ext-panel-Table-method-getManagedWidgets'>    getManagedWidgets: function(ownerId) {
</span>        var me = this,
            contexts = me.liveRowContexts,
            recInternalId,
            result = [];

        for (recInternalId in contexts) {
            result.push(contexts[recInternalId].widgets[ownerId]);
        }
        return result;
    },

<span id='Ext-panel-Table-method-getView'>    /**
</span>     * Gets the view for this panel.
     * @return {Ext.view.Table}
     */
    getView: function() {
        var me = this,
            scroll, scrollable, viewConfig;

        if (!me.view) {
            viewConfig = me.viewConfig;
            scroll = viewConfig.scroll || me.scroll;

            scrollable = me.scrollable;

            if (scrollable == null &amp;&amp; viewConfig.scrollable == null &amp;&amp; scroll !== null) {
                // transform deprecated scroll config into scrollable config
                if (scroll === true || scroll === 'both') {
                    scrollable = true;
                } else if (scroll === false || scroll === 'none') {
                    scrollable = false;
                } else if (scroll === 'vertical') {
                    scrollable = {
                        x: false,
                        y: true
                    };
                } else if (scroll === 'horizontal') {
                    scrollable = {
                        x: true,
                        y: false
                    };
                }
            }

            viewConfig = Ext.apply({
                // TableView injects the view reference into this grid so that we have a reference as early as possible
                // and Features need a reference to the grid.
                // For these reasons, we configure a reference to this grid into the View
                grid: me,
                ownerGrid: me.ownerGrid,
                deferInitialRefresh: me.deferRowRender,
                variableRowHeight: me.variableRowHeight,
                preserveScrollOnRefresh: true,
                trackOver: me.trackMouseOver !== false,
                throttledUpdate: me.throttledUpdate === true,
                xtype: me.viewType,
                store: me.store,
                headerCt: me.headerCt,
                columnLines: me.columnLines,
                rowLines: me.rowLines,
                navigationModel: 'grid',
                features: me.features,
                panel: me,
                emptyText: me.emptyText || ''
            }, me.viewConfig);

            // Impose our calculated scrollable config only if scrollability is not configured.
            if (!('scrollable' in viewConfig || 'scroll' in viewConfig || 'autoScroll' in viewConfig) &amp;&amp; scrollable != null) {
                viewConfig.scrollable = scrollable;
            }

            Ext.create(viewConfig);

            // Normalize the application of the markup wrapping the emptyText config.
            // `emptyText` can now be defined on the grid as well as on its viewConfig, and this led to the emptyText not
            // having the wrapping markup when it was defined in the viewConfig. It should be backwards compatible.
            // Note that in the unlikely event that emptyText is defined on both the grid config and the viewConfig that the viewConfig wins.
            if (me.view.emptyText) {
                me.view.emptyText = '&lt;div class=&quot;' + me.emptyCls + '&quot;&gt;' + me.view.emptyText + '&lt;/div&gt;';
            }

            // TableView's custom component layout, Ext.view.TableLayout requires a reference to the headerCt because it depends on the headerCt doing its work.
            me.view.getComponentLayout().headerCt = me.headerCt;

            me.mon(me.view, {
                uievent: me.processEvent,
                scope: me
            });
            me.headerCt.view = me.view;

            // Plugins and features may need to access the view as soon as it is created.
            if (me.hasListeners.viewcreated) {
                me.fireEvent('viewcreated', me, me.view);
            }
        }
        return me.view;
    },

<span id='Ext-panel-Table-method-getEmptyText'>    getEmptyText: function() {
</span>        return this.view.emptyText;
    },

<span id='Ext-panel-Table-method-setEmptyText'>    setEmptyText: function(emptyText) {
</span>        this.emptyText = emptyText;

        this.view.setEmptyText(
            '&lt;div class=&quot;' + this.emptyCls + '&quot;&gt;' + emptyText + '&lt;/div&gt;'
        );

        return this;
    },

<span id='Ext-panel-Table-method-getColumnManager'>    getColumnManager: function() {
</span>        return this.columnManager;
    },

<span id='Ext-panel-Table-method-getVisibleColumnManager'>    getVisibleColumnManager: function() {
</span>        return this.visibleColumnManager;
    },

<span id='Ext-panel-Table-method-getTopLevelColumnManager'>    getTopLevelColumnManager: function() {
</span>        return this.ownerGrid.getColumnManager();
    },

<span id='Ext-panel-Table-method-getTopLevelVisibleColumnManager'>    getTopLevelVisibleColumnManager: function() {
</span>        return this.ownerGrid.getVisibleColumnManager();
    },

<span id='Ext-panel-Table-method-setAutoScroll'>    /**
</span>     * @method setAutoScroll
     */
    setAutoScroll: Ext.emptyFn,

<span id='Ext-panel-Table-method-applyScrollable'>    applyScrollable: function(scrollable) {
</span>        var view = this.view;

        view = view &amp;&amp; (view.normalView || view);

        if (view) {
            view.setScrollable(scrollable);
        }

        // The view might not yet exists so we just stash the raw config away so it
        // can be processed by getView()
        return scrollable;
    },

<span id='Ext-panel-Table-method-processEvent'>    /**
</span>     * @private
     * Processes UI events from the view. Propagates them to whatever internal Components need to process them.
     * @param {String} type Event type, eg 'click'
     * @param {Ext.view.Table} view TableView Component
     * @param {HTMLElement} cell Cell HTMLElement the event took place within
     * @param {Number} recordIndex Index of the associated Store Model (-1 if none)
     * @param {Number} cellIndex Cell index within the row
     * @param {Ext.event.Event} e Original event
     */
    processEvent: function(type, view, cell, recordIndex, cellIndex, e, record, row) {
        var header = e.position.column;

        if (header) {
            return header.processEvent.apply(header, arguments);
        }
    },

<span id='Ext-panel-Table-method-ensureVisible'>    /**
</span>     * Scrolls the specified record into view.
     * @param {Number/String/Ext.data.Model} record The record, record id,  or the zero-based position in the dataset to scroll to.
     * @param {Object}          [options] An object containing options to modify the operation.
     * @param {Boolean}         [options.animate] Pass `true` to animate the row into view.
     * @param {Boolean}         [options.highlight] Pass `true` to highlight the row with a glow animation when it is in view.
     * @param {Boolean}         [options.select] Pass as `true` to select the specified row.
     * @param {Boolean}         [options.focus] Pass as `true` to focus the specified row.
     * @param {Function}        [options.callback] A function to execute when the record is in view. This may be necessary if the
     *                          first parameter is a record index and the view is backed by a {@link Ext.data.BufferedStore buffered store}
     *                          which does not contain that record.
     * @param {Boolean}         options.callback.success `true` if acquiring the record's view node was successful.
     * @param {Ext.data.Model}  options.callback.record If successful, the target record.
     * @param {HTMLElement}     options.callback.node If successful, the record's view node.
     * @param {Object}          [options.scope] The scope (`this` reference) in which the callback function is executed.
     */
    ensureVisible: function(record, options) {
        this.doEnsureVisible(record, options);
    },

<span id='Ext-panel-Table-method-scrollByDeltaY'>    scrollByDeltaY: function(yDelta, animate) {
</span>        // xDelta should be null here not 0! We're not scrolling horizontally,
        // and the Scroller is sensitive to these things.
        this.getView().scrollBy(null, yDelta, animate);
    },

<span id='Ext-panel-Table-method-scrollByDeltaX'>    scrollByDeltaX: function(xDelta, animate) {
</span>        // Ditto yDelta.
        this.getView().scrollBy(xDelta, null, animate);
    },

<span id='Ext-panel-Table-method-afterCollapse'>    afterCollapse: function() {
</span>        this.saveScrollPos();
        this.callParent(arguments);
    },

<span id='Ext-panel-Table-method-afterExpand'>    afterExpand: function() {
</span>        this.callParent(arguments);
        this.restoreScrollPos();
    },

<span id='Ext-panel-Table-method-saveScrollPos'>    saveScrollPos: Ext.emptyFn,
</span>
<span id='Ext-panel-Table-method-restoreScrollPos'>    restoreScrollPos: Ext.emptyFn,
</span>
<span id='Ext-panel-Table-method-onHeaderResize'>    onHeaderResize: Ext.emptyFn,
</span>
<span id='Ext-panel-Table-method-onHeaderMove'>    // Update the view when a header moves
</span>    onHeaderMove: function(headerCt, header, colsToMove, fromIdx, toIdx) {
        var me = this;

        // If there are Features or Plugins which create DOM which must match column order, they set the optimizedColumnMove flag to false.
        // In this case we must refresh the view on column move.
        if (me.optimizedColumnMove === false) {
            me.view.refreshView();
        }

        // Simplest case for default DOM structure is just to swap the columns round in the view.
        else {
            me.view.moveColumn(fromIdx, toIdx, colsToMove);
        }
        me.delayScroll();
    },

<span id='Ext-panel-Table-method-onHeaderHide'>    // Section onHeaderHide is invoked after view.
</span>    onHeaderHide: function(headerCt, header) {
        var view = this.view;
        // The headerCt may be hiding multiple children if a leaf level column
        // causes a parent (and possibly other parents) to be hidden. Only run the refresh
        // once we're done
        if (!headerCt.childHideCount &amp;&amp; view.refreshCounter) {
            view.refreshView();
        }
    },

<span id='Ext-panel-Table-method-onHeaderShow'>    onHeaderShow: function(headerCt, header) {
</span>        var view = this.view;
        if (view.refreshCounter) {
            view.refreshView();
        }
    },

<span id='Ext-panel-Table-method-onHeadersChanged'>    // To be triggered on add/remove/move for a leaf header
</span>    onHeadersChanged: function(headerCt, header) {
        var me = this;
        if (me.rendered &amp;&amp; !me.reconfiguring) {
            me.view.refreshView();
            me.delayScroll();
        }
    },

<span id='Ext-panel-Table-method-delayScroll'>    delayScroll: function(){
</span>        var target = this.view;
        if (target) {
            // Do not cause a layout by reading scrollX now.
            // It must be read from the target when the task finally executes.
            this.scrollTask.delay(10, null, null, [target]);
        }
    },

<span id='Ext-panel-Table-method-onViewReady'>    /**
</span>     * @private
     * Fires the TablePanel's viewready event when the view declares that its internal DOM is ready
     */
    onViewReady: function() {
         this.fireEvent('viewready', this);   
    },

<span id='Ext-panel-Table-method-onRestoreHorzScroll'>    /**
</span>     * @private
     * Tracks when things happen to the view and preserves the horizontal scroll position.
     */
    onRestoreHorzScroll: function() {
        var me = this,
            x = me.scrollXPos;

        if (x) {
            // We need to restore the body scroll position here
            me.syncHorizontalScroll(me, true);
        }
    },

<span id='Ext-panel-Table-method-getScrollerOwner'>    getScrollerOwner: function() {
</span>        var rootCmp = this;
        if (!this.scrollerOwner) {
            rootCmp = this.up('[scrollerOwner]');
        }
        return rootCmp;
    },

<span id='Ext-panel-Table-method-getLhsMarker'>    /**
</span>     * Gets left hand side marker for header resizing.
     * @private
     */
    getLhsMarker: function() {
        var me = this;
        return me.lhsMarker || (me.lhsMarker = Ext.DomHelper.append(me.el, {
            role: 'presentation',
            cls: me.resizeMarkerCls
        }, true));
    },

<span id='Ext-panel-Table-method-getRhsMarker'>    /**
</span>     * Gets right hand side marker for header resizing.
     * @private
     */
    getRhsMarker: function() {
        var me = this;

        return me.rhsMarker || (me.rhsMarker = Ext.DomHelper.append(me.el, {
            role: 'presentation',
            cls: me.resizeMarkerCls
        }, true));
    },

<span id='Ext-panel-Table-method-getSelection'>    /**
</span>     * Returns the grid's selection. See `{@link Ext.selection.Model#getSelection}`.
     * @inheritdoc Ext.selection.Model#getSelection
     */
    getSelection: function () {
        return this.getSelectionModel().getSelection();
    },

<span id='Ext-panel-Table-method-updateSelection'>    updateSelection: function(selection) {
</span>        var me = this,
            sm;

        if (!me.ignoreNextSelection) {
            me.ignoreNextSelection = true;
            sm = me.getSelectionModel();
            if (selection) {
                sm.select(selection);
            } else {
                sm.deselectAll();
            }
            me.ignoreNextSelection = false;
        }
    },

<span id='Ext-panel-Table-method-updateBindSelection'>    updateBindSelection: function(selModel, selection) {
</span>        var me = this,
            selected = null;

        if (!me.ignoreNextSelection) {
            me.ignoreNextSelection = true;
            if (selection.length) {
                selected = selModel.getLastSelected();
                me.hasHadSelection = true;
            }
            if (me.hasHadSelection) {
                me.setSelection(selected);
            }
            me.ignoreNextSelection = false;
        }
    },

<span id='Ext-panel-Table-method-updateFocused'>    updateFocused: function(record) {
</span>        this.getNavigationModel().setPosition(record);
    },

<span id='Ext-panel-Table-method-updateHeaderBorders'>    updateHeaderBorders: function(headerBorders) {
</span>        this[headerBorders ? 'removeCls' : 'addCls'](this.noHeaderBordersCls);
    },

<span id='Ext-panel-Table-method-getNavigationModel'>    getNavigationModel: function() {
</span>        return this.getView().getNavigationModel();
    },

<span id='Ext-panel-Table-method-getSelectionModel'>    /**
</span>     * Returns the selection model being used by this grid's {@link Ext.view.Table view}.
     * @return {Ext.selection.Model} The selection model being used by this grid's {@link Ext.view.Table view}.
     */
    getSelectionModel: function() {
        return this.getView().getSelectionModel();
    },

<span id='Ext-panel-Table-method-getScrollTarget'>    getScrollTarget: function(){
</span>        var items = this.getScrollerOwner().query('tableview');

        // Last view has the scroller
        return items[items.length - 1];
    },

<span id='Ext-panel-Table-method-syncHorizontalScroll'>    syncHorizontalScroll: function(target, setBody) {
</span>        var me = this,
            x = me.view.getScrollX(),
            scrollTarget;

        setBody = setBody === true;
        // Only set the horizontal scroll if we've changed position,
        // so that we don't set this on vertical scrolls
        if (me.rendered &amp;&amp; (setBody || x !== me.scrollXPos)) {
            // Only set the body position if we're reacting to a refresh, otherwise
            // we just need to set the header.
            if (setBody) {   
                scrollTarget = me.getScrollTarget();
                scrollTarget.setScrollX(x);
            }
            me.headerCt.setScrollX(x);
            me.scrollXPos = x;
        }
    },

<span id='Ext-panel-Table-method-onStoreLoad'>    // template method meant to be overriden
</span>    onStoreLoad: Ext.emptyFn,

<span id='Ext-panel-Table-method-getEditorParent'>    getEditorParent: function() {
</span>        return this.body;
    },

<span id='Ext-panel-Table-method-bindStore'>    bindStore: function(store, initial) {
</span>        var me = this,
            view = me.getView(),
            oldStore = me.getStore();

        // Normally, this method will always be called with a valid store (because there is a symmetric
        // .unbindStore method), but there are cases where this method will be called and passed a null
        // value, i.e., a panel is used as a pickerfield. See EXTJS-13089.
        if (store) {
            // Bind to store immediately because subsequent processing looks for grid's store property
            me.store = store;

            if (view.store !== store) {
                // If coming from a reconfigure, we need to set the actual store property on the view. Setting the
                // store will then also set the dataSource.
                //
                // Note that if it's a grid feature then this is sorted out in view.bindStore(), and it's own
                // implementation of .bindStore() will be called.
                view.bindStore(store, false);
            }

            me.mon(store, {
                load: me.onStoreLoad,
                scope: me
            });
            me.storeRelayers = me.relayEvents(store, [
<span id='Ext-panel-Table-event-filterchange'>                /**
</span>                 * @event filterchange
                 * @inheritdoc Ext.data.Store#filterchange
                 */
                'filterchange',
<span id='Ext-panel-Table-event-groupchange'>                /**
</span>                 * @event groupchange
                 * @inheritdoc Ext.data.Store#groupchange
                 */
                'groupchange'
            ]);

            // If this is being called from reconfigure then the storechange will be called
            // by the reconfigure machinery at the end of all processing. Otherwise, fire here.
            if (!me.reconfiguring &amp;&amp; me.hasListeners.storechange &amp;&amp; store !== oldStore) {
                me.fireEvent('storechange', me, store, oldStore);
            }
        } else {
            me.unbindStore();
        }
    },

<span id='Ext-panel-Table-method-unbindStore'>    unbindStore: function() {
</span>        var me = this,
            store = me.store,
            view;

        if (store) {
            store.trackStateChanges = false;

            me.store = null;

            me.mun(store, {
                load: me.onStoreLoad,
                scope: me
            });

            Ext.destroy(me.storeRelayers);

            view = me.view;
            if (view.store) {
                view.bindStore(null);
            }

            // If this is being called from reconfigure then the storechange will be called
            // by the reconfigure machinery at the end of all processing. Otherwise, fire here.
            if (!me.reconfiguring &amp;&amp; me.hasListeners.storechange) {
                me.fireEvent('storechange', me, null, store);
            }
        }
    },

<span id='Ext-panel-Table-method-setColumns'>    setColumns: function(columns) {
</span>        // If being reconfigured from zero columns to zero columns, skip operation.
        // This can happen if columns are being set from a binding and the initial value
        // of the bound data in the ViewModel is []
        if (columns.length || this.getColumnManager().getColumns().length) {
            this.reconfigure(undefined, columns);
        }
    },

<span id='Ext-panel-Table-method-setStore'>    /**
</span>     * A convenience method that fires {@link #reconfigure} with the store param.  To set the store AND change columns,
     * use the {@link #reconfigure reconfigure method}.
     *
     * @param {Ext.data.Store} [store] The new store.
     */
    setStore: function (store) {
        var me = this;

        me.reconfigure(store, undefined, true);

        // If we are visible, load the store
        if (me.isVisible(true)) {
            if (store &amp;&amp; me.autoLoad &amp;&amp; !store.isEmptyStore &amp;&amp; !(store.loading || store.isLoaded())) {
                store.load();
            }
        }
        // Otherwise, ensure that we will load as soon as we become visible
        else if (!me.globalShowListener) {
            me.globalShowListener = Ext.GlobalEvents.on({
                show: me.onGlobalShow,
                scope: me,
                destroyable: true
            });
        }
    },

<span id='Ext-panel-Table-method-onGlobalShow'>    onGlobalShow: function(comp) {
</span>        var me = this,
            store = me.store;

        // If the global show caused this to be shown, then load unless there's already a locked kicked off.
        if (comp === me || (comp.isAncestor(me) &amp;&amp; me.isVisible(true))) {
            if (store &amp;&amp; me.autoLoad &amp;&amp; !store.isEmptyStore &amp;&amp; !(store.loading || store.isLoaded())) {
                store.load();
            }
            Ext.destroy(me.globalShowListener);
        }
    },

<span id='Ext-panel-Table-method-reconfigure'>    /**
</span>     * Reconfigures the grid or tree with a new store and/or columns. Stores and columns 
     * may also be passed as params.
     *
     *     grid.reconfigure(store, columns);
     *
     * Additionally, you can pass just a store or columns.
     *
     *     tree.reconfigure(store);
     *     // or
     *     grid.reconfigure(columns);
     *     // or
     *     tree.reconfigure(null, columns);
     *
     * If you're using locked columns, the {@link #enableLocking} config should be set 
     * to `true` before the reconfigure method is executed.
     *
     * @param {Ext.data.Store/Object} [store] The new store instance or store config. You can 
     * pass `null` if no new store.
     * @param {Object[]} [columns] An array of column configs
     */
    reconfigure: function(store, columns, /* private */ allowUnbind) {
        var me = this,
            oldStore = me.store,
            headerCt = me.headerCt,
            lockable = me.lockable,
            oldColumns = headerCt ? headerCt.items.getRange() : me.columns,
            view = me.getView(),
            block, refreshCounter, storeChanged, columnsChanged, restoreFocus;

        // Allow optional store argument to be fully omitted, and the columns argument to be solo
        if (arguments.length === 1 &amp;&amp; Ext.isArray(store)) {
            columns = store;
            store = null;
        }

        // Make copy in case the beforereconfigure listener mutates it.
        if (columns) {
            columns = Ext.Array.slice(columns);
        }

        me.reconfiguring = true;
        if (store) {
            store = Ext.StoreManager.lookup(store);
            storeChanged = store &amp;&amp; store !== oldStore;
        }
        // Allow for nulling the store (convert to the empty store)
        else if (allowUnbind) {
            store = Ext.StoreManager.lookup('ext-empty-store');
            storeChanged = store !== oldStore;
        }
        me.fireEvent('beforereconfigure', me, store, columns, oldStore, oldColumns);

        Ext.suspendLayouts();

        if (lockable) {
            me.reconfigureLockable(store, columns, allowUnbind);
        } else {
            // Prevent the view from refreshing until we have resumed layouts and any columns are rendered
            block = view.blockRefresh;
            view.blockRefresh = true;
            restoreFocus = view.saveFocusState();

            // Note that we need to process the store first in case one or more passed columns (if there are any)
            // have active gridfilters with values which would filter the currently-bound store.
            if (storeChanged) {
                me.unbindStore();
                me.bindStore(store);
            }

            if (columns) {
                // new columns, delete scroll pos
                delete me.scrollXPos;
                headerCt.removeAll();
                headerCt.add(columns);
                columnsChanged = true;
            }
            
            headerCt.onOwnerGridReconfigure(storeChanged, columnsChanged);

            refreshCounter = view.refreshCounter;
        }

        Ext.resumeLayouts(true);
        me.reconfiguring = false;
        if (lockable) {
            me.afterReconfigureLockable();
        } else {
            view.blockRefresh = block;

            // If the layout resumption didn't trigger the view to refresh, do it here
            if (view.refreshCounter === refreshCounter) {
                view.refreshView();
                restoreFocus();
            }
        }

        me.fireEvent('reconfigure', me, store, columns, oldStore, oldColumns);
        delete me.reconfiguring;
        
        if (storeChanged) {
            me.fireEvent('storechange', me, store, oldStore);
        }
    },

<span id='Ext-panel-Table-method-doDestroy'>    doDestroy: function() {
</span>        var me = this,
            task = me.scrollTask;

        if (me.lockable) {
            me.destroyLockable();
        }
            
        if (task) {
            task.cancel();
        }
        
        // Need to destroy plugins here because they may have listeners on the View
        Ext.destroy(me.plugins, me.focusEnterLeaveListeners, me.freeRowContexts,
                    Ext.Object.getValues(me.liveRowContexts));
        
        me.callParent();
        
        // Have to unbind the store this late because plugins and other things
        // may still need it until the very end.
        me.unbindStore();
    },

<span id='Ext-panel-Table-property-privates'>    privates: {
</span>        // The focusable flag is set, but there is no focusable element.
        // Focus is delegated to the view by the focus implementation.
        initFocusableElement: function() {},

        doEnsureVisible: function(record, options) {
            // Handle the case where this is a lockable assembly
            if (this.lockable) {
                return this.ensureLockedVisible(record, options);
            }

            // Allow them to pass the record id.
            if (typeof record !== 'number' &amp;&amp; !record.isEntity) {
                record = this.store.getById(record);
            }
            var me = this,
                view = me.getView(),
                domNode = view.getNode(record),
                callback, scope, animate,
                highlight, select, doFocus, scrollable, column, cell;

            if (options) {
                callback = options.callback;
                scope = options.scope;
                animate = options.animate;
                highlight = options.highlight;
                select = options.select;
                doFocus = options.focus;
                column = options.column;
            }

            // Always supercede any prior deferred request
            if (me.deferredEnsureVisible) {
                me.deferredEnsureVisible.destroy();
            }

            // We have not yet run the layout.
            // Add this to the end of the first sizing process.
            // By using the resize event, we will come in AFTER any Component's onResize and onBoxReady handling.
            if (!view.componentLayoutCounter) {
                me.deferredEnsureVisible = view.on({
                    resize: me.doEnsureVisible,
                    args: Ext.Array.slice(arguments),
                    scope: me,
                    single: true,
                    destroyable: true
                });
                return;
            }

            if (typeof column === 'number') {
                column = me.ownerGrid.getVisibleColumnManager().getColumns()[column];
            }
            
            // We found the DOM node associated with the record
            if (domNode) {
                scrollable = view.getScrollable();
                if (column) {
                    cell = Ext.fly(domNode).selectNode(column.getCellSelector());
                }
                if (scrollable) {
                    scrollable.scrollIntoView(cell || domNode, !!column, animate, highlight);
                }
                if (!record.isEntity) {
                    record = view.getRecord(domNode);
                }
                if (select) {
                    view.getSelectionModel().select(record);
                }
                if (doFocus) {
                    view.getNavigationModel().setPosition(record, 0);
                }
                Ext.callback(callback, scope || me, [true, record, domNode]);
            }
            // If we didn't find it, it's probably because of buffered rendering
            else if (view.bufferedRenderer) {
                view.bufferedRenderer.scrollTo(record, {
                    animate: animate,
                    highlight: highlight,
                    select: select,
                    focus: doFocus,
                    column: column,
                    callback: function(recordIdx, record, domNode) {
                        Ext.callback(callback, scope || me, [true, record, domNode]);
                    }
                });
            } else {
                Ext.callback(callback, scope || me, [false, null]);
            }
        },
        
        getFocusEl: function() {
            return this.getView().getFocusEl();
        },

<span id='Ext-panel-Table-method-setActionableMode'>        /**
</span>         * Toggles ARIA actionable mode on/off
         * @param {Boolean} enabled
         * @return {Boolean} `true` if actionable mode was entered
         * @private
         */
        setActionableMode: function(enabled, position) {
            // Always set the topmost grid in a lockable assembly
            var me = this.ownerGrid;

            // Can be called to exit actionable mode upon a focusLeave caused by destruction
            if (!me.destroying &amp;&amp; me.view.setActionableMode(enabled, position) !== false) {
                me.fireEvent('actionablemodechange', enabled);
                me[enabled ? 'addCls' : 'removeCls'](me.actionableModeCls);
                return true;
            }
        },

<span id='Ext-panel-Table-method-getOverflowStyle'>        /**
</span>         * Override for TablePanel.
         * A TablePanel can never scroll. Its View scrolls.
         * @private
         */
        getOverflowStyle: function() {
            this.scrollFlags = this._scrollFlags['false']['false'];
            return {
                overflowX: 'hidden',
                overflowY: 'hidden'
            };
        },

        getOverflowEl: function() {
            return null;
        }
    }
});
</pre>
</body>
</html>
