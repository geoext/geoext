<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: src/data/serializer/Vector.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: src/data/serializer/Vector.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* Copyright (c) 2015-present The Open Source Geospatial Foundation
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/>.
 */
/**
 * A serializer for layers that have an `ol.source.Vector` source.
 *
 * This class is heavily inspired by the excellent `ngeo` Print service class:
 * [camptocamp/ngeo](https://github.com/camptocamp/ngeo).
 *
 * Additionally some utility methods were borrowed from the color class of the
 * [google/closure-library](https://github.com/google/closure-library).
 *
 * @class GeoExt.data.serializer.Vector
 */
Ext.define(
  'GeoExt.data.serializer.Vector',
  {
    extend: 'GeoExt.data.serializer.Base',
    mixins: ['GeoExt.mixin.SymbolCheck'],

    // &lt;debug>
    symbols: [
      'ol.color.asArray',
      'ol.Feature',
      'ol.Feature#getGeometry',
      'ol.Feature#getStyleFunction',
      'ol.format.GeoJSON',
      'ol.format.GeoJSON#writeFeatureObject',
      'ol.geom.Geometry',
      'ol.geom.LineString#getType',
      'ol.geom.MultiLineString#getType',
      'ol.geom.MultiPoint#getType',
      'ol.geom.MultiPolygon#getType',
      'ol.geom.Point#getType',
      'ol.geom.Polygon#getType',
      'ol.layer.Vector#getOpacity',
      'ol.layer.Vector#getStyleFunction',
      'ol.source.Vector',
      'ol.source.Vector#getFeatures',
      'ol.style.Circle',
      'ol.style.Circle#getRadius',
      'ol.style.Circle#getFill',
      'ol.style.Fill',
      'ol.style.Fill#getColor',
      'ol.style.Icon',
      'ol.style.Icon#getSrc',
      'ol.style.Icon#getRotation',
      'ol.style.Stroke',
      'ol.style.Stroke#getColor',
      'ol.style.Stroke#getWidth',
      'ol.style.Style',
      'ol.style.Style#getFill',
      'ol.style.Style#getImage',
      'ol.style.Style#getStroke',
      'ol.style.Style#getText',
      'ol.style.Text',
      'ol.style.Text#getFont',
      'ol.style.Text#getOffsetX',
      'ol.style.Text#getOffsetY',
      'ol.style.Text#getRotation',
      'ol.style.Text#getText',
      'ol.style.Text#getTextAlign',
    ],
    // &lt;/debug>

    inheritableStatics: {
      /**
       * The types of styles that mapfish supports.
       *
       * @private
       */
      PRINTSTYLE_TYPES: {
        POINT: 'Point',
        LINE_STRING: 'LineString',
        POLYGON: 'Polygon',
      },

      /**
       * An object that maps an `ol.geom.GeometryType` to a #PRINTSTYLE_TYPES.
       *
       * @private
       */
      GEOMETRY_TYPE_TO_PRINTSTYLE_TYPE: {}, // filled once class is defined

      /**
       * A fallback serialization of a vector layer that will be used if
       * the given source e.g. doesn't have any features.
       *
       * @private
       */
      FALLBACK_SERIALIZATION: {
        geoJson: {
          type: 'FeatureCollection',
          features: [],
        },
        opacity: 1,
        style: {
          'version': '2',
          '*': {
            symbolizers: [
              {
                type: 'point',
                strokeColor: 'white',
                strokeOpacity: 1,
                strokeWidth: 4,
                strokeDashstyle: 'solid',
                fillColor: 'red',
              },
            ],
          },
        },
        type: 'geojson',
      },

      /**
       * The prefix we will give to the generated styles. Every feature will
       * -- once it is serialized -- have a property constructed with
       * the #FEAT_STYLE_PREFIX and a counter. For every unique combination
       * of #FEAT_STYLE_PREFIX  + i with the value style uid (see #getUid
       * and #GX_UID_PROPERTY), the layer serialization will also have a
       * CQL entry with a matching symbolizer:
       *
       *     {
       *          // …
       *          style: {
       *              "[_gx3_style_0='ext-46']": {
       *                  symbolizer: {
       *                      // …
       *                  }
       *              }
       *          },
       *          geoJson: {
       *              // …
       *              features: [
       *                  {
       *                      // …
       *                      properties: {
       *                          '_gx3_style_0': 'ext-46'
       *                          // …
       *                      }
       *                  }
       *              ]
       *          }
       *          // …
       *     }
       *
       * @private
       */
      FEAT_STYLE_PREFIX: '_gx3_style_',

      /**
       * The name / identifier for the uid property that is assigned and read
       * out in #getUid
       *
       * @private
       */
      GX_UID_PROPERTY: '__gx_uid__',

      /**
       * A shareable instance of ol.format.GeoJSON to serialize the features.
       *
       * @private
       */
      format: new ol.format.GeoJSON(),

      /**
       * @inheritdoc
       */
      sourceCls: ol.source.Vector,

      /**
       * @inheritdoc
       */
      serialize: function (layer, source, viewRes, map) {
        const me = this;
        me.validateSource(source);
        let extent;

        if (map) {
          extent = map.getView().calculateExtent();
        }
        const format = me.format;
        const geoJsonFeatures = [];
        const mapfishStyleObject = {
          version: 2,
        };

        const processFeatures = function (feature) {
          const geometry = feature.getGeometry();
          if (Ext.isEmpty(geometry)) {
            // no need to encode features with no geometry
            return;
          }
          const geometryType = geometry.getType();
          const geojsonFeature = format.writeFeatureObject(feature);

          // remove parent feature references as they break serialization
          // later on
          if (
            geojsonFeature.properties &amp;&amp;
            geojsonFeature.properties.parentFeature
          ) {
            geojsonFeature.properties.parentFeature = undefined;
          }

          let styles = null;
          let styleFunction = feature.getStyleFunction();
          if (Ext.isDefined(styleFunction)) {
            styles = styleFunction(feature, viewRes);
          } else {
            styleFunction = layer.getStyleFunction();
            if (Ext.isDefined(styleFunction)) {
              styles = styleFunction(feature, viewRes);
            }
          }

          if (!Ext.isArray(styles)) {
            styles = [styles];
          }
          if (!Ext.isEmpty(styles)) {
            geoJsonFeatures.push(geojsonFeature);
            if (Ext.isEmpty(geojsonFeature.properties)) {
              geojsonFeature.properties = {};
            }
            Ext.each(styles, function (style, j) {
              const styleId = me.getUid(style, geometryType);
              const featureStyleProp = me.FEAT_STYLE_PREFIX + j;
              me.encodeVectorStyle(
                mapfishStyleObject,
                geometryType,
                style,
                styleId,
                featureStyleProp,
              );
              geojsonFeature.properties[featureStyleProp] = styleId;
            });
          }
        };
        if (extent) {
          source.forEachFeatureInExtent(extent, processFeatures);
        } else {
          Ext.each(source.getFeatures(), processFeatures);
        }

        let serialized;

        // MapFish Print fails if there are no style rules, even if there
        // are no features either. To work around this, we add a basic
        // style in the else clause array of GeoJSON features is empty.
        if (geoJsonFeatures.length > 0) {
          const geojsonFeatureCollection = {
            type: 'FeatureCollection',
            features: geoJsonFeatures,
          };
          serialized = {
            geoJson: geojsonFeatureCollection,
            opacity: layer.getOpacity(),
            style: mapfishStyleObject,
            type: 'geojson',
          };
        } else {
          serialized = this.FALLBACK_SERIALIZATION;
        }

        return serialized;
      },

      /**
       * Encodes an ol.style.Style into the passed MapFish style object.
       *
       * @param {Object} object The MapFish style object.
       * @param {ol.geom.GeometryType} geometryType The type of the GeoJSON
       *    geometry
       * @param {ol.style.Style} style The style to encode.
       * @param {string} styleId The id of the style.
       * @param {string} featureStyleProp Feature style property name.
       * @private
       */
      encodeVectorStyle: function (
        object,
        geometryType,
        style,
        styleId,
        featureStyleProp,
      ) {
        const me = this;
        const printTypes = me.PRINTSTYLE_TYPES;
        const printStyleLookup = me.GEOMETRY_TYPE_TO_PRINTSTYLE_TYPE;
        if (!Ext.isDefined(printStyleLookup[geometryType])) {
          // unsupported geometry type
          return;
        }
        const styleType = printStyleLookup[geometryType];
        const key = '[' + featureStyleProp + " = '" + styleId + "']";
        if (Ext.isDefined(object[key])) {
          // do nothing if we already have a style object for this CQL
          // rule
          return;
        }
        const styleObject = {
          symbolizers: [],
        };

        object[key] = styleObject;

        const fillStyle = style.getFill();
        const imageStyle = style.getImage();
        const strokeStyle = style.getStroke();
        const textStyle = style.getText();

        const hasFillStyle = !Ext.isEmpty(fillStyle);
        const hasImageStyle = !Ext.isEmpty(imageStyle);
        const hasStrokeStyle = !Ext.isEmpty(strokeStyle);
        const hasTextStyle = !Ext.isEmpty(textStyle);

        const POLYTYPE = printTypes.POLYGON;
        const LINETYPE = printTypes.LINE_STRING;
        const POINTTYPE = printTypes.POINT;
        if (styleType === POLYTYPE &amp;&amp; hasFillStyle) {
          me.encodeVectorStylePolygon(
            styleObject.symbolizers,
            fillStyle,
            strokeStyle,
          );
        } else if (styleType === LINETYPE &amp;&amp; hasStrokeStyle) {
          me.encodeVectorStyleLine(styleObject.symbolizers, strokeStyle);
        } else if (styleType === POINTTYPE &amp;&amp; hasImageStyle) {
          me.encodeVectorStylePoint(styleObject.symbolizers, imageStyle);
        }
        // this can be there regardless of type
        if (hasTextStyle) {
          me.encodeTextStyle(styleObject.symbolizers, textStyle);
        }
      },

      /**
       * Encodes an `ol.style.Fill` and an optional `ol.style.Stroke` and adds
       * it to the passed symbolizers array.
       *
       * @param {Array&lt;Object>} symbolizers Array of MapFish Print symbolizers.
       * @param {ol.style.Fill} fillStyle Fill style.
       * @param {ol.style.Stroke} strokeStyle Stroke style. May be null.
       * @private
       */
      encodeVectorStylePolygon: function (symbolizers, fillStyle, strokeStyle) {
        const symbolizer = {
          type: 'polygon',
        };
        this.encodeVectorStyleFill(symbolizer, fillStyle);
        if (strokeStyle !== null) {
          this.encodeVectorStyleStroke(symbolizer, strokeStyle);
        }
        symbolizers.push(symbolizer);
      },

      /**
       * Encodes an `ol.style.Stroke` and adds it to the passed symbolizers
       * array.
       *
       * @param {Array&lt;Object>} symbolizers Array of MapFish Print symbolizers.
       * @param {ol.style.Stroke} strokeStyle Stroke style.
       * @private
       */
      encodeVectorStyleLine: function (symbolizers, strokeStyle) {
        const symbolizer = {
          type: 'line',
        };
        this.encodeVectorStyleStroke(symbolizer, strokeStyle);
        symbolizers.push(symbolizer);
      },

      /**
       * Encodes an `ol.style.Image` and adds it to the passed symbolizers
       * array.
       *
       * @param {Array&lt;Object>} symbolizers Array of MapFish Print symbolizers.
       * @param {ol.style.Image} imageStyle Image style.
       * @private
       */
      encodeVectorStylePoint: function (symbolizers, imageStyle) {
        let symbolizer;
        if (imageStyle instanceof ol.style.Circle) {
          symbolizer = {
            type: 'point',
          };
          symbolizer.pointRadius = imageStyle.getRadius();
          const fillStyle = imageStyle.getFill();
          if (fillStyle !== null) {
            this.encodeVectorStyleFill(symbolizer, fillStyle);
          }
          const strokeStyle = imageStyle.getStroke();
          if (strokeStyle !== null) {
            this.encodeVectorStyleStroke(symbolizer, strokeStyle);
          }
        } else if (imageStyle instanceof ol.style.Icon) {
          const src = imageStyle.getSrc();
          if (Ext.isDefined(src)) {
            const img = imageStyle.getImage(window.devicePixelRatio || 1);
            const canvas = document.createElement('canvas');
            canvas.width = img.naturalWidth || img.width;
            canvas.height = img.naturalHeight || img.height;
            canvas.getContext('2d').drawImage(img, 0, 0);
            const format = 'image/' + src.match(/\.(\w+)$/)[1];
            symbolizer = {
              type: 'point',
              externalGraphic: canvas.toDataURL(),
              graphicFormat: format,
            };
            const rotation = imageStyle.getRotation();
            if (rotation !== 0) {
              const degreesRotation = (rotation * 180) / Math.PI;
              symbolizer.rotation = degreesRotation;
            }
          }
        }
        if (Ext.isDefined(symbolizer)) {
          symbolizers.push(symbolizer);
        }
      },

      /**
       * Encodes an `ol.style.Text` and adds it to the passed symbolizers
       * array.
       *
       * @param {Array&lt;Object>} symbolizers Array of MapFish Print symbolizers.
       * @param {ol.style.Text} textStyle Text style.
       * @private
       */
      encodeTextStyle: function (symbolizers, textStyle) {
        const symbolizer = {
          type: 'Text',
        };
        const label = textStyle.getText();
        if (!Ext.isDefined(label)) {
          // do not encode undefined labels
          return;
        }

        symbolizer.label = label;

        const labelAlign = textStyle.getTextAlign();
        if (Ext.isDefined(labelAlign)) {
          symbolizer.labelAlign = labelAlign;
        }

        const labelRotation = textStyle.getRotation();
        if (Ext.isDefined(labelRotation)) {
          // Mapfish Print expects a string to rotate text
          const strRotationDeg = (labelRotation * 180) / Math.PI + '';
          symbolizer.labelRotation = strRotationDeg;
        }

        const offsetX = textStyle.getOffsetX();
        const offsetY = textStyle.getOffsetY();
        if (offsetX) {
          symbolizer.labelXOffset = offsetX;
        }
        if (offsetY) {
          symbolizer.labelYOffset = -offsetY;
        }

        const fontStyle = textStyle.getFont();

        if (Ext.isDefined(fontStyle)) {
          const el = document.createElement('span');
          el.style.font = fontStyle;

          symbolizer.fontWeight = el.style.fontWeight;
          symbolizer.fontSize = el.style.fontSize;
          symbolizer.fontFamily = el.style.fontFamily;
          symbolizer.fontStyle = el.style.fontStyle;
        }

        const strokeStyle = textStyle.getStroke();
        if (strokeStyle !== null &amp;&amp; strokeStyle.getColor()) {
          const strokeColor = strokeStyle.getColor();
          const strokeColorRgba = ol.color.asArray(strokeColor);
          symbolizer.haloColor = this.rgbArrayToHex(strokeColorRgba);
          symbolizer.haloOpacity = strokeColorRgba[3];
          const width = strokeStyle.getWidth();
          if (Ext.isDefined(width)) {
            symbolizer.haloRadius = width;
          }
        }

        const fillStyle = textStyle.getFill();
        if (fillStyle !== null &amp;&amp; fillStyle.getColor()) {
          const fillColorRgba = ol.color.asArray(fillStyle.getColor());
          symbolizer.fontColor = this.rgbArrayToHex(fillColorRgba);
        }

        // Mapfish Print allows offset only if labelAlign is defined.
        if (Ext.isDefined(symbolizer.labelAlign)) {
          symbolizer.labelXOffset = textStyle.getOffsetX();
          // Mapfish uses the opposite direction of OpenLayers for y
          // axis, so the minus sign is required for the y offset to
          // be identical.
          symbolizer.labelYOffset = -textStyle.getOffsetY();
        }

        symbolizers.push(symbolizer);
      },

      /**
       * Encode the passed `ol.style.Fill` into the passed symbolizer.
       *
       * @param {Object} symbolizer MapFish Print symbolizer.
       * @param {ol.style.Fill} fillStyle Fill style.
       * @private
       */
      encodeVectorStyleFill: function (symbolizer, fillStyle) {
        const fillColor = fillStyle.getColor();
        if (fillColor !== null) {
          const fillColorRgba = ol.color.asArray(fillColor);
          symbolizer.fillColor = this.rgbArrayToHex(fillColorRgba);
          symbolizer.fillOpacity = fillColorRgba[3];
        }
      },

      /**
       * Encode the passed `ol.style.Stroke` into the passed symbolizer.
       *
       * @param {Object} symbolizer MapFish Print symbolizer.
       * @param {ol.style.Stroke} strokeStyle Stroke style.
       * @private
       */
      encodeVectorStyleStroke: function (symbolizer, strokeStyle) {
        const strokeColor = strokeStyle.getColor();
        if (strokeColor !== null) {
          const strokeColorRgba = ol.color.asArray(strokeColor);
          symbolizer.strokeColor = this.rgbArrayToHex(strokeColorRgba);
          symbolizer.strokeOpacity = strokeColorRgba[3];
        }
        const strokeWidth = strokeStyle.getWidth();
        if (Ext.isDefined(strokeWidth)) {
          symbolizer.strokeWidth = strokeWidth;
        }
      },

      /**
       * Takes a hex value and prepends a zero if it's a single digit.
       * Taken from https://github.com/google/closure-library color.js-file.
       * It is called `prependZeroIfNecessaryHelper` there.
       *
       * @param {string} hex Hex value to prepend if single digit.
       * @return {string} The hex value prepended with zero if it was single
       *     digit, otherwise the same value that was passed in.
       * @private
       */
      padHexValue: function (hex) {
        return hex.length === 1 ? '0' + hex : hex;
      },

      /**
       * Converts a color from RGB to hex representation.
       * Taken from https://github.com/google/closure-library color.js-file.
       *
       * @param {number} r Amount of red, int between 0 and 255.
       * @param {number} g Amount of green, int between 0 and 255.
       * @param {number} b Amount of blue, int between 0 and 255.
       * @return {string} The passed color in hex representation.
       * @private
       */
      rgbToHex: function (r, g, b) {
        r = Number(r);
        g = Number(g);
        b = Number(b);
        if (
          isNaN(r) ||
          r &lt; 0 ||
          r > 255 ||
          isNaN(g) ||
          g &lt; 0 ||
          g > 255 ||
          isNaN(b) ||
          b &lt; 0 ||
          b > 255
        ) {
          Ext.raise(
            '"(' + r + ',' + g + ',' + b + '") is not a valid ' + ' RGB color',
          );
        }
        const hexR = this.padHexValue(r.toString(16));
        const hexG = this.padHexValue(g.toString(16));
        const hexB = this.padHexValue(b.toString(16));
        return '#' + hexR + hexG + hexB;
      },

      /**
       * Converts a color from RGB to hex representation.
       * Taken from https://github.com/google/closure-library color.js-file
       *
       * @param {Array&lt;number>} rgbArr An array with three numbers representing
       *    red, green and blue.
       * @return {string} The passed color in hex representation.
       * @private
       */
      rgbArrayToHex: function (rgbArr) {
        return this.rgbToHex(rgbArr[0], rgbArr[1], rgbArr[2]);
      },

      /**
       * Returns a unique id for this object. The object is assigned a new
       * property #GX_UID_PROPERTY and modified in place if this hasn't
       * happened in a previous call.
       *
       * @param {Object} obj The object to get the uid of.
       * @param {string} geometryType The geometryType for the style.
       * @return {string} The uid of the object.
       * @private
       */
      getUid: function (obj, geometryType) {
        if (!Ext.isObject(obj)) {
          Ext.raise('Cannot get uid of non-object.');
        }
        let key = this.GX_UID_PROPERTY;
        if (geometryType) {
          key += '-' + geometryType;
        }
        if (!Ext.isDefined(obj[key])) {
          obj[key] = Ext.id();
        }
        return obj[key];
      },
    },
  },
  function (cls) {
    // This is ol.geom.GeometryType, from
    // https://github.com/openlayers/ol3/blob/master/src/ol/geom/geometry.js
    const olGeomTypes = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      LINEAR_RING: 'LinearRing',
      POLYGON: 'Polygon',
      MULTI_POINT: 'MultiPoint',
      MULTI_LINE_STRING: 'MultiLineString',
      MULTI_POLYGON: 'MultiPolygon',
      GEOMETRY_COLLECTION: 'GeometryCollection',
      CIRCLE: 'Circle',
    };
    // The supported types for the print
    const printStyleTypes = cls.PRINTSTYLE_TYPES;

    // a map that connect ol geometry types to their mapfish equivalent;
    // Please note that not all ol geometry types can be serialized.
    const geom2print = {};
    geom2print[olGeomTypes.POINT] = printStyleTypes.POINT;
    geom2print[olGeomTypes.MULTI_POINT] = printStyleTypes.POINT;
    geom2print[olGeomTypes.LINE_STRING] = printStyleTypes.LINE_STRING;
    geom2print[olGeomTypes.MULTI_LINE_STRING] = printStyleTypes.LINE_STRING;
    geom2print[olGeomTypes.POLYGON] = printStyleTypes.POLYGON;
    geom2print[olGeomTypes.MULTI_POLYGON] = printStyleTypes.POLYGON;

    cls.GEOMETRY_TYPE_TO_PRINTSTYLE_TYPE = geom2print;

    // Register this serializer via the inherited method `register`.
    cls.register(cls);
  },
);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GeoExt.component.FeatureRenderer.html">FeatureRenderer</a></li><li><a href="GeoExt.component.Map.html">Map</a></li><li><a href="GeoExt.component.OverviewMap.html">OverviewMap</a></li><li><a href="GeoExt.component.Popup.html">Popup</a></li><li><a href="GeoExt.data.MapfishPrintProvider.html">MapfishPrintProvider</a></li><li><a href="GeoExt.data.model.ArcGISRestServiceLayer.html">ArcGISRestServiceLayer</a></li><li><a href="GeoExt.data.model.Base.html">Base</a></li><li><a href="GeoExt.data.model.Feature.html">Feature</a></li><li><a href="GeoExt.data.model.Layer.html">Layer</a></li><li><a href="GeoExt.data.model.LayerTreeNode.html">LayerTreeNode</a></li><li><a href="GeoExt.data.model.OlObject.html">OlObject</a></li><li><a href="GeoExt.data.model.print.Capability.html">Capability</a></li><li><a href="GeoExt.data.model.print.Layout.html">Layout</a></li><li><a href="GeoExt.data.model.print.LayoutAttribute.html">LayoutAttribute</a></li><li><a href="GeoExt.data.serializer.Base.html">Base</a></li><li><a href="GeoExt.data.serializer.ImageWMS.html">ImageWMS</a></li><li><a href="GeoExt.data.serializer.TileWMS.html">TileWMS</a></li><li><a href="GeoExt.data.serializer.Vector.html">Vector</a></li><li><a href="GeoExt.data.serializer.WMTS.html">WMTS</a></li><li><a href="GeoExt.data.serializer.XYZ.html">XYZ</a></li><li><a href="GeoExt.data.store.ArcGISRestServiceLayer.html">ArcGISRestServiceLayer</a></li><li><a href="GeoExt.data.store.Features.html">Features</a></li><li><a href="GeoExt.data.store.Layers.html">Layers</a></li><li><a href="GeoExt.data.store.LayersTree.html">LayersTree</a></li><li><a href="GeoExt.data.store.OlObjects.html">OlObjects</a></li><li><a href="GeoExt.data.store.WfsFeatures.html">WfsFeatures</a></li><li><a href="GeoExt.form.field.GeocoderComboBox.html">GeocoderComboBox</a></li><li><a href="GeoExt.mixin.SymbolCheck.html">SymbolCheck</a></li><li><a href="GeoExt.plugin.layertreenode.ContextMenu.html">ContextMenu</a></li><li><a href="GeoExt.selection.FeatureCheckboxModel.html">FeatureCheckboxModel</a></li><li><a href="GeoExt.selection.FeatureModel.html">FeatureModel</a></li><li><a href="GeoExt.selection.FeatureModelMixin.html">FeatureModelMixin</a></li><li><a href="GeoExt.state.PermalinkProvider.html">PermalinkProvider</a></li><li><a href="GeoExt.toolbar.WfsPaging.html">WfsPaging</a></li><li><a href="GeoExt.util.Layer.html">Layer</a></li><li><a href="GeoExt.util.OGCFilter.html">OGCFilter</a></li><li><a href="GeoExt.util.Version.html">Version</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:aftermapmoveTriggeredwhenthe'moveend'eventoftheunderlyingOpenLayersmapisfired.">aftermapmove

Triggered when the 'moveend' event of the underlying OpenLayers map is
fired.</a></li><li><a href="global.html#event:click">click</a></li><li><a href="global.html#event:pointerrestFiresiftheuserhasleftthepointerforanamountof#pointerRestIntervalmillisecondsatthe*samelocation*.Usetheconfiguration#pointerRestPixelTolerancetoconfigurehowlongapixelisconsideredtobeonthe*samelocation*.Pleasenotethatthiseventwillonlyfireifthemaphas#pointerRestconfiguredwith%2560true%2560.">pointerrest

Fires if the user has left the pointer for an amount
of #pointerRestInterval milliseconds at the *same location*. Use the
configuration #pointerRestPixelTolerance to configure how long a pixel is
considered to be on the *same location*.

Please note that this event will only fire if the map has #pointerRest
configured with `true`.</a></li><li><a href="global.html#event:pointerrestoutFiresiftheuserfirstwasrestinghispointeronthemapelement,butthenmovedthepointeroutofthemapcompletely.Pleasenotethatthiseventwillonlyfireifthemaphas#pointerRestconfiguredwith%2560true%2560.">pointerrestout

Fires if the user first was resting his pointer on the map element, but
then moved the pointer out of the map completely.

Please note that this event will only fire if the map has #pointerRest
configured with `true`.</a></li><li><a href="global.html#event:readyFiresafterthePrintCapabilitystoreisloaded.">ready
Fires after the PrintCapability store is loaded.</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addLayer">addLayer</a></li><li><a href="global.html#addLayerNode">addLayerNode</a></li><li><a href="global.html#addMapExtentParams">addMapExtentParams</a></li><li><a href="global.html#applyAnchorStyle">applyAnchorStyle</a></li><li><a href="global.html#applyBoxStyle">applyBoxStyle</a></li><li><a href="global.html#applyEnableBoxDrag">applyEnableBoxDrag</a></li><li><a href="global.html#applyPointerRest">applyPointerRest</a></li><li><a href="global.html#applyPointerRestInterval">applyPointerRestInterval</a></li><li><a href="global.html#applyRecenterOnClick">applyRecenterOnClick</a></li><li><a href="global.html#applyState">applyState</a></li><li><a href="global.html#attributesReturnsanExt.data.Storeofreferenced%257B@linkGeoExt.data.model.print.LayoutAttribute%257Ds.">attributes
Returns an Ext.data.Store of referenced
{@link GeoExt.data.model.print.LayoutAttribute}s.</a></li><li><a href="global.html#autoLoad">autoLoad</a></li><li><a href="global.html#bindLayer">bindLayer</a></li><li><a href="global.html#bindLayers">bindLayers</a></li><li><a href="global.html#bindMap">bindMap</a></li><li><a href="global.html#bindStateOlEvents">bindStateOlEvents</a></li><li><a href="global.html#cacheFeatureCount">cacheFeatureCount</a></li><li><a href="global.html#capabilityRec">capabilityRec</a></li><li><a href="global.html#cls">cls</a></li><li><a href="global.html#constructor">constructor</a></li><li><a href="global.html#contextUi">contextUi</a></li><li><a href="global.html#convertToCoordinate">convertToCoordinate</a></li><li><a href="global.html#convertToExtent">convertToExtent</a></li><li><a href="global.html#count">count</a></li><li><a href="global.html#createContextUi">createContextUi</a></li><li><a href="global.html#createLayer">createLayer</a></li><li><a href="global.html#createParameters">createParameters</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#descriptionProperty">descriptionProperty</a></li><li><a href="global.html#destroy">destroy</a></li><li><a href="global.html#destroyDragBehaviour">destroyDragBehaviour</a></li><li><a href="global.html#disableBoxUpdate">disableBoxUpdate</a></li><li><a href="global.html#displayField">displayField</a></li><li><a href="global.html#displayValueMapping">displayValueMapping</a></li><li><a href="global.html#drawLocationFeatureOnMap">drawLocationFeatureOnMap</a></li><li><a href="global.html#emptyText">emptyText</a></li><li><a href="global.html#enableBoxUpdate">enableBoxUpdate</a></li><li><a href="global.html#featureCountOutputFormat">featureCountOutputFormat</a></li><li><a href="global.html#features">features</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#getByFeature">getByFeature</a></li><li><a href="global.html#getByLayer">getByLayer</a></li><li><a href="global.html#getCapabilityReturnsthelayoutsparentprintcapabilities.MaybenullifLayoutisinstantiateddirectly.">getCapability
Returns the layouts parent print capabilities. May be null if Layout is
instantiated directly.</a></li><li><a href="global.html#getCenter">getCenter</a></li><li><a href="global.html#getExtent">getExtent</a></li><li><a href="global.html#getFeature">getFeature</a></li><li><a href="global.html#getFeatures">getFeatures</a></li><li><a href="global.html#getLayers">getLayers</a></li><li><a href="global.html#getLayoutReturnstheattributeparentlayoutmodel.MaybenullifLayoutAttributeisinstantiateddirectly.">getLayout
Returns the attribute parent layout model. May be null if
LayoutAttribute is instantiated directly.</a></li><li><a href="global.html#getOlLayer">getOlLayer</a></li><li><a href="global.html#getOlLayerProp">getOlLayerProp</a></li><li><a href="global.html#getPermalinkHash">getPermalinkHash</a></li><li><a href="global.html#getRefItems">getRefItems</a></li><li><a href="global.html#getRefOwner">getRefOwner</a></li><li><a href="global.html#getStore">getStore</a></li><li><a href="global.html#getView">getView</a></li><li><a href="global.html#initComponent">initComponent</a></li><li><a href="global.html#inverseLayerOrder">inverseLayerOrder</a></li><li><a href="global.html#isMouseOverIgnoreEl">isMouseOverIgnoreEl</a></li><li><a href="global.html#layerAttribution">layerAttribution</a></li><li><a href="global.html#layerOptions">layerOptions</a></li><li><a href="global.html#layoutsReturnsanExt.data.Storeofreferenced%257B@linkGeoExt.data.model.print.Layout%257Ds.">layouts
Returns an Ext.data.Store of referenced
{@link GeoExt.data.model.print.Layout}s.</a></li><li><a href="global.html#loadRawData">loadRawData</a></li><li><a href="global.html#locationLayer">locationLayer</a></li><li><a href="global.html#locationLayerStyle">locationLayerStyle</a></li><li><a href="global.html#logicalFilterCombinator">logicalFilterCombinator</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#minChars">minChars</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#olClass">olClass</a></li><li><a href="global.html#olCollection">olCollection</a></li><li><a href="global.html#olObject">olObject</a></li><li><a href="global.html#onBeforeDestroy">onBeforeDestroy</a></li><li><a href="global.html#onBindStore">onBindStore</a></li><li><a href="global.html#onFocus">onFocus</a></li><li><a href="global.html#onLayerVisibleChange">onLayerVisibleChange</a></li><li><a href="global.html#onResize">onResize</a></li><li><a href="global.html#outputFormat">outputFormat</a></li><li><a href="global.html#passThroughFilter">passThroughFilter</a></li><li><a href="global.html#position">position</a></li><li><a href="global.html#propertyName">propertyName</a></li><li><a href="global.html#proxy">proxy</a></li><li><a href="global.html#proxyRootProperty">proxyRootProperty</a></li><li><a href="global.html#queryDelay">queryDelay</a></li><li><a href="global.html#queryParam">queryParam</a></li><li><a href="global.html#recenterParentFromBox">recenterParentFromBox</a></li><li><a href="global.html#recreateContextUi">recreateContextUi</a></li><li><a href="global.html#remoteFilter">remoteFilter</a></li><li><a href="global.html#remoteSort">remoteSort</a></li><li><a href="global.html#removeLayer">removeLayer</a></li><li><a href="global.html#removeLocationFeature">removeLocationFeature</a></li><li><a href="global.html#removeMapExtentParams">removeMapExtentParams</a></li><li><a href="global.html#repositionAnchorFeature">repositionAnchorFeature</a></li><li><a href="global.html#request">request</a></li><li><a href="global.html#requestMethod">requestMethod</a></li><li><a href="global.html#restrictExtent">restrictExtent</a></li><li><a href="global.html#restrictToMapExtent">restrictToMapExtent</a></li><li><a href="global.html#resumeCollectionEvents">resumeCollectionEvents</a></li><li><a href="global.html#selectedFeatureAttr">selectedFeatureAttr</a></li><li><a href="global.html#selectedFeatures">selectedFeatures</a></li><li><a href="global.html#service">service</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#setCenter">setCenter</a></li><li><a href="global.html#setExtent">setExtent</a></li><li><a href="global.html#setOverviewMapProperty">setOverviewMapProperty</a></li><li><a href="global.html#setView">setView</a></li><li><a href="global.html#setupDragBehaviour">setupDragBehaviour</a></li><li><a href="global.html#showContextUi">showContextUi</a></li><li><a href="global.html#showLocationOnMap">showLocationOnMap</a></li><li><a href="global.html#srs">srs</a></li><li><a href="global.html#srsName">srsName</a></li><li><a href="global.html#startIndex">startIndex</a></li><li><a href="global.html#startIndexOffset">startIndexOffset</a></li><li><a href="global.html#store">store</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#suspendCollectionEvents">suspendCollectionEvents</a></li><li><a href="global.html#synchronize">synchronize</a></li><li><a href="global.html#synchronizedProperties">synchronizedProperties</a></li><li><a href="global.html#textProperty">textProperty</a></li><li><a href="global.html#typeName">typeName</a></li><li><a href="global.html#unRestrictExtent">unRestrictExtent</a></li><li><a href="global.html#unbindLayers">unbindLayers</a></li><li><a href="global.html#unbindMap">unbindMap</a></li><li><a href="global.html#unnamedGroupLayerText">unnamedGroupLayerText</a></li><li><a href="global.html#unnamedLayerText">unnamedLayerText</a></li><li><a href="global.html#unregisterPointerRestEvents">unregisterPointerRestEvents</a></li><li><a href="global.html#update">update</a></li><li><a href="global.html#updateBox">updateBox</a></li><li><a href="global.html#updateExtraParams">updateExtraParams</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#valueField">valueField</a></li><li><a href="global.html#version">version</a></li><li><a href="global.html#zoom">zoom</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Wed Dec 11 2024 10:55:31 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
